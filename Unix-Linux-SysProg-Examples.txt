/*--------------------------------------------------------------------------------------------------------------------------

                                            C ve Sistem Programcıları Derneği

                            U   NIX/Linux Sistem Programlama Kursunda Yapılan Örnekler ve Özet Notlar
        
                                                    Eğitmen: Kaan ASLAN
 
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
                                            1. Ders 22/10/2022 - Cumartesi
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Merhaba UNIX/Linux Programı
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>

int main(void)
{
    printf("Hello UNIX/Linux System Programming...\n");
    
    return 0;
}

/*--------------------------------------------------------------------------------------------------------------------------
                                            4. Ders 05/11/2022 - Cumartesi
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
	UNIX/Linux dünyasında komut satırı argümanlarının oluşturulması için geniş bir kesim tarafındna kullanılan geleneksel bir biçim vardır. 
	Bu biçime "GNU biçimi" de denilmektedir. Biz de kursumuzda UNIX/Linux dünyasında yazacağımız programlarda bu geleneği kullanacağız. 
	GNU stilinde komut satırı argümanları üçe ayrılmaktadır:

	1) Argümansız seçenekler
	2) Argümanlı seçenekler
	3) Seçeneksiz argümanlar

	Argümansız seçenekler "-" karakterine yapışık tek bir harften oluşmaktadır. Harflerde büyük harf küçük harf duyarlılığı (case sensitivity)
	dikkate alınmaktadır. Örneğin:

	ls -l -i /usr/include

	Burada -l ve -i argümansız seçeneklerdir. /usr/include argğmanının bu seçeneklerle hiçbir ilgisi yoktur. Argümansız seçenekler tek bir 
	karakterden oluşturulduğu için birleştirilebilmektedir. Örneğin:

	ls -li

	Buradaki -li aslında -l -i ile tamamen aynı anlamdadır. Genel olarak GNU stilinde seçenekler arasındaki sıranın bir önemi yoktur. 
	Yani örneğin:

	ls -l -i

	ile

	ls -i -l 

	arasında bir farklılık yoktur.  

	Argümanlı seçeneklerde bir seçeneğin yanında o seçenekle ilişkili bir argüman da bulunur. Örneğin:

	gcc -o sample sample.c

	Burada -o seçeneği seçeneği tek başına kullanılmaz. Hedef dosyanın ismi seçeneğin argümanını oluşturmaktadır. O halde buradaki 
	-o seçeneği tipik olarak argümanlı seçeneğe bir örnektir. Argüman seçeneklerin birleştirilmesi tavsiye edilmez. Ancak birleştirme yapılabilmektedir. 
	Örneğin:

	gcc -co sample.o sample.c

	Bu yazım biçimini pek çok program kabul etse de biz tavsiye etmiyoruz. Buradaki argümanların aşağıdaki gibi belirtilesi daha uygundur:

	gcc -c -o sample.o sample.c

	Programlar argümanlı seçeneklerde seçeneğin argümanı hiç boşluk karakterleriyle ayrılmasa bile bunu kabul edebilmektedir. Örneğin:

	gcc -osample sample.c

	Burada -o argümanlı seçebek olduğu için onu başka bir seçenek izleyemeyeceğinden dolayı "sample" -o seçeneğinin argümanı olarak 
	ele alınmaktadır.

	Seçeneklerle ilgisi olmayan argümanlara "seçeneksiz argüman" denilmektedir. Örneğin:

	gcc -o sample sample.c

	Burada "sample.c" argümanı herhangi bir seçenekle ilgili değildir. Örneğin:

	cp x.txt y.txt

	Buradaki "x.txt" ve "y.txt" argümanları da seçeneklerle ilgili değildir. Seçeneksiz argümanların sonda bulunması gerekmez. Örneğin:

	gcc sample.c -o sample

---------------------------------------------------------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------------------------------------------------------
	Eskiden yalnızca tek karakterden oluşan kısa seçenekler kullanılıyrodu. Ancak daha sonraları bu kısa seçeneklerin yetersiz kaldığı ve 
	okunabilirliği bozduğu gerekçesiyle uzun seçenekler de kullanılmaya başlanmıştır. POSIX standartları uzun seçenekleri desteklememektedir. 
	Ancak UNIX/Linux dünyasında yaygın biçimde kullanılmaktadır. Uzun seçenekler "--" öneki ile başlatılmaktadır. Örneğin:

	prog --count -a -b --length 100

	Uzun seçenkler de arümanlı ve arümansız olabilmektedir. Yukarıdaki örnekte "--count" arümansız uzun seçenek, "-a" ve "-b" argümansız seçenekler 
	ve "--length 100" ise argümanlı uzun seçenektir. 
	
	Uzun seçeneklerde "isteğe bağlı argüman (optional argument)" denilen özel bir argüman da kullanılmaktadır. İsmi üzerinde "isteğe bağlı argüman" 
	uzun seçeneklerde yanında verilip verilmemesi isteğe bağlı olan argümanlardır. Uzun seçeneklerin isteğe bağlı argümanları "=" sentaksı ile 
	yapışık bir biçimde belirtilmektedir. Örneğin:

	prog --size=512

	Burada --size uzun seçeneğinin argümanı isteğe bağlıdır. Yani bu uzun seçenek argümansız da aşağıdaki gibi kullanılabilirdi:

	prog --size

	Genel olarak bugün programlar kısa seçenekleri de uzun seçenekleri de bir arada kullanmaktadır. Programcılar bazı kısa seçeneklerin 
	alternatif uzun seçeneklerini oluşturabilmektedir. Yukarıda da belirttiğimiz gibi POSIX standratları uzun seçenekleri desteklememektedir. 
--------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    UNIX/Linux dünyasında kullanılan komut satırı argümanlarını parse etmek için getopt ve getopt_long isimli iki fonksiyon bulunudurlmuştur. 
	getopt fonksiyonu bir POSIX fonksiyonudur. Ancak bu fonksiyon uzun seçenekleri parse etmemektedir. getopt_long ise uzun seçenekleri de parse eden
	getopt fonksiyonunun daha gelişmiş bir biçimidir. Ancak getopt_long bir POSIX fonksiyonu değildir. Ancak libc kütüphanesinde bulunmaktadır. 
	Bu fonksiyonlar Windows sistemlerinde hazır bir biçimde herhangi bir kütüphanede bulunmamaktadır. Zaten yukarıda da belirttiğimiz gibi Windows
	sistemlerindeki komut satırı argüman stili UNIX/Linux sistemlerindekinden farklıdır. 
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    getopt fonksiyonunun prototipi şöyledir:

	#include <unistd.h>

	int getopt(int argc, char * const argv[], const char *optstring);

	getopt fonksiyonunun ilk iki paramteresi main fonksiyonunun argc ve argv parametreleri gibidir. Yani programcı main fonksiyonunun bu parametrelerini 
	getopt fonksiyonuna geçirir. Fonksiyon üçüncü parametresinde kısa seçenekler belirtilmektedir. Bu parametre bir yazı biçiminde girilir. 
	Bu yazıdaki her bir karakter bir kısa seçeneği belirtir. Bir karakterin yanında ':' karakteri varsa bu ':' karakteri onun solundaki seçeneğin 
	argümanlı bir seçenek olduğunu belirtmektedir. Örneğin "ab:c" burada -a, -b ve -c seçenekleri belirtilmiştir. Ancak -b seçeneğinin bir argümanı da
	vardır. 

	getopt fonksiyonu bir kez çağrılmaz. Bir döngü içerisinde çağrılmalıdır. Çünkü fonksiyon her çağrıldığında bir kısa seçeneği bulmaktadır. 
	Fonksiyon bütün kısa seçenekleri bulduktan sonra artık bulacak bir seçenek kalmadığında -1 değerine geri dnmektedir. O halde fonksiyonun 
	çağrılma kalıbı şöyle olmaldır:

	int result;
	...

	while ((result = getopt(argc, argv, "ab:c")) != -1) {
		...
	}

	getopt her kısa seçeneği bulduğunda o kısa seçeneğe ilişkin karakterle (yani o karakterin sayısal karşılığı ile) geri dönmektedir. 
	O halde bizim getopt fonksiyonunun geri dönüş değerini switch içerisinde ele almamaız gerekir:

	while ((result = getopt(argc, argv, "ab:c")) != -1) {
        switch (result) {
            case 'a':
                ...
                break;
            case 'b':
                ...
                break;
            case 'c':
				...
                break;
        }
    }

	getopt fonksiyonu olmayan (yani üçüncü parametresinde belirtilmeyen) bir kısa seçenekle karşılaştığında ya da argümanı olması gerektiği 
	halde girilmemiş bir kısa seçenekle karşılaştığında '?' özel değerine geri dönmektedir. Programcının switch deyimine bu case bölümünü 
	ekleyerel bu durumu da değerlendirmesi uygun olur. Örneğin:

	while ((result = getopt(argc, argv, "ab:c")) != -1) {
        switch (result) {
            case 'a':
                ...
                break;
            case 'b':
                ...
                break;
            case 'c':
				...
                break;
			case '?':
				...
				break;
        }
    }

	getopt fonksiyonunun kullandığı dört global dğeişken vardır. Bu global değişkenler kütüphanenin içeisinde tanımlanmıştır. Bunları biz
	extern bildirimi ile kullanabiliriz. Ancak bunların extern bildirimleri zaten <unistd.h> dosyası içierisinde yapılmış durumdadır:

	extern int opterr;
	extern int optopt;
	extern int optind;
	extern char *optarg;

	Default durumda getopt fonksiyonu geçersiz bir seçenekle (yani üçüncü parametresinde belirtilmeyen bir seçenekle) karşılaştığında 
	stderr dosyasına (ekranda çıkacaktır) kendisi hata mesajını yazdırmaktadır. Programcılar genellikle bunu istemezler. getopt fonksiyonunun 
	hata geçersiz seçenekler için hata mesajını yazdırması opterr değişkenine 0 değeri atanarak sağlanabilir. Yani opterr değişkeni sıfır dışı 
	bir değerdeyse (default durum) fonksiyon mesajı stderr dosyasına kendisi de yazar, sıfır değerindeyse fonksiyon hata mesajını stder dosyasına 
	yazmaz. 

	getopt fonksiyonu geçersiz bir seçenekle ya da argümanı girilmemiş argümanlı bir seçenekle karşılaştığında '?' geri dönmekle birlikte aynı zamanda
	optopt global değişkenine geçersiz seçeneğin karakter karşılığıı yerleştirmektedir. Böylece programcı daha yeterli bir mesaj verebilmektedir. 
	Örneğin:

	opterr = 0;
    while ((result = getopt(argc, argv, "ab:c")) != -1) {
        switch (result) {
            case 'a':
                printf("-a given...\n");
                break;
            case 'b':
                printf("-b given...\n");
                break;
            case 'c':
                printf("-c given...\n");
                break;
            case '?':
            if (optopt == 'b')
                fprintf(stderr, "-b option given without argument!..\n");
            else
                fprintf(stderr, "invalid option: -%c\n", optopt);
            break;
        }
    }

	Argümanlı bir kısa seçenek bulunduğunda getopt fonksiyonu optarg global değişkenini o kısa seçeneğin argümanını gösterecek biçimde 
	set eder. Ancak optarg yeni bir argümanlı kısa eçenek bulunduğunda bu kez onun argümanını gösterecek biçimde set edilmektedir. Yani 
	programcı argümanlı kısa seçeneği bulduğu anda optarg değişkenine başvurmalı gerekirse onu başka bir göstericide saklamalıdır. 

	Pekiyi seçeneksiz argümnalrı nasıl edebiliriz? Seçeneksiz argümanlar argv dizisinin herhangi bir yerine bulunuyor olabilir. İşte getopt 
	fonksiyonu her zaman seçeneksiz argümanları girildiği sırada argv dizisinin sonuna taşır ve onların başladığı indeksi de optind global 
	değişkeninin göstermesini sağlar. O halde programcı getopt ile işini bitirdikten sonra (yani while döngüsünden çıktıktan sonra) optind
	indeksinden argc indeksine kadar ilerleyerek tüm seçeneksiz argümanları elde edebilmektedir. Örneğin:

	./sample -a ali -b veli selami -c

	Burada "ali" ve "selami" seçeneksiz argümanlardır. getopt bu argv dizisini şu halde getirmekltedir:

	./sample -a -b veli -c ali selami

	Şimdi burada optind indeksi artık "ali" argümanının bşaldağı indeksi belirtecektir. Onun ötesindeki türm argümanlar seçeneksiz argümanlardır. 
	Bu argümanları while dönüsünün dışnda şyle yazdırabiliriz:

	for (int i = optind; i < argc; ++i)
        puts(argv[i]);

	Programcının girilmiş olan seçenekleri saklayıp programın ilerleyen aşamalarında bunları kullanması gerekebilmektedir. Bunun için şöyle 
	bir kalıp önerilebilir: 
	
	- Her seçenek için bir flag değişkeni tutulur. Bu flag değişkenlerine başlangıçta 0 atanır.
	- Her argümanlı seçenek için bir gösterici tutulur. 
	- Her seçenekle karşılaşıldığında flag değişkenine 1 atanarak o seçeneğin kullanıldığı kaydedilir. 
	- Argümanlı seçeneklerle karşılaşıldığında onların argümanları göstericilerde saklanır. 
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    getopt fonksiyonun kullanımına ilişkin tipik bir kalıp aşağıda verilmiştir. Aşağıdaki örnekte -a, -b, -d argümansız seçenekler,
    -c ve -e ise argümanlı seçeneklerdir. Bu kalıbı kendi programlarınızda da kullanabilirsiniz. Bu örnekte ayrıştırma işleminde 
    bir hata oluştuğunda programın devam etmemesini isteriz. Ancak tüm hataların rapor edilmesi de gerekmektedir. Bunun için bir 
    flag değişkenindne faydalanılabilir. O flag değişkeni hata durumunda set edilir. Çıkışta kontrol edilip duruma göre 
	program sonlandırılır. 
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>

int main(int argc, char *argv[])
{
    int result;
    int a_flag, b_flag, c_flag, d_flag, e_flag, err_flag;
    char *c_arg, *e_arg;

    a_flag = b_flag = c_flag = d_flag = e_flag = err_flag = 0;

    opterr = 0;
    while ((result = getopt(argc, argv, "abc:de:")) != -1) {
        switch (result) {
            case 'a':
                a_flag = 1;
                break;
            case 'b':
                b_flag = 1;
                break;
            case 'c':
                c_flag = 1;
                c_arg = optarg;
                break;
            case 'd':
                d_flag = 1;
                break;
            case 'e':
                e_flag = 1;
                e_arg = optarg;
                break;
            case '?':
                if (optopt == 'c' || optopt == 'e')
                    fprintf(stderr, "-%c option must have an argument!\n", optopt);
                else
                    fprintf(stderr, "-%c invalid option!\n", optopt);
                err_flag = 1;
        }
    }

    if (err_flag)
        exit(EXIT_FAILURE);

    if (a_flag)
        printf("-a option given\n");
    if (b_flag)
        printf("-b option given\n");
    if (c_flag)
        printf("-c option given with argument \"%s\"\n", c_arg);
    if (d_flag)
        printf("-d option given\n");
    if (e_flag)
        printf("-e option given with argument \"%s\"\n", e_arg);

    if (optind != argc)
        printf("Arguments without option:\n");
    for (int i = optind; i < argc; ++i)
        puts(argv[i]);

    return 0;
}

/*--------------------------------------------------------------------------------------------------------------------------
	getopt fonksiyonun kullanımına bir örnek. Bu örnekte disp isimli program şu klomut satırı argümanlarını almaktadır:

	-x (display hex)
	-o (display octal)
	-t (display text)
	-n (number of character per line)

	Burada -x, -o ve -t seçeneklerinden yalnızca bir tanesi kullanılabilmektedir. eğer hiçbir seçenek kullanılmazsa default durum "-t" 
	biçimindedir. -n seçeneği yalnızca hex ve octal görüntülemede kullanılabilmektedir. Bu seçenek de belirtilmezse sanki "-n 16" gibi 
	bir belirleme yapıldığı varsayılmaktadır. 
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <ctype.h>
#include <stdbool.h>
#include <unistd.h>

#define DEFAULT_LINE_CHAR       16

bool disp_text(FILE *f);
bool disp_hex(FILE *f, int n_arg);
bool disp_octal(FILE *f, int n_arg);
int check_number(const char *str);

int main(int argc, char *argv[])
{
    int result;
    int t_flag, o_flag, x_flag, n_flag, err_flag;
    int n_arg;
    FILE *f;
    
    t_flag = o_flag = x_flag = n_flag = err_flag = 0;
    n_arg = DEFAULT_LINE_CHAR;
    opterr = 0;

    while ((result = getopt(argc, argv, "toxn:")) != -1) {
        switch (result) {
            case 't':
                t_flag = 1;
                break;
            case 'o':
                o_flag = 1;
                break;
            case 'x':
                x_flag = 1;
                break;
            case 'n':
                n_flag = 1;
                if ((n_arg = check_number(optarg)) < 0) {
                    fprintf(stderr, "-n argument is invalid!..\n");
                    err_flag = 1;
                }
                break;
            case '?':
                if (optopt == 'n')
                    fprintf(stderr, "-%c option given without argument!..\n", optopt);
                else
                    fprintf(stderr, "invalid option: -%c\n", optopt);
                err_flag = 1;

            break;
        }
    }

    if (err_flag) 
        exit(EXIT_FAILURE);

    if (t_flag + o_flag + x_flag > 1) {
        fprintf(stderr, "only one of -[tox] option may be specified!..\n");
        exit(EXIT_FAILURE);
    }

   if (t_flag + o_flag + x_flag == 0)
        t_flag = 1;

    if (t_flag && n_flag) {
        fprintf(stderr, "-n option cannot be used with -t option!..\n");
        exit(EXIT_FAILURE);
    }

    if (argc - optind == 0) {
        fprintf(stderr, "file must be specified!..\n");
        exit(EXIT_FAILURE);
    }
    if (argc - optind > 1) {
        fprintf(stderr, "too many files specified!..\n");
        exit(EXIT_FAILURE);
    }

    if ((f = fopen(argv[optind], t_flag ? "r" : "rb")) == NULL) {
        fprintf(stderr, "cannot open file: %s\n", argv[optind]);
        exit(EXIT_FAILURE);
    }
    if (t_flag)
        result = disp_text(f);
    else if (x_flag)
        result = disp_hex(f, n_arg);
    else if (o_flag)
        result = disp_octal(f, n_arg);

    if (!result) {
        fprintf(stderr, "canno read file: %s\n", argv[optind]);
        exit(EXIT_FAILURE);
    }

    fclose(f);

    return 0;
}

bool disp_text(FILE *f)
{
    int ch;

    while ((ch = fgetc(f)) != EOF)
        putchar(ch);

    return feof(f);       
}

bool disp_hex(FILE *f, int n_arg)
{
    size_t i;
    int ch;

    for (i = 0;(ch = fgetc(f)) != EOF; ++i) {
        if (i % n_arg == 0) {
            if (i != 0)
                putchar('\n');
            printf("%08zX ", i);
        }
        printf("%02X ", ch);

    }
    putchar('\n');

    return feof(f);
}

bool disp_octal(FILE *f, int n_arg)
{
    size_t i;
    int ch;

    for (i = 0;(ch = fgetc(f)) != EOF; ++i) {
        if (i % n_arg == 0) 
            printf("%08zo ", i);
    
        printf("%03o ", ch);
        if (i % n_arg == n_arg - 1)
            putchar('\n');
    }
    putchar('\n');

    return feof(f);
}

int check_number(const char *str)
{
    const char *temp;
    int result;

    while (isspace(*str))
        ++str;
    
    temp = str;

    while (isdigit(*str))
        ++str;
    
    if (*str != '\0')
        return -1;
    
    result = atoi(temp);
    if (!result)
        return -1;

    return result;
}

/*--------------------------------------------------------------------------------------------------------------------------
    Aşağıdaki örnekte mycalc isimli bir program yazılmıştır. Program iki komut satırı argümanı ile aldığı değerler üzerinde dört 
    işlem yapmaktadır. Aşağıdaki seçeneklere sahiptir:

    -a: toplama işlemi
    -m: Çarpma işlemi
    -d: Bölme işlemi
    -s: Çıkartma işlemi
    -D msg: Çıktının başında "msg: " kısmını ekler
---------------------------------------------------------------------------------------------------------------------------*/

/* mycalc.c */

#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>

int main(int argc, char *argv[])
{
    int result;
    int a_flag, m_flag, M_flag, d_flag, s_flag, err_flag;   
    char *M_arg;
    double arg1, arg2, calc_result;

    a_flag = m_flag = M_flag = d_flag = s_flag = err_flag = 0;
    
    opterr = 0;
    
    while ((result = getopt(argc, argv, "amM:ds")) != -1) {
        switch (result) {
            case 'a':
                a_flag = 1;
                break;
            case 'm':
                m_flag = 1;
                break;
            case 'M':
                M_flag = 1;
                M_arg = optarg;
                break;
            case 'd':
                d_flag = 1;
                break;
            case 's':
                s_flag = 1;
                break;
            case '?':
                if (optopt == 'M')
                    fprintf(stderr, "-M option must have an argument!\n");
                else
                    fprintf(stderr, "invalid option: -%c\n", optopt);
                err_flag = 1;
        }
    }

    if (err_flag)
        exit(EXIT_FAILURE);

    if (a_flag + m_flag + d_flag + s_flag > 1) {
        fprintf(stderr, "only one option must be specified!\n");
        exit(EXIT_FAILURE);
    }
    if (a_flag + m_flag + d_flag + s_flag  == 0) {
        fprintf(stderr, "at least one of -amds options must be specified\n");
        exit(EXIT_FAILURE);
    }

    if (argc - optind != 2) {
        fprintf(stderr, "two number must be specified!\n");
        exit(EXIT_FAILURE);
    }

    arg1 = atof(argv[optind]);
    arg2 = atof(argv[optind + 1]);

    if (a_flag)
        calc_result = arg1 + arg2;
    else if (m_flag)
        calc_result = arg1 * arg2;
    else if (d_flag)
            calc_result = arg1 / arg2;
    else
        calc_result = arg1 - arg2;

    if (M_flag)
        printf("%s: %f\n", M_arg, calc_result);
    else
        printf("%f\n", calc_result);

    return 0;
}

/*--------------------------------------------------------------------------------------------------------------------------
	Daha önceden de belirttiğimiz gibi komut satırında uzun seçenek kullanımı POSIX standartlarında yoktur. Ancak Linux gibi pek çok 
	sistemdeki çeşitli yardımcı programlar uzun seçenekleri desteklemektedir. Programlarda bazı kısa seçeneklerin eşdeğer uzun seçenekleri
	bulunmaktadır. Bazı uzun seçeneklerin ise kısa senek eşdeğeir bulunmamaktadır. Bazı kısa seçeneklerin de uzun seçenek eşdeğerleri yoktur. 

	Uzun seçenekleri parse etmek için getopt_long isimli fonksiyon kullanılmakatdır. Uzun seçenekler POSIX standartlarında olmadığına göre 
	getopt_long fonksiyonu da bir POSIX fonksiyonu değildir. Ancak GNU'nun glibc kütüphanesinde bir eklenti biçiminde bulunmaktadır. 
	getopt_long fonksiyonu işlevsel olarak getopt fonksiyonunu kapsamaktadır. Ancak fonksiyonun kullanımı biaz daha zordur. Fonksiyonun 
	prototipi şöyledir:


	#include <getopt.h>

	int getopt_long(int argc, char * const argv[], const char *optstring, const struct option *longopts, int *longindex);

	Fonksiyonun birinci ve ikinci parametrelerine main fonksiyonundan alınan argc ve argv parametreleri geçirilir. Fonksiyonun üçüncü parametresi 
	yine kısa seçeneklerin belirtildiği yazının adresini almaktadır. Yani fonksiyonun ilk üç parametresi tamamen getopt fonksiyonu ile aynıdır. 
	Fonksiyonun dördüncü parametresi uzun seçeneklerin belirtildiği struct option türünden bir yapı dizisinin adresini almaktadır. Her uzun seçenek
	struct option türünden bir nesneyle ifade edilmektedir. struct option yapısı şöyle bildirilmiştir:

	struct option {
		const char *name;
		int         has_arg;
		int        *flag;
		int         val;
	};

	Fonksiyon bu yapı dizisinin bittiğini nasıl anlayacaktır? İşte yapı dizisinin son elemanına ilişkin yapı nesnesinin tüm elemanları 0'larla
	doldurulmalıdır. (0 sabitinin göstericiler söz konusu olduğunda NULL adres anlamına geldiğini de anımsayınız.)

	struct option yapısının name elemanı uzun seçeneğin ismini belirtmektedir. Yapının has_arg elemanı üç değerden birini alabilir:

	no_argument (0)
	required_argument (1)
	optional_argument (2)

	Bu eleman uzun seçeneğin argüman alıp almadığını belirtmektedir. Yapının flag ve val elemanları birbirleriyle ilişkilidir. Yapının val elemanı
	uzun seçenek bulunduğunda bunun hangi sayısal değerle ifade edileceğini belirtir. İşte bu flag elemanına int bir nesnenin adresi geçilirse bu durumda 
	uzun seçenek bulunduğunda bu val değeri bu int nesneye yerleştirilir. getopt_long iğse bu udurmda 0 değeri ile geri döner. Ancak bu flag 
	göstewricisine NULL adres de geçilebilir. Bu durumda getopt_long uzun seçenek bulunduğunda val elemanındaki değeri geri dönüş değeri olarak verir. 
	Örneğin:

	struct option options[] = {
		{"count", required_argument, NULL, 'c'},
		{0, 0, 0, 0}
	};

	Burada uzun seçenek "--count" biçimindedir. Bir argümanla kullanılmak zorundadır. Bu uzun seçenek bulunduğunda flag parametresi NULL adres 
	geçildiği için getopt_long fonksiyonu 'c' değeri ile geri dönecektir. Örneğin:

	int count_flag;
	...

	struct option options[] = {
		{"count", required_argument, &count_flag, 1},
		{0, 0, 0, 0}
	};

	Burada artık uzun seçenek bulunduğunda getopt_long fonksiyonu 0 ile geri dönecek ancak 1 değeri count_flag nesnesine yerleştirilecektir. 

	getopt_long fonksiyonunun son parametresi uzun seçenek bulunduğunda o uzun seçeneğin option dizisindeki kaçıncı indeksli uzun seçenek olduğunu 
	anlamak için kullanılmaktadır. Burada belirtilen adresteki nesneye uzun seçeneğin option dizisi içerisindeki ndeks numarası yerleştirilmektedir. 
	Ancak bu bilgiye genellikle gereksinim duyulmamaktadır. Bu parametre NULL geçilebilir. Bu durumda böyle bir yerleştirme yapılmaz. 

	Bu durumda getopt_long fonksiyonunun geri dönüş değeri beş biçimden biri olabilir:

	1) Fonksiyon bir kısa seçenek bulmuştur. Kısa seçeneğin karakter koduyla geri döner. 
	2) Fonksiyon bir uzun seçenek bulmuştur ve option yapısının flag elemanında NULL adres vardır. Bu durumda fonksiyon option yapısının 
	val elemanındaki değerler geri döner. 
	3) Fonksiyon bir uzun seçenek bulmuştur ve option yapısının flag elemanında NULL adres yoktur. Bu durumda fonksiyon val değerini bu adrese 
	yerleştirir ve 0 değeri ile geri döner. 
	4) Fonksiyon geçersiz (yani olmayan) bir kısa ya da uzun seçenekle karşılaşmıştır ya da argümanlı bir kısa seöenek ya da uzun seçeneğin 
	argümanı girilmemiştir. Bu durumda fonksiyon '?' karakterinin değeriyle geri döner. 
	5) Parse edecek argüman kalmamıştır fonksiyon -1 ile geröner. 

	getopt fonksiyonundaki yardımcı global değişkenlerin aynısı burada da kullanılmaktadır:

	opterr: Hata mesajının fonksiyon tarafından stderr dosyasına basılıp basılmayacağını belirtir. 
	optarg: Argümanlı bir kısa ya da uzun seçenekte argümanı belirtmektedir. Eğer "isteğe bağlı argümanlı" bir uzun seçenek bulunmuşsa 
	ve bu uzun seçenek için argüman girilmemişse optarg nesnesine NULL adres yerleştirilmektedir. 
	optind: Bu değişken yine seöeneksiz argümanların başladığı indeksi belirtmektedir. 
	optopt: Bu değişken geçerisz bir uzun ya da kısa seçenek girildiğinde hatanın nedenini belirtmektedir. 

	getopt_long geçersiz bir seçenekle karşılaştığında '?' geri dönmekle birlikte optopt değişkenini şu biçimlerde set etmektedir:

	1) Eğer fonksiyon argümanlı bir kısa seçenek bulduğu halde argüman girilmemişse o argümanlı kısa seçeneğin karakter karşışığını 
	optopt değişkenine yerleştirir. 
	2) Eğer fonksiyon argümanlı bir uzunseçenek bulduğu halde argüman girilmemişse o argümanlı uzun seçeneğin option yapısındaki val değerini 
	optopt değişkenine yerleştirmektedir. 
	3) Eğer fonksiyon geçersiz bir kısa seçenekle karşılaşmışsa bu duurmda optopt geçersiz kısa seçeneğin karakter karşılığına geri döner.
	4) Eğer fonksiyon geçersiz bir uzun seçenekle karşılaşmışsa bu duurmda optopt değişkenine 0 değeri yerleştirilmektedir.

	Maalesef getopt_long olmayan bir uzun seçenek girildiğinde bunubize vermemektedir. Ancak GNU'nun getopt_long gerçekleştirimine bakıldığında 
	bu geçersiz uzun seçeneğin argv dizisinin "optind - 1" indeksinde olduğu görülmektedir. Yani bu geçersiz uzun seçeneğe argv[optind - 1] 
	ifadesi ile erişilebilmektedir. Ancak bu durum glibc dokümanlarında belirtilmemiştir. Bu nedenle bu özelliğin kullanılması uygun değildir. 
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
                                                    5. Ders 06/11/2022 - Pazar
--------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
	Aşağıdaki örnekteki komut satırı argümanları şunlardır:

	-a
	-b
	-c <arg> ya da --count <arg>
	--verbose
--------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <getopt.h>

int main(int argc, char *argv[])
{
	int a_flag, b_flag, c_flag, verbose_flag;
	int err_flag;
	char *c_arg;
	int result;

	struct option options[] = {
		{"count", required_argument, NULL, 'c'},
		{"verbose", no_argument, &verbose_flag, 1},
		{0, 0, 0, 0}
	};

	a_flag = b_flag = c_flag = verbose_flag = err_flag = 0;

	opterr = 0;
	while ((result = getopt_long(argc, argv, "abc:", options, NULL)) != -1) {
		switch (result) {
		case 'a':
			a_flag = 1;
			break;
		case 'b':
			b_flag = 1;
			break;
		case 'c':
			c_flag = 1;
			c_arg = optarg;
			break;
		case '?':
			if (optopt == 'c')
				fprintf(stderr, "option -c or --count without argument!..\n");
			else if (optopt != 0)
				fprintf(stderr, "invalid option: -%c\n", optopt);
			else
				fprintf(stderr, "invalid long option!..\n");
			/* fprintf(stderr, "invalid long option: %s\n", argv[optind - 1]); */
			err_flag = 1;
			break;
		}
	}

	if (err_flag)
		exit(EXIT_FAILURE);

	if (a_flag)
		printf("-a option given\n");
	if (b_flag)
		printf("-b option given\n");
	if (c_flag)
		printf("-c or --count option given with argument \"%s\"\n", c_arg);
	if (verbose_flag)
		printf("--verbose given\n");

	if (optind != argc) {
		printf("Arguments without options");
		for (int i = optind; i < argc; ++i)
			printf("%s\n", argv[i]);
	}

	return 0;
}

/*--------------------------------------------------------------------------------------------------------------------------
	getopt_long fonksiyonun kullanımına diğer bir örnekte aşağıda verilmiştir. Aşağıda programın komut satırı argümanları şunlardır:

	-a
	-b <arg>
	-c 
	-h ya da --help
	--count <arg>
	--line[=<arg>]
--------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <getopt.h>

int main(int argc, char *argv[])
{
	int result;
	int a_flag, b_flag, c_flag, h_flag, count_flag, line_flag;
	char *b_arg, *count_arg, *line_arg;
	int err_flag;
	int i;

	struct option options[] = {
		{"help", no_argument, &h_flag, 1},
		{"count", required_argument, NULL, 2},
		{"line", optional_argument, NULL, 3},
		{0, 0, 0, 0 },
	};

	a_flag = b_flag = c_flag = h_flag = count_flag = line_flag = 0;
	err_flag = 0;

	opterr = 0;
	while ((result = getopt_long(argc, argv, "ab:ch", options, NULL)) != -1) {
		switch (result) {
			case 'a':
				a_flag = 1;
				break;
			case 'b':
				b_flag = 1;
				b_arg = optarg;
				break;
			case 'c':
				c_flag = 1;
				break;
			case 'h':
				h_flag = 1;
				break;
			case 2:			/* --count */
				count_flag = 1;
				count_arg = optarg;
				break;
			case 3:			/* --line */
				line_flag = 1;
				line_arg = optarg;
				break;
			case '?':
				if (optopt == 'b')
					fprintf(stderr, "-b option must have an argument!..\n");
				else if (optopt == 2)
					fprintf(stderr, "argument must be specified with --count option\n");
				else if (optopt != 0)
					fprintf(stderr, "invalid option: -%c\n", optopt);
				else
					fprintf(stderr, "invalid long option!..\n");

				err_flag = 1;

				break;
		}
	}

	if (err_flag)
		exit(EXIT_FAILURE);

	if (a_flag)
		printf("-a option given...\n");

	if (b_flag)
		printf("-b option given with argument \"%s\"...\n", b_arg);

	if (c_flag)
		printf("-c option given...\n");

	if (h_flag)
		printf("-h or --help option given...\n");

	if (count_flag)
		printf("--count option specified with \"%s\"...\n", count_arg);

	if (line_flag) {
		if (line_arg != NULL)
			printf("--line option given with optional argument \"%s\"\n", line_arg);
		else
			printf("--line option given without optional argument...\n");
	}

	if (optind != argc) {
		printf("Arguments without options:\n");
		for (i = optind; i < argc; ++i)
			printf("%s\n", argv[i]);
	}

	return 0;
}

/*--------------------------------------------------------------------------------------------------------------------------
    getopt_long fonksiyonun kullanılmasına başka bir örnek. Bu örnekteki seçenekler şöyledir:

    -a: arümansız kısa seçenek
    -b: argümanlı kısa seçenek
    --all: argümansız uzun seçenek
    --length: argümanlı uzun seçenek
    --number: isteğe bağlı argümanlı uzun seçenek
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <getopt.h>

int main(int argc, char *argv[])
{
    int result;
    struct option options[] = {
        {"all", no_argument, NULL, 1}, 
        {"length", required_argument, NULL, 2}, 
        {"number", optional_argument, NULL, 3},
        {0, 0, 0, 0},
    };
    int a_flag, b_flag, all_flag, length_flag, number_flag, err_flag;
    char *b_arg, *length_arg, *number_arg;

    a_flag = b_flag = all_flag = length_flag = number_flag = err_flag = 0;
    opterr = 0;
    while ((result = getopt_long(argc, argv, "ab:", options, NULL)) != -1) {
        switch (result) {
            case 'a':
                a_flag = 1;
                break;
            case 'b':
                b_flag = 1;
                b_arg = optarg;
                break;
            case 1:
                all_flag = 1;
                break;
            case 2:
                length_flag = 1;
                length_arg = optarg;
                break;
            case 3:
                number_flag = 1;
                number_arg = optarg;
                break;
            case '?':
                if (optopt == 'b')
                    fprintf(stderr, "-b option without argument!\n");
                else if (optopt == 2)
                    fprintf(stderr, "--length option without argument!\n");
                else if (optopt != 0)
                    fprintf(stderr, "invalid option: -%c\n", optopt);
                else
                    fprintf(stderr, "invalid long option!\n");
                err_flag = 1;
        }
    }    
    if (err_flag)
        exit(EXIT_FAILURE);

    if (a_flag)
        printf("-a option given\n");
    if (b_flag)
        printf("-b option given with argument \"%s\"\n", b_arg);
    if (all_flag)
        printf("--all option given\n");
    if (length_flag)
        printf("--length option given with argument \"%s\"\n", length_arg);
    if (number_flag)
        if (number_arg != NULL)
            printf("--number option given with argument \"%s\"\n", number_arg);
        else
            printf("--number option given without argument\n");
       
    if (optind != argc) 
        printf("Arguments without options:\n");
    for (int i = optind; i < argc; ++i)
        puts(argv[i]);
    
    return 0;
}

/* 

test girişi: ./sample --all --length 100 --number=300 -a ali veli selami
Çıktısı şöyledir:

-a option given
--all option given
--length option given with argument "100"
--number option given with argument "300"
Arguments without options:
ali
veli
selami

*/

/*--------------------------------------------------------------------------------------------------------------------------
    getopt_long fonksiyonunda struct option yapısındaki flag elemanına NULL adres yerine int bir nesnenin adresi geçirilirse
    bu durumda getopt_long bu uzun seçenek girildiğinde doğrudan yapının val elemanındaki değeri bu nesneye yerleştirir ve 0 ile geri 
    döner. Böylece programcı isterse argümansız uzun seçenekleri switch içerisinde işlemeden doğrudan onun bayrağına set işlemi 
    yapabilir. Ayrıca programlarda kısa seçeneklerin uzun seçenek eşdeğerleri de bulunabilmektedir. Bunu sağlamanın en kolay yolu 
    uzun seçeneğe ilişkin struct option yapısındaki val elemanına kısa seçeneğe ilişkin karakter kodunu girmektir. 
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <getopt.h>

int main(int argc, char *argv[])
{
    int result;
    int a_flag, b_flag, all_flag, length_flag, number_flag, err_flag;
    char *b_arg, *length_arg, *number_arg;
    struct option options[] = {
        {"all", no_argument, &all_flag, 1}, 
        {"length", required_argument, NULL, 'l'}, 
        {"number", optional_argument, NULL, 3},
        {0, 0, 0, 0},
    };

    a_flag = b_flag = all_flag = length_flag = number_flag = err_flag = 0;
    opterr = 0;
    while ((result = getopt_long(argc, argv, "ab:l:", options, NULL)) != -1) {
        switch (result) {
           case 'b':
                b_flag = 1;
                b_arg = optarg;
                break;
            case 1:
                all_flag = 1;
                break;
            case 'l':
                length_flag = 1;
                length_arg = optarg;
                break;
            case 3:
                number_flag = 1;
                number_arg = optarg;
                break;
            case '?':
                if (optopt == 'b')
                    fprintf(stderr, "-b option without argument!\n");
                else if (optopt == 2)
                    fprintf(stderr, "--length option without argument!\n");
                else if (optopt != 0)
                    fprintf(stderr, "invalid option: -%c\n", optopt);
                else
                    fprintf(stderr, "invalid long option!\n");
                err_flag = 1;
        }
    }    
    if (err_flag)
        exit(EXIT_FAILURE);

    if (a_flag)
        printf("-a option given\n");
    if (b_flag)
        printf("-b option given with argument \"%s\"\n", b_arg);
    if (all_flag)
        printf("--all option given\n");
    if (length_flag)
        printf("--length option given with argument \"%s\"\n", length_arg);
    if (number_flag)
        if (number_arg != NULL)
            printf("--number option given with argument \"%s\"\n", number_arg);
        else
            printf("--number option given without argument\n");
       
    if (optind != argc) 
        printf("Arguments without options:\n");
    for (int i = optind; i < argc; ++i)
        puts(argv[i]);
    
    return 0;
}

/*--------------------------------------------------------------------------------------------------------------------------
                                            6. Ders 12/11/2022 - Cumartesi
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Bir kullanıcı ile login olunduğunda login programı /etc/passwd dosyasında belirtilen programı çalıştırır. 
    Biz istersek bu programı değiştirip kendi istediğimiz bir programın çalıştırılmasını sağlayabiliriz. Kendi programımız 
    myshell isimli program olsun ve onu /bin dizinine kopyalamış olalım. /etc/passwd dosyasnının içeriğini şöyle değiştirebiliriz:

    ali:x:1002:1001::/home/ali:/bin/myshell
---------------------------------------------------------------------------------------------------------------------------*/

/* myshell.c */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

#define MAX_CMD_LINE        4096
#define MAX_CMD_PARAMS      128

typedef struct tagCMD {
    char *name;
    void (*proc)(void);
} CMD;

void parse_cmd_line(char *cmdline);
void dir_proc(void);
void clear_proc(void);
void pwd_proc(void);

char *g_params[MAX_CMD_PARAMS];
int g_nparams;

CMD g_cmds[] = {
    {"dir", dir_proc},
    {"clear", clear_proc},
    {"pwd", pwd_proc},
    {NULL, NULL}
};

int main(void)
{
    char cmdline[MAX_CMD_LINE];
    char *str;
    int i;

    for (;;) {
        printf("CSD>");
        if (fgets(cmdline, MAX_CMD_LINE, stdin) == NULL)
            continue;
        if ((str = strchr(cmdline, '\n')) != NULL)
            *str = '\0';
        parse_cmd_line(cmdline);
        if (g_nparams == 0)
            continue;
        if (!strcmp(g_params[0], "exit"))
            break;
        for (i = 0; g_cmds[i].name != NULL; ++i)
            if (!strcmp(g_params[0], g_cmds[i].name)) {
                g_cmds[i].proc();
                break;
            }
        if (g_cmds[i].name == NULL)
            printf("bad command: %s\n", g_params[0]);
    }

    return 0;
}

void parse_cmd_line(char *cmdline)
{
    char *str;

    g_nparams = 0;
    for (str = strtok(cmdline, " \t"); str != NULL; str = strtok(NULL, " \t"))
        g_params[g_nparams++] = str;
}

void dir_proc(void)
{
    printf("dir command executing..\n");
}

void clear_proc(void)
{
    system("clear");
}

void pwd_proc(void)
{
    char cwd[4096];

    if (g_nparams > 1) {
        printf("pwd command must be used withoud argument!..\n");
        return;
    }

    getcwd(cwd, 4096);

    printf("%s\n", cwd);
}

/*--------------------------------------------------------------------------------------------------------------------------
                                            7. Ders 13/11/2022 - Pazar
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Bir hata değerinin yazsını elde etmek için strerror fonksiyonu kullanılabilir. Fonksiyon bizden EXXXX biçimindeki hata kodunu 
    parametre olarak alır, bize statik düzeyde tahsis edilmiş hata yazısının adresini verir. Biz de POSIX fonksiyonu başarısız 
    olduğunda errno değerini bu biçimde yazıya dönüştürüp rapor edebiliriz. 

    Aşağıda buna bir örnek verilmiştir.
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <errno.h>
#include <fcntl.h>

int main(void)
{
    int fd;

    if ((fd = open("xxx.txt", O_RDONLY)) == -1) {
        fprintf(stderr, "open failed: %s\n", strerror(errno));
        exit(EXIT_FAILURE);
    }
    printf("success\n");
    
    return 0;
}

/*--------------------------------------------------------------------------------------------------------------------------
    strerror fonksiyonu ile alınan error yazısı default durumda İngilizcedir. POSIX standartlarına göre bu yazının içeriği locale'in
    LC_MESSAGES kategorisine göre ayarlanmaktadır. Dolayısıyla eğer mesajları Türkçe bastırmak istiyorsanız LC_MESSAGES kategorisine ilişkin 
    locale'i setlocale fonksiyonu ile değiştrmelisiniz. Tabii genel olarak tüm kategorilerin değiştirilmesi yoluna gidilmektedir. 
    Türkçe UNICODE UTF-8 locale'i "tr_TR.UTF-8" ile temsil edilmektedir. dolayısıyla bu işlemi şöyle yapabilirsiniz:

    if (setlocale(LC_ALL, "tr_TR.UTF-8") == NULL) {
        fprintf(stderr, "cannot set locale!..\n");
        exit(EXIT_FAILURE);
    }
---------------------------------------------------------------------------------------------------------------------------*/


#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <errno.h>
#include <locale.h>

int main(void)
{
    if (setlocale(LC_ALL, "tr_TR.UTF-8") == NULL) {
        fprintf(stderr, "cannot set locale!..\n");
        exit(EXIT_FAILURE);
    }

    puts(strerror(EPERM));
    
    return 0;
}

/*--------------------------------------------------------------------------------------------------------------------------
    POSIX fonksiyonlarında oluşan hatayı rapor etmek için perror isimli daha pratik kullanımı olan bir POSIX fonksiyonu (aynı zamanda 
    standart C fonksiyonudur) bulundurulmuştur. Fonksiyonun prototipi şöyledir:

    #include <stdio.h> 

    void perror(const char *str);

    Fonksiyon argüman olarak girilen yazıyı stderr dosyasına yazdırır. Sonra hemen yanına ':' karakterini ve bir SPACE karakterini basar ve sonra da o andaki 
    errno değerinin yazısını yazdırır. İmleci şağaı satırın başına geçirir. Fonksiyon aşağıdaki gibi yazılabilir:

    void perror(const char *str)
    {
        fprintf(stderr, "%s: %s\n", str, strerror(errno));
    }

---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <fcntl.h>

int main(void)
{
    int fd;

    if ((fd = open("xxx.txt", O_RDONLY)) == -1) {
        perror("open");
        exit(EXIT_FAILURE);
    }
    printf("success\n");
    
    return 0;
}

/*--------------------------------------------------------------------------------------------------------------------------
    Biz kursumuzda bir POSIX fonksiyonu başarısız olduğunda genellikle (ancak her zaman değil) programımızı sonlandıracağız. 
    Bu durumda daha az tuşa basmak için bir exit_sys isimli "sarma (wrapper)" fonksiyondan faydalanacağız. Bu fonksiyon önce perror
    fonksiyonu ile hatayı stderr dosyasına yazdıracak sonra da exit fonksiyonu ile program  sonlandıracaktır:

    void exit_sys(const char *msg)
    {
        perror(msg);

        exit(EXIT_FAILURE);
    }

---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <errno.h>
#include <fcntl.h>

void exit_sys(const char *msg);

int main(void)
{
    int fd;

    if ((fd = open("xxx.txt", O_RDONLY)) == -1) 
        exit_sys("open");
        
    printf("success\n");
    
    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/*--------------------------------------------------------------------------------------------------------------------------
    Bazı programcılar ukarıdaki exit_sys fonksiyonunu printf fonksiyonuna benzetmektedir. (Örneğin Stevens "Advanced Programming int the
    UNIX Environment)" kitabında böyle bir sarma fonksiyon kullanmıştır. Böyle bir sarma fonksiyona örnek şu olabilir:

    void exit_sys(const char *format, ...)
    {
        va_list ap;
    
        va_start(ap, format);
        vfprintf(stderr, format, ap);
        fprintf(stderr, ": %s\n", strerror(errno));

        va_end(ap);

        exit(EXIT_FAILURE);
    }
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <stdarg.h>
#include <errno.h>
#include <fcntl.h>

void exit_sys(const char *format, ...);

int main(void)
{
    int fd;
    char path[] = "xxx.txt";

    if ((fd = open(path, O_RDONLY)) == -1) 
        exit_sys("open (%s)", path);

    printf("success\n");
    
    return 0;
}

void exit_sys(const char *format, ...)
{
    va_list ap;
   
    va_start(ap, format);
    vfprintf(stderr, format, ap);
    fprintf(stderr, ": %s\n", strerror(errno));
    va_end(ap);

    exit(EXIT_FAILURE);
}

/*--------------------------------------------------------------------------------------------------------------------------
    C standartlarında errno değeri çok kısıtlı bir biçimde kullanılmıştır. Yani C standartlarında pek az fonksiyon errnoo değişklenini 
    set etmektedir. Ancak standartlar çeşitli standart C fonksiyonlarının errno değişkenini derleyiciye bağlı olarak set edebileceğini 
    belirtmektedir. POSIX standartlarına göre her standart C fonksiyonu aynı zamanda bir POSIX fonksiyonu olarak ele alınmaktadır. 
    Standart C fonksiyonları aynı zamanda errno değişkenini de set etmektedir. Örneğin biz fopen fonksiyonu ile bir dosyayı açmak istesek 
    fopen başarısız olduğunda UNIX/Linux sistemleri errno değerini uygun biçimde set edebilmektedir. Böylece biz standart C fonksiyonlarındaki 
    hata mesajlarını da aşağıdaki gibi yazdırabilmekteyiz:

    if ((f = fopen("test.dat", "r")) == NULL)
        exit_sys("fopen");

    Ya da örneğin:

    if ((p = malloc(SIZE)) == NULL) 
        exit_sys("malloc");

    Her ne kadar standart C fonksiyonları UNIX/Linux sistemlerinde errno değişkenini set ediyorsa da biz standart C uyumunu korumak için
    kursumuzda standart C fonksiyonlarında set edilen errno değişkenini kullanmayacağız. Örneğin:

    if ((f = fopen("test.dat", "r")) == NULL) {
        fprintf(stderr, "cannot open file!..\n");
        exit(EXIT_FAILURE);
    }

---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    UNIX/Linux sistemlerinde her dosyanın bir kullanıcı id'si (user id) ve grup id'si (group id) bulunmaktadır. Bu sistemlerde 
    tüm dosyalar "open" isimli bir POSIX fonksiyonu tarafından yaratılmaktadır. Bir dosyanın kullanıcı id'si onu yaratan 
    prosesin etkin kullanıcı id'si olarak set edilmektedir. Dosyanın grup id'si ise iki seçenekten biri olarak set edilebilmektedir. 
    Bazı sistemler dosyanın grup id'sini onu yaratan prosesin etkin grup id'si olarak set etmektedir. Bu biçim klasik AT&T 
    UNIX sistemlerinin uyguladığı biçimdir. Linux böyle davranmaktadır. İkinci seçenek BSD sistemlerinde olduğu gibi dosyanın grup 
    id'sinin onun içinde bulunduğu dizinin grup id'si olarak set edilmesidir. POSIX standratları her iki durumu da geçerli kabul etmektedir. 
    Linux sistemlerinde "mount parametreleriyle" BSD tarzı davranış istenirse oluşturulabilmektedir. Aynı zamanda Linux sistemlerinde 
    "dosyanın içinde bulunduğu dizinde set group id" baayrağı set edilerek de aynı etki oluşturulabilmektedir. 
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
                                                    8. Ders 20/11/2022 - Cumartesi
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Bir dosya üzerinde işlem yapmak isteyen proses erişme biçimini de (okumak için mi, yazmak için mi, hem okuyup hem yazmak için mi, 
    yoksa dosyadaki kodu çalıştırmak için mi) belirtmektedir. Bu durumda işletim sistemi sırasıyla şu kontrolleri yapmaktadır (bu işlemler else-if
    biçiminde sıralanmıştır):

    1) Eğer işlem yapmak isteyen isteyen prosesin etkin kullanıcı id'si (etkin grup id'sinin burada önemi yoktur) 0 ise işlem yapmak
    isteyen proses yetkili kullanıcının bir prosesidir. Bu tür proseslere "root prosesler" ya da "super user prosesler" ya da "öncelikli (priviledged)
    prosesler" denilmektedir. Bu durumda işletim sistemi yapılmak istenen işlem ne olursa olsun bu işleme onay verir.

    2) Eğer işlem yapmak isteyen prosesin etkin kullanıcı id'si (effective user id) dosyanın kullanıcı id'si ile aynıysa bu durumda "dosyanın sahibinin 
    dosya üzerinde işlem yaptığı gibi mantıksal bir çıkarım" yapılmaktadır. Yapılmak istenen işlem ile dosyanın sahiplik (owner) erişim bilgileri karşılaştırılır.
    Eğer bu erişim bilgileri işlemi destekliyorsa işleme onay verilir. Değilse işlem başarısızlıkla sonuçlanır.

    3) Eğer işlem yapmak isteyen prosesin etkin grup id'si (effective group id) ya da "ek grup (supplemantary groups)" id'lerinden  biri dosyanın grup id'si ile 
    aynıysa bu durumda "dosya ile aynı grupta bulunan bir kullanıcının  dosya üzerinde işlem yaptığı gibi mantıksal bir çıkarım" yapılmaktadır. Yapılmak istenen işlem ile dosyanın grupluk (group) erişim bilgileri karşılaştırılır. Eğer bu erişim bilgileri işlemi destekliyorsa işleme onay verilir. Değilse işlem başarısızlıkla sonuçlanır.

    4) İşlem yapmak isteyen proses herhangi bir proses ise bu durmda yapılmak istenen işlem ile dosyanın "diğer (other)" erişim bilgileri karşılaştırılır. Eğer bu erişim bilgileri işlemi destekliyorsa işleme onay verilir. Değilse işlem başarısızlıkla sonuçlanır. 

    Örneğin aşağıdaki gibi bir dosya söz konusu olsun:

    -rw-r--r-- 1 kaan study    20 Kas 13 13:54 test.txt

    Dosya erişim yapmak isteyen proses "okuma ve yazma amaçlı" erişim yapmak istesin. Eğer prosesin etkin kullanıcı id'si 0 ise bu işlem onaylanacaktır. 
    Eğer prosesin etkin kullanıcı id'si "kaan" ise bu işlem yine onaylanacaktır. Ancak prosesin etkin grup id'si ya da ek grup id'lerinden biri study ise
    işlemonaylanmayacaktır. Çünkü erişim hakları gruptaki üyelere yalnızca pkuma izni vermektedir. Benzer biçimde prosesin etkin kullanıcı id'si ya da etkin grup id'si (ve ek grup id'leri) burada belirtilenlerin dışında ise yine prosese bu işlem için onay verilmeyecektir. 

    Yukarıdaki maddelere else-if biçiminde düşünülmelidir. Örneğin dosya aşağıdaki gibi olsun:

    -r--rw-r-- 1 kaan study    20 Kas 13 13:54 test.txt

    Burada dosyanın sahibi (yani etkin kullanıcı id'si dosyanın kullanıcı id'si ile aynı olan proses) dosya üzerinde yazma yapamayacaktır. Ancak aynı 
    grupta olan prosesler bunu yapabilecektir. Tabii bu biçimdeki erişim hakları mantıksal olarak tuhaf ve anlamsızdır. Yani dosyanın sahibine 
    verilmeyen bir hakkın gruba ya da diğerlerine verilmesi normal bir durum değildir.

    Çalıştırılabilir bir dosya 'x' hakkı ile temsil edilmiştir. Bu durumda biz bir program dosyasının başkaları tarafından çalıştırılması engelleyebiliriz. Örneğin:

    -rwxr--r-- 1 kaan study 16816 Kas 13 13:49 sample

    Burada dosyanın sahibi (ve tabii root kullanıcısı) bu dosyayı çalıştırabilir. Ancak diğer kullanıcılar bu dosyayı çalıştıramazlar. Örneğin:

    -rw-r--r-- 1 kaan study 16816 Kas 13 13:49 sample

    Burada artık root kullanıcısı da dosyayı çalıştıramaz. root kullanıcısının dosyayı çalıştırabilmesi için sahiplik, grupluk ya da diğer erişim bilgilerinin 
    en az birinde 'x' hakkının belirtilmiş olması gerekmektedir. 
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    POSIX standartlarında erişim mekanizması üzerinde açıklamalar yapılırken "root önceliği" ya da "prosesin etkin kullanıcı id'sinin
    0 olması" gibi bir anlatım uygulanmamıştır. Onun yerine POSIX standartlarında "appropriate privileges" terimi kullanılmıştır. 
    Çünkü bir POSIX sistemi "ya hep ya hiç" biçiminde tasarlanmak zorunda değildir. Gerçekten de örneğin Linux sistemlerinde "capability"
    denilen bir özellik bulunmaktadır. Bu "capability" sayesinde bir prosesin etkin kullanıcı id'si 0 olmamasına karşın o proses belirlenen bazı şeyleri 
    yapabilir duruma getirilebilmektedir. İşte POSIX standartlarındaki "appropriate priveleges" terimi bunu anlatmaktadır. Yani buradaki 
    "appropriate privileges" terimi "prosein etkin kullanıcı id'si 0 ya da 0 olmasa da prosesin bu işlemi yapabilme yeteneğinin" olduğunu 
    belirtmektedir. 
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Prosesin çalışma dizini getcwd isimli POSIX fonksiyonuyla elde edilebilmektedir. Fonksiyonun prototipi şöyledir:

    #include <unistd.h>

    char *getcwd(char *buf, size_t size);

    Fonksiyonun birinci parametresi yol ifadesinin yerleştirileceği dizinin adresini ikinci parametresi ise bu dizinin null karakter 
    dahil olmak üzere uzunluğunu almaktadır. Fonksiyon başarı durumunda birinci parametresiyle belirtilen adresin aynısına başarısızlık durumunda 
    NULL adrese geri dönmektedir. Fonksiyonun ikinci parametresinde belirtilen uzunluk eğer yol ifadesini ve null karakteri içerecek büyüklükte değilse 
    fonksiyon başarısız olmaktadır. 

    UNIX/Linux sistemlerinde bir yol ifadesinin maksimum karakter sayısı (null karakter dahil olmak üzere) <limits.h> içerisindeki 
    PATH_MAX sembolik sabitiyle belirtilmiştir. Ancak bu konuda bazı ayrıntılar vardır. Bazı sistemlerde bu PATH_MAX sembolik sabiti tanımlı değildir. 
    Dolayısıyla bazı sistemlerde maksimum yol ifadesi uzunluğu pathconf denilen özel bir fonksiyon ile elde edilebilmektedir. Linux sistemlerinde 
    <limits.h> dosyası içerisinde PATH_MAX 4096 olarak define edilmiştir. 
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <limits.h>
#include <unistd.h>

void exit_sys(const char *msg);

int main(void)
{
    char buf[PATH_MAX];

    if (getcwd(buf, PATH_MAX) == NULL) 
        exit_sys("getcwd");

    puts(buf);
    
    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/*--------------------------------------------------------------------------------------------------------------------------
    Proesin çalışma dizinini chdir isimli POSIX fonksiyonuyla değiştirebiliriz. Fonksiyonun prototipi şöyledir:

    #include <unistd.h>

    int chdir(const char *path);

    Fonksiyon yeni çalışma dizinin yol ifadesini parametre olarak alır. Başarı durumunda 0 değerine başarısızlık durumunda -1 değerine 
    geri döner. 
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <limits.h>
#include <unistd.h>

void exit_sys(const char *msg);

int main(void)
{
    char buf[PATH_MAX];

    if (getcwd(buf, PATH_MAX) == NULL) 
        exit_sys("getcwd");

    puts(buf);

    if (chdir("/usr/bin") == -1)
        exit_sys("chdir");

    if (getcwd(buf, PATH_MAX) == NULL) 
        exit_sys("getcwd");

    puts(buf);
    
    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/*--------------------------------------------------------------------------------------------------------------------------
    Daha önce yapmış olduğumuz kabuk programına cd komutunu aşağıdaki gibi ekleyebiliriz. Bu örnekteki getenv fonksiyonunu henüz görmedik.
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <errno.h>
#include <limits.h>
#include <unistd.h>

#define MAX_CMD_LINE        4096
#define MAX_CMD_PARAMS      128

typedef struct tagCMD {
    char *name;
    void (*proc)(void);
} CMD;

void parse_cmd_line(char *cmdline);
void dir_proc(void);
void clear_proc(void);
void pwd_proc(void);
void cd_proc(void);

void exit_sys(const char *msg);

char *g_params[MAX_CMD_PARAMS];
int g_nparams;
char g_cwd[PATH_MAX];

CMD g_cmds[] = {
    {"dir", dir_proc},
    {"clear", clear_proc},
    {"pwd", pwd_proc},
    {"cd", cd_proc},
    {NULL, NULL}
};

int main(void)
{
    char cmdline[MAX_CMD_LINE];
    char *str;
    int i;

    if (getcwd(g_cwd, PATH_MAX) == NULL)
        exit_sys("fatal error (getcwd)");

    for (;;) {
        printf("CSD:%s>", g_cwd);
        if (fgets(cmdline, MAX_CMD_LINE, stdin) == NULL)
            continue;
        if ((str = strchr(cmdline, '\n')) != NULL)
            *str = '\0';
        parse_cmd_line(cmdline);
        if (g_nparams == 0)
            continue;
        if (!strcmp(g_params[0], "exit"))
            break;
        for (i = 0; g_cmds[i].name != NULL; ++i)
            if (!strcmp(g_params[0], g_cmds[i].name)) {
                g_cmds[i].proc();
                break;
            }
        if (g_cmds[i].name == NULL)
            printf("bad command: %s\n", g_params[0]);
    }

    return 0;
}

void parse_cmd_line(char *cmdline)
{
    char *str;

    g_nparams = 0;
    for (str = strtok(cmdline, " \t"); str != NULL; str = strtok(NULL, " \t"))
        g_params[g_nparams++] = str;
}

void dir_proc(void)
{
    printf("dir command executing..\n");
}

void clear_proc(void)
{
    system("clear");
}

void pwd_proc(void)
{
    printf("%s\n", g_cwd);
}

void cd_proc(void)
{
    char *dir;

    if (g_nparams > 2) {
        printf("too many arguments!\n");
        return;
    }  
    if (g_nparams == 1) {
        if ((dir = getenv("HOME")) == NULL)
            exit_sys("fatal error (getenv");
    }
    else 
        dir = g_params[1];

    if (chdir(dir) == -1) {
        printf("%s\n", strerror(errno));
        return;
    }

    if (getcwd(g_cwd, PATH_MAX) == NULL)
        exit_sys("fatal error (getcwd)");
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/*--------------------------------------------------------------------------------------------------------------------------
                                         9. Ders 20/11/2022 - Pazar
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Dizinler de işletim sistemi tarafından birer dosyaymış gibi ele alınmaktadır. Gerçekten de dizinleri sanki "içerisinde 
    dosya bilgilerini tutan dosyalar" gibi düşünebiliriz. Dolayısıyla UNIX/Linux sistemlerinde bir dosyayı silmek için, 
    bir dosya yaratmak için, bir dosyanın ismini değiştirmek için prosesin o dizine "w" hakkının olması gerekir. Yukarıda belirtitğimiz 
    üç işlem de aslında dizine yazma yapma anlamına gelmektedir. Yani bizim bir dosyayı silebilmek için dosyaya "w" hakkına sahip olmamız 
    gerekmez dosyanın içinde bulunduğu dizine "w" hakkına sahip olmamız gerekir. Bir dizin için "r" hakkı demek o diziin içeriğinin 
    okunabilmesi hakkı demektir. Yani bizim bir dizinin içeriğini elde edebilmemiz (ya da ls gibi bir komutla görüntüleyebilmemiz)
    için o dizine "r" hakkına sahip olmamız gerekir. 
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Dizinlerde "x" hakları farklı bir anlama gelmektedir. İşletim sistemi bir yol ifadesi verildiğinde yol ifadesinde hedeflenen 
    dizin girişi için bilgileri elde etmek isteyecektir. Örneğin:

    "/home/kaan/Study/C/sample.c" 

    Burada hedeflenen dosya "sample.c" dosyasıdır. Ancak işletim sistemi bu dosyanın yerini bulabilmek için yol ifadesindeki 
    bileşenlerin üzerinden geçer. Bu işleme "pathname resolution" denilmektedir. İşte "pathname resolution" işleminde dizin geçişleriyle
    hedefe ulaşılabilmesi için prosesin yol ifadesine ilişkin dizin bileşenlerinin "x" hakkına sahip olması gerekir. Yani dizilerideki "x" 
    hakkı "içinden geçilebilirlik" gibi bir anlama gelmektedir. Biz bir dizinimizdeki "x" hakkını kaldırırsak daha işletim sistemi pathname
    resolution işleminde başarısız olur. Dolayısıyla pathname resolution işleminin başarılı olabilmesi için yol ifadesindeki 
    dizin bileşenlerinin hepsine (son bileşen de dahil olmak üzere) prosesin "x" hakkına sahip olması gerekir. Yukarıdaki örnekte 
    pathname resolution işleminin bitirilebilmesi için prosesin "home" dizini "kaan" dizini "Study" dizini ve "C" dizini için "x" 
    hakkına sahip olması gerekir. "x" hakkı bir dizin ağacında bir noktaya duvar örmek için kullanılabilmektedir. mkdir gibi 
    kabuk komutları dizin yaratırken zaten "x" hakkını default durumda  vermektedir. Proses id'si 0 olan "root" prosesler her zaman 
    pathname resolution sırasında dizinler içerisinden geçebilirler.
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Bir işletim sisteminin dosyalarla uğraşan kısmına "dosya sistemi (file system)" denilmektedir. Dosya sisteminin iki yönü vardır:
    Disk ve Bellek. İşletim sistemi dosya organizasyonu için diskte belli bir biçim kullanmaktadır. Ancak bir dosya açıldığında işletim sistemi
    çekirdek alanı içerisinde bazı veri yapıları oluşturur bu da dosya sisteminin bellek tarafı ile ilgilidir. 

    Pek çok POSIX uyumlu işletim sistemi dosya işlemeleri için 5 sistem bulundurmaktadır:

    - Dosya açmak için gereken sistem fonksiyonu (Linux'ta sys_open)
    - Dosya kapatmak için gereken sistem fonksiyonu (Linux'ta sys_close)
    - Dosyadan okuma yapmak için gereken sistem fonksiyonu (Linux'ta sys_read)
    - Dosyaya yazma yapmak için gereken sistem fonksiyonu (Linux'ta sys_write)
    - Dosya göstericisini konumlandırmak için gereken sistem fonksiyonu (Linux'ta sys_lseek)
    
    Bu 5 sistem fonksiyonunu çağıran 5 POSIX fonksiyonu bulunmaktadır: open, close, read, write ve lseek

    Biz bir UNIX/Linux sisteminde hangi düzeyde çalışıyor olursak olalım eninde sonunda dosya işlemleri bu 5 POSIX fonksiyonu ile yapılmaktadır. 
    Programa dili ne olursa olsun durum böyledir. 
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Bir dosya açıldığında işletim sistemi açılacak dosyanın bilgilerini pathname resolution işlemi sonucunda diskte bulur. 
    Dosyanın bilgilerini kernel alanı içerisinde bir alana çeker. Bu alana "dosya nesnesi (file object)" denilmektedir. Buradaki "nesne (object)" 
    terimi tahsis edilmiş yapı alanları için kullanılmaktadır. Dosya nesnesi Linux'un kaynak kodlarında "struct file" ile temsil edilmiştir. 
    İşletim sistemi bir proses bir dosyayı açtığnda açılan dosyayı o proses ile ilişkilendirir. Yani dosya nesnelerine proses kontrol blokları 
    yoluyla erişilmektedir. Güncel Linux çekirdeklerinde bu durum biraz karmaşıktır:

    task_struct (files) ---> files_struct (fdt) ---> fdtable (fd) --->  file * türünden bir dizi ---> file

    Linux'ta proses kontrol bloktan dosya nesnesine erişim birkaç yapıdan geçilerek yapılmaktadır. Ancak biz bu durumu 
    şöyle basitleştirerek ifade edebiliriz: "proses kontrol blokta bir eleman bir diziyi göstermektedir. Bu diziye "dosya betimleyici tablosu (file desctiptor table)"
    denilmektedir. Dosya betimleyici tablosunun her elemanı bir dosya nesnesini göstermektedir. Yani biz yukarıdaki yapıyı aşağıdaki gibi 
    sadeleştirerek kavramsallaştırıyoruz:

    proses kontrol block ---> betimleyici tablosu --> dosya nesneleri 

    Dosya betimleyici tablosu (file descriptor table) açık dosyalara ilişkin dosya nesnelerini,n adreslerini tutan bir gösterici dizisidir. 
    Dosya betimleyici tablosuna proses kontrol bloktan hareketle erişilmektedir. Her prosesin ayrı bir dosya betimleyici tablosu vardır. 
    İşletim sistemi her açılan dosya için bir dosya nesnesi tahsis etmektedir. Aynı dosya ikinci kez açıldığında o dosya için yine yeni bir
    dosya nesnesi oluşturulur. Dosya göstericisinin konumu da dosya nesnesinin içerisinde saklanmaktadır. 
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    UNIX/Linux sistemlerinde dosyayı açmak için open isimli POSIX fonksiyonu kullanılmaktadır. (Örneğin fopen standart C fonksiyonu da 
    UNIX/Linux sistemlerinde aslında open fonksiyonunu çağırmaktadır.) Fonksiyonun prototipi şöyledir:

    #include <fcntl.h>

    int open(const char *path, int flags, ...);

    open fonksiyonu isteğe bağlı (optional) olarak bir üçüncü argüman alabilmektedir. Eğer fonksiyon 3 argümanla çağrılacaksa üçüncü argüman
    mode_t türünden olmalıdır. Her ne kadar prototipteki "..." "istenildiği kadar argüman girilebilir" anlamına geliyorsa da open ya iki argümanla 
    ya da üç argümanla çağrılmalıdır. open fonksiyonunu daha fazla argümanla çağırmak "tanımsız davranışa (undefined behavior) yol açmaktadır.

    Fonksiyonun birinci parametresi açılacak dosyanın yol ifadesini belirtir. İkinci parametre açış bayraklarını (modlarını) belirtmektedir. 
    Bu parametre O_XXXX biçiminde isimlendirilmiş sembolik sabitlerin Bit OR işlemine sokulmasıyla oluşturulur. Açış sırasında aşağıdaki sembolik sabitlerden 
    yalnızca biri belirtilmek zorundadır. 

    O_RDONLY
    O_WRONLY
    O_RDWR
    O_SEARCH (at'li fonksiyonlar için bulundurulmuştur, ileride ele alınacaktır)
    O_EXEC (fexecve fonksiyonu için bulundurulmuştur, ileride ele alınacaktır)

    Buradaki O_RDONLY "yalnızca okuma yapma amacıyla", O_WRONLY "yalnızca yazma yapma amacıyla" ve O_RDWR "hem okuma hem de yazma yapma amacıyla"
    dosyanın açılmak istendiği anlamına gelmektedir. İşletim sistemi prosesin etkin kullanıcı id'sine ve etkin grup id'sine ve dosyanın kullanıcı ve grup 
    id'lerine balarak prosesin dosyaya "r", "w" hakkının olup olmadığını kontrol eder. Eğer proses bu hakka sahip değilse open fonksiyonu başarısız olur. 
    Buradaki O_SEARCH bayrağı bazı POSIX fonksiyonlarının "at"li versiyonları için, O_EXEC bayrağı ise "fexecve" fonksiyonu için bulundurulmuştur. Bu bayraklar
    ileride ele alınacaktır.

    open fonksiyonu yalnızca olan dosyayı açmak için değil aynı zamanda yeni bir dosya yaratmak için de kullanılmaktadır. O_CREAT bayrağı 
    dosya varsa etkili olmaz. Ancak dosya yoksa dosyanın yaratılmasına yol açar. Yani O_CREAT bayrağı "dosya varsa olanı aç, yoksa yarat ve aç"
    anlamına gelmektedir. Bir dosya yaratılırken dosyanın erişim haklarını dosyayı yaratan kişi open fonksiyonun üçüncü parametresinde vermek zorundadır. 
    Yani dosyanın erişim haklarını dosyayı yaratan kişi belirlemektedir. Biz O_CREAT bayrağını açış moduna eklemişsek bu durumda "dosya yaratılabilir" 
    fiktri ile erişim haklarını open fonksiyonun üçücü parametresinde belirtmemiz gerekir. Erişim hakları tüm bitleri sıfır tek biti 1 olan sembolik sabitlerin bit OR 
    işlemine sokulmasıyla oluşturulmaktadır. Bu sembolik sabitlerin hepsi S_I öneki başlar. Bunu R, W ya da X harfi izler. Bunu da USR, GRP ya da OTH harfleri izlemektedir. 
    Böylece 9 tane erişim hakkı şöyle isimlendirilmiştir:

    S_IRUSR
    S_IWUSR
    S_IXUSR
    S_IRGRP
    S_IWGRP
    S_IXGRP
    S_IROTH
    S_IWOTH
    S_IXOTH

    Örneğin S_IRUSR|S_IWUSR|S_IRGRP|S_IROTH erişim hakları "rw-r--r--" anlamına gelmektedir. 

    Ayrıca <sys/stat.h> içerisisinde aşağıdaki sembolik sabitler de bildirilmiştir:

    S_IRWXU
    S_IRWXG
    S_IRWXO

    Bu sembolik sabitler şöyle oluşturulmuştur:

    #define S_IRWXU (S_IRUSR|S_IWUSR|S_IXUSR)
    #define S_IRWXG (S_IRGRP|S_IWGRP|S_IXGRP)
    #define S_IRWXO (S_IROTH|S_IWOTH|S_IXOTH)

    Bu durumda örneğin S_IRWXU|S_IRWXG|S_IRWXO işlemi "rwxrwxrwx" anlamına gelmektedir. 

    Yukarıdaki S_IXXX biçimindeki sembolik sabitlerin değerlerinin eskiden sistemden sisteme değişebileceği dikkate alınmıştır. 
    Bu nedenle POSIX standartları başlarda bu sembolik sabitlerin sayısal değerlerini işletim sistemlerini oluşturanların belirlmesini istemiştir. 
    Ancak daha sonraları (2008 ve sonrasında, SUS 4) bu sembolik sabitlerin değerleri POSIX standartlarında açıkça belirtilmiştir. Dolayısyla programcılar artık bu sembolik 
    sabitleri kullanmak yerine bunların sayısal karşılıkalrını da kullanabilir duruma gelmiştir. Ancak eski sistemler dikkate alındığında bunların sayısal 
    karşılıkları yerine yukarıdaki sembolik sabitlerin kullanılması tavsiye edilmektedir. Bu sembolik sabitler aynı zamanda okunabilirliği de artırmaktadır. 
    POSIX standartları belli bir sürümden sonra bu sembolik sabitlerin sayısal değerlerini aşağıdaki gibi belirlemiştir:

    S_IRWXU             0700        
    S_IRUSR             0400 
    S_IWUSR             0200 
    S_IXUSR             0100 
    S_IRWXG             070 
    S_IRGRP             040 
    S_IWGRP             020 
    S_IXGRP             010 
    S_IRWXO             07 
    S_IROTH             04 
    S_IWOTH             02 
    S_IXOTH             01 
    S_ISUID             04000 
    S_ISGID             02000 
    S_ISVTX             01000

    Yani belli bir süreden sonra artık rwxrwxrwx biçiminde owner, group ve other bilgilerine ilişkin S_IXXX biçimindeki sembolik sabitler 
    gerçekten yukarıdaki sıraya göre bitleri temsil eder hale gelmiştir. Örneğin S_IWGRP sembolik sabiti 000010000 bitlerinden oluşmaktadır. 
    Bu durumda belli bir süreden sonra önrğien S_IRUSR|S_IWURS|S_IRGRP|S_IROTH bir erişim hakkını biz 0644 octal değeri ile edebiliriz. 
    Bu sembolik sabitlerin binary karşılıklarını da vermek istioruz.

    S_IRUSR        100 000 000
    S_IWUSR        010 000 000
    S_IXUSR        001 000 000

    S_IRGRP        000 100 000
    S_IWGRP        000 010 000
    S_IXGRP        001 001 000

    S_IROTH        000 000 100
    S_IWOTH        000 010 010
    S_IXOTH        001 001 001

    open fonksiyonunda O_CREAT bayrağı belirtilmemişse erişim haklarının girilmesinin hiçbir anlamı yoktur. Kaldı ki 
    O_CREAT bayrağı girildiğinde dosya varsa erişim hakları yine dikkate alınmayacaktır. 

    POSIX sistemlerinde yukarıdaki S_IXXX biçimindeki sembolik sabitler mode_t türüyle temsil edilmiştir. mode_t türü 
    <sys/types.h> ve bazı başlık dosyalarında sistemi oluşturanların belirlediği bir tamsyı türü olarak typedef edilmiştir. 

    O_TRUNC açış bayrağı "eğer dosya varsa onu sıfırılayarak aç" anlamına gelmektedir. Ancak O_TRUNC ancak yazma modunda açılan
    dosyalarda kullanılabilmektedir. Yani O_TRUNC bayrağını kullanabilmek için O_WRONLY ya da O_RDWR bayraklarından birinin de 
    belirtilmiş olması gerekmektedir. Örneğin O_WRONLY|O_CREAT|O_TRUNC açış modu "dosya yoksa yarat ancak varsa sıfırılayarak aç" 
    anlamına gelmektedir. O_TRUNC bayrağı için dosyanın yaratılıyor olması gerekmz. O_WRONLY|O_TRUNC geçerli bir açış modudur. 
    Bu durumda dosya yoksa open başarısz olur. Ancak dosya varsa sıfırılanarak açılır. 

    O_APPEND bayrağı yazma işlemlerinin dosyanın sonuna yapılacağı anlamına gelmektedir. Yani bu bayrak kullanılırsa tüm yazma 
    işlemlerinde işletim sistemi dosya göstericisini dosyanın sonuna çekip sonra yazmayı yapmaktadır. Bu açış modu da O_WRONLY
    ya da O_RDWR için anlamlıdır. Örneğin O_RDWR|O_APPEND burada dosyaya her yazılan sona eklenecektir. Ancak dosyanın herhangi bir yerinden 
    okuma yapılabilecektir. 

    O halde standart C'nin fopen fonksiyonundaki açış modlarının POSIX karşılıkları şöyle oluşturulabilir:

    Standart C fopen                    POSIX

    "w"                                 O_WRONLY|O_CREAT|O_TRUNC
    "w+"                                O_RDWR|O_CREAT|O_TRUNC
    "r"                                 O_RDONLY
    "r+"                                O_RDWR
    "a"                                 O_WRONLY|O_CREAT|O_APPEND
    "a+"                                O_RDWR|O_CREAT|O_APPEND

    O_EXCL bayrağı "exclusive" açım kullanılmaktadır. Bu bayrak O_CREAT ile birlikte kullanılmalıdır. O_CREAT|O_EXCL biçiminde 
    açış modu "dosya yoksa yarat, varsa yaratma başarısız ol" anlamına gelmektedir. O_EXCL bayrağının O_CREAT olmadan kullanıması 
    "tanımsız davranışa" yol açmaktadır. 

    O_DIRECTORY bayrağının tek işlevi açılmak istenen dosya bir dizin dosyası değilse açımın başarısız olmasını sağlamak içindir. 
   
    open fonksiyonun diğer açış modları ileride başka konular içerisinde ele alınacaktır. 

    Erişim hakları open fonksiyonu tarafından (yani open fonksiyonun çağırdığı sistem fonksiyonu tarafından) kontrol edilmektedir. 
    Örneğin bz dosyayı O_RDWR modunda açmak isteyelim bu durmda prosesimizin dosyaya "r" ve "w" haklarına sahip olması gerekir. Eğer 
    prosesimiz dosya için bu haklara sahip değilse open başarısız olur ve erro EACCESS değeri ile set edilir. Burada önemli olan nokta
    kontrolün en başta open tarafındna yapılmasıdır. Yani O_RDWR modunda açma istendiğinde eğer proses bu haklara sahip değilse
    açma başarılı olup read ya da write fonksiyonlarında hata oluşmamaktadır. Açma başarısız olmaktadır. 

    open fonksiyonu başarı durumunda int türden "dosya betimleyicisi (file descriptor)" denilen bir değerle geri dönmektedir. 
    Dosya betimleyicisi bir handle olarak diğer fonksiyonlar tarafından istenmektedir. open başarısz olursa -1 ile geri döner ve errno 
    uygun biçimde set edilir. open fonksiyonun başarısız olması için pek çok neden söz konusudur. Bundan dolayı açma işleminin başarısı 
    kesinlikle test edilmelidir. 
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
                                             10. Ders 26/11/2022 - Cumartesi
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------

    open fonksiyonu işletim sisteminin dosya açan sistem fonksiyonunu (Linux'ta sys_open) çağırmaktadır. Bu sistem fonksiyonu
    açılacak dosyaya ilişkin bilgileri diskten bulur ve o bilgileri "dosya nesnesi (file object)" denilen bir yapının içerisine 
    yerleştirir. Dosya nesnesi Linux'un kaynak kodlarında "struct file" türü ile temsil edilmiştir. İşletim sistemi dosya nesnesinin 
    içini doldurduktan sonra dosya betimleyici tablosunda boş bir slot bulur ve o slota dosya nesnesinin adresini yazar. Anımsanacağı gibi 
    dosya betimleyici tablosu dosya nesnelerinin adreslerini tutan bir gösterici dizisi biçiminde organize edilmiştir. Dosya betimleyici tablosunun 
    yeri prosein kontrol bloğundan hareketle elde edilmektedir. İşte open fonksiyonun bize geri döndürdüğü dosya betimleyicisi aslında
    dosya betimleyici tablosunda (yani dsteri dizisinde) bir indeks belirtmektedir. 

    Bir program çalıştığında genellikle dosya betimleyici tablosunun ilk üç betimleyicisi dolu diğerleri boştur. Dosya betimleyici tablosunun 
    0'ıncı slotu (yani 0 numaralı betimleyici) terminal aygıt sürücüsü için oluşturulmuş dosya nesnesini göstermektedir. Buna stdin 
    dosya betimleyici denilmektedir. 1 ve 2 numaralı betimleyiciler yine terminal aygıt sürücüsü oluşturulmuş dosya betimleyicisini göstermektedir. 
    (1 ve 2 numaralı betimleyiciler aynı nesnesyi göstermektedir) bu betimleyicilere de sırasıyla stdout ve stderr denilmektedir. 
    Böylece ilk boş betimleyici genellikle 3 numaralı betimleyici olmaktadır. open fonskiyonun dosya betimleyici tablosunda ilk boş betimleyiciyi vermesi
    POSIX standartlarında garanti edilmiştir. 

    Her prosesin proses kontrol bloğu ve dolayısıyla dosya betimleyici tablosu birbirinden farklıdır. O halde dosya betimleyicileri 
    kendi prosesinin dosya betimleyici tablosunda bir indeks belirtmektedir. Yani dosya betimleyicileri prosese özgü bir anlama sahiptir.

    Bu durumda tipik olarak işlerim sisteminin dosya açan sistem fonksiyonu sırasıyla şu işlemleri yapmaktadır:

    1) Dosya betimleyici tablosunda ilk boş betimleyiciyi bulmaya çalışır. Boş betimleyiciyi bulamazsa başarısız olur ve errno 
    değerini EMFILE ise set eder. 

    2) Dosya nesnesini tahsis eder ve bunun içini diskten elden ettiği bilgilerle doldurur. Bunun adresini de dosya betimleyici tablosunda 
    ilk boş betimleyiciye ilişkin slota yazar. 

    3) Dosya betimleyici tablosunda indeks belirten betimleyici ile geri döner. 
    
    C'nin fopen fonksiyonunda dosya açımı sırasında "text mode", "binary mode" gibi bir kavram vardır. Halbuki işletim sisteminde 
    böyle bir kavram yoktur. İşletim sistemine göre dosya byte'lardan oluşmaktadır. Text mode, binary mode C ve diğer diller tarafından 
    uydurulmuş olan yapay bir kavramdır. 

    Bir proses her open işlemi yaptığında kesinlikle yeni bir dosya nesnesi oluşturulur. Bu durumda bir proses yanı dosyayı aynı biçimde
    ikinci kez açmış olsa bile dosya aynı dosa nesnesi kulalnılmaz. Her iki open iki farklı dosya nesnesinin ve dosya betimleyicisinin
    oluşmasına yol açmaktadır. 
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <fcntl.h>
#include <sys/stat.h>

void exit_sys(const char *msg);

int main(void)
{
    int fd;

    if ((fd = open("test.txt", O_WRONLY|O_CREAT|O_TRUNC, S_IRUSR|S_IWUSR|S_IRGRP|S_IROTH)) == -1)
        exit_sys("open");
    
    printf("file opened: %d\n", fd);
    
    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/*--------------------------------------------------------------------------------------------------------------------------
    Açılan her dosyanın kapatılması gerekir. Bir dosyanın kapatılması sırasında işletim sistemi dosyanın açılması sırasında yapılan 
    işlemleri geri almaktadır. Tipik olarak UNIX/Linux sismlerinde dosya kapatıldığında şunlar yapılmaktadır:

    1) Dosya nesnesi eğer onu gösteren tek bir betimleyici varsa yok edilir. 
    2) Dosya betimleyici tablosundaki betimleyiciye ilişkin slot boşaltılır. 

    İleride de görüleceği gibi dosya betimleyici tablosunda birden fazla betimleyici aynı dosya nesnesini gösteriyor durumda olabilir. 
    Bu durumda işletim sistemi dosya nesnesi içerisinde bir sayaç turup bu sayaıcı artırıp eksiltmektedir. Sayaç 0'a gediğinde nesneyi silmektedir. 
    (Linux'un kaynak kodlarında bu sayaç struct file yapısının f_count elemanında turulmaktadır.)

    Bir dosya artık kullanılmayacaksa onu kapatmak iyi bir tekniktir. Çünkü bu sayede:

    1) Dosya betimleyici tablosunda gereksiz bir slot tahsis edilmiş durumda olmaz. 
    2) Dosya nesnesi gereksiz bir biçimde kenel alanı içerisinde yer kaplamaz.

    Tabii işletim sistemi proses dosyayı kapatmasa bile proses sonlandırılırken dosya prosesin dosya betimleyici tablosunu inceler
    ve açık dosyaları bu biçimde kapatır. Yani biz bir dosyayı kapatmasak bile proses bittiğinde dosyalar zaten kapatılmaktadır. 

    Dosyanın kapatılması için close isimli POSIX fonksiyonu bulundurulmuştur. Bu POSIX fonksiyonu doğrudan işletim sisteminin 
    dosyayı kapatan sistem fonksiyonunu çağırmaktadır. close fonksiyonunun prototipi şöyledir:

    #include <unistd.h>

    int close(int fd);

    Fonksiyon parametre olarak dosya betimleyicisini alır. close fonksiyonu başarı durumunda 0 başarısızlık durumunda -1 değerine geri 
    dönmektedir. Fonksiyonun geri dönüş değeri genellikle kontrol edilmez. 

---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <fcntl.h>
#include <sys/stat.h>

void exit_sys(const char *msg);

int main(void)
{
    int fd;

    if ((fd = open("test.txt", O_WRONLY|O_CREAT|O_TRUNC, S_IRUSR|S_IWUSR|S_IRGRP|S_IROTH)) == -1)
        exit_sys("open");
    
    printf("file opened: %d\n", fd);

    close(fd);
    
    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/*--------------------------------------------------------------------------------------------------------------------------
    İlk UNIX sistemlerinden beri creat isimli bir fonksiyon da open fonksiyonun bir sarma fonksiyonu biçiminde bulundurulmaktadır. 
    creat fonksiyonu POSIX standartlarında var olan bir fonksiyondur. Fonksiyonun prototipi şöyledir:

    #include <fcntl.h>

    int creat(const char *path, mode_t mode);

    Fonkisyonun birinci parametresi dosyanın yol ifadesini belirtmektedir. İkinci parametre erişim beilgisini belirtir. Görüldüğü gibi 
    fonksiyonda açış modu belirten flags parametresi yoktur. Çünkü bu parametre O_WRONLY|O_CREAT|O_TRUNC biçiminde alınmaktadır. creat fonksiyonu
    aşağıdaki gibi yazılmıştır:

    int creat(const char *path, mode_t mode)
    {
        return open(path, O_WRONLY|O_CREAT|O_TRUNC, mode);
    }

---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Dosyadaki her bir byte'a bir offset numarası karşı getirilmiştir. Buna ilgili byte'ın offset'i denilmektedir. Dosya göstericisi
    okuma ve yazma işlemlerinin hangi offset'ten itibaen yapılacağını gösteren bir offset belirtmektedir. Okuma ya da yazma miktarı 
    kadar dosya göstericisi otomatik olarak ilerletilmektedir. Dosya ilk açıldığında dosya göstericisi 0 durumundadır. Dosya göstericisinin 
    dosyanın son byte'ından sonraki byte'ı göstermesi durumuna EOF durumu denir. EOF durumundan okuma yapılamaz. Ancak yazma yapılabilir. 
    Bu durumda yazılanlar dosyaya eklenmiş olur. Dosyada araya bir şey eklemek (insert) diye bir kavram yoktur. Dosya boyutunu değiştirmek 
    için dosya göstericisi EOF'a çekilip yazma yapılmalıdır. 

    Dosya göstericisin konumu dısya nesnesi içerisinde saklanmaktadır. (Linux'un kaynak kodlarında "struct file" yapısının f_pos 
    elemanı dosya göstericisinin konumunu tutmaktadır.) Biz aynı dosyayı ikinci kez açmış olsak bile yeni bir dosya nesnesi 
    dolayısıyla yeni bir dsoya göstericisi elde etmiş oluruz. 
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Dosyadan okuma yapmak için read POSIX fonksiyonu kullanılmaktadır. Pek çok sistemde bu POSIX fonksiyonu doğrudan işletim sisteminin
    okuma yapan sistem fonksiyonunu (Linux'ta sys_read) çağırmaktadır. read fonksiyonunun prototipi şöyledir:

    #include <unistd.h>

    ssize_t read(int fd, void *buf, size_t nbyte);

    Fonksiynun birinci parametresi okuma işleminin yapılacağı dosya betimleyicisini belirtmektedir. İşletim sistemi bu betimleyiciden 
    hareketle dosya nesnesine erişmektedir. İkinci parametre bellekteki tranfer adresini belirtmektedir. Üçücncü parametre okunacak 
    byte sayısını belirtir. 

    Fonksiyon başarı durumunda okuyabildiği byte ise geri döner. read fonksiyonu ile eğer dosya göstericisinin gösterdiği yerden itibaren dosya sonuna kadar 
    mevcut olan byte miktarından daha fazla byte okunmak istenirse read fonksiyonu okuyabildiği kadar byte'ı okur ve okuyabildiği byte sayısına 
    geri döner. Dosya göstericisi EOF durumunda ise read hiç okuma yapamayacağı için 0 ile geri dönmektedir. Ancak argümanların
    yanlış girilmesinde ya da IO hatalarında read başarısız olur ve -1 değerine geri döner. ssize_t <unistd.h> ve <sys/types.h> 
    içerisinde işaretli bir tamsayı türü biçiminde typedef edilmek durumunda olan POSIX'e özgü bir typedef ismidir. 

    read fonksiyonu ile dosyadan 0 byte okunmak istendiğinde read fonksiyonu temel bazı kontrolleri yarap (örneğin dosyanın okuma modunda 
    açılmış olup olmadığı) eğer bu kontrollerde bir sorun çıkarsa -1 değerine geri döner. Eğer bu kontrollerde bir sorun çıkmazsa 
    0 değerine geri döner ve herhangi bir okuma işlemi yapmaz. 
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <fcntl.h>
#include <sys/stat.h>
#include <unistd.h>

void exit_sys(const char *msg);

int main(void)
{
    int fd;
    char buf[10 + 1];
    ssize_t result;

    if ((fd = open("test.txt", O_RDONLY)) == -1)
        exit_sys("open");
    
    if ((result = read(fd, buf, 10)) == -1)
        exit_sys("read");

    buf[result] = '\0';

    printf(":%s:\n", buf);

    close(fd);
    
    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/*--------------------------------------------------------------------------------------------------------------------------
    Şimdi bir dosyayı (örneğimizde içerisinde yazı olan bir dosyayı) dosya sonuna kadar read fonksiyonu ile bir döngü içerisinde 
    okuyalım. Bu tür durumlarda klasik yöntem aşağıdaki gibi bir döngü oluşturmaktır:

     while ((result = read(fd, buf, BUFSIZE)) > 0) {
        buf[result] = '\0';
        printf("%s", buf);
    }

    if (result == -1)
        exit_sys("read");

    Bu döngüden IO hatası oluşunca ya da dosya göstericisi dosyanın sonuna geldiğinde çıkılacaktır. 
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <fcntl.h>
#include <sys/stat.h>
#include <unistd.h>

#define BUFSIZE     4096

void exit_sys(const char *msg);

int main(void)
{
    int fd;
    char buf[BUFSIZE + 1];
    ssize_t result;

    if ((fd = open("sample.c", O_RDONLY)) == -1)
        exit_sys("open");
    
    while ((result = read(fd, buf, BUFSIZE)) > 0) {
        buf[result] = '\0';
        printf("%s", buf);
    }

    if (result == -1)
        exit_sys("read");

    close(fd);
    
    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/*--------------------------------------------------------------------------------------------------------------------------
                                                    11. Ders 27/11/2022 - Pazar
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Dosyaya yazma yapmak için write isimli POSIX fonksiyonu kullanılmaktadır. Bu fonksiyon da pek çok sistemde doğrudan işletim sisteminin
    dosyaya yazma yapan sistem fonksiyonunu (Linux'ta sys_write) çağırmaktadır. Prototipi şöyledir:

    #include <unistd.h>

    ssize_t write(int fd, const void *buf, size_t nbyte);

    Fonksiyonun birinci parametresi yazma yapılacak dosyaya ilişkin dosya betimleyicisini belirtir. İkinci parametre yazılacak 
    bilgilerin bulunduğu bellek adresidir. Üçüncü parametre yazılacak byte sayısını belirtir. write fonksiyonu başarılı olarak yazılan 
    byte sayısı ile geri dönmektedir. Normal olarak bu değer üçüncü parametrede belirtilen yazılmak istenen byte sayısıdır. Ancak çok seyrek 
    bazı durumlarda (örneğin diskin dolu olması gibi) write talep edilenden daha az byte'ı yazabilir. Bu durumda yazabildiği byte sayısı ile geri döner. 
    write başarısız olursa -1 değerinegeri dönmektedir. 

    write fonksiyonu ile dosyaya 0 byte yazılmak istendiğinde gerçek bir yazma yapılmaz. write fonksiyonu bu durumda yazma konusunda 
    gerekli kontrolleri yapar (örneğin dosyanın yazma modunda açılıp açılmadığı gibi). Eğer bu kontrollerde başarısızlık oluşursa 
    write fonksiyonu -1 ile geri döner. Eğer bu kontrollerde başarısızlık oluşmazsa write fonksiyonu 0 ile geri döner. Ancak yukarıda da 
    belirttiğimiz gibi bu durumda gerçek bir yazma yapılmamaktadır. POSIX standartları normal dosyaların dışında (yani "regular" olmayan dosyaların dışında)
    0 byte yazma işlemini "unspeicifed" olarak belirtmiştir. Dolayısıyla ileride göreceğimiz boru gibi dosyalara 0 byte yazıldığında ne olacağı
    o sisteme bağlı bir durumdur. 
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <fcntl.h>
#include <sys/stat.h>
#include <unistd.h>

void exit_sys(const char *msg);

int main(void)
{
    int fd;
    char buf[] = "this is a test";
    ssize_t result;

    if ((fd = open("test.txt", O_WRONLY|O_CREAT|O_TRUNC, S_IRUSR|S_IWUSR|S_IRGRP|S_IROTH)) == -1)
        exit_sys("open");
    
    if (write(fd, buf, strlen(buf)) == -1)
        exit_sys("write");

    close(fd);
    
    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/*--------------------------------------------------------------------------------------------------------------------------
    UNIX/Linux sistemlerinde dosya kopyalama bir döngü içerisinde kaynak dosyadan hedef dosyaya blok blok okuma yazma işlemi ile
    yapılmaktadır. Ancak bazı UNIX türevi işletim sistemleri dosya kopyalama işlemi için sistem fonksiyonları da bulundurabilmektedir. 
    Örneğin Linux sistemlerinde copy_file_range isimli sistem fonksiyonı doğrudan disk üzerinde blok kopyalaması yoluyla dosya 
    kopyalamasını hiç user mode işlem yapmadan gerçekleştirebilmektedir. Ancak bu işlemin taşınabilir yolu yukarıda belirttiğimiz gibi 
    kaynaktan hedefe aktarım yapmaktır. Pekiyi bu kopyalama işleminde hangi büyüklükte bir tampon kullanılmalıdır? Tipik olarak dosya sistemindeki 
    blok uzunluğu bunun için tercih edilir. stat, fstat, lstat gibi fonksiyonlar bunu bize verirler. Blok uzunlukları 512'nin 
    katları biçimindedir. 

    Aşağıdaki örnekte blok kopyalaması yoluyla dosya kopyalaması yapılmıştır. 
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <fcntl.h>
#include <sys/stat.h>
#include <unistd.h>

#define BUFFER_SIZE     4096

void exit_sys(const char *msg);

int main(int argc, char *argv[])
{
    char buf[BUFFER_SIZE];
    int fds, fdd;
    ssize_t result;

    if (argc != 3) {
        fprintf(stderr, "wrong number of arguments!..\n");
        exit(EXIT_FAILURE);
    }

    if ((fds = open(argv[1], O_RDONLY)) == -1)
        exit_sys(argv[1]);

    if ((fdd = open(argv[2], O_WRONLY|O_CREAT|O_TRUNC, S_IRUSR|S_IWUSR|S_IRGRP|S_IROTH)) == -1)
        exit_sys(argv[2]);

    while ((result = read(fds, buf, BUFFER_SIZE)) > 0) 
        if (write(fdd, buf, result) != result) {
            fprintf(stderr, "cannot write file!..\n");
            exit(EXIT_FAILURE);
        }

    if (result == -1)
        exit_sys("read");

    close(fds);
    close(fdd);
    
    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/*--------------------------------------------------------------------------------------------------------------------------
    write çok çok seyrek de olsa başarılı olduğu halde talep edilen miktar kadar hedef dosyaya yazamayabilir. Örneğin diskin dolu 
    olması durumunda ya da bir sinyal oluşması durumunda write talep edilen miktar kadar yazma yapamayabilir. Bu tür durumları diğer
    durumlardan ayırmak için ayrı bir kontrol yapmak gerekebilir. 
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <fcntl.h>
#include <sys/stat.h>
#include <unistd.h>

#define BUFFER_SIZE     4096

void exit_sys(const char *msg);

int main(int argc, char *argv[])
{
    char buf[BUFFER_SIZE];
    int fds, fdd;
    ssize_t size, result;

    if (argc != 3) {
        fprintf(stderr, "wrong number of arguments!..\n");
        exit(EXIT_FAILURE);
    }

    if ((fds = open(argv[1], O_RDONLY)) == -1)
        exit_sys(argv[1]);

    if ((fdd = open(argv[2], O_WRONLY|O_CREAT|O_TRUNC, S_IRUSR|S_IWUSR|S_IRGRP|S_IROTH)) == -1)
        exit_sys(argv[2]);

    while ((result = read(fds, buf, BUFFER_SIZE)) > 0) {
        if ((size = write(fdd, buf, result)) == -1) 
            exit_sys("write");
        if (size != result) {
            fprintf(stderr, "cannot write file!..\n");
            exit(EXIT_FAILURE);
        }
    }

    if (result == -1)
        exit_sys("read");

    close(fds);
    close(fdd);
    
    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/*--------------------------------------------------------------------------------------------------------------------------
    Dosya göstericisi dosya açıldığında 0'ıncı offset'tedir. Ancak okuma ve yazma yapıldığında okunan ya da yazılan miktar kadar otomatik ilerletilmektedir. 
    Dosya göstericisini belli bir konuma almak için lseek isimli POSIX fonksiyonu kullanılmaktadır. Bu fonksiyon da pek çok işletim 
    sisteminde doğrudan dosyayı konumlandıran sistem fonksiyonunu (Linux'ta sys_lseek) çağırmaktadır. lseek fonksiyonun genel kullanımı
    fseek standart C fonksiyonuna çok benzemektedir. Fonksiyonun prototipi şöyledir:

    #include <unistd.h>

    off_t lseek(int fd, off_t offset, int whence);

    Fonksiyonun birinci parametresi dosya göstericisi konumlandırılacak dosyayaya ilişkin dosya betimleyicisini belirtir. Dosya göstericisi 
    dosya nesnesinin (Linux'ta struct file) içerisinde tutulmaktadır. İkinci parametre konumlandırma offset'ini belirtir. off_t 
    <unistd.h> ve <sys/types.h> içerisinde işaretli bir tamsayı türü biçiminde typedef edilmiş olan bir tür ismidir. Üçüncü parametre konumlandırma 
    orijinini belirtmektedir. Bu üçüncü parametre 0, 1 ya da 2 olarak girilebilir. Tabii sayısal değer girmek yerine yine SEEK_SET (0), SEEK_CUR (1)
    ve SEEK_END (2) sembolik sabitlerini girebiliriz. Bu sembolik sabitler <unistd.h> ve <stdio.h> içerisinde de bildirilmiştir. 
    Fonksyon başarı durumunda konumlandırılan offset'e başarısızlık durumunda -1 değerine geri dönmektedir. 

    SEEK_SET konumlandırmanın dosyanın başından itibaren yapılacağını, SEEK_CUR konumlandırmanın o anda dosya göstericisinin gösterdiği 
    yerden itibaren yapılacağını ve SEEK_END de konumlandırmanın EOF durumundan itibaren yapılacağını belirtmektedir. En normalk durum 
    SEEK_SET orijininde ikinci parametrenin >= 0, SEEK_END orijininde <= 0 biçiminde girilmesidir. SEEK_CUR orijininde ikinxi 
    parametre pozitif ya da negatif girilebilir. Örneğin dosya göstericisini EOF durumuna şöyle konumlandırabiliriz:

    lseek(fd, 0, SEEK_END);

    Dosya sistemine de bağlı olarak UNIX/Linux istemleri dosya göstericisini EOF'un ötesine konumlandırmaya izin verebilmektedir. 
    Bu özel bir durumdur. Bu tüğr durumlarda dosyaya yazma yapıldığında "dosya delikleri (file holes)" oluşmaktadır. Dosya delikleri konusu ileride 
    ele alınacaktır. 

    Aslında dosya açarken O_APPEND modu atomik bir biçimde her write işleminden önce dosya göstericisini EOF durumuna çekmektedir. Bu nedenle 
    her yazılan dosyanın sonuna eklenmektedir. 

    Aşağıdaki örnekte "test.txt" O_WRONLY modunda açılmış ve dosya göstericisi EOF durumuna çekilerek dosyaya ekleme yapılmıştır. 
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <fcntl.h>
#include <sys/stat.h>
#include <unistd.h>

void exit_sys(const char *msg);

int main(void)
{
    int fd;
    char buf[] = "\nthis is a test";

    if ((fd = open("test.txt", O_WRONLY)) == -1)
        exit_sys("open");

    lseek(fd, 0, SEEK_END);

    if (write(fd, buf, strlen(buf)) == -1)
        exit_sys("write");

    close(fd);

    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/*--------------------------------------------------------------------------------------------------------------------------
    Bir C/C++ programcısı olarak UNIX/Linux sistemlerinde dosya işlemleri yapmak için üç seçenek söz konusu olabilir:

    1) C'nin ya da C++'ın standart dosya fonksiyonlarınu kullanmak
    2) POSIX dosya fonksiyonlarını kullanmak
    3) Sistem fonksiyonlarını kullanmak

    Burada en taşınabilir olan standart C/C++ fonksiyonlarıdır. Dolayısıyla ilk tercih bunlar olmalıdır. Ancak C ve C++'ın standart dosya fonksiyonları  
    spesifik bir sistemin gereksinimini karşılayacak biçimde yazılmamıştır. Bunedenle bazen doğrudan POSIX fonksiyonlarının kullanılması 
    gerekebilmektedir. Genellikle dosya işlemleri yapan sistem fonksiyonlarının kullanılması hiç gerekmez. Çünkü Linux'ta olduğu gibi 
    pek çok UNIX türevi sistemde yukarıda gördüğümüz POSIX fonksiyonları zaten doğrudan sistem fonksiyonlarını çağırmaktadır.
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    POSIX standratlarına göre dosyaya yapılan read ve write işlemleri sistem genelinde atomiktir. Yani örneğin iki program 
    aynı anda aynı dosyanın aynı yerine yazma yapsa bile iç içe geçme oluşmaz. Önce birisi yazar daha sonra diğeri yazar. 
    Tabii hangi prosesin önce yazacağını bilemeyiz. Ancak burada önemli lan nokta iç içe geçmenin olmamasıdır. Benzer biçimde
    bir read ile bir dısyanın bir yerinden n byte okumak istediğimizde başka bir proses aynı dosyanın aynı yerine yazma yaptığnda
    biz ya o prosesin yazdıklarını okuruz ya da onun yazmadan önceki dosya değerlerini okuruz. Yarısı eski yarısı yeni bir bilgi okumayız. 
    Ancak işletim sistemi farklı read ve write çağrılarını bu anlamda senktronize etmemektedir. Yani örneğin biz bir dosyanın belli bir yerine
    iki farklı write fonksiyonu ile ardışık şeyler yazdığımızı düşünelim. Birinci write işleminden sonra başka bir proses artık orayı 
    değiştirebilir. Dlayısıyla bu anlamda bir iç içe girme durumu oluşabilir. Veritabanı programlarında bu tür durumlarla sık karşılaşılmaktadır. 
    Örneğin veri tabanı programı bir kaydı "data" dosyasına yazıp ona ilişkin indeksleri "index" dosyasına yazıyor olabilir. Bu durumda 
    iki write işlemi söz konusudur. Data dosyasına bilgiler yazıldktan sonra henüz indeks dosyasına bilgi yazılmadan başka bir proses bu iki işlemi hızlı
    davranarak yaparsa data ve indeks bütünlüğü bozulur. İşletim sisteminin burada bir sorumluluğu yoktur. Bu tarz işlemlerde senkroznizasyon 
    programcılar tarafından sağlanmak zorundadır. Bu tür senktronizasyonlar senkronizasyon nesneleriyle (semaphore gibi, mutex gibi) dosya bütününde 
    yapılabilir. Ancak tüm dosyaya erişimin engellenmesi iyi bir teknik değildir. İşte bu tür durumlar için işletim sistemleri çekirdeğe 
    entegre edilmiş olan "dosya kilitleme (file locking)" mekanizması bulundurmaktadır. Dosya kilitleme tüm dosyayı değil dosyanın belli offset'lerine erişimi 
    engelleme amacındadır.
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Biz open fonksiyonu ile bir dosya yaratırken yaratacağımız dosyaya verdiğimiz erişim hakları dosyaya tam olarak yansıtılmayabilir. 
    Yani örneğin biz gruba "w" hakkı vermek istesek bile bunu sağlayamayabiliriz. Çünkü belirtilen erişim değerlerini maskeleyen (yani ortadan kaldıran)
    bir mekanizma vardır. Buna prosin umask değeri denilmektedir. Prosesin umask değeri mode_t türü ile ifade ediir; sahiplik, grupluk ve diğerlik
    bilgilerini içerir. Bu bilgiler aslında maskeleneck değerleri belirtmektedir. Örneğin prosesin umask değerinin S_IWGRP|S_IWOTH olduğunu varsayalım.
    Bu umask değeri "biz open fonksiyonu ile bir dosyayı yaratırken grup için ve diğerleri için "w" hakkı versek bile bu hak dosyaya 
    yanısıtılmayacak" anlamına gelmektedir. Eğer prosesin umask değeri 0 ise bu durumda maskelenecek bir şey yoktur dolayısıyla verilen 
    hakların hepsi dosyaya yansıtılır. Prosesin umask değerinin umask olduğunu varsayalım. Dosyaya vermek istediğimiz erişim haklarının da 
    mode olduğunu varsayalım. (Yani mode S_IXXX gibi tek biti 1 olan değerlerin bit düzeyinde OR'lanması ile oluşturumuş değr olsun.)
    Bu durumda dosyaya yansıtılacak erişim hakları mode & ~umask olacaktır. Yani prosesin umask değerindeki bitler maskelenecek erişim 
    haklarını belirtmektedir. 

    Prosesin başlangıçtaki umask değeri üst prosesten aktarılmaktadır. Örneğin biz kabuktan program çalıştırırken çalıştırdığımız programın umask 
    değeri kabuğun (örneğin bash prosesinin) umask değeri olarak bizim prosesimize geçirilecektir. Kabuğun umask değeri "umask" isimli
    komutla elde edilebilir. Bu değer genellikle "0022" ya da "0002" gibi bir değerde olacaktır. Buradaki basamaklar octal sayı (sekizlik sistemde sayı)
    belirtmektedir. Bir octal digit 3 bitle açılmaktadır. Dolayısıyla bu bitler maskelenecek erişim haklarının durumunu belirtir: 

   ? owner group other

    En yüksek anlamlı octal digit şimdiye kadar görmediğimiz başka haklarla ilgilidir. Bu haklara "set user id", "set group id" ve "sticky"
    hakları denilmektedir. Ancak diğer 3 octal digit sırasıyla owner, group ve other maskeleme bitlerini belirtmektedir. 

    Kabuk üzerinde umask komutuyla aynı zamanda kabuğun umask değeri de değiştirilebilir. Bu durumda yine değiştirme değerleri octal digitler 
    biçiminde verilmelidir. Örneğin:

    umask 022

    Burada en yüksek anlamlı octal verilmediğine göre 0 kabul edilir. O halde burada belirtilern umask değeri grup içimn ve diğerleri için
    "w" hakkını maskeleyecektir. (Zaten pek çok kabulta umask değerin default durumu böyledir.) Bazen programcı umask değerini tamamen sıfırlamak da isteyebilir. 
    Bu işlem şöyle yapılabilir:

    umask 0

    Burada yüksek anlamlı üç octal digit de 0 kabul edilmektedir. Bu durumda artık çalıştırdığımız programda open fonksiyonun tüm erişim hakları 
    dosyalara yansıtılacaktır.

    Bir proses başlangıçta umask değerini üst prosesten almaktadır. Ancak proses istediği zaman umask isimli POSIX fonksiyonu ile kendi umask 
    değerini değiştirebilmektedir. umask fonksiyonunun prototipi şöyledir:

    #include <sys/stat.h>

    mode_t umask(mode_t cmask);

    Fonksiyon belirtilen değerle prosesin umask değerini set eder ve prosesin eski umask değerine geri döner. Fonksiyon başarısız olamaz. 

    umask fonksiyonu ile kendi prosesimizin umask değerini almak için onu değişltirmemiz gerekir. Bu durumda bu işlem aşağıdaki bir kodla 
    yapılabilir:

    mode_t mode;

    mode = umask(0);
    umask(mode);

    Tabii programcı umask fonksiyonuna octal digitler girebilir. Ancak sistemlerde bu ocatl digitler tam olarak S_IXXX sembolik sabitlerinin 
    değerlerine karşı gelmeyebilir. Ancak daha önceden de bahsedildiği gibi POSIX standartlarında belli bir zamandan  sonra bu S_IXXXX sembolik sabitlerinin 
    değerleri açıkça belirtilmiştir. Örneğin:

    umask(00022);               /* Eskiden bu biçimde belirleme taşınabilir değildi, eski sistemlerde dikkat edilmesi gerekir */
    umask(S_IWGRP|S_IWOTH);     /*  Bu biçimde belirleme daha okunabilirdir. */

    Aşağıdaki örnekte prosesin umask değeri önce sıfırlanmış, sonra bir dosya yaratılmıştır. open fonksiyonunda verilen erişim hakları 
    artık dosyaya tamamen yansıtılacaktır.
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <unistd.h>

void exit_sys(const char *msg);

int main(void)
{
    int fd;

    umask(0);

    if ((fd = open("x.dat", O_WRONLY|O_CREAT, S_IRWXU|S_IRWXG|S_IRWXO)) == -1)
        exit_sys("open");

    printf("success...\n");  

    close(fd);  


	return 0;
} 

void exit_sys(const char *msg)
{
	perror(msg);

	exit(EXIT_FAILURE);
}

/*--------------------------------------------------------------------------------------------------------------------------
                                        12. Ders 03/12/2022 - Cumartesi
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Aşağıdaki daha önce yapmış olduğumuz shell programına umask komutunu ekliyoruz.
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <errno.h>
#include <sys/stat.h>
#include <limits.h>
#include <unistd.h>

#define MAX_CMD_LINE        4096
#define MAX_CMD_PARAMS      128

typedef struct tagCMD {
    char *name;
    void (*proc)(void);
} CMD;

void parse_cmd_line(char *cmdline);

void dir_proc(void);
void clear_proc(void);
void pwd_proc(void);
void cd_proc(void);
void umask_proc(void);

int check_umask_arg(const char *str);

void exit_sys(const char *msg);

char *g_params[MAX_CMD_PARAMS];
int g_nparams;
char g_cwd[PATH_MAX];

CMD g_cmds[] = {
    {"dir", dir_proc},
    {"clear", clear_proc},
    {"pwd", pwd_proc},
    {"cd", cd_proc},
    {"umask", umask_proc},
    {NULL, NULL}
};

int main(void)
{
    char cmdline[MAX_CMD_LINE];
    char *str;
    int i;

    if (getcwd(g_cwd, PATH_MAX) == NULL)
        exit_sys("fatal error (getcwd)");

    for (;;) {
        printf("CSD:%s>", g_cwd);
        if (fgets(cmdline, MAX_CMD_LINE, stdin) == NULL)
            continue;
        if ((str = strchr(cmdline, '\n')) != NULL)
            *str = '\0';
        parse_cmd_line(cmdline);
        if (g_nparams == 0)
            continue;
        if (!strcmp(g_params[0], "exit"))
            break;
        for (i = 0; g_cmds[i].name != NULL; ++i)
            if (!strcmp(g_params[0], g_cmds[i].name)) {
                g_cmds[i].proc();
                break;
            }
        if (g_cmds[i].name == NULL)
            printf("bad command: %s\n", g_params[0]);
    }

    return 0;
}

void parse_cmd_line(char *cmdline)
{
    char *str;

    g_nparams = 0;
    for (str = strtok(cmdline, " \t"); str != NULL; str = strtok(NULL, " \t"))
        g_params[g_nparams++] = str;
}

void dir_proc(void)
{
    printf("dir command executing..\n");
}

void clear_proc(void)
{
    system("clear");
}

void pwd_proc(void)
{
    printf("%s\n", g_cwd);
}

void cd_proc(void)
{
    char *dir;

    if (g_nparams > 2) {
        printf("too many arguments!\n");
        return;
    }  
    if (g_nparams == 1) {
        if ((dir = getenv("HOME")) == NULL)
            exit_sys("fatal error (getenv");
    }
    else 
        dir = g_params[1];

    if (chdir(dir) == -1) {
        printf("%s\n", strerror(errno));
        return;
    }

    if (getcwd(g_cwd, PATH_MAX) == NULL)
        exit_sys("fatal error (getcwd)");
}

void umask_proc(void)
{
    mode_t mode;
    int argval;

    if (g_nparams > 2) {
        printf("too many arguments in umask command!..\n");
        return;
    }

    if (g_nparams == 1) {
        mode = umask(0);
        umask(mode);

        printf("%04o\n", (int)mode);

        return;
    }

    if (!check_umask_arg(g_params[1])) {
        printf("%s octal number out of range!..\n", g_params[1]);
        return;
    }

    sscanf(g_params[1], "%o", &argval);
    umask(argval);
}

int check_umask_arg(const char *str)
{
    if (strlen(str) > 4)
        return 0;

    for (int i = 0; str[i] != '\0'; ++i)
        if (str[i] < '0' || str[i] > '7')
            return 0;

    return 1;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/*--------------------------------------------------------------------------------------------------------------------------
    UNIX/Linux sistemlerinde open, close, read, wri,te ve lseek fonksiyonlarının yanı sıra pek çok yardımcı dosya fonksiyonları da vardır. 
    Bu yardımcı dosya fonksiyonları dosyalar üzerinde bazı önemli işlemleri yapmaktadır. Bu bölümde bu fonlksiyonların önemli olanlarını
    tanıtacağız. 
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Bir dosyaya ilişkin bilgileri elde etmek için stat, lstat ve fstat isimli üç fonksiyon kullanılmaktadır. Bu fonksiyonlar
    aslıunda aynı şeyi yaparlar. Fakat parametrik yapı bakımından ve semantik bakımdan bunların arasında küçük farklılıkllr vardır. 
    Fonksiyonların prototipleri şöyledir:

    #include <sys/stat.h>

    int stat(const char *path, struct stat *buf);
    int fstat(int fd, struct stat *buf);
    int lstat(const char *path, struct stat *buf);
 
    stat fonksiyonları bir dosyanın bilgilerini elde etmek amacıyla kullanılmaktadır. Örneğin dosyanın erişim hakları, kullanıcı ve grup id'leri,
    dosyanın uzunluğu, dosyanın tarih zaman bilgileri bu stat fonksiyonlarıyla elde edilmektedir. ls komutu -l seneği ile kullanıldığında
    aslında dosya bilgilerini bu stat fonksiyonuyla elde edip ekrana yazdırmaktadır.

    stat fonksiyonlarından en çok kullanılanı stat fonksiyonudur:

    int stat(const char *path, struct stat *buf); 

    Fonksiyonun birinci parametresi bilgisi elde edilecek dosyanın yol ifadesini belirtmektedir. İkinci parametresi dosya 
    bilgilerinin yerleştirileceği struct stat isimli bir yapı nesnesinin adresini almaktadır. stat isimli yapı <sys/stat.h> 
    içerisinde bildirilmiştir. Fonksiyon başarı durumunda 0 başarısızlık durumunda -1 değerine geri döner.

    struct stat yapısının elemanları şöyledir:

     struct stat {
        dev_t     st_dev;         /* ID of device containing file */
        ino_t     st_ino;         /* Inode number */
        mode_t    st_mode;        /* File type and mode */
        nlink_t   st_nlink;       /* Number of hard links */
        uid_t     st_uid;         /* User ID of owner */
        gid_t     st_gid;         /* Group ID of owner */
        dev_t     st_rdev;        /* Device ID (if special file) */
        off_t     st_size;        /* Total size, in bytes */
        blksize_t st_blksize;     /* Block size for filesystem I/O */
        blkcnt_t  st_blocks;      /* Number of 512B blocks allocated */

        /* Since Linux 2.6, the kernel supports nanosecond
            precision for the following timestamp fields.
            For the details before Linux 2.6, see NOTES. */

        struct timespec st_atim;  /* Time of last access */
        struct timespec st_mtim;  /* Time of last modification */
        struct timespec st_ctim;  /* Time of last status change */

    #define st_atime st_atim.tv_sec      /* Backward compatibility */
    #define st_mtime st_mtim.tv_sec
    #define st_ctime st_ctim.tv_sec
    };

    Yapının st_dev elemanı dosyanın içinde bulunduğu aygıtın aygıt numarsını belirtir. Genellikle programcılar bu bilgiye gereksinim duymazlar. dev_t 
    türü herhangi bir tamsayı türü biçiminde typedef edilebilecek bir tür ismidir. 
    
    stat fonksiyonları dosya bilgilerini aslında diskten elde etmektedir. UNIX/Linux sistemlerinde kullanılan dosya sistemlerinin disk organşizasyonunda 
    i-node tablosu denilen bir tablo vardır. i-node tablosu  i-node elemanlarından oluşmaktadır. Her i-node elemanı bir dosyaya ilişkin bilgileri tutar. 
    İşte bir dosyanın bilgilerinin hangi i-node elemanında olduğu stat yapısının st_ino elemanına yerleştirilmektedir. Dosyanın i-node elemanı i-node 
    tablosunda bir indeks belirtmektedir. Dosyaların i-node numarları ls komutunda -i seçeneği ile gösterilmektedir. ino_t türü işaretsiz olmak koşuluyla 
    herhangi bir tamsayı türü biçiminde typedef edilebilmektedir. 
    
    Yapının st_mode elemanı dosyanın erişim bilgilerini ve türünü içermektedir. Yine bu elemanın içerisindeki değerler bitler biçiminde oluşturulmuştur. 
    1 olan bitler ilgili özelliğin olduğunu belirtmektedir. Belli bir erişim hakkının (örneğin S_IWGRP gibi) olup olmadığını anlamak için programcı ilgili 
    bitin set edilip edilmedeiğine st_mode & S_IXXX işlemi ile bakmalıdır. Dosyanın türü de yine aynı elemanın içerisine bitsel olarak kodlanmıştır. Ancak hangi bitlerin
    hangi türleri belirttiği POSIX standartlarında belirtilmemiştir. Bu durum sistemden sisteme değişebilmektedir. (Anımsanacağı gibi eskiden aynı durum S_IXXXX
    sembolik sabitleri için de geçerliydi. Ancak daha sonra bu sembolik sabitlerinyonları sayısal değerleri yani bit pozisyonları POSIX standartlarında belirlendi.)
    Dosyanın türünü anlamak için iki yöntem bulunmaktadır. Birincisi <sys/stat.h> içerisindeki S_ISXXX biçimindeki makroları kullanmaktaır. Bu makrolar
    eğer dosya ilgili türdense sıfır dışı bir değer ilgili türden değilse sıfır değerini verir. Makrolar şunlardır:

    S_ISBLK(m)      Blok aygıt sürücü dosyası mı? (ls -l'de 'b' dosya türü)
    S_ISCHR(m)      Karakter aygıt sürücü dosyası mı? (ls -l'de 'c' dosya türü)
    S_ISDIR(m)      Dizin dosyası mı? (ls -l'de 'd' dosya türü)
    S_ISFIFO(m)     Boru dosyası mı? (ls -l'de 'p' dosya türü)
    S_ISREG(m)      Sıradan bir disk dosyası mı? (ls -l'de '-' dosya türü)
    S_ISLNK(m)      Sembolik bağlantı dosyası mı? (ls -l'de 'l' dosya türü)
    S_ISSOCK(m)     Soket dosyası mı? (ls -l'de 's' dosya türü)

    Dosya türünün tespiti için ikinci yöntem st_mode içerisindeki dosya tür bitlerinin S_IFMT sembolik sabiti ile bit AND işlemi ile 
    elde edilip aşağıdaki sembolikl sabitlerle karşılaştırılmasıdır. 

    S_IFBLK         Blok aygır dosyası
    S_IFCHR         Karakter aygıt dosyası
    S_IFIFO         Boru dosyası
    S_IFREG         Sıradan disk dosyası
    S_IFDIR         Dizin dosyası
    S_IFLNK         Sembolik bağlantı dosyası
    S_IFSOCK        Soket dosyası

    st_mode değeri S_IFMT değeri ile bir AND işlemine sokulduktan sonra bu sembolik sabitlerle karşılaştırılmalıdır. Bu sembolik sabitlerin 
    tek biti 1 değildir. Yani karşılaştırma (mode & S_IFMT) == S_IFXXX biçiminde yapılmalıdır.
  
    Yapının st_nlink elemanı dosyanın "hard link" sayısını belirtmektedir. Hard link kavramı ileride ele alınacaktır. nlink_t türü
    bir tamsayı türü olmak koşuluyla herhangi bir tür olarak typedef edilebilmektedir. 

    Yapının st_uid elemanı dosyanın kullanıcı id'sini belirtmektedir. Tabii ls -l komutu bu id'yi sayı olarak değil /etc/passwd dosyasına başvurarak
    isim biçiminde yazdırmaktadır. uid_t türü herhangi bir tamsayı türü olarak typedef edilebilmektedir. 

    Yapının st_gid elemanı dosyanın grup id'sini belirtmektedir. Tabii ls -l komutu bu id'yi sayı olarak değil /etc/group dosyasına başvurarak
    isim biçiminde yazdırmaktadır. ugid_t türü herhangi bir tamsayı türü olarak typedef edilebilmektedir. 

    Yapının st_rdev elemanı eğer dosya bir aygıt dosyası ise temsil ettiği atgıtın numarasını bize vermektedir. Bu eleman da dev_t türündedir. 

    Yapının st_size elemanı dosyanın uzunluğunu bize vermektedir. off_t türü daha önceden de belittiğimiz gibi işaretli bir tamsayı 
    türü biçiminde typedef edilmek zorundadır. 

    Yapının st_blksize elemanı dosyanın içinde bulunduğu dosya sisteminin kullandığı blok uzunluğunu belirtmektedir. Dosyaların parçaları 
    diskte "block" denilen ardışıl byte topluluklarında tutulmaktadır. İşte bir bloğun kaç byte olduğu bilgisi bu elemanla belirtilmektedir. 
    Aynı zamanda programcılar dosya kopyalama gibi işlemlerde bu büyüklüğü tampon büyüklüğü (buffer size) olarak da kullanmaktadır.
    blksize_t işaretli bir tamsayı türüolarak typedef edilmek zorundadır.

    Yapının st_blocks elemanı dosyanın diskte kapladığı blok sayısını belirtmektedir. (Ancak buradaki sayı 512 byte'lık blokların sayısıdır. 
    Yani dosya sistemindeki dosyanın parçaları olan bloklara ilişkin sayı değildir.) blkcnt_t işaretli bir tamsayı türü olarak typedef 
    edilmek zorundadır. 

    UNIX/Linux sistemlerinde kullanılan i-node tabanlı dosya sistemleri bir dosya için üç zaman bilgisi tutmaktadır:

    1) Dosyanın son değiştirilme zamanı
    2) Dosyanın son okunma zamanı
    3) Dosyanın i-node bilgilerinin son değiştirilme zamanı

    POSIX standartları hangi POSIX fonksiyonlarının hangi zamanları dosya için güncellediğini belirtmektedir. Örneğin read fonksiyonu
    dosyanın son okuma zamanını, write fonksiyonu son yazma ve i-node bilgilerinin değiştirilme zamanını güncellemektedir.  

    stat yapısının bu zamanı tutan elemanları eski POSIX standartlarında time_t türündendi ve isimleri st_atime, st_mtime ve st_ctime
    biçimindeydi. Bu elemanlar epoch olan 01/01/1970'ten geçen saniye sayısını tutuyordu (C Programlama Dilinde epoch'un 01/01/1970 olması 
    zorunlu değildir. Ancak POSIX standartlarında bu zorunludur.) Ancak daha sonra POSIX standartlarında bu zaman bilgisini nanosaniye çözünürlüğe
    çektiler. Dolayısıyla zamansal bilgiler time_t türü ile değil timespec bir yapıyla belirtilmeye başlandı. Yapı elemanlarının isimleri de 
    st_atime, st_mtim ve st_ctim olarak değiştirildi. timespec yapısı geçmişe doğru uyumu koruyabilmek için aşağıdaki gibi bildirilmiştir:

    struct timespec {
        time_t  tv_sec;      
        long    tv_nsec;
    };

    Yapının tv_sec elemanı yşne 01/01/1970'ten geçen saniye saniye sayısını tv_nsec elemanı ise o saniyeden sonraki nano saniye sayısını tutmaktadır. 
    Sistemlerin çoğu POSIX standartlarında bu konuda değişiklik yapılmış olsa da eski doğru uyumu şöyle korumuştur:

     struct stat {
        ...
        struct timespec st_atim;  /* Time of last access */
        struct timespec st_mtim;  /* Time of last modification */
        struct timespec st_ctim;  /* Time of last status change */

    #define st_atime st_atim.tv_sec      /* Backward compatibility */
    #define st_mtime st_mtim.tv_sec
    #define st_ctime st_ctim.tv_sec
    };

    Bu durumda programcı sisteminin yeni POSIX standartlarını destekleyip desteklemediğine bakmalı ve duruma göre yapının eski ya da yeni 
    elemanlarını kullanmalıdır. 
---------------------------------------------------------------------------------------------------------------------------*/
                                   
/*--------------------------------------------------------------------------------------------------------------------------
                                                13. Ders 04/12/2022 - Pazar
---------------------------------------------------------------------------------------------------------------------------*/
  
/*--------------------------------------------------------------------------------------------------------------------------
      Aşağıda dosya bilgilerini stat fonksiyonu ile alıp yazdıran bir örnek verilmiştir.
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <time.h>
#include <sys/stat.h>

void exit_sys(const char *msg);
void disp_mode(mode_t mode);

int main(int argc, char *argv[])
{
    struct stat finfo;
    struct tm *pt;

    if (argc == 1) {
        fprintf(stderr, "file(s) must be specified!\n");
        exit(EXIT_FAILURE);
    }

    for (int i = 1; i < argc; ++i) {
        if (stat(argv[i], &finfo) == -1)
            exit_sys("stat");

        printf("i-node no: %llu\n", (unsigned long long)finfo.st_ino);
        printf("file mode: ");
        disp_mode(finfo.st_mode);
        printf("number of hard links: %llu\n", (unsigned long long)finfo.st_nlink);
        printf("user id: %llu\n", (unsigned long long)finfo.st_uid);
        printf("group id: %llu\n", (unsigned long long)finfo.st_gid);
        printf("file size: %lld\n", (long long)finfo.st_size);
        printf("file block size: %lld\n", (long long)finfo.st_blksize);
        printf("number of blocks: %lld\n", (long long)finfo.st_blocks);

        pt = localtime(&finfo.st_mtim.tv_sec);
        printf("last modification: %02d/%02d/%04d %02d:%02d:%02d\n", pt->tm_mday, pt->tm_mon + 1, pt->tm_year + 1900, 
                    pt->tm_hour, pt->tm_min, pt->tm_sec);
        pt = localtime(&finfo.st_atim.tv_sec);
        printf("last access (read): %02d/%02d/%04d %02d:%02d:%02d\n", pt->tm_mday, pt->tm_mon + 1, pt->tm_year + 1900, 
                    pt->tm_hour, pt->tm_min, pt->tm_sec);
        pt = localtime(&finfo.st_ctim.tv_sec);
        printf("last i-node changed: %02d/%02d/%04d %02d:%02d:%02d\n", pt->tm_mday, pt->tm_mon + 1, pt->tm_year + 1900, 
                    pt->tm_hour, pt->tm_min, pt->tm_sec);
        
        if (argc > 2)
            printf("-----------------\n");
    }

	return 0;
} 

void exit_sys(const char *msg)
{
	perror(msg);

	exit(EXIT_FAILURE);
}

void disp_mode(mode_t mode)
{
    static mode_t modes[] = {S_IRUSR, S_IWUSR, S_IXUSR, S_IRGRP, S_IWGRP, S_IXGRP, S_IROTH, S_IWOTH, S_IXOTH};
    static mode_t ftypes[] = {S_IFBLK, S_IFCHR, S_IFIFO, S_IFREG, S_IFDIR, S_IFLNK, S_IFSOCK};

    for (int i = 0; i < 7; ++i)
        if ((mode & S_IFMT) == ftypes[i]) {
            putchar("bcp-dls"[i]);
            break;
        }
    /* 
    
    alternatifi 
    
    if (S_ISBLK(mode))
        putchar('b');
    else if (S_ISCHR(mode))
        putchar('c');
    else if (S_ISDIR(mode))
        putchar('d');
    else if (S_ISFIFO(mode))
        putchar('p');
    else if (S_ISREG(mode))
        putchar('-')
    else if (S_ISLNK(mode))
        putchar('l');
    else if (S_ISSOCK(mode))
        putchar('s');
    else 
        putchar('?');
    
    */ 

    for (int i = 0; i < 9; ++i)
         putchar(mode & modes[i] ? "rwx"[i % 3] : '-');
    putchar('\n');    
}

/*--------------------------------------------------------------------------------------------------------------------------
    Aşağıdaki örnekte get_ls isimli fonksiyon bizden stat yapısını ve dosyanın ismini alarak char türden static bir dizinin içerisine
    dosya bilgilerini ls -l formatında kodlamaktadır. Ancak biz henüz kullanıcı id'sini ve grup id'sini /etc/passwd ve /etc/group
    dosyalarına başvurarak isimlere dönüştürmedik. Buı nedenle bu örnekte dosyaların kullanıcı ve grup id'leri yazı olarak değil
    sayı olarak kodlanmıştır.
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <time.h>
#include <sys/stat.h>

#define LS_BUFSIZE      4096

void exit_sys(const char *msg);
char *get_ls(struct stat *finfo, const char *name);

int main(int argc, char *argv[])
{
    struct stat finfo;
    struct tm *pt;

    if (argc == 1) {
        fprintf(stderr, "file(s) must be specified!\n");
        exit(EXIT_FAILURE);
    }

    for (int i = 1; i < argc; ++i) {
        if (stat(argv[i], &finfo) == -1)
            exit_sys("stat");
        printf("%s\n", get_ls(&finfo, argv[i]));
    }

	return 0;
} 

void exit_sys(const char *msg)
{
	perror(msg);

	exit(EXIT_FAILURE);
}

char *get_ls(struct stat *finfo, const char *name)
{
    static char buf[LS_BUFSIZE];
    static mode_t modes[] = {S_IRUSR, S_IWUSR, S_IXUSR, S_IRGRP, S_IWGRP, S_IXGRP, S_IROTH, S_IWOTH, S_IXOTH};
    static mode_t ftypes[] = {S_IFBLK, S_IFCHR, S_IFIFO, S_IFREG, S_IFDIR, S_IFLNK, S_IFSOCK};
    int index;
    struct tm *ptime;

    index = 0;
    for (int i = 0; i < 7; ++i)
        if ((finfo->st_mode & S_IFMT) == ftypes[i]) {
            buf[index++] = "bcp-dls"[i];
            break;
        }

    for (int i = 0; i < 9; ++i)
        buf[index++] = finfo->st_mode & modes[i] ? "rwx"[i % 3] : '-';

    ptime = localtime(&finfo->st_mtim.tv_sec);

    index += sprintf(buf + index, " %llu", (unsigned long long)finfo->st_nlink);
    index += sprintf(buf + index, " %llu", (unsigned long long)finfo->st_uid);
    index += sprintf(buf + index, " %llu", (unsigned long long)finfo->st_uid);
    index += sprintf(buf + index, " %llu", (unsigned long long)finfo->st_size);
    index += strftime(buf + index, LS_BUFSIZE, " %b %2e %H:%M", ptime);

    sprintf(buf + index, " %s", name);
    
    return buf;
}

/*--------------------------------------------------------------------------------------------------------------------------
    fstat fonksiyonu stat fonksiyonunun yol ifadesi değil dosya betimleyicisi alan biçimidir. Prototipi şöyledir:

    int fstat(int fd, struct stat *buf);

    Genel olarak işletim sisteminin dosya betimleyicisinden hareketle i-node bilgilerine erişmesi yol ifadesinden hareketle 
    erişmesinden daha hızlı olmaktadır. Çünkü open fonksiyonunda zaten open dosyanın i-node bilgilerine erişip onu dosya nesnesinin
    içerisine almaktadır. Tabii önce dosyayı açıp sonra fstat uygulamak anlamsız bir yöntemdir. Ancak zaten biz bir dosyayı 
    başka amaçla açmışsak onun bilgilerini fstat ile daha hızlı elde edebiliriz.
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <time.h>
#include <fcntl.h>
#include <sys/stat.h>
#include <unistd.h>

#define LS_BUFSIZE      4096

void exit_sys(const char *msg);
char *get_ls(struct stat *finfo, const char *name);

int main(int argc, char *argv[])
{
    int fd;
    struct stat finfo;

     if (argc != 2) {
        fprintf(stderr, "wrong number of arguments!..\n");
        exit(EXIT_FAILURE);
    }

    if ((fd = open(argv[1], O_RDONLY)) == -1)
        exit_sys("open");

    /* burada dosyayla ilgili birtakım işlemler yapılıyor */

    if (fstat(fd, &finfo) == -1)
        exit_sys("fstat");

    printf("%s\n", get_ls(&finfo, "sample.c"));

    close(fd);

	return 0;
} 

void exit_sys(const char *msg)
{
	perror(msg);

	exit(EXIT_FAILURE);
}

char *get_ls(struct stat *finfo, const char *name)
{
    static char buf[LS_BUFSIZE];
    static mode_t modes[] = {S_IRUSR, S_IWUSR, S_IXUSR, S_IRGRP, S_IWGRP, S_IXGRP, S_IROTH, S_IWOTH, S_IXOTH};
    static mode_t ftypes[] = {S_IFBLK, S_IFCHR, S_IFIFO, S_IFREG, S_IFDIR, S_IFLNK, S_IFSOCK};
    int index;
    struct tm *ptime;

    index = 0;
    for (int i = 0; i < 7; ++i)
        if ((finfo->st_mode & S_IFMT) == ftypes[i]) {
            buf[index++] = "bcp-dls"[i];
            break;
        }

    for (int i = 0; i < 9; ++i)
        buf[index++] = finfo->st_mode & modes[i] ? "rwx"[i % 3] : '-';

    ptime = localtime(&finfo->st_mtim.tv_sec);

    index += sprintf(buf + index, " %llu", (unsigned long long)finfo->st_nlink);
    index += sprintf(buf + index, " %llu", (unsigned long long)finfo->st_uid);
    index += sprintf(buf + index, " %llu", (unsigned long long)finfo->st_uid);
    index += sprintf(buf + index, " %llu", (unsigned long long)finfo->st_size);
    index += strftime(buf + index, LS_BUFSIZE, " %b %2e %H:%M", ptime);

    sprintf(buf + index, " %s", name);

    return buf;
}

/*--------------------------------------------------------------------------------------------------------------------------
    Bir dosyayı işaret eden özel dosyalara "sembolik bağlantı dosyaları (symbolic link files)" denilmektedir. Sembolik bağlantı dosyaları 
    aynı zamanda "soft link" dosyalar biçiminde de isimlendirilmektedir. Sembolik bağlantı dosyaları bir dosyayı işaret eden dosyalardır. 
    Bunlar gerçek anlamda birer dosya değildir. Adeta bir "pointer" dosyadır. İşletim sistemleri sembolik bağlantı dosyaları için diskte 
    yalnızca bir i-node elemanı tutmaktadır. Sembolik bağlantı dosyaları komut satırında ln -s komutuyla yaratılabilirler. Örneğin:

    ln -s x.dat y.dat 

    Burada "x.dat" dosyanının "y.dat" isimli bir sembolik bağlantı dosyası oluşturulmuştur. ls -l komutunda sembolik bağlantı dosyaları ok işaretiyle 
    gösterilmektedir. Örneğin:

    kaan@kaan-virtual-machine:~/Study/Unix-Linux-SysProg$ ls -l x.dat y.dat

    -rwxr-xr-x 1 kaan study 0 Kas 27 13:07 x.dat
    lrwxrwxrwx 1 kaan study 5 Ara 10 10:11 y.dat -> x.dat   

    Sembolik bağlantı dosyaları "l" dosya türü ile gösterilmektedir. Bir sembolik bağlantı dosyası başka bir sembolik bağlantı dosyasını gösterebilir. 
    Örneğin:

    kaan@kaan-virtual-machine:~/Study/Unix-Linux-SysProg$ ls -l x.dat y.dat z.dat
    -rwxr-xr-x 1 kaan study 0 Kas 27 13:07 x.dat
    lrwxrwxrwx 1 kaan study 5 Ara 10 10:11 y.dat -> x.dat
    lrwxrwxrwx 1 kaan study 5 Ara 10 10:48 z.dat -> y.dat

    Sembolik bağlantı dosyaları yaratıldığında erişim hakları otomatik olarak "lrwxrwxrwx" biçiminde oluşturulmaktadır. Sembolik bağlantı dosyalarının 
    kendi erişim haklarının bir önemi yoktur. Bu dosyaların kendi erişim haklarısistem tarafından herhangi bir biçimde kullanılmamaktadır.

    open gibi POSIX fonksiyonlarının pek çoğu sembolik bağlantı dosyalarında bağlantıyı izlemektedir. Yani örneğin biz open fonksiyonu 
    ile bir sembolik bağlantı dosyasını açmaya çalışsak open fonksiyonu o dosyayı değil o dosyanın gösterdiği dosyayı açmaya çalışır. 
    Yukarıdaki örnekte biz "z.dat" dosyasını açmak istesek aslında "x.dat" dosyası açılacaktır. Bu durum ileride ele alacağımız POSIX fonksiyonlarının
    hemen hepsinde böyledir. Ancak lstat fonksiyonu istisnalardan biridir. 

    Bir dosya fonksiyonuna yol ifadesi olarak sembolik bağlantı dosyası verildiğinde fonksiyon (lstat dışındaki fonksiyonlar) sembolik bağlantıyı 
    izlemektedir. Ancak bu izleme sırasında bir döngü oluşabilir. Örneğin a sembolik bağlantı dosyası b sembolik bağlantı dosyasını, 
    b sembolik bağlantı dosyası da c sembolik bağlantı dosyasını gösteriyor olabilir. c sembolik bağlantı dosyası da yeniden a sembolik bağlantı 
    dosyasını gösteriyor olabilir. Böyle bir işlemde sonsuz döngü söz konusu olmaktadır. İşte dosya fonksiyonları bu durumu da dikkate alır ve böylesi bir
    döngüsellik varsa başarısızlıkla geri döner. Bu başarısızlık durumunda errno değeri ELOOP biçiminde set edilmektedir. Aslında POSIX sistemlerinde işletim
    sistemi tarafından belirlenmiş maksimum link izleme sayısı vardır. Bu sayı aşıldığında ilgili fonksiyomn başarısız olup errno değişkeni ELOOP değeri 
    ile set edilmektedir. (POSIX standartlarında maksimum link izleme değeri <sys/limits.h> içerisinde SYMLOOP_MAX sembolik sabitiyle belirtilmektedir. 
    Ancak bu sembolik sabit define edilmiş olmak zorunda değildir. Ayrıca POSIX sistemlerinde olabilecek en düşük sembolik link izleme sayısı da _POSIX_SYMLOOP_MAX (8)
    değeri ile belirlenmiştir.) Yani aslında sembolik bağlantıların döngüye genellikle girmesi maksimum sayacın aşılması ile anlaşılmaktadır.

    Bir sembolik bağlantı dosyasının gösterdiği dosya silinirse burada tuhaf bir durum oluşur. İşte bu tür durumlarda bu sembolik bağlantı dosyası 
    kullanıldığında (örneğin open fonksiyonuyla açılmaya çalışıldığında) sanki dosya yokmuş gibi bir hata oluşurb (ENOENT). Çünkü bağlantının işaret ettiği 
    bir dosya bulunmamaktadır. Windows sistemlerinde sembolik bağlantıı dosyalarının bir benzerleri "kısayol (shortcut)" dosyalar biçiminde karşımıza çıkmaktadır. 

    lstat fonksiyonu ile stat fonksiyonu arasındaki tek fark eğer stat bilgisi elde edilecek dosya bir sembolik bağlantı dosyası ise 
    stat fonksiyonun bu bağlantının gösterdiği dosyanın bilgisini alması ancak lstat fonksiyonun sembolik bağlantı dosyasının kendi bilgisini almasıdır. 
    Diğer dosyalar için bu fonksiyon arasında bir farklılık yoktur. Örneğin:

    parallels@ubuntu-linux-20-04-desktop:~/Study/Unix-Linux-SysProg$ ls -l sample.c x
    -rw-rw-r-- 1 parallels parallels 1748 Dec  4 13:46 sample.c
    lrwxrwxrwx 1 parallels parallels    8 Dec  4 13:47 x -> sample.c

    Burada "x" bir sembolik bağlantı dosyasıdır ve bu dosya "sample.c" dosyasını göstermektedir. İşte biz "x" dosyasının stat bilgilerini 
    stat fonksiyonu ile almaya çalışırsak stat bize aslında "sample.c" dosyasının bilgilerini verir. Ancak biz "x" dosyasının stat bilgilerini
    lstat fonksiyonu ile alırsak lstat bize "x" dosyasının kendi bilgisini verir. 

    Aşağıdaki örnekte sembolik bağlantı dosyasının lstat ve stat fonksiyonlarıyla stat bilgileri alınmıştır.
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <time.h>
#include <sys/stat.h>

#define LS_BUFSIZE      4096

void exit_sys(const char *msg);
char *get_ls(struct stat *finfo, const char *name);

int main(int argc, char *argv[])
{
    struct stat finfo;
    struct tm *pt;

    if (argc == 1) {
        fprintf(stderr, "file(s) must be specified!\n");
        exit(EXIT_FAILURE);
    }

    for (int i = 1; i < argc; ++i) {
        if (lstat(argv[i], &finfo) == -1)
            exit_sys("stat");
        printf("%s\n", get_ls(&finfo, argv[i]));
    }

	return 0;
} 

void exit_sys(const char *msg)
{
	perror(msg);

	exit(EXIT_FAILURE);
}

char *get_ls(struct stat *finfo, const char *name)
{
    static char buf[LS_BUFSIZE];
    static mode_t modes[] = {S_IRUSR, S_IWUSR, S_IXUSR, S_IRGRP, S_IWGRP, S_IXGRP, S_IROTH, S_IWOTH, S_IXOTH};
    static mode_t ftypes[] = {S_IFBLK, S_IFCHR, S_IFIFO, S_IFREG, S_IFDIR, S_IFLNK, S_IFSOCK};
    int index;
    struct tm *ptime;

    index = 0;
    for (int i = 0; i < 7; ++i)
        if ((finfo->st_mode & S_IFMT) == ftypes[i]) {
            buf[index++] = "bcp-dls"[i];
            break;
        }

    for (int i = 0; i < 9; ++i)
        buf[index++] = finfo->st_mode & modes[i] ? "rwx"[i % 3] : '-';

    ptime = localtime(&finfo->st_mtim.tv_sec);

    index += sprintf(buf + index, " %llu", (unsigned long long)finfo->st_nlink);
    index += sprintf(buf + index, " %llu", (unsigned long long)finfo->st_uid);
    index += sprintf(buf + index, " %llu", (unsigned long long)finfo->st_gid);
    index += sprintf(buf + index, " %llu", (unsigned long long)finfo->st_size);
    index += strftime(buf + index, LS_BUFSIZE, " %b %2e %H:%M", ptime);

    sprintf(buf + index, " %s", name);
    
    return buf;
}

/*--------------------------------------------------------------------------------------------------------------------------
    Bir dosyanın stat bilgilerini görüntülemek için stat isimli kabuk komutu da bulundurulmuştur. Tabii bu komut aslında 
    stat ve lstat POSIX fonksiyonlarını çağırarak elde ettikleri bilgileri yazdırmaktadır. Örneğin:

    kaan@kaan-virtual-machine:~/Study/Unix-Linux-SysProg$ stat sample.c
    File: sample.c
    Size: 329       	Blocks: 8          IO Block: 4096   normal dosya
    Device: 805h/2053d	Inode: 1207667     Links: 2
    Access: (0644/-rw-r--r--)  Uid: ( 1000/    kaan)   Gid: ( 1001/   study)
    Access: 2022-12-10 10:59:52.700330245 +0300
    Modify: 2022-12-10 10:59:46.620211508 +0300
    Change: 2022-12-10 11:41:11.151049064 +0300
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
                                                            14. Ders 10/12/2022 - Cumartesi
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Bir dosyayı silmek için remove ve unlink isimli fonksiyonlar kullanılmaktadır. remove bir standart C fonksiyonudur. unlink ise 
    bir POSIX fonksiyonudur. Bu iki fonksiyon tamamen aynı şeyi yapmaktadır. Fonksiyonların prototipleri şöyledir:

    #include <stdio.h>

    int remove(const char *path);       

    #include <unistd.h>

    int unlink(const char *path);

    Fonksiyonlar başarı durumunda 0 değerine başarısızlık durumunda -1 değerine geri dönmektedir. 

    remove ve unlink fonksiyonlarıyla bir dosyayı silebilmek için prosesin dosyanın kendisine "w" hakkının olması gerekmez. 
    Ancak dosyanın içinde bulunduğu dizine "w" hakkının olması gerekir. Bizim eğer dosyanın içinde bulunduğu dizine "w" 
    hakkımız varsa dosyanın sahibi olmasak bile dosyayı silebiliriz. Tabii proses id'si 0 olan prosesler herhangi bir kontrol 
    uygulamadan bu silme işlemini yapabilirler. 

    Bir dosya unlink ya da remove fonksiyonlarıyla silindiğinde dizin girişi silinir. Ancak dosyanın kendisi dosyanın hard link sayacı 
    0'a düşmüşse silinmektedir. Ynai unlink ve remove fonksiyonları dosyayı dizin girişindne silerler. Sonra dosyanın hard link sayacını 1
    eksiltirler. Eğer hard link sayacı 0'a düşmüşse dosyayı fiziksel olarak silerler. HArd link sayacının ne anlama geldiği ileride 
    ele alınacaktır.

    Aşağıdaki örnekte komut satırından verilen yol ifadelerine ilişkin dosyalar silinmeye çalışılmıştır. 
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>

int main(int argc, char *argv[])
{
    if (argc == 1) {
        fprintf(stderr, "file name(s) must be specified!..\n");
        exit(EXIT_FAILURE);
    }

    for (int i = 1; i < argc; ++i)
        if (unlink(argv[i]) == -1) 
            perror("unlink");

    return 0;
}

/*--------------------------------------------------------------------------------------------------------------------------
    Daha önceden de belirttiğimiz gibi aslında "dizinler" birer dosya gibi organize edilmiştir. Dizin dosyalarının içerisinde 
    "dizin girişleri (directory entries)" bulunmaktadır. Bir dizin girişinin formatı dosya sisteminden dosya sistemine değişebilmektedir. 
    Ancak özet olarak bir dizin dosyasının içeriği şöyledir:

    Dizi Dosyası
    ---------------
    dosya_ismi  i-node no
    dosya_ismi  i-node no
    dosya_ismi  i-node no
    ...
    dosya_ismi  i-node no
    dosya_ismi  i-node no
    dosya_ismi  i-node no

    Dosyaların asıl bilgileri (yani stat fonksiyonuyla elde ettiğimiz bilgiler) Diskte "I-Node Block" denilen bir bölgede saklanmaktadır. 
    I-Node Block i-node elemanlarından oluşur. Her i-node elemanına ilk eleman 0 olmak üzere artan sırada bir numara karşı düşürülmüştür.
    İşletim sistemi bir dosya ile ilgili işlem yaparken kesinlikle o dosyanın i-node elemanına erişmek ve oradaki bilgileri kullanmak
    zorundadır. 

    Bir dosya unlink ya da remove fonksiyonlarıyla silindiğinde kesinlikle dizin girişi silinmektedir. Ancak dosyanın silinip 
    silinmeyeceği hard-link sayacına bağlıdır. 

    Farklı dizin girişleri farklı isimlerle aynı i-node numaralarını işaret ediyorsa buna "hard link" denilmektedir. Örneğin:

    Dizin Dosyası
    -------------------
    a.txt   12345678
    b.txt   12345678
    ....

    Burada bizim open fonksiyonuyla "a.txt" ya da "b.txt" dosyalarını açmamız arasında hiçbir farklılık yoktur. Çünkü dosyanın bütün bilgileri 
    i-node elemanının içerisindedir. İşte biz bu dosyalardan örneğin "a.txt" dosyasını silersek aslında yalnızca dizin girişini silmiş oluruz. 
    Çünkü işletim sistemi "a.txt" dosyasının işaret ettiği i-node elemanının başka bir giriş tarafından kullanıldığını gördüğü için i-node elemanını 
    ve dosyanın diskteki varlığını silmez. İşte bu durum "har link sayacı" ile kontrol edilmektedir. Yukarıdaki örnekte dosyanın hard link sayacı 2'dir. 
    Biz bu dizin girişlerinden birini sildiğimizde hard link sayacı 1'e düşer. Dğerini de sildiğimizde hard link sayacı 0'a düşer ve dosya gerçekten silinir. 

    Bir dosyanın hard link'ini oluşturmak için ln kabuk komutu kullanılmaktadır. Örneğin:

    ln sample.c mample.c

    kaan@kaan-virtual-machine:~/Study/Unix-Linux-SysProg$ ls -li sample.c mample.c
    1207667 -rw-r--r-- 2 kaan study 329 Ara 10 10:59 mample.c
    1207667 -rw-r--r-- 2 kaan study 329 Ara 10 10:59 sample.c

    Dosyanın hard link sayacının 2 olduğuna dikkat ediniz. 

    Bir dizin yaratıldığında onun içerisinde "." ve ".." biçiminde iki dizin girişi otomatik olarak yaratılmaktadır. (UNIX/Linux 
    sistemlerinde başı "." ile başlayan dizin girişleri ls komutunda default olarak görüntülenmemektedir. Bunların görüntülenmesi için
    -a (all) seçeneğinin de kullanılmaıs gerekir.) "." dizin girişi kendi dizn dosyaının i-node elemanını ".." dizin girişi ise 
    üst dizinin i-node elemanını göstermektedir. Bu nedenle bir dizin yaratıldığında dizin dosyasına ilişkin hard-link sayacı
    2 olur. O dizinin içerisinde yaratılan her dizin ".." girişini içereceğindne dolayı o dizinin hard link sayacını artıracaktır. 

    Belli bir i-node elemanını gösteren dizin girişlerinin elde edilmesine yönelik bu sistemlerde pratik bir yol yoktur. Yapılacak şey
    diskteki tüm dosyaları gözden geçirip i-node numaralarından onların aynı i-node elemanını gösterip göstermediğini anlamaktır.  
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Yukarıda da belirttiğimiz gibi dosya bilgileri disk üzerinde i-node bloktaki i-node elemanının içerisinde tutulmaktadır. 
    stat fonksiyonları erişim bilgilerini buradan almaktadır (ls komutu da stat fonksiyonları kullanılarak yazılmıştır). 
    Dosyanın erişim hakları yine anımsayacağınız gibi open fonksiyonunda dosya yaratılırken belirlenmektedir. İşte bir dosyanın erişim haklarını
    dosyanın içine dokunmadan chmod isimli POSIX fonksiyonu ile değiştirebiliriz. Fonksiyonun prototipi şöyledir:

    #include <sys/stat.h>

    int chmod(const char *path, mode_t mode);

    Fonksiyonun birinci parametresi dosyanın yol ifadesini, ikinci parametresi erişim haklarını belirtmektedir. Fonksiyon başarı durumunda 0 değerine,
    başarısızlık durumunda -1 değerine geri dönmektedir. Erişim hakları 2008 stnadralarına kadar S_IXXX sembolik sabitleriyle 
    oluşturulmak zorundaydı. Ancak 2008 ve sonrasında artık bu S_IXXX sembolik sabitlerinin değerleri belirlendiği için programcı doğrudan 
    octal bir sayı biçiminde bu erişim haklarını verebilir. Fakat tavsiye edilen yine S_IXXX sembolik sabitlerinin kullanılmasıdır. 

    Bir dosyanın erişim haklarını chmod fonksiyonuyla değiştirebilmek için prosesin etkin kullanıcı id'sinin dosyanın kullanıcı id'si ile 
    aynı olması ya da prosesin etkin kullanıcı id'sinin 0 olması gerekmektedir. Dosyanın dördüncü 3 btilik S_ISUID, S_ISGID ve S_ISVTX 
    erişim hakları da bu fonksiyonla set edilmeye çalışılabilir. Ancak bazı sistemler S_ISUID ve S_ISGID erişim haklarını değiştirmeye izin vermeyebilmektedir. 

    chmod POSIX fonksiyonu prosesin umask değerini dikkate almamaktadır. Yani fonksiyonda belirttiğimiz erişim haklarının hepsi 
    dosyaya yansıtılmaktadır.

    Aşağıdaki girilen octal digitlerle dosyaların erişim haklarını değiştiren bir örnek verilmiştir. Bu örnekte doğrudan chmod fonksiyonunda
    bitmask değerler sayısal olarak kullanılmıştır. Bu durumun eski sistemlerde sorunlu olabileceğini bir kez daha vuruguluyoruz.
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/stat.h>

int check_mode(const char *str);
void exit_sys(const char *msg);

int main(int argc, char *argv[])
{
    int mode;

    if (argc < 3) {
        fprintf(stderr, "too few parameters!..\n");
        exit(EXIT_FAILURE);
    }

    if (!check_mode(argv[1])) {
        fprintf(stderr, "invalid mode: %s\n", argv[1]);
        exit(EXIT_FAILURE);
    }

    sscanf(argv[1], "%o", &mode);
    for (int i = 2; i < argc; ++i) 
        if (chmod(argv[i], mode) == -1) 
            fprintf(stderr, "cannot change mode: %s\n", argv[1]);

    return 0;
}

int check_mode(const char *str)
{
    if (strlen(str) > 4)
        return 0;

    for (int i = 0; str[i] != '\0'; ++i)
        if (str[i] < '0' || str[i] > '7')
            return 0;

    return 1;
}

void exit_sys(const char *msg)
{
	perror(msg);

	exit(EXIT_FAILURE);
}

/*--------------------------------------------------------------------------------------------------------------------------
    Aşağıdaki örnekte eski POSIX standartları da dikkate alınarak mode bilgisi S_IXXX sembolik sabitlerinin bit düzeyinde 
    OR'lanması ile oluşturulmuştur. 
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/stat.h>

int check_mode(const char *str);
void exit_sys(const char *msg);

int main(int argc, char *argv[])
{
    int modeval;
    mode_t modes[] = {S_ISUID, S_ISGID, S_ISVTX, S_IRUSR, S_IWUSR, S_IXUSR, S_IRGRP, S_IWGRP, S_IXGRP, S_IROTH, S_IWOTH, S_IXOTH};
    mode_t mode;

    if (argc < 3) {
        fprintf(stderr, "too few parameters!..\n");
        exit(EXIT_FAILURE);
    }

    if (!check_mode(argv[1])) {
        fprintf(stderr, "invalid mode: %s\n", argv[1]);
        exit(EXIT_FAILURE);
    }

    sscanf(argv[1], "%o", &modeval);

    mode = 0;
    for (int i = 11; i >= 0; --i)
        if (modeval >> i & 1)
            mode |= modes[11 - i];

    for (int i = 2; i < argc; ++i) 
        if (chmod(argv[i], mode) == -1) 
            fprintf(stderr, "cannot change mode: %s\n", argv[1]);

    return 0;
}

int check_mode(const char *str)
{
    if (strlen(str) > 4)
        return 0;

    for (int i = 0; str[i] != '\0'; ++i)
        if (str[i] < '0' || str[i] > '7')
            return 0;

    return 1;
}

void exit_sys(const char *msg)
{
	perror(msg);

	exit(EXIT_FAILURE);
}

/*--------------------------------------------------------------------------------------------------------------------------
    chmod POSIX fonksiyonunun yanı sıra bir de dosya betimleyicisi ile çalışan fchmod fonksiyonu vardır. Eğer dosyayı zaten açmışsak chmod yerine
    fchmod fonksiyonu daha hızlı bir çalışma sunmaktadır. Fonksiyonun prototipi şöyledir:

    #include <sys/stat.h>

    int fchmod(int fd, mode_t mode);
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Dosyanın erişim haklarını değiştirmek için chmod isimli bir kabuk komutu da bulunmaktadır. Bu kabuk komutu tabii chmod POSIX
    fonksiyonu kullanılarak yazılmıştır. Bu kabuk komutunun kullanımının birkaç biçimi vardır. Tipik olarak komutta erişim hakları 
    octal digitlerle belirtilmektedir. Örneğin:

    chmod 664 a.txt b.txt

    Burada 664'ün bit karşılığı şöyledir: 110 110 100. Bu erişim hakları olarak şu anlama gelmektedir: rw-rw-r--. Komutun ikinci kullanımı 
    + ve -'li kullanımıdır. Örneğin:

    chmod +w a.txt

    Burada "a.txt" dosyasının "owner", "group" ve "other" "w" hakkı eklemektedir. Komutta "-" ilgili hakkın çıkartılacağınıbelirtmektedir. 
    Bunların önüne u, g, o ya da a harfleri getirilebilir. Örneğin:

    chmod o+w a.txt

    Burada yalnızca "other" için "w" hakkı eklenmiştir. a hepsine anlamına gelir. Örneğin:

    chmod a-w a.txt

    Burada owner, group ve other için "w" hakları silinmiştir. Tabii birden fazlası kombine edilebilir. Örneğin:

    chmod 0 a.txt
    chmod ug+rw a.txt

    Komutta octal sayı belirtilirse umask etkili olmaz. Ancak ocatl sayıyerine ugua ve rwx beelirtilirse bu durumda 
    kabuğun umask değeri etkili olmaktadır. 

    Komutun başka ayrıntıları da vardır. Bunun için ilgili dokimanlara başvurabilirsiniz.      
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Bir dosyanın kullanıcı id'si ve grup id'si dosya yaratılırken belirleniyordu. Ancak programcı isterse dosyanın kullajcı id'sini 
    ver grup id'sini chown isimli POSIX fonksiyonu ile değiştirebilir. Fonksiyonun prototipi şöyledir:

    #include <unistd.h>

    int chown(const char *path, uid_t owner, gid_t group);  

    Fonksionun birinci parametresi dosyanın yol ifadesini ikinci parametresi değiştirilecek kullanıcı id'sini ve üçüncü parametresi de değiştirilecek 
    grup id'sini belirtmektedir. Bir dosyanın kullanıcı ve grup id'lerinin değiştirilmesi kötüye kullanıma açık bir durum oluşturabilmektedir. 
    (Yani örneğin kaan kullancısı kendi dosyasını sanki ali'nin dosyayıymış gibi gösterirse burada bir kötü niyet de söz konusu olabilir.)
    Bu nedenle bu fonksiyonun kullanımı üzerinde bazı kısıtlar vardır. Şöyle ki:

    1) Eğer prosesin etkin kullanıcı id'si dosyanın kullanıcı id'si ile aynı ise bu durumda chwon fonksiyonu dosyanın grup id'sini 
    kendi grup id'si olarak ya da ek gruplarının birinin id'si olarak eğiştirebilmektedir. Ancak dosyanın kullanıcı id'sinin değiştirilmesi 
    işletim sisteminin iznine bağlıdır. Modern sistemler bu izni vermemektedir. Ancak bazı eski sistemler bu izni vermektedir. Bu izin 
    "change own restricted" ismiyle ifade edilmektedir. İlgili sistemin bu izni verip vermediği <unisth.h> dosyaıs içerisindeki _POSIX_CHOWN_RESTRICTED 
    sembolik sabitiyle derleme aşamsında sorgulanbilir. 

    2) Proses id'si 0 olan root prosesler her zaman dosyanın kullanıcı ve grup id'sini istedikleri gibi değiştirebilirler.

    Fonksiyon ile yalnızca kullanıcı id'si ya da grup id'si değiştirilebilir. Bu durumda değiştirilmeyecek değer için -1 girilmelidir. 
    Fonksiyon başarı durumunda 0 değerine başarıszlık durumunda -1 değerine geri dönmektedir. Change on restricted durumu aşağıdaki gibi 
    #ifdef komutuyla sorgulanabilir:

    #include <stdio.h>
    #include <unistd.h>

        int main(int argc, char *argv[])
    {
    #ifdef _POSIX_CHOWN_RESTRICTED
        printf("chown restricted\n");
    #else
        printf("chown not restricted\n");
    #endif

        return 0;
    }

    Aşağıda chown fonksiyonun örnek bir kullanımını görüyorsunuz:

---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>

void exit_sys(const char *msg);

int main(void)
{
    if (chown("test.txt", 1000, -1) == -1)
        exit_sys("chown");

    printf("Ok\n");

    return 0;
}

void exit_sys(const char *msg)
{
	perror(msg);

	exit(EXIT_FAILURE);
}

/*--------------------------------------------------------------------------------------------------------------------------
    truncate isimli POSIX fonksiyonu bir dosyanın boyutunu değiştirmek için kullanılmaktadır. Fonksiyonun prototipi şöyledir:

    #include <unistd.h>

    int truncate(const char *path, off_t length);

    Fonksiyonun birinci parametresi dosyanın yol ifadesini almaktadır.  İkinci parametresi dosyanın yeni uzunluğunu belirtir. Bu fonksiyon 
    genellikle dosyanın sonundaki kısmı atarak onun boyutunu küçültmek amacıyla kullanılmaktadır. Burada belirtilen uzunluk dosyanın
    gerçek uzunluğundan küçükse dosyanın sonundaki ilgili kısım yok edilir ve dosya burada belirtilen uzunluğa getirilir. (Fonksiyonun 
    ismi tipik olarak dosyaların küçültüleceği fikriyle "trunctate" olarak verilmiştir.) Biz truncate fonksiyonu ile dosyayı büyütmek 
    de isteyebiliriz. Bu durumda dosya büyütülür ve büyütülen kısım 0'larla doldurulur. Bugünkü sistemlerde dosya sistemi 
    "dosya deliklerini (file holes)" destekliyorsa büyütme delik (hole) oluşturularak yapılmaktadır. Fonksiyon başarı durumunda 0 
    değerine başarısızlık durumunda -1 değerine geri döner ve errno değişkeni uygun biçimde set edilir. Tabii truncate yapabilmek için 
    prosesin dosyaya yazma hakkının olması olması gerekmektedir. 

    trucncate fonksiyonunun yol ifadesini alarak değil dosya betimleyicisini alarak aynı işlemi yapan ftruncate isminde bir benzeri de vardır. 
    Fonksiyonun prototipi şöyledir:

    #include <unistd.h>

    int ftruncate(int fd, off_t length);

    Fonksiyonun birinci parametresi dosya betimleyicisini almaktadır. İkinci parametresi dosyanın yeni uzunluğudur. Fonksiyon başarı durumunda 0 
    değerine başarısızlık durumunda -1 değerine geri döner ve errno değişkeni uygun biçimde set edilir. Tabii ftruncate yapabilmek için 
    prosesin dosyanın yazma modunda açılmış olması gerekmektedir. 

    Fonksiyonun işlev bakımından truncate fonksiyonundan hiçbir farkı yoktur. 

    Aşağıdaki örnekte daha önce var olan "test.dat" dosyası 1000 byte uzunluğa çekilmiştir. 
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <fcntl.h>
#include <unistd.h>


void exit_sys(const char *msg);

int main(void)
{
    int fd;

    if ((fd = open("test.dat", O_RDWR)) == -1)
        exit_sys("open");

    if (ftruncate(fd, 1000) == -1)
        exit_sys("open");

    printf("success...\n");

    close(fd);

    return 0;    
}

void exit_sys(const char *msg)
{
	perror(msg);

	exit(EXIT_FAILURE);
}

/*--------------------------------------------------------------------------------------------------------------------------
                                             15. Ders 11/12/2022 - Pazar
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    chown POSIX fonksiyonunun dosya betimleyicisi ile çalışan fchown isminde bir benzeri de vardır. Bu fonksiyonun chown fonksiyonundan 
    tek farkı dosyanın yol ifadesini değil dosya betimleyicisini larak işlem yapmasıdır. Elimizde zaten açmış olduğumuz bir dosya varsa
    biz bu betimleyiciyi kullanarak bu işlemi nispeten daha hızlı yapabiliriz. Fonksiyonun prototipi şöyledir:

    #include <unistd.h>

    int fchown(int fd, uid_t owner, gid_t group);   
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Dosyanın kullanıcı ve grup id'lerini değiştirebilmek için chown isimli bir kabuk komutu da bulundurulmuştur. Komut aşağıdaki biçimlerde kullanılmaktadır:

    sudo chwon kaan:study test.txt
    sudo chown kaan test.txt
    sudo chown :study test.txt
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Bir dizin (directory) yaratmak için mkdir isimli POSIX fonksiyonu kullanılmaktadır. Dizin yaratma işlemi open fonksiyonuyla 
    yapılamamaktadır. mkdir fonksiyonun prototipi şöyledir:

    #include <sys/stat.h>

    int mkdir(const char *path, mode_t mode);

    Fonksiyonun birinci parametresi yaratılacak dizinin yol ifadesini, ikinci parametresi ise erişim haklarını belirtmektedir. Fonksiyon yine 
    başarı durumunda 0 değerine, başarısızlık durumunda -1 değerine geri dönmektedir.  

    Dizin yaratırken erişim haklarında 'x' hakkını bulundurmayı unutmayınız. Anımsanacağı gibi dizinlerde 'x' hakkı "içinden geçilebilirlik"
    anlamına geliyordu. mkdir fonksiyonu tıpkı open fonksiyonu gibi prosesin umask değerinden etkilenmektedir. O halde istediğiniz 
    erişim haklarının hepsinin dizine yansıtılmasını istiyorsanız işin başında umask(0) çağrısıyla prosesinizin umask değerini 
    sıfırlayabilirsiniz. 

    Bir dizin yaratıldığında içerisinde "." ve ".." isminde iki dizin girişi bulunmaktadır. Daha önceden de belirtildiği gibi "." dizin 
    girişi bulunulan dizinin i-node elemanını, ".." dizin girişi ise üst dizinin i-node elemanını işaret eder. Bu nedenle bir dizin yaratıldığında
    kendi dizininin ve üst dizinin har link sayaçları bir artırılmaktadır.

    Aşağıda komut satırından verilen isimle bir dizin yaratn örnek verilmiştir. 
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <sys/stat.h>

void exit_sys(const char *msg);

int main(int argc, char *argv[])
{
    if (argc != 2) {
        fprintf(stderr, "wrong number of arguments!..\n");
        exit(EXIT_FAILURE);
    }

    if (mkdir(argv[1], S_IRWXU|S_IRWXG|S_IRWXO) == -1)
        exit_sys("mkdir");

    printf("success...\n");

    return 0;
}

void exit_sys(const char *msg)
{
	perror(msg);

	exit(EXIT_FAILURE);
}

/*--------------------------------------------------------------------------------------------------------------------------
    Komut satırında dizin yaratmak için mkdir isminde bir kabuk komutu da bulunmaktadır. Tabii bu komut mkdir POSIX fonksiyonu 
    kullanılarak yazılmıştır. Komut default durumda umask değerinden etkilenir. Ancak -m ya da --mode seçeneği ile biz erişim 
    haklarını octal basamaklar biçiminde belirtebilmekteyiz. Örneğin:

    mkdir xxx
    mkdir -m 777 yyy

    Dizinler çin de hard link çıkartılabilmektedir. Ancak bu durum dizin ağacını dolaşan kodların sonsuz döngüye girmesine yol açabilmektedir. 
    Bu nedenle dizinler için hard link çıkartmak yerine soft link (sembolik bağlantı) çıkartmak tercih edilmektedir. 
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Bir dizini silmek için unlink ya da remove fonksiyonları kullanılamaz. Dizin silmek için rmdir isimli özel bir POSIX fonksiyonu 
    bulundurulmuştur. Fonksiyonun prototipi şöyledir:

    #include <unistd.h>

    int rmdir(const char *path);  

    Fonksiyon parametre olarak silinecek dizinin yol ifadesini alır. Başarı durumunda 0 değerine başarısızlık durumunda -1 değerine
    geri döner. 

    rmdir fonksiyonu ile içinde dosya olan dizinler silinememektedir. Bu durum güvenlik amacıyla düşünülmüştür. İçi boş dizin demek
    içinde yalnızca "." ve ".." girişlerinin bulunduğu dizin demektir. Zaten UNIX/Linux, macOS ve Windows sistemlerinde bu iki özel 
    dizin girişi silinememektedir. rmdir fonksiyonuna bir dizini işaret eden sembolik bağlantı dosyası verilirse fonksiyob bağlantıyı 
    izlemez. Başarısız olur ve errno değeri ENOTDIR biçiminde set edilir. 

    rmdir fonksiyonun başarılı olabilmesi için prosesin dizine yazma hakkına sahip olması gerekmez ancak dizinin içinde bulunduğu 
    dizine yazma hakkına sahip olması gerekir. 
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Komut satırından dizin silmek için rmdir isimli bir kabuk komutu da bulunmaktadır. Tabii bu komut aslıdan rmdir POSIX fonksiyonu
    kullanılarak yazılmıştır. Tabii rmdir komutuyla dizin silmek için yine dizinin boş olması gerekir. İçi dolu dizinleri tek hamlede silmek için 
    rm komutu -r seçeneği ile kullanılabilir. Örneğin:

    rm -r xxx
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Anımsanacağı gibi genel olarak pek çok UNIX/Linux sisteminde kullanıcılar hakkında bilgiler /etc/passwd ve /etc/group 
    dosyalarında tutuluyordu. Bu dosyalardaki satırlar ':' ile ayrılmış olan alanlardan oluşmaktaydı. Bu dosyalar ve bunların formatları 
    POSIX standartlarında belirtilmemiştir. Onun yerine POSIX standartlarında bu dosyalardan okuma yapan özel fonksiyonlar bulundurulmuştur. 
    (Yani aslında bir POSIX sisteminde /etc/passwd ve /etc/group dosyaları bu isimlerde ve Linux'tak içerikte bulunmak zorunda değildir. 
    Ancak bu bilgileri alan aşağıda açıklayacağımız POSIX fonksiyonları bulunmak zorundadır.)
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    /etc/passwd dosyası üzerinde parse işlemi yapan fonksiyonların prototipleri <pwd.h> dosyası içerisinde bulundurulmuştur. 
    getpwnam POSIX fonksiyonu bir kullanıcının ismini alarak o kullanıcı hakkında /etc/passwd dosyasında belirtilen bilgileri 
    vermektedir. Fonksiyonun prototipi şöyleid:r

    #include <pwd.h>

    struct passwd *getpwnam(const char *name);

    Fonksiyon parametre olarak kullanıcı ismini almaktadır. Başarı durumunda o kullanıcıya ilişkin bilgileri barındıran statik düzeyde tahsis edilmiş olan 
    struct passwd isimli bir yapı nesnesinin adresiyle geri dönmektedir. struct passwd yapısı şöyle bildirilmiştir:

    struct passwd {
        char   *pw_name;       /* username */
        char   *pw_passwd;     /* user password */
        uid_t   pw_uid;        /* user ID */
        gid_t   pw_gid;        /* group ID */
        char   *pw_gecos;      /* user information */
        char   *pw_dir;        /* home directory */
        char   *pw_shell;      /* shell program */
    };

    Aslında bu yapının elemanları /etc/passwd dosyasındaki satır bilgilerinden oluşmaktadır. Aşağıda /etc/passwd dosyasından birkaç satır
    verilmiştir:

    ...
    kaan:x:1000:1001:Kaan Aslan,,,:/home/kaan:/bin/bash
    student:$6$EW3bJuIgtpIfgbdm$Sy4Z4XNdxgBrNlzc7cEnEJn2gp36XCvaIUqaH9p8ZZrtfF3qQZ7KTK7qpM4T54/p5Lck24ZknXC1EuXm2hnBm1:1001:1001:Student,,,:/home/student:/bin/ulak-shell
    ali:x:1001:1001::/home/ali:/bin/myshell
    veli:x:1002:1002::/home/veli:/bin/bash
    ...

    Yapının pw_nam elemanı kullanıcı ismini, pw_passwd elemanı parola bilgisini, pw_uid ve pw_gid elemanları login olunduğunda 
    çalıştırılacak programa ilişkin prosesin gerçek ve etkin kullanıcı ve group id değerlerini pw_gecos yorum bilgisini (kullanıya ilişkin ek 
    birtakım bilgileri, pw_dir login olunduğunda çalıştırılacak programa ilişkin prosesin çalışma dizinini ve pw_shell elemanı da login olunduğunda çalıştırılacak
    programı belirtmektedir.)

    getpwnam fonksiyonu iki nedenden dolayı başarısız olabilir. Birincisi belirtilen isme ilişkin bir kullanıcının /etc/passwd dosyası içerisinde 
    bulunamamasıdır. İkincisi ise daha patolojik durumlardır. Yani bir IO hatası, /etc/passwd dosyasının silinmiş olması gibi. Programcının 
    Eğer fonksiyon isme ilişkin bir kayıt bulamadıysa errno değerini değiştirmemektedir. Ancak diğer hatalı durumlarda errno değerini uygun biçimde 
    set etmektedir. Dolayısıyla programcı bu tür durumlarda fonksiyonu çağırmadan önce errno değerini 0'a çeker. Sonra fonksiyon başarısız olduğunda
    errno değerine bakar. Eğer bu değer hala 0 ise fonksiyonun ilgili kullanıcı ismini bulamadığından dolayı başarısız olduğu anlaşılır. 


    Aşağıdaki örnekte komut satırından ismi alınan kullanıcının /etc/passwd dosyasındaki bilgileri ekrana (stdout dosyasına) yazdırılmıştır.
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <errno.h>
#include <pwd.h>

void exit_sys(const char *msg);

int main(int argc, char *argv[])
{
    struct passwd *pass;

    if (argc != 2) {
        fprintf(stderr, "wrong number of arguments!..\n");
        exit(EXIT_FAILURE);
    }

    errno = 0;
    if ((pass = getpwnam(argv[1])) == NULL) {
        if (errno == 0) {
            fprintf(stderr, "user name cannot found!..\n");
            exit(EXIT_FAILURE);
        }
        exit_sys("getpwnam");
    }

    printf("User Name: %s\n", pass->pw_name);
    printf("Password: %s\n", pass->pw_passwd);
    printf("User id: %llu\n", (unsigned long long)pass->pw_uid);
    printf("Group id: %llu\n", (unsigned long long)pass->pw_gid);
    printf("Gecos: %s\n", pass->pw_gecos);
    printf("Current Working Directory: %s\n", pass->pw_dir);
    printf("Login Program: %s\n", pass->pw_shell);

    return 0;
}

void exit_sys(const char *msg)
{
	perror(msg);

	exit(EXIT_FAILURE);
}

/*--------------------------------------------------------------------------------------------------------------------------
    getpwuid fonksiyonu da getpwnam fonksiyonu gibidir. Yalnızca kullanıcı ismi ile değil kullanıcı id'si ile kullanıcı bilgilerini elde
    etmektedir. Fonksiyonun prototipi şöyledir:

    #include <pwd.h>

    struct passwd *getpwuid(uid_t uid);

    Fonksiyon yine başarı durumunda statik düzeyde tahsis edilmiş olan struct passwd türünden yapı nesnesinin adresiyle başarıszlık durumunda 
    NULL adresle geri dönmektedir. Başarısızlığın nedeni kullanı id'sine ilişkin kullanıcının bulunamaması nedeni ile ise 
    bu durumda fonksiyon errno değerini değiştirmemektedir. 

    Aşağıdaki örnekte komut satırından verilen kullanıcı id'sine ilişkin kullanıcı bilgileri ekrana (stdout dosyasına) yazdırılmıştır.
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <errno.h>
#include <pwd.h>

void exit_sys(const char *msg);

int main(int argc, char *argv[])
{
    struct passwd *pass;

    if (argc != 2) {
        fprintf(stderr, "wrong number of arguments!..\n");
        exit(EXIT_FAILURE);
    }

    errno = 0;
    if ((pass = getpwuid(atoi(argv[1]))) == NULL) {
        if (errno == 0) {
            fprintf(stderr, "user name cannot found!..\n");
            exit(EXIT_FAILURE);
        }
        exit_sys("getpwnam");
    }

    printf("User Name: %s\n", pass->pw_name);
    printf("Password: %s\n", pass->pw_passwd);
    printf("User id: %llu\n", (unsigned long long)pass->pw_uid);
    printf("Group id: %llu\n", (unsigned long long)pass->pw_gid);
    printf("Gecos: %s\n", pass->pw_gecos);
    printf("Current Working Directory: %s\n", pass->pw_dir);
    printf("Login Program: %s\n", pass->pw_shell);

    return 0;
}

void exit_sys(const char *msg)
{
	perror(msg);

	exit(EXIT_FAILURE);
}

/*--------------------------------------------------------------------------------------------------------------------------
    Bazen programcı /etc/passwd dosyasındaki tüm kayıtları elde etmek isteyebilir. Bunun için getpwent, endpwent ve setpwend POSIX
    fonksiyonları bulundurulmuştur. Fonksiyonların prototipileri şöyledir:

    #include <pwd.h>

    struct passwd *getpwent(void);
    void setpwent(void);
    void endpwent(void);

    getpwent fonksiyonu her çağrıldığında sıraki bir kullanıcının bilgisini verir. Fonksiyon /etc/passwd dosaysının sonuna gelindiğinde 
    (yani artık bilgisi verilecek kullanıcı kalmadığında) NULL adrese geri döner. Tabii getpwent IO hatası nedeniyle de başarısız olabilir. 
    Bu durumda errno değerini değiştirmez. Programcı bu sayede başarısızlığın nedenini anlayabilir. İşlem bitince endpwent fonksiyonu 
    son kez çağrılmalıdır. (Bu fonksiyon arka planda muhtemelen /etc/passwd dosyasını kapatmaktadır.) Eğer dolaşım yeniden yapılacaksa
    setpwent fonksiyonu çağrılır. İlk dolaşımda setğwent fonksiyonun çağrılması gerelmemektedir. 

    Aşağıdaki programda tüm kullanıcı bilgileri bir döngü içerisinde elde edilip ekrana (stdout dosyasına) yazdırılmıştır.
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <errno.h>
#include <pwd.h>

void exit_sys(const char *msg);

int main(void)
{
    struct passwd *pass;

    while ((errno = 0, pass = getpwent()) != NULL) {
        printf("User Name: %s\n", pass->pw_name);
        printf("Password: %s\n", pass->pw_passwd);
        printf("User id: %llu\n", (unsigned long long)pass->pw_uid);
        printf("Group id: %llu\n", (unsigned long long)pass->pw_gid);
        printf("Gecos: %s\n", pass->pw_gecos);
        printf("Current Working Directory: %s\n", pass->pw_dir);
        printf("Login Program: %s\n", pass->pw_shell);
        printf("-----------------------------------------------------------\n");
    }

    if (errno != 0) 
        exit_sys("getpwent");

    endpwent();

    return 0;
}

void exit_sys(const char *msg)
{
	perror(msg);

	exit(EXIT_FAILURE);
}

/*--------------------------------------------------------------------------------------------------------------------------
    Bilindiği gibi pek çok UNIX türevi sistemde grup bilgileri /etc/group isimli bir dosyada tutulmaktadır. (POSIX standartları 
    grup bilgilerinin böyle bir dosyada tutulacağına yönelik bir bilgi içermemektedir.) İşte grup bilgilerinin bu dosyadan alınması 
    için de benzer bir mekanizma oluşturulmuştur. Aşağıda grup /etc/group dosyasından birkaç satır görüyprsunuz:

    ...
    nm-openvpn:x:133:
    kaan:x:1000:
    sambashare:x:134:kaan
    study:x:1001
    test:x:1002
    ...

    Grup bilgilerini elde etmek için kullanılan POSIX fonksiyonları da şöyledir:

    #include <grp.h>

    struct group *getgrnam(const char *name);
    struct group *getgrgid(gid_t gid);
    struct group *getgrent(void);
    void setgrent(void);
    void endgrent(void);

    Bu fonksiyonlardaki struct group yapısı <grp.h> dosyası içerisinde şöyle bildirilmiştir:

    struct group {
        char   *gr_name;        /* group name */
        char   *gr_passwd;      /* group password */
        gid_t   gr_gid;         /* group ID */
        char  **gr_mem;         /* NULL-terminated array of pointers to names of group members */
    };

    Yapının gr_name elemanı grubun ismini belirtmektedir. gr_passwd elemanı grubun parola bilgisini belirtir. Gruplarda da parola 
    kavramı vardır. Ancak seyrek kullanılmaktadır. gr_gid elemanı grubun numarısını belirtir. Anımsanacağı gibi bir kullanıcı 
    birdenfazla gruba üye olabilmektedir. Kullanıcının asıl grubu /etc/passwd dosyasında belirtilen grup id'ye ilişkin gruptur. 
    Örneğin /etc/group dosyasında aşağıdaki gibi bir satır bulunuyor olsun:

    study:x:1001:ali,veli,selami

    Burada grup bilgilerinin sonundaki ali, vel, selami bu study grubuna ek grup olarak dahil edilen kullanıcıları belirtmektedir. 
    Örneğin kaan kullanıcısının asıl grubu project olabilir. Ancak kaan kullanıcısı aynı zamanda "ek grup (supplementary group)" olarak 
    study grubuna da dahil olabilir. Yani sistemin bir kullanıcının ek gruplarını elde edebilmesi için /etc/group dosyasını baştan sona gözden geçirip
    kullanıcının hangi satırların ':' ayrılmış son bölümünde geçtiğini belirlemesi gerekmektedir. İşte group yapısının gr_mem 
    elemanı bir göstericiyi gösteren göstericidir ve bu gruba ait olan kullanıcıları belirtmektedir. Tabii bu gr_mem ile belirtilmiş olan 
    gösterici dizisinin son elemanı NULL adres içermektedir.

    getgrnam fonksiyonu grubun isminden hareketle grup bilgilerini, getgrgid fonksiyonu ise grup id'sinden hareketle grup bilgilerini vermektedir. 
    Tıpkı kullanıcı bilgilerinde olduğu gibi grup bilgilerinin de tek tek elde edilmesi benzer biçimde get_grent, endgrent ve setgrent 
    fonksiyonlarıyla yapılmaktadır. 

    Aşağıdaki örnekte tüm gruplara ilişkin grup bilgileri ekrana (stdout dosaysına) yazdırılmıştır.
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <errno.h>
#include <grp.h>

void exit_sys(const char *msg);

int main(void)
{
    struct group *grp;

    while ((errno = 0, grp = getgrent()) != NULL) {
        printf("Group name: %s\n", grp->gr_name);
        printf("Password: %s\n", grp->gr_passwd);
        printf("Group id: %llu\n", (unsigned long long)grp->gr_gid);
        printf("Supplemenray userf of this group: ");
        for (int i = 0; grp->gr_mem[i] != NULL; ++i) {
            if (i != 0)
                printf(", ");
            printf("%s", grp->gr_mem[i]);
        }
        printf("\n-----------------------------------------------------\n");
    }

    if (errno != 0) 
        exit_sys("getgrent");

    endgrent();

    return 0;
}

void exit_sys(const char *msg)
{
	perror(msg);

	exit(EXIT_FAILURE);
}

/*--------------------------------------------------------------------------------------------------------------------------
                                            16. Ders 17/12/2022 - Cumartesi
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Daha önce ls -l komutu formatında dosya bilgilerini yazdıran bir örnek yapmıştık. Ancak o örnekte kullanıcı ve grup isimleri 
    isim olarak değil kullanıcı ve grup id'leri olarak ekrana (stdout dosyasına) yazdırılmıştı. Şimdi artık getpwuid ve getgrgid
    fonksiyonları ile bu sayısal id değerlerinden kullanıcı ve grup isimlerini elde edebiliriz. 
    
    Aşağıda ls -l komutunun düzeltilmiş hali verilmektedir. 
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <time.h>
#include <sys/stat.h>
#include <pwd.h>
#include <grp.h>

#define LS_BUFSIZE      4096

void exit_sys(const char *msg);
char *get_ls(struct stat *finfo, const char *name);

int main(int argc, char *argv[])
{
    struct stat finfo;

    if (argc == 1) {
        fprintf(stderr, "file(s) must be specified!\n");
        exit(EXIT_FAILURE);
    }

    for (int i = 1; i < argc; ++i) {
        if (lstat(argv[i], &finfo) == -1)
            exit_sys("stat");
        printf("%s\n", get_ls(&finfo, argv[i]));
    }

	return 0;
} 

void exit_sys(const char *msg)
{
	perror(msg);

	exit(EXIT_FAILURE);
}

char *get_ls(struct stat *finfo, const char *name)
{
    static char buf[LS_BUFSIZE];
    static mode_t modes[] = {S_IRUSR, S_IWUSR, S_IXUSR, S_IRGRP, S_IWGRP, S_IXGRP, S_IROTH, S_IWOTH, S_IXOTH};
    static mode_t ftypes[] = {S_IFBLK, S_IFCHR, S_IFIFO, S_IFREG, S_IFDIR, S_IFLNK, S_IFSOCK};
    int index;
    struct tm *ptime;
    struct passwd *pw;
    struct group *gr;

    pw = getpwuid(finfo->st_uid);
    gr = getgrgid(finfo->st_gid);

    index = 0;
    for (int i = 0; i < 7; ++i)
        if ((finfo->st_mode & S_IFMT) == ftypes[i]) {
            buf[index++] = "bcp-dls"[i];
            break;
        }

    for (int i = 0; i < 9; ++i)
        buf[index++] = finfo->st_mode & modes[i] ? "rwx"[i % 3] : '-';

    ptime = localtime(&finfo->st_mtim.tv_sec);

    index += sprintf(buf + index, " %llu", (unsigned long long)finfo->st_nlink);
    if (pw == NULL)
        index += sprintf(buf + index, " %llu", (unsigned long long)finfo->st_uid);
    else 
        index += sprintf(buf + index, " %s", pw->pw_name);
    if (gr == NULL)
        index += sprintf(buf + index, " %llu", (unsigned long long)finfo->st_gid);
    else 
        index += sprintf(buf + index, " %s", gr->gr_name);

    index += sprintf(buf + index, " %llu", (unsigned long long)finfo->st_size);
    index += strftime(buf + index, LS_BUFSIZE, " %b %2e %H:%M", ptime);

    sprintf(buf + index, " %s", name);
    
    return buf;
}

/*--------------------------------------------------------------------------------------------------------------------------
    Anımsanacağı gibi dizinler (directories) de aslında tamamen dosyalar gibi organize ediliyordu. Dizinlerin içerisinde aşağıdaki gibi 
    dizin girişleri bulunyordu:

    isim    i-node_no
    isim    i-node_no
    isim    i-node_no
    ...

    Dizin dosyalarının gerçek formatları biraz daha detay içerebilmektedir. Kursumuzun sonlarında doğru Ext-2 dosya sisteminin disk organizasyonu
    üzerinde duracağız. 

    Bir dizini erişim hakları yeterliyse open fonlsiyonuyla açabiliriz. Ancak POSIX standartlarında dizin dosyalarından okuma, yazma ve konumlandırma işlemlerinin 
    yapılıp yapılamayacağı işletim sistemini yazanların isteğine bırakılmıştır. Linux, BSD, macOS gibi sistemler dizin dosyalarından read ve write fonksiyonları ile 
    okuma ve yazma yapmaya izin vermemektedir. Ancak bu sistemler lseek fonksiyonuyla dizin dosyalarının dosya göstericilerinin konumlandırılmasına izin vermektedir. 
    Pekiyi mademki işletim sistemleri dizin dosyalarından okuma yazma yapmaya izin vermeyebiliyorlar, bu durumda open fonksiyonuyla dizin dosyalarını hangi modda 
    açabiliriz? İşte bunun POSIX standartlarında O_SEARCH isimli bir mod bulunmaktadır. Bu mod aslında ileride ele alacağımız at'li POSIX 
    fonksiyonları için düşünülmüştür. Eğer O_SEARCH modunda bir dizin açılırsa bu dizinden okuma yazma yapılamaz ancak bu at'li fonksiyonlar kullanılabilir. 
    Ancak O_SEARCH modu Linux tarafıdan desteklenmemektedir. Bu durumda mecburen Linux'ta bir dizini açacaksak işletim sistemi read fonksiyonu ile okuma yapılmasına 
    izin vermiyor olsa da biz açış modu olarak O_RDONLY kullanırız. 

    Pekiyi bir dizini O_SEARCH modunda açmak ile O_RDONLY modunda açmak arasında ne fark vardır? O_SEARCH modu POSIX standartlarına bir dizin üzerinde "read", "write"
    yapmamak ancak başka işlemlerde kullanılmak amacıyla kullanılmak için eklenmiştir. Dolayıısyla bir işletim sistemi örneğin dizin dosyalarından read fonksiyonu ile
    okuma yapmaya izin veriyorsa bu durumda biz o dizini O_SEARCH modunda açarsak okuma yapamayız. Ancak O_RDONLY modunda açarsak okuma yapabiliriz. 
    Linux ve macOS O_SEARCH modunu desteklememektedir. Ancak BSD türevi sistemler bu modu desteklemektedir. 

    Aşağıdaki Linux sistemlerinde bir dizin'inin open fonksiyonuyla açılmasına örnek verdik. Linux açış modu olarak O_SREACH modunu 
    desteklemediği için O_RDONLY modunu kullandık. İşletim sistemleri genel olarak dizinlerin write modda açılmasına izin vermemektedir. 

---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <fcntl.h>
#include <unistd.h>

void exit_sys(const char *msg);

int main(void)
{
    int fd;

    if ((fd = open(".", O_RDONLY)) == -1)
        exit_sys("open");

    printf("Ok\n");


    close(fd);

	return 0;
} 

void exit_sys(const char *msg)
{
	perror(msg);

	exit(EXIT_FAILURE);
}

/*--------------------------------------------------------------------------------------------------------------------------
    Pekiyi mademki işletim sistemlerinin çoğu bir dizin üzerinde read ve write fonksiyonları ile işlem yapmaya izin vermiyorsa bu durumda 
    bir dizini open fonksiyonu ile açmanın ne anlamı vardır? İşte anımsanacağı gibi yol ifadesi alan POSIX dosya fonksiyonlarının başı f ile başlayan 
    dosya betimleyicisi alan biçimleri de vardı. Örneğin stat ve lstat fonksiyonları yol ifadesi alırken fstat fonksiyonu dosya betimleyicisi 
    alıyordu. Benzer biçimde chmod için fchmod, chown fchown fonksiyonları bulunmaktaydı. İşte bu f'li fonksiyonların bir de at'li versiyonları vardır. 
    Örneğin fstatat, fchmodat, fchownat gibi. Ayrıca başı f ile başlamayan çeşitli dosya fonksiyonlarının da at'li versiyonarı bulunmaktadır. 
    Örneğin open fonksiyonun da bir at'li versiyonu vardır. Aslında at'li versiyonlar seyrek kullanılan fonksiyonlardır. Ancak biz kursumuzda bunlar 
    hakkında açıklama yapmayı da uygun görüyoruz. Pekiyi bu at'li fonksiyonlar ne yapmaktadır. Aşağıda openat fonksiyonunun prototipini 
    görüyorsunuz:

    #include <fcntl.h>

    int openat(int fd, const char *path, int oflag, ...);

    Fonksiyonun prototipini open fonksiyonu ile karşılaştırınız:

    int open(const char *path, int oflag, ...);

    Fonksiyonların at'li vesiyonları genel olarak bir dosya betimleyicisi de almaktadır. Bu dosya betimleyicisinin bir dizin'e ilişikin olması
    gerekir. Eğer bu dosya betimleyicisi bir dizin'e ilişkin değilse fonksiyon başarısız olur. at'li versiyonlara bir dizine ilişkin dosya betimleyicisi
    verdikten sonra ayrıca bu fonksiyonlar bir de yol ifadesi de alırlar. Buradaki yol ifadesi eğer mutlak (absolute) ise bu at'li versiyonların at'siz
    versiyonlardan (flag parametreleri dışında) hiçbir farkı kalmaz. Dolayısıyla bu durumda geçerli olsa da at'li versiyonları kullanmanın anlamı kalmamaktadır. 
    (Bazı at'li versiyuonlar flag parametresine de sahiptir. Bu parametrenin işlevinden faydalanmakl için de at'li fonksiyonlar kullanılabilmektedir.)
    Yani fonksiyon bu dizin betimleyicisinden faydalanmamaktadır. Ancak yol ifadesi göreli (relative) ise bu durumda dosya prosesin çalışma dizininden itibaren değil
    dizin betimleyicisinin belirttiği dizinden itibaren orijin belirtmektedir. Yani biz at'li versyionlarla göreli yol ifadeleriniin orijinlerini prosesin 
    çalışma dizinin dışında başka bir dizine kaydırabilmekteyiz. Tabii fonksiyonların at'li versiyonları kullanılacaksa bu durumda dizin dosyalarının 
    O_SEARCH modunda açılması daha uygundur. Çünkü bu at'li versiyonlar için dizin dosyalarının okuma modunda açılması gerekmemektedir. Zaten POSIX'te
    O_SEARCH modu bu at'li fonksiyonlar için bulundurulmuştur. Linux ve macOS sistemleri O_SEARCH modunu desteklemediğine göre bu sistemlerde 
    at'li fonksiyonları kullanırken dizin'leri O_RDONLY modda açmamız gerekir. POSIX standartlarına göre at'li fonksiyonlarda eğer dizin O_SEARCH modunda 
    açılmışsa belirtilen dizinin "x" hakkına sahilik kontrolü yapılmaz. Eğer dizin O_SERACH yerine diğer modlarla (örneğin O_RDONLY) açılmışsa
    bu durumda belirtilen dizinde "x" hakkı kontrolü yapılmaktadır. Ayrıca fonksiyonların at'li versiyonlarında dizine ilişkin dosya betimleyicisine özel olarak 
    AT_FDCWD değeri geçirilirse bu durumda sanki prosesin çalışma dizinine ilişkin dizin betimleyicisi geçirilmiş gibi bir etki oluşmaktadır. 
    Tabii bu durumda fonksiyonun at'li versiyonu ile at'siz versyonu arasında bir fark kalmaz. Ancak fonksiyonarın at'li versiyonlarının ekstra parametreleri de 
    olabilmektedir (genellikle bu ekstra parametre flag parametresi biçimindedir). İşte programcı bu ekstra parametrelerden faydalanabilmek için dosya 
    betimleyici parametresini AT_FDCWD biçiminde geçebilmektedir. Ayrıca fonksiyonların at'li versiyonlarında biz yol ifadesi olarak mutlak ifadesi geçtiğimizde 
    fonksiyonun dizin betimleyici parametresi zaten hiç kontrol edilmemektedir (yani bu parametre geçersiz bir betimleyici belirtse bile eğer yol ifadesi mutlak ise 
    fonksiyon için bir sorun oluşturmamaktadır.)

    Diğer at'li bazı fonksiyonların da prototipleri şöyledir:
    
    int fchmodat(int fd, const char *path, mode_t mode, int flag);
    int fchownat(int fd, const char *path, uid_t owner, gid_t group, int flag);
    int fstatat(int fd, const char *restrict path, struct stat *restrict buf, int flag);

    Aşağıda openat fonksiyonun kullanımına bir örnek verilmiştir. Burada çalılşma dizininde "test.txt" dosyası bulunduğu halde fonksiyon 
    başarısız olacaktır.  
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <fcntl.h>
#include <unistd.h>

void exit_sys(const char *msg);

int main(void)
{
    int fddir, fd;

    if ((fddir = open("/usr/include", O_RDONLY)) == -1)
        exit_sys("open");

    if ((fd = openat(fddir, "test.txt", O_RDONLY)) == -1)
        exit_sys("openat");
        
    printf("Ok\n");

    close(fd);
    close(fddir);

	return 0;
} 

void exit_sys(const char *msg)
{
	perror(msg);

	exit(EXIT_FAILURE);
}

/*--------------------------------------------------------------------------------------------------------------------------
    Bir dizin dosyası içerisindeki "dizin girişlerini (directory entry)" elde etmek için bir grup POSIX fonksiyonu bulundurulmuştur. 
    (Dizin dosyalarının open ya da openat ile fonksiyonu ile açılabildiğine ancak pek çok sistemde read fonksiyonu ile okunamadığına dikkat ediniz. 
    Ayrıca dizin dosyalarının iç formatı dosya sisteminden dosya sistemine değişebilmektedir. Bu nedenle POSIX standartlarında bu işi yapan ayrı 
    fonksiyonlar bulundurulmuştur.)

    Linux sistemlerinde dizin girişlerinin okunması için getdents isimli bir sistem fonksiyonu bulundurulmuştur. Dolayısıyla aşağıda açıklayacağımız
    POSIX fonksiyonları arka planda Linuz sistemlerinde getdents sistem fonksiyonunu çağırmaktadır. 
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Dizin girişlerini elde etmek için önce dizn'in opendir fonksiyonuyla açılması gerekmektedir. Bunun için dizin'e okuma hakkının 
    bulunuyor olması gerekmektedir. opendir fonksiyonun prototipi şöyledir:

    #include <dirent.h>

    DIR *opendir(const char *dirname);

    Fonksiyon parametre olarak açılacak dizin'in yol ifadesini almaktadır. Fonksiyonun geri dönüş değeri DIR isimli bir yapı türünden (DIR bir typedef ismidir)
    bir adrestir. Bu DIR adresi bir handle gibi kullanılamktadır. Fonksiyon başarısızlık durumunda NULL adrese geri döner ve errno uygun biçimde değer
    alır. opendir fonksiyonun fdopendir isimli bir verisyonu da vardır. Bu versiyon eğer zate dizin O_SEARCH ya da O_RDONLY modda açılmışsa o dizine ilişkin betimleyici
    yoluyla DIR adresini vermektedir:

    #include <dirent.h>

    DIR *fdopendir(int fd);

    Dizin opendir ya da fdopendir fonksiyonuyla açılıp DIR handle'ı elde edilmektedn sonra artık dizin girişleri readdir POSIX 
    fonksiyonuyla tek tek bir döngü içerisinde okunabilir. readdir fonksiyonu her çağrıldığında bir sonraki dizin girişi elde edilir. 
    Fonksiyonun prototipi şöyledir:

    #include <dirent.h>

    struct dirent *readdir(DIR *dirp);

    Fonksiyon parametre olarak DIR yapısının adresini alır sıradaki dizin girişini elde eder. Bu dizin girişinin bilgilerini statik 
    ömürlü struct dirent isimli bir yapı nesnesinin içerisine yerleştirir. Bize de onun adresini verir. Eğer readdir dizin listesinin
    sonuna gelirse NULL adrese geri dönmektedir. Ancak fonksiyon IO hatalarından dolayı da başarısız olabilir. Bu durmda başarısızlığın 
    dizin sonuna gelmekten dolayı mı yoksa IO hatalarından dolayı mı olduğunu anlamak gerekebilir. İşte readdir fonksiyonu eğer dizin sonuna 
    gelindiğinden dolayı NULL adrese geri dönmüş ise bu durumda errno değişkeninin değerini değiştirmemektedir. O halde programcı fonksiyonu çağırmadan 
    önce rrno değişkenine 0 atamalı sonra fonksiyonu çağırmalıdır. Eğer fonksiyon NULL adrese geri dönmüşse errno değişkenine bakmalı eğer errno
    hala 0 ise fonksiyonun dizin sonuna gelindiğinden dolayı başrasız olduğu sonucunu çıkarmalıdır. O halde fonksiyon tipik olarak şöyle kullanılmalıdır:

    struct dirent *de;
    ...
    while (errno = 0, (de = readdir(dir)) != NULL) {
        /* ... */
    }
    if (errno != 0)
        exit_sys("readdir);

    dirent yapısı POSIX standartlarına göre en az iki elemana sahip olmak zorundadır. Bu elemanlar d_ino ve d_name elemanlarıdır. 
    d_ino elemanı ino_t türündendir. d_name elemanı ise char türden bir dizidir. Ancak işletim sistemleri genellikle bu dirent yapısında
    daha fazla eleman bulundurmaktadır. Örneğin Linux'taki dirent yapısı şöyledir:

    struct dirent {
        ino_t          d_ino;       /* Inode number */
        off_t          d_off;       /* Not an offset; see below */
        unsigned short d_reclen;    /* Length of this record */
        unsigned char  d_type;      /* Type of file; not supported
                                        by all filesystem types */
        char           d_name[256]; /* Null-terminated filename */
    };

    Görüldüğü gibi Linux'ta yapının içerisinde d_off, d_reclen ve d_type elemanları da bulunmaktadır. d_off ve d_reclen elemanları 
    önemli değildir. Ancak d_type elemanı dosyanın ne dosyası olduğunu belirtmektedir. Bu eleman sayesinde programcı dosyanın türünü 
    anlamak için stat fonksiyonlarını çağırmak zorunda kalmaz. Gerçekten de i-node tabanlı dosya sistemleri dizin girişlerinde dosyanın 
    türünü de zaten tutmaktadır. Ancak POSIX standartlarında bu elemanlar zorunlu olarak belirtilmediğinden taşınabilir programlarda 
    yalnızca yapının d_ino ve d_name elemanları kullanılmalıdır. 

    dirent yapısının d_ino elemanı bize dosyanın i-node numarasını verir. d_name elemanı ise dizin girişinin ismini vermektedir. 
    Linux sistemlerinde d_type bit düzeyinde kodlanmamıştır. Aşağıdaki değerlerden birine eşit olmak zorundadır:

    DT_BLK      block device
    DT_CHR      character device
    DT_DIR      directory
    DT_FIFO     named pipe (FIFO)
    DT_LNK      symbolic link
    DT_REG      regular file.
    DT_SOCK     UNIX domain socket.
    DT_UNKNOWN  Bilinmeyen bir tür

    readdir ile dizin girişleri dosya sistemindeki kayıtlara göre verilmektedir. Halbuki ls komutu default durumda önce dizin girişlerini 
    isme göre sıraya dizmekte sonra onları göstermektedir. (Liux'ta -f'densonra -l'yi kullanınız, ters sırada çalışmıyor.) Doğal sıranın 
    ne anlam ifade ettiği dosya sistemlerinin anlatıldığı bölümde ele alımacaktır. 

    Dizin girişleri elde edildikten sonra dizin closedir POSIX fonksiyonuyla kapatılmaldır:

    #include <dirent.h>

    int closedir(DIR *dirp);

    Fonksiyon başarı durumunda 0, başarısızlık durumunda -1 değerine geri dönmektedir. 

    closedir fonksiyonu kendi içerisinde kullandığı betimleyicileri close etmektedir. Örneğin biz DIR nesnesini (directory stream)
    fdopendir ile dizin betimleyicisini vererek yaratmış olalım. closedir bu betimleyiciyi kendisi close etmektedir. 

---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <errno.h>
#include <dirent.h>

void exit_sys(const char *msg);

int main(int argc, char *argv[])
{
    DIR *dir;
    struct dirent *de;

    if (argc != 2) {
        fprintf(stderr, "wrong number of arguments!..\n");
        exit(EXIT_FAILURE);
    }

    if ((dir = opendir(argv[1])) == NULL)
        exit_sys("opendir");

    while (errno = 0, (de = readdir(dir)) != NULL) 
        printf("%s\n", de->d_name);
    
    if (errno != 0)
        exit_sys("readdir");

    closedir(dir);

	return 0;
} 

void exit_sys(const char *msg)
{
	perror(msg);

	exit(EXIT_FAILURE);
}

/*--------------------------------------------------------------------------------------------------------------------------
    Aşağıdaki örnekte bir dizindeki dosyaların hepsini ls -l stili ile yazdırıyoruz. Bu örnekte bazı noktalara dikkat ediniz:

    - Biz argv[1] ile görüntülenecek dizini alıyoruz. Ancak bu dizindeki dosyaların stat bilgileri elde edilirken yok ifadesinin 
    dosya isminin başına eklenmesi gerekmektedir:

    while (errno = 0, (de = readdir(dir)) != NULL) {
        sprintf(path, "%s/%s", argv[1], de->d_name);
        if (lstat(path, &finfo) == -1)
            exit_sys("stat");

        printf("%s\n", get_ls(&finfo, de->d_name));
    }

    Aslında bu tür durumlarda fonksiyonların at'li versiyonlarını kullanmak daha uygun olabilmektedir. 

    - Biz burada bir hizalama yapmadık. Halbuki orijinal ls -l komutu yazısal sütnları karakter sayısına göre hizalayıp sola 
    dayalı olarak, sayısal sütunları ise hizalayıp sağa dayalı olarak yazdırmaktadır. Tabii bunun için dütnun en geniş elemanının 
    bulunması da gerekmektedir. Bu işlem "çalışma sorusu" olarak sorulacaktır. 

    - Biz bu örnekte dizin girişlerini doğal sıraya göre görüntüledik. Halbuki ls -l komutu önce onları isme göre sıraya dizip 
    sonra görüntülemektedir. 
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <time.h>
#include <errno.h>
#include <sys/stat.h>
#include <dirent.h>
#include <pwd.h>
#include <grp.h>

#define LS_BUFSIZE      4096

void exit_sys(const char *msg);
char *get_ls(struct stat *finfo, const char *name);

int main(int argc, char *argv[])
{
    struct stat finfo;
    DIR *dir;
    struct dirent *de;
    char path[4096];
    
    if (argc != 2) {
        fprintf(stderr, "wrong number od arguments!..\n");
        exit(EXIT_FAILURE);
    }

    if ((dir = opendir(argv[1])) == NULL) 
        exit_sys("opendir");

    while (errno = 0, (de = readdir(dir)) != NULL) {
        sprintf(path, "%s/%s", argv[1], de->d_name);
        if (lstat(path, &finfo) == -1)
            exit_sys("stat");

        printf("%s\n", get_ls(&finfo, de->d_name));
    }
    if (errno != 0)
        exit_sys("readdir");

    closedir(dir);

	return 0;
} 

void exit_sys(const char *msg)
{
	perror(msg);

	exit(EXIT_FAILURE);
}

char *get_ls(struct stat *finfo, const char *name)
{
    static char buf[LS_BUFSIZE];
    static mode_t modes[] = {S_IRUSR, S_IWUSR, S_IXUSR, S_IRGRP, S_IWGRP, S_IXGRP, S_IROTH, S_IWOTH, S_IXOTH};
    static mode_t ftypes[] = {S_IFBLK, S_IFCHR, S_IFIFO, S_IFREG, S_IFDIR, S_IFLNK, S_IFSOCK};
    int index;
    struct tm *ptime;
    struct passwd *pw;
    struct group *gr;

    pw = getpwuid(finfo->st_uid);
    gr = getgrgid(finfo->st_gid);

    index = 0;
    for (int i = 0; i < 7; ++i)
        if ((finfo->st_mode & S_IFMT) == ftypes[i]) {
            buf[index++] = "bcp-dls"[i];
            break;
        }

    for (int i = 0; i < 9; ++i)
        buf[index++] = finfo->st_mode & modes[i] ? "rwx"[i % 3] : '-';

    ptime = localtime(&finfo->st_mtim.tv_sec);

    index += sprintf(buf + index, " %llu", (unsigned long long)finfo->st_nlink);
    if (pw == NULL)
        index += sprintf(buf + index, " %llu", (unsigned long long)finfo->st_uid);
    else 
        index += sprintf(buf + index, " %s", pw->pw_name);
    if (gr == NULL)
        index += sprintf(buf + index, " %llu", (unsigned long long)finfo->st_gid);
    else 
        index += sprintf(buf + index, " %s", gr->gr_name);

    index += sprintf(buf + index, " %llu", (unsigned long long)finfo->st_size);
    index += strftime(buf + index, LS_BUFSIZE, " %b %2e %H:%M", ptime);

    sprintf(buf + index, " %s", name);
    
    return buf;
}

/*--------------------------------------------------------------------------------------------------------------------------
    Yukarıda da belirttiğimiz üzere aslında opendir, readdir, closedir gibi POSIX fonksiyonları arka planda işletim sisteminin sistem fonksiyonlarını
    çağırmaktadır. Örneğin Linux'ta aslında işletim sistemi düzeyinde işlemler önce sys_open sistem fonksiyonu ile dizin'in açılması 
    sonra sys_getdents sistem fonksiyonu ile dizin girişlerinin okunması ve nihayet sys_close fonksiyonu ile dizin'in kapatılması yoluyla 
    yapılmaktadır. Ancak POSIX standartlarında bu işlemler taşınabilir biçimde opendir, readdir ve closedir fonksiyonlarına devredilmiştir. 
    Şüphesiz bu fonksiyonlar asında dizini açıp onun betimleyicisini DIR yapısının içerisinde saklamaktadır. İşte elimizde DIR yapısı 
    varsa biz de açık dizin'in betimleycisini elde etmek isttyorsak bunun için dirfd isimli POSIX fonksiyonundan faydalanabiliriz:

    #include <dirent.h>

    int dirfd(DIR *dirp);

    Fonksiyon parametre olarak DIR yapısının adresini alır, geri dönüş değeri olarak dizine ilişkin betimleyiciyi verir. Fonksiyon başarısızlık durumunda
    -1 değerine geri dönmektedir. 

    Yukarıdaki örneği fstatat fonksiyonunu kullanarak basitleştirebiliriz. fstatat fonksiyonunun prototipi şöyledir:

    #include <sys/stat.h>

    int fstatat(int fd, const char *restrict path, struct stat *restrict buf, int flag);

    Fonskiyonun fd parametresinin yanı sıra aynı zamanda bir flag parametresinin olduğuna dikkat ediniz. Bu parametre stat semantiğinin mi yoksa 
    lstat semantiğinin mi uygulanacağını belirtmektedir. Eğer bu parametreye 0 geçilirse bu durumda stat semnatiği uygulanır Eğer bu parametreye 
    AT_SYMLINK_NOFOLLOW değeri geçilirse bu durumda lstat semantiği uygulanmaktadır. AT_SYMLINK_NOFOLLOW sembolik sabiti <sys/stat.h> içerisinde değil
    <fcntl.h> içerisinde bildirilmiştir. İşte biz yukarıdaki örnekte önce dizin'in betimleycisini dirfd fonksiyonu ile alıp bunu fstatat 
    fonksiyonunda kullanırsak yol ifadesini düzenlememize gerek kalmaz. Aşağıdaki örnekte bu çözüm verilmiştir.
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <time.h>
#include <errno.h>
#include <fcntl.h>
#include <sys/stat.h>
#include <dirent.h>
#include <pwd.h>
#include <grp.h>

#define LS_BUFSIZE      4096

void exit_sys(const char *msg);
char *get_ls(struct stat *finfo, const char *name);

int main(int argc, char *argv[])
{
    struct stat finfo;
    DIR *dir;
    struct dirent *de;
    int fd;
    
    if (argc != 2) {
        fprintf(stderr, "wrong number od arguments!..\n");
        exit(EXIT_FAILURE);
    }

    if ((dir = opendir(argv[1])) == NULL) 
        exit_sys("opendir");

    if ((fd = dirfd(dir)) == -1)
        exit_sys("dirfd");

    while (errno = 0, (de = readdir(dir)) != NULL) {
        if (fstatat(fd, de->d_name, &finfo, AT_SYMLINK_NOFOLLOW) == -1)
            exit_sys("stat");

        printf("%s\n", get_ls(&finfo, de->d_name));
    }
    if (errno != 0)
        exit_sys("readdir");

    closedir(dir);

	return 0;
} 

void exit_sys(const char *msg)
{
	perror(msg);

	exit(EXIT_FAILURE);
}

char *get_ls(struct stat *finfo, const char *name)
{
    static char buf[LS_BUFSIZE];
    static mode_t modes[] = {S_IRUSR, S_IWUSR, S_IXUSR, S_IRGRP, S_IWGRP, S_IXGRP, S_IROTH, S_IWOTH, S_IXOTH};
    static mode_t ftypes[] = {S_IFBLK, S_IFCHR, S_IFIFO, S_IFREG, S_IFDIR, S_IFLNK, S_IFSOCK};
    int index;
    struct tm *ptime;
    struct passwd *pw;
    struct group *gr;

    pw = getpwuid(finfo->st_uid);
    gr = getgrgid(finfo->st_gid);

    index = 0;
    for (int i = 0; i < 7; ++i)
        if ((finfo->st_mode & S_IFMT) == ftypes[i]) {
            buf[index++] = "bcp-dls"[i];
            break;
        }

    for (int i = 0; i < 9; ++i)
        buf[index++] = finfo->st_mode & modes[i] ? "rwx"[i % 3] : '-';

    ptime = localtime(&finfo->st_mtim.tv_sec);

    index += sprintf(buf + index, " %llu", (unsigned long long)finfo->st_nlink);
    if (pw == NULL)
        index += sprintf(buf + index, " %llu", (unsigned long long)finfo->st_uid);
    else 
        index += sprintf(buf + index, " %s", pw->pw_name);
    if (gr == NULL)
        index += sprintf(buf + index, " %llu", (unsigned long long)finfo->st_gid);
    else 
        index += sprintf(buf + index, " %s", gr->gr_name);

    index += sprintf(buf + index, " %llu", (unsigned long long)finfo->st_size);
    index += strftime(buf + index, LS_BUFSIZE, " %b %2e %H:%M", ptime);

    sprintf(buf + index, " %s", name);
    
    return buf;
}

/*--------------------------------------------------------------------------------------------------------------------------
                                        17. Ders 18/12/2022 - Pazar
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    rewinddir isimli POSIX fonksiyonu dolaşımı yeniden başlatmak amacıyla kullanılır. Yani bu işlem adeta dosya göstericisinin 
    dizin dosyasının başına çekilmesi işlemi gibidir. 

    Aşağıdaki örnekte dizin girişleri rewindir fonksiyonu ile iki kez elde edilmiştir. 
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <errno.h>
#include <dirent.h>

void exit_sys(const char *msg);

int main(int argc, char *argv[])
{
    DIR *dir;
    struct dirent *de;

    if (argc != 2) {
        fprintf(stderr, "wrong number of arguments!..\n");
        exit(EXIT_FAILURE);
    }

    if ((dir = opendir(argv[1])) == NULL)
        exit_sys("opendir");

    while (errno = 0, (de = readdir(dir)) != NULL) 
        printf("%s\n", de->d_name);
    
    if (errno != 0)
        exit_sys("readdir");

    printf("---------------------------------------\n");

    rewinddir(dir);

    while (errno = 0, (de = readdir(dir)) != NULL) 
        printf("%s\n", de->d_name);
    
    if (errno != 0)
        exit_sys("readdir");

    closedir(dir);

	return 0;
} 

void exit_sys(const char *msg)
{
	perror(msg);

	exit(EXIT_FAILURE);
}

/*--------------------------------------------------------------------------------------------------------------------------
    Dizin girişlerini dolaşırken belli bir noktada dizin dosyasının dosya göstericisinin konumunu telldir POSIX fonksiyonu 
    ile alabiliriz ve o offset'e seekdir POSIX fonksiyonu ile yeniden konumlandırma yapabiliriz. Fonksiyonların prototipleri şöyledir:

    #include <dirent.h>

    long telldir(DIR *dirp);
    void seekdir(DIR *dirp, long loc);

    Tabii biz belli bir konumu okuduktan sonra kaydedersek bu durumda okumadan dolayı dizin dosyasının dosya göstericisi ilerletilmiş 
    olacaktır. Aşağıdaki örnekte dizin içerisinde "sample.c" dosyası bulunup onun konumu telldir fonksiyonu ile saklanmıştır. Sonra seekdir
    fonksiyonu ile konuma konumlandırma yapılmıştır. Tabii burada kaydedilen konum "sample.c" dosyasından sonraki dosyanın konumdur.
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <errno.h>
#include <dirent.h>

void exit_sys(const char *msg);

int main(int argc, char *argv[])
{
    DIR *dir;
    struct dirent *de;
    long loc;

    if (argc != 2) {
        fprintf(stderr, "wrong number of arguments!..\n");
        exit(EXIT_FAILURE);
    }

    if ((dir = opendir(argv[1])) == NULL)
        exit_sys("opendir");

    while (errno = 0, (de = readdir(dir)) != NULL) {
        printf("%s\n", de->d_name);
        if (!strcmp(de->d_name, "sample.c"))
            loc = telldir(dir);
    }
    
    if (errno != 0)
        exit_sys("readdir");

    printf("----------------------------------------------\n");
    
    seekdir(dir, loc);

    while (errno = 0, (de = readdir(dir)) != NULL) 
        printf("%s\n", de->d_name);
    
    if (errno != 0)
        exit_sys("readdir");

    closedir(dir);

	return 0;
} 

void exit_sys(const char *msg)
{
	perror(msg);

	exit(EXIT_FAILURE);
}

/*--------------------------------------------------------------------------------------------------------------------------
    Dizin ağacının dolaşılması özyinelemeli bir algoritmayla yapılmaldır. Bu işlem çeşitli biçimlerde gerçekleştirilebilir. 
    En basit gerçekletirimi dolaşılacak ağacın kök yol ifadesini alan özyinelemeli bir fonksiyon yazmaktır. Bu fonksiyon 
    dizin girişlerini tek tek elde eder. Eğer söz konusu dizin girişi bir dizine ilişkinse o dizinin yol ifadesiyle kendini çağırır.
    Bu algoritmada dikkat edilmesi gereken birkaç nokta vardır:

    1) Dizin girişleri dolaşılırken "." ve ".." dizinleri continue ile geçilmelidir. Aksi takdirde sonsuz döngü oluşabilir. 
    2) stat fonksiyonu yerine lstat fonksiyonu kullanılmalıdır. Çünkü dizin ağacı dolaşılırken sembolik bağlantı bir dizine ilişkinse
    sembolik bağlantının hedefine gidilmesi özyinelemeyi bozup sonsuz döngülere yol açabilir. 
    3) readdir fonksiyonu dizin girişini okuduğunda bize yalnız girişin ismini vermektedir. Dolayısıyla lstat fonksiyonu uygulanırken 
    prosesin çalışma dizinin uygun olması gerekir. Bunu sağlayabilmek için her dizine geçişte chdir fonksiyonu ile prosesin çalışma dizinini değiştebiliriz. 
    Ya da alternatif olarak mutlak bir yol ifadesi sürekli güncellenebilir. Aslında burada seçeneklerden biri de fonksiyonların at'li 
    biçimlerini kullanmak olabilir. 
    4) Her özyineleme bittiğinde opendir ile açılan dizin closedir ile kapatılmalıdır. 
    5) Genellikle böylesi fonksiyonlar bir fatal error ile programı sonlandırmamalıdır. chdir fonksiyonu ile prosesin çalışma dizini 
    değiştirilemeyebilir. Ya da örneğin opendir ile biz bir dizini açamayabiliriz. Bu tür durumlarda hata stderr dosyasına rapor edilip işlemin 
    devem ettirilmesi uygun olabilir. 
    6) Özyineleemeli dolaşım bittikten sonra prosesin çalışma dizini orijinal halde bırakılmalıdır. 

    Aşağıda tipik bir özyineelemeli "depth-first" dolaşım örneği verilmiştir. Ancak burada prosesin çalışma dizini özyineleme bittikten sonra
    orijinal dizin ile yeniden set edilmemiştir. 

---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <errno.h>
#include <sys/stat.h>
#include <unistd.h>
#include <dirent.h>

void walkdir(const char *path);
void exit_sys(const char *msg);

int main(int argc, char *argv[])
{
    if (argc != 2) {
        fprintf(stderr, "wrong number of arguments!..\n");
        exit(EXIT_FAILURE);
    }

    walkdir(argv[1]);

	return 0;
} 

void walkdir(const char *path)
{
    DIR *dir;
    struct dirent *de;
    struct stat finfo;

    if ((dir = opendir(path)) == NULL) {
        fprintf(stderr, "cannot read directory: %s\n", path);
        return;
    }
    
    if (chdir(path) == -1) {
        fprintf(stderr, "directory cannot change: %s\n", path);
        goto EXIT;
    }
    
    while (errno = 0, (de = readdir(dir)) != NULL) {
        printf("%s\n", de->d_name);
        if (!strcmp(de->d_name, ".") || !strcmp(de->d_name, ".."))
            continue;
        if (lstat(de->d_name, &finfo) == -1) {
            fprintf(stderr, "cannot get stat info: %s\n", de->d_name);
            continue;
        }
     
        if (S_ISDIR(finfo.st_mode)) {
            walkdir(de->d_name);
            if (chdir("..") == -1) {
                fprintf(stderr, "directory cannot change: %s\n", path);
                goto EXIT;
            }
        }
    }
    if (errno != 0)
        fprintf(stderr, "cannot read directory info: %s\n", path);
EXIT:
    closedir(dir);
}

void exit_sys(const char *msg)
{
	perror(msg);

	exit(EXIT_FAILURE);
}

/*--------------------------------------------------------------------------------------------------------------------------
    Özyineleme çağırmada hangi kademede bulunulduğunu belirten bir bilginin de özyinelemeli fonksiyona parametre yoluyla aktarılması
    faydalaı olabilmektedir. Örneğin bu sayede biz ağacı kademeli bir biçimde görüntüleyebiliriz. 

    Aşağıdaki örnekte walkdir fonksiyonuna bir kademe bilgisi de eklenmiştir. 
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <errno.h>
#include <sys/stat.h>
#include <unistd.h>
#include <dirent.h>

void walkdir(const char *path, int level);
void exit_sys(const char *msg);

int main(int argc, char *argv[])
{
    if (argc != 2) {
        fprintf(stderr, "wrong number of arguments!..\n");
        exit(EXIT_FAILURE);
    }

    walkdir(argv[1], 0);

	return 0;
} 

void walkdir(const char *path, int level)
{
    DIR *dir;
    struct dirent *de;
    struct stat finfo;

    if ((dir = opendir(path)) == NULL) {
        fprintf(stderr, "cannot read directory: %s\n", path);
        return;
    }
    
    if (chdir(path) == -1) {
        fprintf(stderr, "directory cannot change: %s\n", path);
        goto EXIT;
    }
    
    while (errno = 0, (de = readdir(dir)) != NULL) {
        printf("%*s%s\n", level * 4, "", de->d_name);
        if (!strcmp(de->d_name, ".") || !strcmp(de->d_name, ".."))
            continue;
        if (lstat(de->d_name, &finfo) == -1) {
            fprintf(stderr, "cannot get stat info: %s\n", de->d_name);
            continue;
        }
     
        if (S_ISDIR(finfo.st_mode)) {
            walkdir(de->d_name, level + 1);
            if (chdir("..") == -1) {
                fprintf(stderr, "directory cannot change: %s\n", path);
                goto EXIT;
            }
        }
    }
    if (errno != 0)
        fprintf(stderr, "cannot read directory info: %s\n", path);
EXIT:
    closedir(dir);
}

void exit_sys(const char *msg)
{
	perror(msg);

	exit(EXIT_FAILURE);
}

/*--------------------------------------------------------------------------------------------------------------------------
    Aslında yukarıdaki walkdir fonksiyonu bir sarma fonksiyonla daha iyi hale getirilebilir. Bu sayede level parametresi kullanıcıdan gizlenebilir 
    ve prosesin çalışma dizini alınıp geri set edilebilir. 

    Aşağıdaki örnekte walkdir fonksiyonu asıl özyineleme işlemini yapan walkdir_recur fonksiyonunu çağırmaktadır. Fonksiyonda kademeli yazım 
    için printf fonksiyonu şöyle çağrılmıştır:

    printf("%*s%s\n", level * 4, "", de->d_name);

    Burada * format karakteri level * 4 ile eşleştirilmiştir. İlk %s format karakteriyle de "" biçiminde boş string eşleşecektir. 
    O halde biz yalnızca satırın başında level * 4 kadar boşluk oluşturmuş oluyoruz.
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <errno.h>
#include <sys/stat.h>
#include <unistd.h>
#include <dirent.h>

void walkdir(const char *path);
void walkdir_recur(const char *path, int level);
void exit_sys(const char *msg);

int main(int argc, char *argv[])
{
    if (argc != 2) {
        fprintf(stderr, "wrong number of arguments!..\n");
        exit(EXIT_FAILURE);
    }

    walkdir(argv[1]);

	return 0;
} 

void walkdir(const char *path)
{
    char cwd[PATH_MAX];

    if (getcwd(cwd, PATH_MAX) == NULL) {
        perror("getcwd");
        return;
    }

    walkdir_recur(path, 0);

    if (chdir(cwd) == -1) {
        perror("chdir");
        return;
    }
}

void walkdir_recur(const char *path, int level)
{
    DIR *dir;
    struct dirent *de;
    struct stat finfo;

    if ((dir = opendir(path)) == NULL) {
        fprintf(stderr, "cannot read directory: %s\n", path);
        return;
    }
    
    if (chdir(path) == -1) {
        fprintf(stderr, "directory cannot change: %s\n", path);
        goto EXIT;
    }
    
    while (errno = 0, (de = readdir(dir)) != NULL) {
        printf("%*s%s\n", level * 4, "", de->d_name);
        if (!strcmp(de->d_name, ".") || !strcmp(de->d_name, ".."))
            continue;
        if (lstat(de->d_name, &finfo) == -1) {
            fprintf(stderr, "cannot get stat info: %s\n", de->d_name);
            continue;
        }
     
        if (S_ISDIR(finfo.st_mode)) {
            walkdir_recur(de->d_name, level + 1);
            if (chdir("..") == -1) {
                fprintf(stderr, "directory cannot change: %s\n", path);
                goto EXIT;
            }
        }
    }
    if (errno != 0)
        fprintf(stderr, "cannot read directory info: %s\n", path);
EXIT:
    closedir(dir);
}

void exit_sys(const char *msg)
{
	perror(msg);

	exit(EXIT_FAILURE);
}

*--------------------------------------------------------------------------------------------------------------------------
    Dizin ağacını dolaşırken her defasında prosesin çalışma dizinini değiştirmek yerine fonksiyonların at'li biçimlerinden de 
    faydalanabiliriz. Aşağıdaki örnekte özyinelemeli fonksiyona üst dizinin betimleyicisi (fdp) ve dosyanın ismi geçirilmiştir. 
    at'li fonksiyonların eğer yol ifadesi mutlak ise at'siz fonksiyonlar gibi davrandığını anımsayınız.
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <errno.h>
#include <fcntl.h>
#include <sys/stat.h>
#include <unistd.h>
#include <dirent.h>

void walkdir(const char *path);
void walkdir_recur(int fddir, const char *fname, int level);
void exit_sys(const char *msg);

int main(int argc, char *argv[])
{
    if (argc != 2) {
        fprintf(stderr, "wrong number of arguments!..\n");
        exit(EXIT_FAILURE);
    }

    walkdir(argv[1]);

	return 0;
} 

void walkdir(const char *path)
{
	int fddir;

	if ((fddir = open(path, O_RDONLY)) == -1) 
		exit_sys(path);

    walkdir_recur(fddir, path, 0);

	close(fddir);
}

void walkdir_recur(int fdp, const char *fname, int level)
{
    DIR *dir;
	int fdc;
    struct dirent *de;
    struct stat finfo;

	if ((fdc = openat(fdp, fname, O_RDONLY)) == -1) {
		fprintf(stderr, "cannot open file: %s\n", fname);
		return;
	}
    if ((dir = fdopendir(fdc)) == NULL) {
        fprintf(stderr, "cannot read directory: %s\n", fname);
		close(fdp);
        return;
    }
    
    while (errno = 0, (de = readdir(dir)) != NULL) {
        printf("%*s%s\n", level * 4, "", de->d_name);
        if (!strcmp(de->d_name, ".") || !strcmp(de->d_name, ".."))
            continue;
        if (fstatat(fdc, de->d_name, &finfo, AT_SYMLINK_NOFOLLOW) == -1) {
			fprintf(stderr, "cannot get stat info: %s\n", de->d_name);
            continue;
        }
     
        if (S_ISDIR(finfo.st_mode)) 
            walkdir_recur(fdc, de->d_name, level + 1);
    }
    if (errno != 0)
        fprintf(stderr, "cannot read directory info: %s\n", fname);
EXIT:
    closedir(dir);
}

void exit_sys(const char *msg)
{
	perror(msg);

	exit(EXIT_FAILURE);
}

/*--------------------------------------------------------------------------------------------------------------------------
    Dizin ağacını dolaşırken genelleştirme sağlamak için fonksiyon göstericilerindne faydalanabiliriz. Yani fonksiyonumuz dizin ağacını 
    dolaşırken dosya isimlerini ekrana yazdırmak yerine parametresiyle aldığı bir callback fonksiyonu çağırabilir. 

    Aşağıda dizin girişi bulundukça çağrılan bir callback mekanizması örneği verilmiştir. Buradaki fonksiyonun prototipi şöyledir:

    int walkdir(const char *path, int (*proc)(const char *, const struct stat *, int));

    Fonksiyonun birinci parametresi dolaşılacak dizinin yol ifadesini belirtir. İkinci parametre callback fonksiyonun adresini almaktadır. 
    callback fonksiyonun virinci parametresi bulunan dizin girişinin ismini (tüm yol ifadesi değil), ikinci parametresi bu dosyanın 
    stat bilgilerini belirtmektedir. Üçüncü parametre ise özyinleme için kademe bilgisini belirtir. Callback fonksiyon 0 ile geri dönerse 
    özyineleme devam ettirlir. Ancak sıfır dışı bir değerle geri dönerse özyineleme sonlandırılır ve walkdir fonksiyonu da bu değerler 
    geri döner. Bu durumda walkdir fonksiyonun geri dönüş değeri üç biçimde olabilir:

    -1: POSIX fonksiyonlarından birinin hatayla geri dönmesi
    > 0: Erken sonlanmayı belirtir. 
    0: Normal sonlanmayı belirtir. 
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <errno.h>
#include <sys/stat.h>
#include <unistd.h>
#include <dirent.h>

int walkdir(const char *path, int (*proc)(const char *, const struct stat *, int));
int walkdir_recur(const char *path, int level, int (*proc)(const char *, const struct stat *, int));

int disp(const char *fname, const struct stat *finfo, int level)
{
    printf("%*s%s\n", level * 4, "", fname);

    if (!strcmp(fname, "d.dat"))
        return 1;

    return 0;
}

int main(int argc, char *argv[])
{
    int result;

    if (argc != 2) {
        fprintf(stderr, "wrong number of arguments!..\n");
        exit(EXIT_FAILURE);
    }

    if ((result = walkdir(argv[1], disp)) == -1) {
        fprintf(stderr, "function terminates problematically!\n");
        exit(EXIT_FAILURE);
    }
    if (result != 0)
        printf("function terminates prematurely with %d code\n", result);
    else
        printf("function terminates normally!..\n");

	return 0;
} 

int walkdir(const char *path, int (*proc)(const char *, const struct stat *, int))
{
    char cwd[PATH_MAX];
    int result;

    if (getcwd(cwd, PATH_MAX) == NULL) {
        perror("getcwd");
        return - 1;
    }

    result = walkdir_recur(path, 0, proc);

    if (chdir(cwd) == -1) {
        perror("chdir");
        return -1;
    }

    return result;
}

int walkdir_recur(const char *path, int level, int (*proc)(const char *, const struct stat *, int))
{
    DIR *dir;
    struct dirent *de;
    struct stat finfo;
    int result = 0;

    if ((dir = opendir(path)) == NULL) {
        fprintf(stderr, "cannot read directory: %s\n", path);
        return -1;
    }
    
    if (chdir(path) == -1) {
        fprintf(stderr, "directory cannot change: %s\n", path);
        result = -1;
        goto EXIT;
    }
    
    while (errno = 0, (de = readdir(dir)) != NULL) {
        if (!strcmp(de->d_name, ".") || !strcmp(de->d_name, ".."))
            continue;
        if (lstat(de->d_name, &finfo) == -1) {
            fprintf(stderr, "cannot get stat info: %s\n", de->d_name);
            continue;
        }
        if ((result = proc(de->d_name, &finfo, level)) != 0) {
            result = -1;
            goto EXIT;
        }
     
        if (S_ISDIR(finfo.st_mode)) {
            result = walkdir_recur(de->d_name, level + 1, proc);
            if (chdir("..") == -1) {
                fprintf(stderr, "directory cannot change: %s\n", path);
                result = -1;
                goto EXIT;
            }
            if (result != 0)
                goto EXIT;
        }
    }
    if (errno != 0)
        fprintf(stderr, "cannot read directory info: %s\n", path);
EXIT:
    closedir(dir);

    return result;
}

/*--------------------------------------------------------------------------------------------------------------------------
    scandir bir dizindeki belli koşulları sağlayan girişleri veren biraz karmaşık parametreye sahip bir POSIX fonksiyonudur. 
    Fonksiyonun parametrik yapısı şöyledir:

    #include <dirent.h>

    int alphasort(const struct dirent **d1, const struct dirent **d2);
    int scandir(const char *dir, struct dirent ***namelist, int (*sel)(const struct dirent *),
                int (*compar)(const struct dirent **, const struct dirent **));  

    scandir fonksiyonunun birinci parametresi dizin'in yol ifadesini almaktadır. İkinci parametreye struct dirent türünden 
    göstericiyi gösteren bir göstericinin adresi geçirilmelidir. Üçüncü parametre filte işleminde kullanılacak fonksiyonu beirtmektedir. 
    Her dizin girişi bulundukça bu fonksiyon çağrılır. Eğer bu fonksiyon sıfır dışı bir değerle geri dönerse dizin girişi biriktirilir. 
    Bu parametre NULL adres geçilebilir. Bu durumda dizindeki tüm girişler elde edilir. Son parametre filtrelenen girişlere ilişkin 
    gösterici dizisini sort etmek için kullanılacak karşılaştırma fonksiyonunu belirtmektedir. Bu karşılaştırma fonksiyonun prototipi şöyle olmalıdır:

    int cmp(const struct **direnet1, const struct **dirent2);

    Fonksiyon tıpkı qsort fonksiyonunda olduğu gibi birinci parametresiyle belirtilmiş olan dizin girişi ikinci parametresiyle belirtilmiş 
    olan dizin girişinden büyükse pozitif herhangi bir değere, küçükse negatif herhangi bir değere ve eşitse sıfır değerine geri dönmelidir. 
    Alfabetik sıralamayı sağlamak amacıyla zaten hazır bir alphasort isimli fonksiyon bulundurulmuştur. 

    scandir fonksiyonu başarı durumunda gösterici dizisine yerleştirilen eleman sayısı ile başarısızlık durumunda -1 ile geri döner ve errno uygun biçimde değer 
    alır. 

    scandir fonksiyonu tüm tahisatları malloc fonksiyonunu kullanarak yapmaktadır. Dolayısıyla programcının tahsis edilen bu alanları kendisinin
    free hale getirmesi gerekmektedir. 

    scandir kendi içerisinde her biriktirilecek diizn girişi için malloc fonksiyonu ile bir truct dirent yapısı tahsis eder, bunların adreslerini 
    de yine tahsis ettiği bir gösterici dizisine yerleştirir. Bu gösterici dizisinin adresini de bizim adresini geçtiğimiz 
    göstericiyi gösteren göstericinin içerisine yerleştirmektedir. 

    Aşağıdaki örnekte komut argümanı olarak girilen bir dizinde başı 'a' ya da 'A' harfi ile başlayan girişler elde edilmiştir. 
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <dirent.h>

void exit_sys(const char *msg);

int myfilter(const struct dirent *de)
{
    return de->d_name[0] == 'a' || de->d_name[0] == 'A';
}

int main(int argc, char *argv[])
{
    int result;
    struct dirent **dents;

    if (argc != 2) {
        fprintf(stderr, "wrong number of arguments!..\n");
        exit(EXIT_FAILURE);
    }

    if ((result = scandir(argv[1], &dents, myfilter, alphasort)) == -1)
        exit_sys("scandir");

    for (int i = 0; i < result; ++i)
        printf("%s\n", dents[i]->d_name);

    for (int i = 0; i < result; ++i)
        free(dents[i]);
    free(dents);

	return 0;
} 

void exit_sys(const char *msg)
{
	perror(msg);

	exit(EXIT_FAILURE);
}

/*--------------------------------------------------------------------------------------------------------------------------
    scandir fonksiyonun tasarımında bize göre kusurlar vardır. Fonksiyonun dirent yapılarını biriktirmesi karşılaştırma fonksiyonu yazacak
    kişiler için yük oluşturmaktadır. Buradaki daha doğru tasarım yeni bir yapı bildirip yapının içerisinde hem dirent bilgilerinin hem de 
    stat bilgilerinin bulunması olabilir. 

    Aşağıda bir karşılaştırma fonkssiyonu yazımı örnek verilmiştir. 
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/stat.h>
#include <dirent.h>

void exit_sys(const char *msg);

int myfilter(const struct dirent *de)
{
    return de->d_name[0] == 'a' || de->d_name[0] == 'A';
}

int cmp_size(const struct dirent **de1, const struct dirent **de2)
{
    struct stat finfo1, finfo2;

    if (stat((**de1).d_name, &finfo1) == -1)
        exit_sys("stat");

    if (stat((**de2).d_name, &finfo2) == -1)
        exit_sys("stat");

    if (finfo1.st_size > finfo2.st_size)
        return 1;

    if (finfo1.st_size < finfo2.st_size)
        return -1;

    return 0;
}

int main(int argc, char *argv[])
{
    int result;
    struct dirent **dents;

    if (argc != 2) {
        fprintf(stderr, "wrong number of arguments!..\n");
        exit(EXIT_FAILURE);
    }

    if (chdir(argv[1]) == -1) 
        exit_sys("chdir");

    if ((result = scandir(argv[1], &dents, myfilter, cmp_size)) == -1)
        exit_sys("scandir");

    for (int i = 0; i < result; ++i)
        printf("%s\n", dents[i]->d_name);

    for (int i = 0; i < result; ++i)
        free(dents[i]);
    free(dents);

	return 0;
} 

void exit_sys(const char *msg)
{
	perror(msg);

	exit(EXIT_FAILURE);
}

/*--------------------------------------------------------------------------------------------------------------------------
                                                18. Ders 24/12/2022 - Cumartesi
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Dizin ağacını özyinelemeli biçimde dolaşan ftw (file traverse walk) ve nftw (new file traverse walk) isimli POSIX fonksiyonları 
    bulunmaktadır. Aslında eskiden yalnızca ftw fonksiyonu vardı. Ancak bu fonksiyona bazı eklemeler yapılıp nftw fonksiyonu oluşturuldu
    ve ftw fonksiyonu "deprecated" yapıldı. Yani bugün hem ftw hem de nftw fonksiyonları bulunuyor olsa da nftw fonksiyonun kullanılması 
    önerilmektedir. Zaten nftw fonksiyonu işlevsel olarak ftw fonksiyonu kapsamaktadır. nftw fonksiyonun prototipi şöyledir:

     #include <ftw.h>

    int nftw(const char *path, int (*fn)(const char *, const struct stat *, int, struct FTW *), int fd_limit, int flags);

    Linux altında bu fonksiyonu libc kütüphanesi ile kullanırken "feature test macro" oluşturulmalıdır. Burada başlık dosyalarının 
    yukarısında aşağıdaki gibi bir sembolik sabit bulundurmak gerekir:

    #define _XOPEN_SOURCE 500

    Feature test macro kavramından daha sonra bahsedilecektir. Budaraki sayının 500'e eşit ya da daha büyük olması gerekmektedir. 

    Fonksiyonun birinci parametresi özyinelemeli dolaşılacak dizin'in yol ifadesini almaktadır. İkinci parametre her dizin girişi bulundukça 
    çağrılacak "callback" fonksiyonun adresini almaktadır. Buradaki fonksiyonun aşağıdaki parametrik yapıya sahip olması gerekir:

    int callback(const char *path, const struct stat *finfo, int flag, struct FTW *ftw);

    nftw fonksiyonun üçüncü parametresi kullanılacak maksimum dosya betimleyici sayısını belirtmektedir. Fonksiyon her derine indikçe 
    o dizini opendir fonksiyonu ile açtığı için (bizde öyle yapmıştık) dosya betimleyici tablosunda bir betimleyici harcamaktadır. Linux'ta
    default durumda prosesin dosya betimleyici tablosunda 1024 tane betimleyici için yer vardır. Dolayısıyla derine inildikçe bu tabloda 
    betimleyici yer kaplayacağından derin ağaçlarda betimleyici sıkıntısı çekilebilir. İşte fonksiyonun dördüncü parametresi (fd_limit)
    fonksiyonun en fazla kaç betimleyiciyi açık olarak tutacığını belirtmektedir. Programcı bu parametreye ortalama bir değer girebilir. 
    Fonksiyon kendi içerisinde burada belirtilen derinlik aşıldığında özyineleme yaparken üst dizin'in betimleyicisini kapatıp geri dönüşte 
    yeniden açmaktadır. Ayrıca fonksiyonun dokümantasyonunda fonksiyonun her kademe için en fazla bir tane betimleyici kullanacağı belirtilmiştir. 
    Fonksiyonun son parametresi özyinelemeli dolaşım sırasında bazı belirlemeler için kullanılmaktadır. Bu parametre çeşitli sembolik sabitlerin 
    bit düzeyinde OR'lanması ile oluşturulmaktadır. Bu sembolik sabitler şunlardır:

    FTW_CHDIR: Eğer bu bayrak belirtilirse fonksiyon her dizine geçtiğinde prosesin çalışma dizinini de o dizin olarak değiştirmektedir. 
   
    FTW_DEPTH: Normalde dolaşım "pre-order" biçimde yapılmaktadır. Bu bayrak girilirse "post-order" dolaşım yapılır. Bayrağın ismi yanlış verilmiştir. 
    "pre-order" dolaşım demek bir dizin ile karşılaşıldığında önce dizin girişinin ele alnıması sonra özyineleme yapılması demektir. "post-order" dolaşım ise
    önce özyineleme yapılıp sonra dizin girişinin ele alınması demektir. Defaul durum "pre-order" dolaşım biçimindedir. 
   
    FTW_MOUNT: Bu bayrak belirtilirse özyineleme yapılırken bir "mount point" ile karşılaşılırsa o dosya sistemine girilmez. Default durumda 
    özyineleme sırasında bir "mount point" ile kaşılaşılırsa özyineleme o dosya sisteminin içime girilerek devam ettirilmektedir. 
   
    FTW_PHYS:  Default durumda nftw fonksiyonu bir sembolik link dosyası ile karşılaştığında linki izler ve link'in hedefine
    yönelik hareket eder. Daha önce bir böyle bir durumun sonsuz döngüye yol açabileceğinden bahsetmiştik. Bu nedenle biz özyinelemede stat fonksiyonu yerine
    lstat fonksiyonunu kullanmıştık. İşte bu bayrak belirtilirse artık nftw fonksiyonu sembolik link dosyası ile karşılaştığında link'i izlemez, 
    sembolik link dosyasının kendisi hakkında bilgi verir. 

    Programcı bu dördüncü parametreye hiçbir bayrak geçmek istemezse 0 girebilir. 

    nftw fonksiyonun geri dönüş değeri fonksiyon başarıssa -1, başarılıysa 0'dır. Ancak aslında fonksiyon başarılı durumda callback fonksiyonun 
    geri dönüş değeri ile geri döner. Şöyle ki: Biz callback fonksiyonu 0 ile geri döndürürsek özyinelemeye devam etmek istediğimizi belirtmiş 
    oluruz. Bu durumda bir IO hatası da olmazsa nftw fonksiyonu 0 ile geri döner. Eğer biz bu fonksiyondan sıfır dışı bir değerle geri dönersek.
    nftw fonksiyonu özyinelemeyi bırakıp hemen hemen geri çıkar ve bizim callback fonksiyondan döndürrüğümüz sıfır dışı değerle geri döner. 

    Şimdi de callback fonksiyonun parametrelerine gelelim:

    int callback(const char *path, const struct stat *finfo, int flag, struct FTW *ftw);

    Fonksiyonun birinci parametresine bulunun dizin girişinin yol ifadesi yerleştirilir. Bu yol ifadesinin baş kısmı tamamen 
    bizin nftw fonksiyonuna verdiğimiz dizin ifadesinden oluşmaktadır. (Yani biz nftw fonksiyonuna mutlak bir yol iafdesi verirsek buraya
    mutlak bir yol ifadesi geçirilir, biz nftw fonksiyonuna göreli bir yol ifadesi verirsek burada göreli bir yol ifadesi geçirilir.) 
    Fonksiyonun ikinci parametresi bulunan dizin girşine ilişkin sturct stat yapısının adresini belirtmektedir. Fonksiyonun üçüncü parametresi ise
    bulunan dizin girişinin türünü belirtmektedir. Bu tür şunlardan birine tam eşit olmak zorundadır:

    FTW_D: Bulunan giriş bir dizin girişidir.
    
    FTW_DNR: Bulunan giriş bir dizin girişidir. Ancak bu dizin'in içi okunamamaktadır. Dolayısıyla bu dizin özyinelemede dolaşılamayacaktır.

    FTW_DP: Post-order dolaşımda bir dizinle karşılaşıldığında bayrak FTW_D yerine FTW_DP olarak set edilmektedir. 

    FTW_F: Bulunan dizin girişi sıradan bir dıosyadır (regular file).

    FTW_NS: Bulunan dizin girişi için stat ya da lstat fonksiyonu başarısız olmuştur. Dolayısıyla fonksiyona geçirilen stat yapısı da
    anlamlı değildir. 

    FTW_SL: Bulunan giriş bir sembolik bağlantı dosyasına ilişkindir. Sembolik bağlantı dosyasının hedefi mevcuttur. 

    FTW_SLN: Bulunan giriş bir sembolik bağlantı dosyasına ilişkindir. Sembolik bağlantı dosyasının hedefi mevcut değildir ("danging klink" durumu). 

    callback fonksiyonun son parametresi FTW isimli bir yapı türündendir Bu yapı şöyle bildirilmiştir:

    struct FTW {
        int base;
        int level;
    };

    Yapının level elemanı ağaçtaki derinlik düzeyini belirtmektedir. Bu değer 0'dan başlayarak derine indikçe artırılmaktadır.
    base elemanı ise dizin girişinin birinci parametrede belirtilen yol ifadesinin kaçıncı indeksinden başladığını belirtmektedir. Örneğin
    biz "/home/kaan/Study" dizinini dolaşmak istemiş olalım. Fonksiyon da dizin girişi olarak "sample.c" bulmuş olsun. Fonksiyon bize bu girişi 
    "/home/kaan/Study/sample.c" biçiminde verecektir. İşte buradaki base 17 olarak verilecektir. 

    Aşağıda nftw fonksiyonunun kullanımına bir örnek verilmiştir. 
---------------------------------------------------------------------------------------------------------------------------*/

#define _XOPEN_SOURCE 500

#include <stdio.h>
#include <stdlib.h>
#include <ftw.h>

int callback(const char *path, const struct stat *finfo, int flag, struct FTW *ftw);
void exit_sys(const char *msg);

int main(int argc, char *argv[])
{
    int result;

    if (argc != 2) {
        fprintf(stderr, "wrong number of arguments!..\n");
        exit(EXIT_FAILURE);
    }

    if ((result = nftw(argv[1], callback, 100, FTW_PHYS)) == -1)
        exit_sys("nftw");

    printf("result = %d\n", result);

	return 0;
} 

int callback(const char *path, const struct stat *finfo, int flag, struct FTW *ftw)
{
    switch (flag) {
        case FTW_DNR:
            printf("%*s%s (cannot read directory)\n", ftw->level * 4, "", path + ftw->base);        
            break;
        case FTW_NS:
            printf("%*s%s (cannot get statinfo)\n", ftw->level * 4, "", path + ftw->base);        
            break;
        default:
            printf("%*s%s\n", ftw->level * 4, "", path + ftw->base);
    }
    
    return 0;
}

void exit_sys(const char *msg)
{
	perror(msg);

	exit(EXIT_FAILURE);
}

/*--------------------------------------------------------------------------------------------------------------------------
    Bir dosyanın hard link'ini programalama yoluyla oluşturabilmek için link isimli POSIX fonksiyonu kullanılmaktadır. Linux sistemlerinde 
    link fonksiyonu doğrudan işletim sisteminin sys_link isimli sistem fonksiyonunu çağırmaktadır. link fonksiyonunun prototipi şöyledir:

    #include <unistd.h>

    int link(const char *oldpath, const char *newpath);

    Fonksiyonun birinci parametresi hard link'i çıkartılacak dosyanın yol ifadesini, ikinci parametresi yeni dizin girişinin ismini belirtmektedir. 
    Tabii prosesin ilgili dizine yazma hakkının olması gerekir. POSIX standartlarına göre bir sembolik bağlantı dosyasının har link'i çıkartılırken 
    bu sembolik bağlantının kendisinin mi yoksa onun hedefinin mi link'inin çıkartılacağı işletim sistemini yazanların isteğine bırakılmıştır. 
    Fonksiyon başarı durumunda 0 değerine, başarıszlık durumunda -1 değerine geri döner ve errno uygun biçimde değer alır.

    Bir dizin'in hard link'inin çıkatılması özyinelemli fonksiyonları sonsuz döngüye sokabilmektedir. Bu nedenle dizinler üzerinde 
    hard link çıkartma şüpheli bir durumdur. POSIX standartları bir dizin'in hard link'ini çıkartılabilmesi için prosesin 
    bunu yapabilecek önceliğe sahip olması gerektiğini (yani etkin kullanıcı id'sinin 0 olması gerektiğini) ve  işletim sisteminin de 
    dizinlerin hard link'lerinin çıkartılabilmesine izin vermesi gerektiğini belirtmektedir. Eskiden Linux sistemleri root prosesler için
    dizinlerin hard link'lerinin çıkartılmasına izin veriyordu. Ancak sonraları bunu da kaldırdı. Yani Linux istemlerinde dizinlerin 
    hard link'leri artık çıkartılamamaktadır.

    Haha öncedne de belirtildiği gibi bir dosyanın hard link'i komut satrında ln komutuyla oluşturulabilmektedir. Tabii aslınd abu program
    link fonksiyonu çağrılarak yazılmıştır. Örneğin

    ln a b
    
    Aşağıdaki örnekte komut satırından verilen bir dosyanın har link'i çıkartılmıştır. 
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>

void exit_sys(const char *msg);

int main(int argc, char *argv[])
{
    if (argc != 3) {
        fprintf(stderr, "wrong number of arguments!..\n");
        exit(EXIT_FAILURE);
    }

    if (link(argv[1], argv[2]) == -1)
        exit_sys("link");

	return 0;
} 

void exit_sys(const char *msg)
{
	perror(msg);

	exit(EXIT_FAILURE);
}

/*--------------------------------------------------------------------------------------------------------------------------
    link fonksiyonunun linkat ismiyle "at"li bir versiyonu da vardır. linkat fonksiyonun prototipi şöyledir:

    #include <fcntl.h>

    int linkat(int fd1, const char *path1, int fd2, const char *path2, int flag);

    Fonksiyonun birinci parametresi ikinci parametresiyle belirtilen yok ifadesi göreli ise aramanın yapılacağı dizinin betimleyicisini alır. 
    Üçüncü parametres ise dörddüncü parametrede belirtilen yol ifadesi göreli ise aramanın yapılacağı dizin'in betimleyicisini almaktadır. 
    Son parametre sembolik bağlantının izlenip inzlenmeyeceğini belirtir. Eğer bu parametre AT_SYMLINK_FOLLOW biçiminde girilirse semboli 
    bağlantı izlenir. Eğer bu parametre 0 girilirse sembolik bağlantı izlenmez. 
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Bir dosyanın sembolik bağlantı dosyası symlink isimli POSIX fonksiyonuyla oluşturulmaktadır. Bu fonksiyon Linux sistemlerinde 
    doğrudan sys_symlink isimli sistem fonksiyonunu çağırmaktadır. Fonksiyonun prototipi şöyledir:

    #include <unistd.h>

    int symlink(const char *path1, const char *path2);

    Foksiyonun birinci parametresi sembolik bağlantısı çıkartılacak dosyanın ypl ifadesini, ikinci parametresi ise sembolik bağlantı dosyasının 
    yol ifadesini alır. Fonksiyon başarı durumunda sıfır değerine, başarıszlık durumunda -1 değerine geri döner. Prptotipten de gördüğünüz 
    gibi sembolik bağlantı dosyasının kendisine ilişkin erişim hakları bizden istenmemektedir. Çünkü sembolik bağlantı dosyasının kendi erişim haklarının 
    bir önemi yoktur. Bu fonksiyon bu erişim hakları için "rwxrwxrwx" haklarını vermektedir. Sembolik bağlantı dosyasını izleyen fonksiyonlar
    hedef dosyanın erişim haklarını dikkate alırlar. Sembolik bağlantı dosyasının kendi erişim haklarının bir önemi yoktur. 

    symlink fonksiyonu ile "dangling" link oluşturulabilmektedir. Yani başka bir deyişle fonksiyonun birinci parametresinde belirtilen 
    dosyanın bulunuyor olması gerekmez.

    Bir POSIX fonksiyonun sembolik bağlantı dosyasını izleyip izlemediğine dikkat ediniz. Şüphe duyarsanız dokğümanlardan bunu doğrulayınız. 
    Örneğin open fonksiyonu sembolik bağlantıyı izlemektedir. Ancak remove ve unlik fonksiyonları sembolik bağalntı dosyalarını izlememektedir. 
    (Yani remove ve unlink ile sembolik bağlantı dosyası silinmeye çalışılırsa bu fonksiyonlar sembolik bağlantı dosyasının kendisini silmektedir.) 
    Genel olarak POSIX fonksiyonlarının büyük bölümü sembolik bağlantı dosyasını izlemektedir. 

    Bir POSIX fonksiyonu "pathname resolution" işlemini yaparken belli sayıdadan fazla sembolik link üzerinden geçilmişse
    döngüsel bir durumun oluştuğunu düşünerek ELOOP özel değeri ile geri dönmektedir. Örneğin:

    a -> b
    b -> a

    Bu duurmda biz "a" dosyasını open fonksiyonuyla açmak istersek fonksiyon başarısız olur ve errno ELOOP değerini alır. 

    Dizin'lerin hard link'lerinin çıkartılması sorunlu bir durum oluşturduğundan yukarı söz etmiştik. Halbuki aynı durum sembolik 
    bağlantılar için geçerli değildir. Yani sıradan bir proses bir dizin'in sembolik bağlantısını oluşturabilmektedir.

    Daha önceden de belirtildiği gibi bir dosyanın sembolik bağlantısı ln -s kabul komutuyla oluşturulabilmektedir. Örneğin:

    ln -s a b

    Burada b sembolik bağlantı dosyası a dosyasını göstermektedir. 

    Aşağıda komut satırından hareketle bir sembolik bağlantı oluşturma örneği verilmiştir. 
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>

void exit_sys(const char *msg);

int main(int argc, char *argv[])
{
    if (argc != 3) {
        fprintf(stderr, "wrong number of arguments!..\n");
        exit(EXIT_FAILURE);
    }

    if (symlink(argv[1], argv[2]) == -1)
        exit_sys("symlink");

	return 0;
} 

void exit_sys(const char *msg)
{
	perror(msg);

	exit(EXIT_FAILURE);
}

/*--------------------------------------------------------------------------------------------------------------------------
    symlink fonksiyonun symlinkat isminde bir de "at"li versyionu vardır:

    #include <fcntl.h>

    int symlinkat(const char *path1, int fd, const char *path2);

    Fonksiyonun ikinci parametresi üçüncü parametresindeki yol ifadesi göreli ise aramanın yapılacağı diziniin betimleyicisini almaktadır.
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Biz lstat fonksiyonuyla bir dosyanın bilgilerini elde ettiğimizde o dosyanın bir sembolik bağlantı dosyası olup olmadığını anlayabiliyorduk. 
    Ancak o sembolik bağlantı dosyasının hangi dosyaya referans ettiğini lstat fonksiyonu bize vermemktedir. İşte readlink 
    isimli POSIX fonksiyonu bu işi yapmaktadır. Fonksiyonun prototipi şöyledir:

    #include <unistd.h>

    ssize_t readlink(const char *path, char *buf, size_t bufsize);

    Fonksiyonun birinci parametresi sembolik bağlantı dosyasının yol ifadesini belirtir. İkinci ve üçüncü parametreler 
    sembolik bağlantı dosyasının referans ettiği dosyanın yol ifadesinin yerleştirileceği yerin adresini ve uzunluğu almaktadır. 
    Bu alan küçük ise fonksiyon başarısız olmaz ancak yol ifadesinin son kısmı budanır. Fonksiyon verdiğimiz adrese yerleştirdiği 
    karakter sayısına geri dönmektedir. Foksiyon (diğer fonksiyonların aksine) null karakteri dizinin sonuna yerleştirmez. 
    Bu durumda programcı referans edilen yol ifadesine erişirken dikkat etmelidir. 

    Fonksiyon başarı durumunda yerleştirilen karakter sayısına, başarısızlık durumunda -1 değeirne geriğ dönmektedir.

    Aşağıda readlink fonksiyonun kullanımına bir örnek verilmiştir. readlink fonksiyonunun null karakteri diziye yerleştirmediğine dikkat ediniz.
    Sonunda null karakter olmayan result uzunlukta bir yazının printf ile bastırılması şöyle yapılabilir:

    printf("%.*s\n, result, buf);

    printf "%.10s" gibi bir format karakterlerinde yazıyı null karakter görene kadar değil n karakter yazdırmaktadır. (Örneğimizde 10).
    Tabii biz burada istersek null karakteri dizinin sonuna yerleştirip onu normak olarak yazdırabiliriz. Ancak bu durumda da dizi uzunluğunun yeterli 
    olduğuna dikkat etmemiz gerekir. 

    Aşağıdaki örnekte biz yoli fadesinin yerleştirileceği diziyi 4096 + 1 eleman uzunluğunda açtık. Lşnux sistemlerinde x86 ve x64 mimarilerinde 
    (sayfa uzunluğunun 4K olduğu mimarilerde) yol ifadeleri en fazla 4096 karakter olabilmektedir. Ancak diğer mimarilerde ve POSIX genelinde
    böyle bir zorunluluk yoktur. O sistemdeki makismum yol ifadesi uzunluğu <limits.h> dosyası içerisindeki PATH_MAX sembolik sabitiyle 
    belirtilmektedir. Ancak maalesef bu sembolik sabitin define edilmiş olması da zorunlu değildir. Bu konunun biraz ayrıntıları olduğu için 
    konu bir başlık altında ileride ele alınacaktır.

    Aşağıdaki örnekte yol ifadesi tam olarak 4096 karakter de olabilir. Ya da daha uzun olup budanmış da olabilir. Bu tür durumlarda tavsiye edilen 
    diziyi büyütüp fonksiyonu başarılı olan kadar tekrar tekrar çağırmaktır. Ancak bir yol ifadesinin 4096 karakterden büyük olması 
    çok çok uç bir noktadır. 
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>

void exit_sys(const char *msg);

int main(int argc, char *argv[])
{
    char buf[4096 + 1];
    ssize_t result;

    if (argc != 2) {
        fprintf(stderr, "wrong number of arguments!..\n");
        exit(EXIT_FAILURE);
    }    

    if ((result = readlink(argv[1], buf, 4096)) == -1)
        exit_sys("readlink");

    printf("result = %lld\n", (long long)result);

    
    if (result < 4096) {        
        buf[result] = '\0';     /* alternatifi -> printf("%.*s\n", (int)result, buf); */
        puts(buf);
    }
    else 
        fprintf(stderr, "path maybe truncated!..\n");
    
	return 0;
} 

void exit_sys(const char *msg)
{
	perror(msg);

	exit(EXIT_FAILURE);
}

/*--------------------------------------------------------------------------------------------------------------------------
                                            19. Ders 24/12/2022 - Pazar
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    access isimli POSIX fonksiyonu bir dosyaya okuma, yazma, çalıştırma gibi erişimlerin mümkün olup olmadığı bilgisini bize vermektedir. 
    Fonksiyonun prototipi şöyledir:

    #include <unistd.h>

    int access(const char *path, int amode) 

    Fonksiyonun birinci parametresi erişim testinin yapılacağı dosyanın yol ifadesini belirtmektedir. İkinci parametresi test edilecek 
    erişimi belirtir. Bu parametre aşağıdaki sembolik sabitlerin bir düzeyinde OR'lanmasıyla oluşturulabilir:

    R_OK: Okuma yapılabilir mi?
    W_OK: Yazma yapılabilir mi?
    X_OK: Çalıştırılabilir mi?
    F_OK: Dosya var mı?

    access fonksiyonuyla ilgili iki önemli nokta vardır. Birincisi access fonksiyonu test işleminde prosesin etkin kullanıcı id'sini ve
    grup id'sini değil gerçek kullanıcı id'sini ve grup id'sini işleme sokar. Her ne kadar prosesin gerçek kullanıcı ve grup id'leri çoğu kez 
    etkin kullanıcı id'leri ve grup id'leri ile aynı olsa da bazen farklılaşabilmektedir. İkinci durum ise, access ile bir test yapıldıktan sonra 
    bu teste dayalı olarak dosya üzerinde işlem yapılmak istendiğinde bu işlemin başarılı olması garanti değildir. Çünkü o arada
    sistemdeki başka bir proses dosyanın erişim hakları üzerinde değişiklik yapmış olabilir. 

    access fonksiyonu test olumluysa 0 değerine olumsuzsa -1 değerine geri dönmektedir. Tabii access fonksiyonun başarısızlığının başka nedenleri de olabilir. 
    Ancak programcı genellikle öyle ya da böyle istediği işlemi yapıp yapamayacağı ile ilgilenmektedir. Ancak yine de fonksiyon başarısız olduğunda 
    errno değeri incelenebilir ve başarısızlığın EACCESS nedenyiyle olduğu doğrulanabilir. Biz aşağıdaki örnekte bu yola gitmiyoruz. 
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>

void exit_sys(const char *msg);

int main(int argc, char *argv[])
{
    if (argc != 2) {
        fprintf(stderr, "wrong number of arguments!..\n");
        exit(EXIT_FAILURE);
    }   

    if (access(argv[1], F_OK) == 0)
        printf("file exists...\n");
    else {
        printf("file doesn't exist!..\n"); 
        exit(EXIT_SUCCESS);
    }
    if (access(argv[1], R_OK) == 0)
        printf("read access ok...\n");
    else
        printf("can't read...\n");

    if (access(argv[1], W_OK) == 0)
        printf("write access ok...\n");
    else 
        printf("can't write...\n");
    
    if (access(argv[1], X_OK) == 0)
        printf("execute access ok\n..");
    else 
        printf("can't execute..\n");

	return 0;
} 

void exit_sys(const char *msg)
{
	perror(msg);

	exit(EXIT_FAILURE);
}

/*--------------------------------------------------------------------------------------------------------------------------
    access fonksiyonunun GNU libc kütüphanesinde prosesin etkin kullanıcı is'sini ve etkin grup id'sini kullanarak test eden 
    euidaccess ve eaccess (ikisi aynı şeyi yapmaktadır) versiyonları da bulunmaktadır. Ancak bu iki fonksiyon POSIX standartlarında 
    yoktur. Dolayısıyla taşınabilir programlar için bu konuya dikkat edilmesi gerekir. 

    #define _GNU_SOURCE             /* See feature_test_macros(7) */
    #include <unistd.h>

    int euidaccess(const char *pathname, int mode);
    int eaccess(const char *pathname, int mode);

    Bu fonksiyonların semantiği etkin kullanıcı id'sini ve grup id'sini kullanmalarının dışında bir farklık içermemektedir. 
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    access fonksiyonunun faccassat isminde "at"li bir versiyonu da vardır. Bu versyonda aynı zamanda istenirse gerçek kullanıcı ve 
    grup id'leri yerine etkin kullanıcı ve grup id'leri de işleme sokulabilmektedir. Fonksiyonun parametrik yapısı şöyledir:

    #include <fcntl.h>

    int faccessat(int fd, const char *path, int amode, int flag);

    Fonksiyonun birinci paraetresi ikinci parametresiyle belirtilen yol ifadesinin göreli olması durumunda aramanın yapılacağı 
    dizini belirtmektedir. Son parametre 0 geçilebilir ya da AT_EACCESS geçilebilir. Bu AT_EACCESS değeri test işleminin etkin kulalnı ve grup 
    id'lerine bakılarak yapılacağı anlamına gelmektedir. (Tabii ikinci parametre ile belirtilen yol ifadesi mutlak olduğunda birinci parametrede 
    belirtilen dizine ilişkin betimleyici yine dikkate alınmaz. Ancak üçüncü parametreyle belirtilen bayrak dikkate alınır)
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <fcntl.h>
#include <unistd.h>

void exit_sys(const char *msg);

int main(int argc, char *argv[])
{
    int fd;

    if (argc != 2) {
        fprintf(stderr, "wrong number of arguments!..\n");
        exit(EXIT_FAILURE);
    }   

    if (faccessat(AT_FDCWD, argv[1], F_OK, AT_EACCESS) == 0)
        printf("file exists...\n");
    else {
        printf("file doesn't exist!..\n"); 
        exit(EXIT_SUCCESS);
    }
    if (faccessat(AT_FDCWD, argv[1], R_OK, AT_EACCESS) == 0)
        printf("read access ok...\n");
    else
        printf("can't read...\n");

    if (faccessat(AT_FDCWD, argv[1], W_OK, AT_EACCESS) == 0)
        printf("write access ok...\n");
    else 
        printf("can't write...\n");
    
    if (faccessat(AT_FDCWD, argv[1], X_OK, AT_EACCESS) == 0)
        printf("execute access ok\n..");
    else 
        printf("can't execute..\n");

	return 0;
} 

void exit_sys(const char *msg)
{
	perror(msg);

	exit(EXIT_FAILURE);
}

/*--------------------------------------------------------------------------------------------------------------------------
    Anımsanacağı gibi "dosya betimleyici tablosu (file descriptor table)" proses kontrol blok yoluyla erişilebilen dosy anesnelerinin 
    adresleerinin tutulduğu bir gösterici dizisi biçimindeydi. İşletim sisteminin çekirdeği ne zaman bir dosya açılsa o dosya için
    bir dosya nesnesi (Linux'ta "file" yapısı) yaratıp dosya betimleyici tablosunda bir slotun o nesneyi göstermesini sağlıyordu. 
    Zaten "dosya betimleyicisi (file descriptor)" de dosya betimleyici tablosunda bir indeks belirtiyordu. Linux çekirdeklerinde 
    buradak veri yapıları zamanla biraz değiştirilmiştir. Güncel çekirdekte proses kontrol bloktan dosya nesnesine erişim birkaç yapıdan geçilerek 
    yapılmaktadır:

    task_struct (files) ---> files_struct (fdt) ---> fdtable (fd) --->  file * türünden bir dizi ---> file

    Genellikle bir proses çalışmaya başladığında ilk üç betimleyici doludur. Bu betimleyicilere sırasıyla "stdin", "stdout" ve "stderr"
    betimleyicileri denilmektedir. Bu ilk üç betimleyici için <unistd.h> dosyasında üç sembolik de bulundurulmuştur:

    #define STDIN_FILENO        0
    #define STDOUT_FILENO       1
    #define STDERR_FILENO       2

    Aygıt "sürücüler (device drivers)" dosya gibi açılarak kullanılmaktadır. (Yani bir aygıt sürücü de kullanılmadan önce "open" fonksiyonuyla açılır, 
    sonra "read" fonksiyonuyla ondan okuma yapılıp "write" fonksiyonu ile ona yazma yapabilir.) Dolayısıyla bir dosya nesnesi bir disk dosyasına ilişkin olabileceği gibi 
    bir aygıt sürücüs dosyasına da ilişkin olabilir. Örneğin biz bir betimleyiciden read fonksiyonu ile okuma yapmak istediğimizde 
    sistem eğer bu betimleyicinin gösterdiği dosya nesnesi bir disk dosyasına ilişkinse bizim dosyadan okuma yapmamızı sağlar. Ancak bir 
    aygıt sürücüye ilişkinse bu durumda sistem o aygıt sürücünün "read" fonksiyonunu çağırır. Yani aygıt sürücülerin içerisinde 
    "read" yapıldığında "write" yapıldığında çağrılacak fonksiyonlar vardır. İşte örneğin biz 0 numaralı betimleyiciden okuma yapmak istediğimizde aslında 
    "terminal aygıt sürücüsünün" "read" fonksiyonu çağrılmaktadır. 0 numaralı betimleyici O_RDONLY modunda açılmıştır. Terminal aygıt sürücüsünün
    "read" fonksiyonu da bize klavyeden okunanları verir. Program çalışmaya başladığında 1 ve 2 numları betimleyicilerin her ikisi de aynı dosya nesnesini göstermektedir. 
    Bu dosya da O_WRONLY modunda açılmıştır. Bu dosya nesneleri de yine "terminal aygıt sürücüsüne" ilişkindir. Dolayısıyla biz write işlemi yaptığımızda
    aslında terminal aygıt sürücüsünün "write" fonksiyonunu çağırmış oluruz. O da bilgileri imlecin bulunduğu noktadan itibaren ekrana yazar. 
    Burada stdout ve stderr betimleyicilerinin aynı dosya nesnesini gösterdiğine dikkat ediniz. Dolayısıyla bu betimleyiciler kullanıldığında yazdırılmak istenen 
    şeyler ekrana çıkacaktır. (O halde stdout ile stderr arasında ne farklılık vardır? İzleyen bölümlerde bu durum açıklanacaktır)

    open fonksiyonunun ilk boş betimleyici veridiği garanti edilmiştir. Yani örneğin programımız başladığında 0, 1 ve 2 numaralı betimleyiciler dolu olduğuna
    göre open fonksiyonu bize 3 numaralı betimleyiciyi vercektir. Tabii dosyaları kapattığımızda o betimleyicilere ilişkin slot'lar serbest bırakılır. 
    Bu durumda open ilk boş betimleyiciyi bize verir. 
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Dosya betimleyici tablosunda iki dosya betimleyicisi aynı dosya nesnesini gösteriyorsa bu duruma "dosya betimleyicilerinin 
    çiftlenmiş (duplicate) olması" denilmektedir. Bu durumda bizim bu betimleyicilerden hangisini kullandığımız bir önemi kalmamaktadır. 
    Pekiyi böyle bir durumda bir betimleyiciyi close fonksiyonuyla kapattığımızda ne olacaktır? İşte dosya nesnelerinin içerisinde 
    bir sayaç bulunmaktadır. close fonksiyonu bu sayacın değerini bir eksiltir. Dosya nesnesinin silinmesi sayaç 0'a düştüğünde
    yapılmaktadır. O halde close her durumda betimleyici slotunu boşaltır. Ancak dosya nesnesinin referans sayıcını bir eksilttikten sonra
    eğer referans sayacı 0'a düşmüşse dosya nesnesini siler. Aşağıda Linux'un güncel çekirdeğindeki dosya nesnesi verilmiştir. 
    Buradaki f_count elemanı bu sayacı belirtmektedir:
    
    struct file {
        union {
            struct llist_node	f_llist;
            struct rcu_head 	f_rcuhead;
            unsigned int 		f_iocb_flags;
        };
        struct path		f_path;
        struct inode		*f_inode;	/* cached value */
        const struct file_operations	*f_op;

        /*
        * Protects f_ep, f_flags.
        * Must not be taken from IRQ context.
        */
        spinlock_t		f_lock;
        atomic_long_t		f_count;
        unsigned int 		f_flags;
        fmode_t			f_mode;
        struct mutex		f_pos_lock;
        loff_t			f_pos;
        struct fown_struct	f_owner;
        const struct cred	*f_cred;
        struct file_ra_state	f_ra;

        u64			f_version;
    #ifdef CONFIG_SECURITY
        void			*f_security;
    #endif
        /* needed for tty driver, and maybe others */
        void			*private_data;

    #ifdef CONFIG_EPOLL
        /* Used by fs/eventpoll.c to link all the hooks to this file */
        struct hlist_head	*f_ep;
    #endif /* #ifdef CONFIG_EPOLL */
        struct address_space	*f_mapping;
        errseq_t		f_wb_err;
        errseq_t		f_sb_err; /* for syncfs */
    };

---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Bir betimleyicinin gösterdiği dosya nesnesini gösteren yeni bir betimleyici oluşturulabilir. Bunun için dup ve dup2 
    isimli POSIX fonksiyonları kullanılmaktadır. dup fonksiyonunun prototipi şöyledir:

    #include <unistd.h>

    int dup(int fildes);

    Fonksiyon parametre olarak açık bir dosyanın betimleyicisini alır, o betimleycinin gösterdği dosya nesnesini gösteren yeni bir betimleyici 
    oluşturup o betimleyiciye geri döner. Fonksiyon başarısızlık durumunda -1'e geri dönmektedir. dup fonksiyonunun en düşük boş betimleyici
    slotunu tahsis etmesi garanti edilmiştir. 

    Açık dosyanın tüm bilgileri dosya nesnesinin içerisinde olduğuna göre iki betimleyici aynı dosya nesnesini gösteriyorsa 
    örneğin aynı dosya göstericisine sahip gibi davranırlar. Aşağıdaki programda dup fonksiyonuna bir örnek verilmiştir. 
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <fcntl.h>
#include <unistd.h>

void exit_sys(const char *msg);

int main(void)
{
    int fd;
    int fd2;
    char buf[10 + 1];
    ssize_t result;

    if ((fd = open("sample.c", O_RDONLY)) == -1)
        exit_sys("open");

    if ((fd2 = dup(fd)) == -1)
        exit_sys("dup");

    if ((result = read(fd, buf, 10)) == -1)
        exit_sys("read");
    buf[result] = '\0';

    puts(buf);

    if ((result = read(fd2, buf, 10)) == -1)
        exit_sys("read");
    buf[result] = '\0';

    puts(buf);

    close(fd2);
    close(fd);

	return 0;
} 

/*--------------------------------------------------------------------------------------------------------------------------
    dup2 isimli POSIX fonksiyonu dup fonksiyonunun biraz daha ayrıntılı biçimidir. Fonksiyonun prototipi şöyledir:

    #include <unistd.h>

    int dup2(int fildes, int fildes2);

    Bu fonksiyon yine birinci parametresiyle belirtilen betimleyici çiftlemek için kullanılmaktadır. Ancak bu fonksiyon
    ilk boş betimleyici ile değil ikinci parametresiyle belirtilen betimleyici ile geri dönmek ister. Yani biz istersek 
    bu fonksiyon sayesinde istediğimiz bir betimleyicinin birinci parametresiyle belirtilen betimleyici ile aynı dosya nesnesini 
    göstermesini sağlayabiliriz. Eğer ikinci parametresiyle belirtilen betimleyici zaten açık bir dosyaya ilişkinse bu durumda dosya 
    önce kapatılır, sonra o betimleyicinin birinci parametresiyle belirtilen betimleyciin gösterdiği dosya nesnesini göstermesi 
    sağlanır. Fonksiyon başarı durumunda ikinci parametresiyle belirtilen betimleyicinin aynısına başarısızlık durumunda -1 değerine
    geri dönmektedir. Tabii fonksiyon birinci ve ikinci parametresinin aynı betimleyiciye ilişkin olduğunu da kontrol etmektedir. 
    Bu durumda bir şey yapmadan başarılı olur. Fonksiyonun iki argümanı aynı betimleyiciyi belirtiyorsa dup2 hiçbir şey yapmaz, argümanlarla
    belirtilen betimleyiciye geri döner.

    Aşağıda dup2 fonksiyonunun kullanımına bir örnek verilmiştir. 
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <fcntl.h>
#include <unistd.h>

void exit_sys(const char *msg);

int main(void)
{
    int fd;
    int fd2;
    char buf[10 + 1];
    ssize_t result;

    if ((fd = open("sample.c", O_RDONLY)) == -1)
        exit_sys("open");

    if ((fd2 = dup2(fd, 25)) == -1)
        exit_sys("dup");

    printf("fd = %d, fd2 = %d\n", fd, fd2);
    
    if ((result = read(fd, buf, 10)) == -1)
        exit_sys("read");
    buf[result] = '\0';

    puts(buf);

    if ((result = read(fd2, buf, 10)) == -1)
        exit_sys("read");
    buf[result] = '\0';

    puts(buf);

    close(fd2);
    close(fd);

	return 0;
} 

void exit_sys(const char *msg)
{
	perror(msg);

	exit(EXIT_FAILURE);
}

/*--------------------------------------------------------------------------------------------------------------------------
                                            20. Ders 07/01/2023 - Cumartesi
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Dosyalar konusundaki önemli bir alt konu da "IO Yönlendirmesi (IO Redirection)" denilen konudur. IO yönlendirmesi teknik olarak
    bir dosya betimleyicisinin gösterdiği dosya nesnesinin değiştirilmesi işlemidir. Bu sayede bir kişi belli bir dosya üzerinde 
    işlem yaptığını sanırken aslında başka bir dosya üzerinde işlem yapar hale gelmektedir. IO yönlendirmesi en çok "stdin", "stdout" ve
    "stderr", dosyaları üzerinde uygulanmaktadır. 
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Anımsanacağı gibi bir proses yaratıldığında genellikle işin başında 0, 1 ve 2 numaralı betimleyiciler zaten dolu durumdadır. 
    UNIX/Linux dünyasında 0 numaralı betimleyiciye "stdin" betimleyicisi, "1 numaralı betimleyiciye "stdout" betimleyicisi ve 
    2 numaralı betimleyiciye ise "stderr" betimleyicisi denilmektedir. Bir dosya betimleyicisinin gösterdiği dosya nesnesi 
    bir disk dosyasına ilişkin olabileceği gibi bir "aygıt sürücü (device driver)" dosyasına ilişkin de olabilmektedir. 
    Gerçekten de 0, 1 ve 2 numaralı betimnleyicilerin gösterdiği dosya nesneleri "terminal aygıt sürücüsüne" ilişkindir. 

    Bir aygıt sürücü kernel modda çalışan bir kod topluluğudur. Bir dosya betimleyicisi bir aygıt sürücüne ilişkinse bu betimleyici 
    ile read fonksiyonu çağrıldığında aygıt sürücüsünü yazanların "read" olarak tanımladıkları fonksiyon çağrılmaktadır. Benzer biçimde
    bir aygıt sürücüne ilişkinse bu betimleyici ile write fonksiyonu çağrıldığında aygıt sürücüsünü yazanların "write" diye tanımladıkları
    fonksiyon çağrılmaktadır. 

    0 numaralı stdin betimleyicisi "read-only" modda açılmış durumdadır. Benzer biçimde 1 ve 2 numaralı betimleyiciler de "write-only"
    modda açılmış durumdadır. 0 numaralı betimleyiciden okuma yapılmak istendiğinde aygıt sürücüsünün okuma fonksiyonu çalıştırılır ve
    bu fonksiyon da aslında klavyeden okunanları bize verir. 1 ve 2 numaralı betimleyiciler dup yapılmış durumdadır. Yani bu betimleyiciler 
    aynı dosya nesnesini göstermektedir. Bu betimleyicilerle yazma işlemi yapılırsa aygıt sürücülerin yazma fonksiyonları devreye girer
    ve bu fonksiyonlar da yazdırılacak şeyleri ekrana çıkartırlar. 

    Görüldüğü gibi aygıt sürücüler sanki bir dosyaymış gibi ele alınmaktadır. Bunun önemli faydaları vardır. Yani programcı bu sayede
    "sanki klavye ve ekran birer dosyaymış gibi" dosya fonksiyonlarını kullanarak onlarla işlem yapabilmektedir.  

    Aşağıdaki örnekte 0 numaralı stdin betimleyicisinden read fonksiyonuyla okuma yapılmış ve okunanlar 1 numaralı stdout 
    betimleyicisine yazılmıştır. Biz read fonksiyonuyla stdin dosyasından okuma yapmak istediğimizde read fonksiyonu ENTER tuşuna basılına
    kadarki klavyeden girilenleri bize vermektedir.

    <unistd.h> dosyasında okunabilirliği artırmak için şu sembolik sabitler bildirilmiştir:

    #define STDIN_FILENO        0
    #define STDOUT_FILENO       1
    #define STDERR_FILENO       2

    Bir program çalışmaya başladığında 0, 1 ve 2 numaralı betimleyiciler zaten hazır durumdadır. Bu betimleyicileri programcı oluşturmamıştır.
    O halde bu betişmleyicilerin kapatılmasını da programcı yapmamalıdır. Buradaki mekanizma ileride ele alınacaktır.

---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
 
void exit_sys(const char *msg);

int main(void)
{
    char buf[4096];
    ssize_t result;

    if ((result = read(0, buf, 4096)) == -1)
        exit_sys("read");

    if (write(1, buf, result) == -1)
        exit_sys("write");

    return 0;
}

void exit_sys(const char *msg)
{
	perror(msg);

	exit(EXIT_FAILURE);
}

/*--------------------------------------------------------------------------------------------------------------------------
    C'nin <stdio.h> dosyası içerisinde prototipleri bulunan stdin ve stdout dosyaları üzerinde işlem yapan "scanf", "puts", 
    "printf" gibi fonksiyonları eninde sonunda read ve write fonksiyonlarını 0 ve 1 numaralı betimleyicilerle çağırarak işlemlerini 
    yapmaktadır. Zaten bu sistemlerde ekrana bir şey yazdırmak için klavyeden bir şey okumak için başka bir yol yoktur. Örneğin 
    biz printf fonksiyonu ile ekrana bir şeyler yazdırmak istediğimiz zaman aslında printf önce yazdırılacak yazıyı bir dizide oluşturur
    sonra write fonksiyonunu 1 numaralı betimleyici ile çağırır. 
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Aşağıdaki örnekte biz close(1) ile 1 numaralı betimleyicinin gösterdiği terminal aygıt sürücüsüne ilişkin dosyayı kapattık. 
    Sonra da open fonksiyonu ile yeni bir dosyayı açtık. open fonksiyonu en düşük boş betimleyiciyi vereceğine göre artık 
    1 numaralı betimleyici terminal aygıt sürücüne ilişkin dosya nesnesini değil bizim açtığımız dosya nesnesini gösteriyor
    durumda olacaktır. Daha bu örnekte biz printf fonksiyonu ile ekrana bir şeyler yazdık. printf eninde sonunda write(1, ...)
    çağrısıyla ekrana bir şeyler yazdırmak isteyeceğine göre artık printf ekrana değil bizim açtığımız dosyaya yazma yapacaktır. 
    IO yönlendirmesinin temel mekanizması bu biçimdedir. 
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <fcntl.h>
#include <sys/stat.h>
#include <unistd.h>

void exit_sys(const char *msg);

int main(void)
{
    int fd;

    close(1);

    if ((fd = open("test.txt", O_WRONLY|O_CREAT|O_TRUNC, S_IRUSR|S_IWUSR|S_IRGRP|S_IROTH)) == -1)
        exit_sys("open");

    for (int i = 0; i < 10; ++i)
        printf("Number: %d\n", i);

    return 0;
}

void exit_sys(const char *msg)
{
	perror(msg);

	exit(EXIT_FAILURE);
}

/*--------------------------------------------------------------------------------------------------------------------------
    IO yönlendirmesinin yukarıdaki gibi yapılmasının iki önemli problemi vardır:

    1) Bu yönlendirme aynı biçimde yüksek numaralı betimleyiciler için yapılmak istenirse o betimleyicilerden önce boş boş 
    betimleyicilerin bulunuyor olma olasılığı yükselir. Dolayısıyla open istediğimiz betimekyciyi değil başka bir betimleyiciyi 
    tahsis edebilir. 

    2) Çok thread'li programlarda close işleminden sonra henüz open yapılmadan önce başka bir thread dosya açarsa bu betimleyiciyi 
    o thread kapabilir. Çünkü close ile open işlemleri atomik değildir. 

    IO yönlendirmesi daha sağlıklı bir biçimde dup2 fonksiyonuyla yapılabilir. Anımsanacağı gibi dup2(fd1, fd2) işleminde 
    fd2 betimleyicisi fd1 betimleyicisi ile aynı dosya nesnesini gösterir hale getirilmektedir. fd2 zaten açık bir dosyaya ilişkinse
    önce o betimleyici üzerinde atomik bir biçimde close işlemi uygulanmaktadır. dup2 fonksiyonun en düşük betimleyiciyi değil ikinci parametresiyle
    blirtilen betimleyiciyi yönlendirdiğine dikkat ediniz. O halde örneğin 1 numaralı betimleyici şöyle yönlendirilebilir:

    int fd;
    ...

    if ((fd = open("test.txt", O_WRONLY|O_CREAT|O_TRUNC, S_IRUSR|S_IWUSR|S_IRGRP|S_IROTH)) == -1)
        exit_sys("open");

    if (dup2(fd, 1) == -1)
        exit_sys("dup2");

    close(fd);

    Burada dup2 ile birlikte hem 1 numaralı betimleyicinin hem de fd numaralı betimleyicinin yeni açılan dosyaya ilişkin dosya nesnesini gösteridiğine
    dikkat ediniz. fd betimleyicisini kapatmak doğru tekniktir. 1 numaralı betimleyici zaten ileride de ele alınacağı gibi proses bittiğinde kapatılmaktadır.

    Burada gerçekleşmesi beklenmeyen bir küçük nokta üzerinde de durmak istiyoruz. Bizim open fonksiyonuyla yönlendirilecek dosyayı
    açtığımız durumda ya stdout dosyası zaten katapılmışsa ne olacaktır? İşte bu durumda close işlemi bizim için sorun oluşturur. Şöyle ki 
    Bu durumda open fonksiyonu en düşük betimleyici olan 1 numaralı betimleyiciyi tahsis edecektir. dup2(fd, 1) çağrısında her iki betimleyici de
    aynı olduğu için dup2 bir şey yapmayacaktır. Ancak bundan sonda fd betimleyicisinin kapatılması aslında 1 numaralı betimleyicinin 
    kapatılması anlamına gelecektir. Yani sakıncalı bir durum oluşaçaktır. Bu sakıncalı durum aşağıdaki gibi bir kontrolle elimine edilebilir:


    int fd;
    ...

    if ((fd = open("test.txt", O_WRONLY|O_CREAT|O_TRUNC, S_IRUSR|S_IWUSR|S_IRGRP|S_IROTH)) == -1)
        exit_sys("open");
    if (fd != 1) {
        if (dup2(fd, 1) == -1)
            exit_sys("dup2");
        close(fd);
    }

    Tabii programcının genellile böyle bir kontrol yapmasına gerek yoktur. Çünkü içinde bulunduğu durumda 1 numaralı betimleyicinin 
    stdout dosyasını göstermesi normal bir durumdur. 

---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <fcntl.h>
#include <sys/stat.h>
#include <unistd.h>

void exit_sys(const char *msg);

int main(void)
{
    int fd;

    if ((fd = open("test.txt", O_WRONLY|O_CREAT|O_TRUNC, S_IRUSR|S_IWUSR|S_IRGRP|S_IROTH)) == -1)
        exit_sys("open");

    if (fd != 1) {              /* kontrol özel bir durum yoksa gerekmemektedir */
        if (dup2(fd, 1) == -1)
            exit_sys("dup2");

        close(fd);
    }

    for (int i = 0; i < 10; ++i)
        printf("Number: %d\n", i);

    return 0;
}

void exit_sys(const char *msg)
{
	perror(msg);

	exit(EXIT_FAILURE);
}

/*--------------------------------------------------------------------------------------------------------------------------
    Yukarıdaki örnekte biz 1 numaralı betimleyicinin bizim dosyamıza ilişkin dosya nesnesini göstermesini sağladık. Pekiyi 
    bundan geri dönebilir miyiz? Yani 1 numaralı betimleyicinin yeniden terminale ilişkin aygıt sürücüsünü göstermesini sağlayabilir miyiz?
    Anımsanacağı gibi 1 ve 2 numaralı betimleyicilerin her ikisi de terminal aygıt sürücüsüne ilişkin dosya nesnesini belirtiyordu.
    İşte biz bu sayede geri dönüşü aşağıdaki gibi yapabiliriz:

    int fd;

    if ((fd = open("test.txt", O_WRONLY|O_CREAT|O_TRUNC, S_IRUSR|S_IWUSR|S_IRGRP|S_IROTH)) == -1)
        exit_sys("open");

    if (dup2(fd, 1) == -1)
        exit_sys("dup2");

    close(fd);
    
    .....

    if (dup2(2, 1) == -1)
        exit_sys("dup2");

    Aşağdaki örnekte bu işlem uygulanmıştır. Ancak burada bir fflush çağırması da yapılmıştır. Bunun nedeni izleyen konularda
    anlaşılabilecektir.
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <fcntl.h>
#include <sys/stat.h>
#include <unistd.h>

void exit_sys(const char *msg);

int main(void)
{
    int fd;

    if ((fd = open("test.txt", O_WRONLY|O_CREAT|O_TRUNC, S_IRUSR|S_IWUSR|S_IRGRP|S_IROTH)) == -1)
        exit_sys("open");

    if (dup2(fd, 1) == -1)
        exit_sys("dup2");

    close(fd);

    for (int i = 0; i < 10; ++i)
        printf("Number: %d\n", i);
        
    fflush(stdout);

    if (dup2(2, 1) == -1)
        exit_sys("dup2");

    for (int i = 0; i < 10; ++i)
        printf("Number: %d\n", i);

    return 0;
}

void exit_sys(const char *msg)
{
	perror(msg);

	exit(EXIT_FAILURE);
}

/*--------------------------------------------------------------------------------------------------------------------------
    Pekiyi yukarıdaki örnekte 2 numaralı betimleyici bir biçimde yönlendirilmişse ya da close edilmişse geri dönüş nasıl sağlanabilir?
    Burada artık işleme başlamadan önce dup işlemi ile 1 numaralı betimleyicinin gösterdiği dosya nesnesini gösteren başka bir 
    yedek betimleyicinin oluşturulması gerekir. Aşağıda bu duruma örnek verilmiştir.
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <fcntl.h>
#include <sys/stat.h>
#include <unistd.h>

void exit_sys(const char *msg);

int main(void)
{
    int fd, fd_stdout;

    close(2);

    if ((fd = open("test.txt", O_WRONLY|O_CREAT|O_TRUNC, S_IRUSR|S_IWUSR|S_IRGRP|S_IROTH)) == -1)
        exit_sys("open");

     if ((fd_stdout = dup(1)) == -1)
        exit_sys("dup2");

    if (dup2(fd, 1) == -1)
        exit_sys("dup2");

    close(fd);

    for (int i = 0; i < 10; ++i)
        printf("Number: %d\n", i);

    fflush(stdout);

    if (dup2(fd_stdout, 1) == -1)
        exit_sys("dup2");

    for (int i = 0; i < 10; ++i)
        printf("Number: %d\n", i);

    return 0;
}

void exit_sys(const char *msg)
{
	perror(msg);

	exit(EXIT_FAILURE);
}

/*--------------------------------------------------------------------------------------------------------------------------
    Şimdi de 0 numaralı betimleyiciyi yönlendirelim. Eğer biz 0 numaralı betimleyiciyi bir dosyaya yönlendirirsek bu durumda 
    kalvyeden (stdin dosyasından) okuma yaptığını sanan standart C fonksiyonları aslında bu dosyadan okuma yapacaktır. Yani adeta 
    sanki bu dosyanın içindekiler klavyeden girilmiş gibi bit etki oluşturacaktır. Aşağıdaki örnekte "test.txt" dosyasının içeriği şöyledir:

    10 20
    30 40
    50
    60
    70
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <fcntl.h>
#include <sys/stat.h>
#include <unistd.h>

void exit_sys(const char *msg);

int main(void)
{
    int fd;
    int val;

    if ((fd = open("test.txt", O_RDONLY)) == -1)
        exit_sys("open");

    if (fd != 0) {                  /* özel bir durum yoksa  bu kontrole gerek yok */
        if (dup2(fd, 0) == -1)
            exit_sys("dup2");
        close(fd);
    }

    while (scanf("%d", &val) == 1)
        printf("%d\n", val);

    return 0;
}

void exit_sys(const char *msg)
{
	perror(msg);

	exit(EXIT_FAILURE);
}

/*--------------------------------------------------------------------------------------------------------------------------
    IO yönlendirmesi kabuk üzerinden de yapılabilmektedir. Kabukta ">" sembolü 1 numaralı betimleyicinin yönlendirileceği anlamına gelmektedir. Örneğin:

    ./sample > test.txt

    Bu durumda kabuk önce ">" sembolünün sağındaki dosyayı O_WRONLY|O_TRUNC modunda açar. Sonra ./sample programını çalıştırarak bu 
    prosesin 1 numaralı betimleyicisini dup2 fonksiyonu ile bu dosyaya yönlendirir. Böylece ./sample sample programının ekrana yazdığını
    zannettiği ieşyle bu dosyaya yazılmış olacaktır. 

    ls gibi, cat gibi kabuk komutlarının da aslında birer program olduğuna bunların da 1 numaralı betimleyiciyi kullanarak yazdırma 
    yaptığına dikkat ediniz. Örneğimn biz kabuk üzerinde şu komutu uygulayabiliriz:

    ls -l > test.txt

    Eğer kabulta ">" yerine ">>" sembolü kullanılırsa bu durumda ">>" sembolünün sağındaki dosya O_CREAT|O_WRONLY|O_APPEND modunda 
    açılmaktadır. Yani dosya varsa bu durumda olan dosyanın sonuna ekleme yapılacaktır. Örneğin:
    
    ls -l >> test.txt
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Kabuk üzerinde "<" sembolü de 0 numaralı betimleyiciyi yönlendirmektedr. Örneğin:

    ./sample < test.txt

    Burada kabuk "test.txt" dosyasını O_RDONLY modda açar. Sonra ./sample programını çalıştırır. Prosesin 0 numaralı betimleyicisini
    "test.txt" dosyasına dup2 fonksiyonuyla yönlendirir. Böylece rpogram sanki klavyeden okuduğunu sanırken aslında dosyadan okuma
    yapacaktır. Aşağıdaki örnekte programın "sample.c" olduğunu kabul edelim. "test.txt" dosyasının içeriği de şöyle olsun:

    10 20
    30 40
    50
    60
    70

    Programı kabultan aşağıdaki gibi çalıştırıp sonucu inceleyiniz:

    ./sample < test.txt
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>

int main(void)
{
    int val;

    while (scanf("%d", &val) == 1)
        printf("%d\n", val);

    return 0;
}

/*--------------------------------------------------------------------------------------------------------------------------
    Aslında kabukta genel olarak yönlendirme için "n>" ve "n<" sembolleri de kullanılabilmektedir. Buradaki n betimleyicinin 
    numarasını belirtir. Bu sayede biz herhangi bir betimleyiciyi okuma ve yazma amaçlı bir dosyaya yönlendirebiliriz. Örneğin:

    ./sample 2> test.txt

    Burada "test.txt" dosyası açılıp ./sample programının "stderr" olarak isimlendirilen 2 numaralı betimleyicisi bu dosyaya 
    yönlendirilecektir. 

    Kabuk programları ">", "<", "n>" "n<" gibi yönlendirmeleri nasıl yapmaktadır? Bu konu ileride ele alınacaktır. Kabuk önce bir kez
    fork işlemi yapar. Sonra yönlendirme işlemini gerçekleştirir. Sonra da exec işlemi yapmaktadır.
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Tabii hem stdout dosyasını hem de stdin dosyasını kabuk üzerinden birlikte de yönlendirebiliriz. Örneğin:

    ./sample > out.txt < in.txt

    Burada 1 numaralı betimleyici "out.txt" dosyasına, 0 numaralı betimleyici "in.txt" dosyasına yönlendirilmiştir.
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Aygıt sürücüler yine open fonksiyonuyla açılmaktadır. open fonksiyonunda aygıt sürücüyü temsil eden bir dizin girişi 
    belirtilie. Örneğin:

    fd = open("/dev/null", O_WRONLY);

    Ancak bu dizin girişi gerçek bir dosya değildir. Bu giriş için yalnızca bir i-node elemanı bulundurulmaktadır. İşletim sistemi 
    böyle bir dosya açılmaya çalışıldığında aslında "bir aygıt sürücü ile işlem yapılmak istendiğini" anlamaktadır. Yani aygıt sürücü
    bir dosya gibi açılıyor olsa da aslında onun bir dosyayla ilgisi yoktur. Aygıt dosyaları (örneğimizdeki "dev/null" dosyası) 
    dummy bir dosyadır. Aslında kernel içerisindeki aygıt sürücüyü temsil etmektedir. 
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Pekiyi stderr dosyası ne anlama gelmektedir? Anımsanacağı gibi stderr 2 numaralı betimleyici ile temsil edilmektedir. 1 ve 2
    numaralı betimleyiciler dup yapılmış durumdadır. Yani her iki betimleyici ile de write yapıldığında yazılanlar ekrana çıkacaktır. 
    O halde stderr dosyasının ne anlamı vardır? 

    C'de stdin, stdout ve stderr isimli değişkenler betimleyici belirtmezler. Bu değişkenler FILE * türündendir. Tabii stdin 
    UNIX/Linuz sistemlerinde 0 numaralı betimleyici ile stdout 1 numaralı betimleyici ile stderr de 2 numaralı betimleyici ile 
    ilişkilidir. Biz C'de stderr dosyasına fprintf fonksiyonu ile aşağıdaki gibi bir şeyler yazabiliriz:

    fprintf(stderr, "stderr\n");

    Tabii aslında bilindiği gibi printf ile fprintf arasında, scanf ile fscanf arasındaki tek farklılık printf ve scanf fonksiyonlarının
    default olarak stdout ve stdin dosya bilgi göstericilerini kullanmasıdır. Yani örneğin printf(...) çağrısı tamamen fprintf(stdout, ...)
    çağrısı eşdeğerdir. Benzer biçimde scanf(...) çağrısı ile de fscanf(stdin, ...) eşdeğerdir.


    Programcı hata mesajlarını her zaman "stderr" dosyasına yazdırmalıdır. Bu iyi bir tekniktir. Örneğin:

    if ((f = fopen("test.txt", "r")) == NULL) {
        fprintf(stderr, "cannot open file!..\n");
        exit(EXIT_FAILURE);
    }

    Böylece ileride gerekirse programın normal çıktılarıyla hata mesajları IO yönlendirmesiyle birbirinden ayrılabilir. Tabii biz 
    IO yönlendirmesi yapmadıktan sonra programın normal mesajlarıyla hata mesajlarının her ikisi de ekrana çıkacaktır. Aşağıdaki gibi bir program olsun:

    /* sample.c */

    #include <stdio.h>

    int main(void)
    {
        fprintf(stderr, "stderr\n");
        fprintf(stdout, "stdout\n");
        
        return 0;
    }

    Biz bu programı çeşitli biçimlerde çalıştıralım:

    parallels@ubuntu-linux-20-04-desktop:~/Study/Unix-Linux-SysProg$ ./sample
    stderr
    stdout
    parallels@ubuntu-linux-20-04-desktop:~/Study/Unix-Linux-SysProg$ ./sample > test.txt
    stderr
    parallels@ubuntu-linux-20-04-desktop:~/Study/Unix-Linux-SysProg$ ./sample 2> test.txt
    stdout

    Görüldüğü gibi biz programın hata mesajları ile normal mesajları artık ayırabilmekteyiz. Eğer her mesayı printf ile stdout dosyasına 
    yazdırsaydık bunun imkanı olmayacaktı.

    Örneğin biz find programı ile "sample.c" dosyasını dizin ağacında aramak isteyelim:

    find / -name "sample.c"

    Burada erişilemeyen dizinler için find programı bir sürü hata mesajını stderr dosyasına yazdırcaktır. Dolayısıyla kafamız
    karışacaktır. Şimdi programı şöyle çalıştıralım:

    find / -name "sample.c" 2> test.txt

    Artık hata mnesajları ekranda görünmeyecektir. Bu tür durumlar için /dev/null isimli bir aygıt sürücü bulundurulmuştur. Bu 
    aygıt sürücü açılırsa ve ona yazma yapılırsa yazılanlar atılmaktadır. O halde programın yazdığı hata mesajları gereksiz yer kaplamasın diye
    biz yönlendirmeyi /dev/null aygıt sürücüsüne yapabiliriz. Örneğin:

    find / -name "sample.c" 2> /dev/null
    
    /dev/null aygıt sürücüsünden okuma yapılmaya çalışılırsa sanki dosya sonuna gelinmiş (yani EOF durumuna gelinmiş) gibi bir durum oluşur.

---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
                                                    21. Ders 08/01/2023 - Pazar
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    "/dev/zero" aygıt sürücüsü "/dev/null" aygıt sürücüsüne çok benzemektedir. "/dev/zero" aygıt sürücüsüne yazılanlar da 
    atılır. Ancak bu aygıt sürücüden okuma yapıldığında hep sıfır okunmaktadır. Aşağıdaki örnekte bu aygıt sürücü açılıp 
    okuma yapılmıştır. Burada standart C fonksiyonlarını kullanmanın bizim için bir dezavantajı yoktur. 
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>

int main(void)
{
    FILE *f;
    int ch;

    if ((f = fopen("/dev/zero", "rb")) == NULL) {
        fprintf(stderr, "cannot open file!..\n");
        exit(EXIT_FAILURE);
    }

    for (int i = 0; i < 10; ++i) {
        if ((ch = fgetc(f)) == EOF) {
            fprintf(stderr, "cannot read from file!..\n");
            exit(EXIT_FAILURE);
        }
        printf("%d ", ch);
        fflush(stdout);
    }
    printf("\n");
    
    fclose(f);

	return 0;
} 

/*--------------------------------------------------------------------------------------------------------------------------
    "/dev/random" ve "/dev/urandom" aygıt sürücüleri her okunduğunda rastgele byte'lar elde edilmektedir. Bu iki aygıt sürücü arasında
    bazı küçük farklılıklar vardır. Ancak burada onun üzerinde durmayacağız. Ayrıca bu aygıt sürücülerden okumayı pratik hale getirmek 
    için Linux'a 3.17 çekirdeği ile birlikte "sys_getrandom" isimli bir sistem fonksiyonu da eklenmiştir. Aşağıdaki örnekte bu aygıt sürücüden 
    rastgele byte'lar okunup hex sistemde ekrana yazdırılmıştır. Program beklemelere yol açarsa şaşırmayınız. Çünkü konuun bazı 
    ayrıntıları vardır. 
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>

int main(void)
{
    FILE *f;
    int ch;

    if ((f = fopen("/dev/random", "rb")) == NULL) {
        fprintf(stderr, "cannot open file!..\n");
        exit(EXIT_FAILURE);
    }

    for (int i = 0; i < 256; ++i) {
        if ((ch = fgetc(f)) == EOF) {
            fprintf(stderr, "cannot read from file!..\n");
            exit(EXIT_FAILURE);
        }
        printf("%02X%c", ch, i % 16 == 15 ? '\n' : ' ');    
        fflush(stdout);
    }
    printf("\n");

    fclose(f);

	return 0;
} 

/*--------------------------------------------------------------------------------------------------------------------------
    Komut satırındaki diğer önemli bir işlem de "boru (pipe)" işlemidir. Boru işlemi "|" ile temsil edilmektedir. Kabul üzerinden
    aşağıdaki gibi bir komut uygulamış olalım:

    a | b

    Burada kabuk bu yazıyı "|" karakterindne parse eder. "|" karakterinin solundaki ve sağındakileri birer program olarak ele alır. 
    Her iki programı da çalışırır. Yani burada "a" programı da "b" programı da çalıştırılacaktır. "a" programının "stdout" dosyasına
    yazdıklarını "b" programı "stdin" dosyasından okuyacaktır. Başka bir deyişle "a" programının 1 numaralı betimeyiciyle yaptuığı write 
    işlemlerini "b" programı 0 numaralı betimleyici ile read fonksiyonunu kullanarak okuyabilecektir. Kabuk boru işlemlerini
    "prosesler arası haberleşme yöntemlerindne biri olan boru haberleşmesi ile" gerçekleştirmektedir. Zaten ilerleyen bölümlerde 
    bu konu ele alınacaktır. 

    Tabii boru işlemi yapılırken programların komut satırı arümanları da verilebilir. Örneğin:

    a b c | d e f

    Burada aslında çalıştırılacak programlar "a" ve "d" programlarıdır. Diğerleri bunların komut satırı argümanlarıdır. 

    Aşağıdaki örnekte "a" programı ekrana (stdout dosyasına) 0'dan 10'a kadar sayıları yazdırmaktadır. "b" programı ise
    döngü içerisinde klavyeden (stdin dosyasından) değer okuyup ekrana yazdırmaktadır. Bu iki programı aşağıdkai gibi çalıştıralım:

    ./a | ./b

    Burada artık a'nın ekrana yazdıklarını sanki b klavyeden okuyormuş gibi bir etki oluşacaktır.
---------------------------------------------------------------------------------------------------------------------------*/

/* a.c */

#include <stdio.h>

int main(void)
{
    for (int i = 0; i < 10; ++i)
        printf("%d\n", i);

    return 0;
}

/* b.c */

#include <stdio.h>

int main(void)
{
    int val;

    while (scanf("%d", &val) == 1)
        printf("%d\n", val);

    return 0;
}

/*--------------------------------------------------------------------------------------------------------------------------
    UNIX/Linux sistemlerindeki dosya yol ifadesi alan POSIX kabuk komutları eğer doys yol ifadesi verilmezse genellikle "stdin" 
    dosyasından okuma yapacak biçimde yazılmışlardır. Örneğin "cat" komutu bir dosyanın içeriğini stdout dosyasına yazdırır:

    cat test.txt

    Ancak bu "cat" komutu argümansız kullanılırsa okumayı "stdin" dosyasından yapar. Örneğin "wc" isimli kabuk komutu normal olarak
    bir dosyayı argüman olarak alır ve o dosyadaki satır sayısını, sözcük sayısını ve byte sayısını stdout dosyasına yazdırır. 
    Ancak bu program komut satırı argümanı verilmeden kullanılırsa klavyedne (stdin dosyasından) okuma yapacaktır. Bu biçimdeki 
    tasarımın nedeni bu komutların "boru" eşliğinde kullanımını sağlamaktır. Örneğin:

    ps -e | wc

    Burada "ps -e" komutu satır satır sistemdeki prosesleri "stdout" dosyasına yazmaktadır. "wc" komutuna argüman verilmediğinde göre
    bu komut "stdin" dosyasındna okuma yapacaktır. O halde bu durumda aslında "ps -e" komutunun ekrana yazdıklarını "wc" komutu 
    işleme sokacaktır.
    
    Örneğin bir çıktıyı sayfa sayfa görüntülemek için "more" isimli bir komut bulunmaktadır. "more" programı normalde bir dosyayı 
    argüman olarak alır. Ancak eğer dosya verilmezse bu duurmda "more" stdin dosyasındna okunanları sayfa sayfa görüntüler. 
    Biz de bu sayede aşağıdkai gibi faydalaı işlemler yapabiliriz:

    ps -e | more

    Burada "ps -e" komutunun ekrana yazdırdıkları sayfa sayfa görüntülenecektir. 

    Pekiyi "|" karakterinin sağındaki program tdin dosyasındna okuma yapmıyorsa ne olur? Örneğin:

    ps -e | wc sample.c

    Burada "wc" komutu artık stdin dosyasındna okuma yapmayacaktır. Bu durumda yine "ps -e" komutunun çıktısı boruya yönlendirilir. 
    Ancak "sample.c" stdin dosyasından okuma yapmadığı için "ps e" komutunun ekrana yazdıklarını işleme sokmayacaktır.

    Boru işlemleri yinelemeli olarak yapılabilir. Örneğin:

    a | b | c

    Burada "a" programının stdout dosyasına yazdıklarını "b" programı stdin dosyasından okuyacaktır. "b" programının da stdout dosyasına 
    yazdıklarını "c" programı stdin dosyasından okuyacaktır.

    Eğer boru mekanizması olmasaydı yukarıdaki işlemler yine yapılabilirdi. Ancak bu duurmda geçici dosyaların oluşturulması gerekirdi. 
    Örneğin:

    ps -e > temp.txt
    wc temp.txt
    rm temp.txt

---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Çok prosesli (multiprocessing) işletim sistemlerinin çalıştığı donanımlarda kullanılan mikroişlemcilerin "koruma mekanizması (protection mechanism)"
    denilen bir özelliği vardır. Çok prosesleri sistemlerde bütün programlar o anda RAM'de bir biçimde bulunmaktadır. Tabii işletim sisteminin
    kendisi de RAM'de bulunur. Bir programın göstericiler yoluyla kendi bellek alanının dışına çıkarak başka bir prosesin bellek alanına
    erişmesi mutlaka engellenmesi gereken bir durumdur. Çünkü eğer bu durum engellenmezse bir program başka bir programın bellek
    alanını bozabilir. Bu bozulma da o programın hatalı çalışmasına ya da çökmesine yol açabilir. Program başka bir programın bellek alanını
    bozmasa bile oradaki programlar üzerinde casuslak faaliyeliteleri yürütebilir. Buna ek olarak bazı makine komutları tamamen sistemin çökmesine yol 
    açabilmektedir. Bir programın bu makine komutlarını kullanmasının tüm sistemi çökertebileceği için önüne geçilmesi gerekir. 
    İşte işlemcilerin koruma mekanizması bu tür ihlallerin birinci elden işlemci tarafından tespit edilip engellenmesini sağlamaktadır.

    İşlemcilerinm koruma mekanizmasının iki yönü vardır:

    1) Bellek Koruması 
    2) Komut Koruması

    Bellek koruması bir prosesin kendi bellek alanının dışına erişimlerinin tespit edilmesine yönelik mekanizmadır. Komut koruması 
    ise sistemi çökertme potansiyeline sahip makine komutlarının kullanımının engellenmesine yönelik mekanizmadır. 

    Tabii her türlü mikroişlemci böyle bir mekanizmaya sahip değildir. Ancak güçlü işlemcilerde bu mekanizma bulunmaktadır. 
    Örneğin Intel'in 80386 ve sonrası işlemcileri ARM'nin Cortex A serisi işlemcileri, Alpha işlemcileri, PowerPC işlemcileri, 
    Itanium işlemcileri bu mekanizmalarsa sahiptir. Mikrodenetleyiciler genel olarak küçük işlemciler oldukları için bu mekanizmaya 
    sahip değillerdir. Windows gibi Linux gibi macOS gibi işletim sistemleri bu mekanizmaya sahip olmayan işlemcilerin bulundurğu sistemlerde 
    kullanılamazlar.  

    Bir prosesin bellek korumasını ve komut korumasını ihlal etmesi birinci elde mikroişlemci tarafından tespit edilmektedir. 
    Mikroişlemci ihlali tespit eder ve işletim sistemine bildirir. İşletim sistemi de hemen her zaman programı sonlandırır. 

    Öte yandan kernel içerisindeki kodların ve aygıt sürücülerin kodlarının bu koruma engeline takılmaması gerekmektedir. Kernel 
    belleğin her yerine erişebilmelidir. Çünkü programları bile belleğe yükleyen kernel'dır. Aynı zamanda kernel sistemi çökertme 
    potansiyelinde olan pek çok makine komutunu uygun bir biçimde kullanmaktadır. Benzer biçimde aygıt sürücüler de mecburen 
    bu tür makine komutlarını kullanmak zorundadırlar. İşte kernek kodlarının ve aygıt sürücü kodlarının bir biçimde bu koruma 
    mekaznizmasından muaf olması gerekmektedir. 

    İşlemcileir tasarlayanlar genellikle prosesler için iki çalışma modu tanımlamışlardır: "Kernel Mode" ve "User Mode".
    Eğer bir kod "kernel modda" çalışıyorsa işlemci koruma mekanizmasını o kod için işletmez. Böylece o kod her şeyi yapabilir. 
    Ancak eğer bir kod "user modda" çalışıyorsa işlemci o kod için koruma mekanizmasını işletmektedir. Normal programların hepsi 
    user modda çalışmaktadır. Ancak kernel kodları ve aygıt sürücüler (kernel modülleri) kernel modda çalışırlar. 

    Bir programın "sudo" ile çalıştırılmasının (yani programın proses id'sinin 0 olmasının) bu konuyla hiçbir ilgisi yoktur. 
    Proses id'nin 0 olması yalnızca dosya erişimleri için avantaj sağlayabilmektedir. Yoksa biz bir programı "sudo" ile çalıştırsak bile 
    o program yine "user modda" çalıştırılmaktadır.  

    Pekiyi biz kendi programımızı kernel modda çalıştıramaz mıyız? Bu sorunun yanıtı genel olarak "hayır" biçimindedir. Bunun tek 
    yolu "aygıt sürücü" ya da "kernel modül" denilen biçimde kod yazmaktır. Zaten aygıt sürücülerin en önemli özelliği onların 
    kernel modda çalışmasıdır. Tabii aygıt srücüler ancak sistem yöneticisitarafından bir parola eşiliğinde (yani sudo ile) 
    yüklenebilmektedir. 

    Sistem fonksiyonları kernel'ın içerisindeki fonksiyonlardır. Dolayısıyla bu fonksiyonlar özel makine komutalrını kullanırlar ve 
    bellekte her yere erişebilirler. Aksi takdirde bu fonksiyonların yazılabilmesi mümkün değildir. Pekiyi bizim programlarımız
    user modda çalıştığına göre biz bir sistem fonksiyonunu çağırdığımızda ne olacaktır? İşte user mod bir proses bir sistem 
    fonksiyonunu çağırdığında prosesin modu otomatik olarak kernel moda geçirilmektedir. Böylece sistem fonksiyonu yine kernel 
    modda çalışmış olmaktadır. Sistem fonksiyonunun çalışması bittiğinde proses yine otomatik olarak user moda dönmektedir. 
    Örneğin Intel işlemcilerinde bu geçişi sağlayan mekanizmaya "kapı (gate)" denilmektedir. Tabii kapı yerleştirmek kernel modda 
    yapılabilecek ir işlemdir. Dolayısıyla user mod proses yalnızca zaten belirlenmiş olan kodları çalıştırmak üzere kernel moda 
    geçebilmektedir. 

    Sistem fonksiyonlarını çağırmanın zamansal bir maliyeti vardır. Çünkü prosesin user moddan kernel moda geçmesi ve birtakım 
    gerekli kontrollerin kernel modda yapılması zaman kaybına yol açmaktadır. Örneğin:

    read(fd, (char *)0x123456, 10)

    Linux'ta read POSIX fonksiyonu doğrudan sys_read sistem fonksiyonunu çağıracaktır. Eğer bu sistem fonksiyonu ikinci parametreyle
    verilen adresi hiç kontrol etmezse koruma mekanizmasından da muaf olduğu için tuzağa düşecektir. İşte bu tür sistem fonksiyonları kesinlikle
    adreslerin o prosesin alanı içerisinde olup olmadığını test ederler. Bunun gibi pek çok yapılması egreken irili ufaklı kontroller 
    vardır. 

    O halde aslında bir proses yaşamının önemli bir kısmını user modda geçrirken bir kısmını da kernel modda geçirebilmektedir. 
    Örneğin "time" isimli kabuk komutuyla biz prosesin ne kadar zamanı kernel modda ne kadar zamanı user modda geçirdiğini görebiliriz:

    kaan@kaan-virtual-machine:~/Study/Unix-Linux-SysProg$ time ./sample

    real	0m0,189s
    user	0m0,185s
    sys	    0m0,005s
    
    Buarad "sys" kernel modu "user" user modu ve "real" da toplam zamanı vermektedir. 

---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    C'nin prototipleri <stdio.h> içerisinde olan ve başı "f" ile başlayan dosya fonksiyonları aslında birer "sarma fonksiyon (wapper function)"
    gibidir. Biz bu fonksiyonları kullandığımızda arka planda bu fonksiyonlar UNIX/Linux ve macOS sistemlerinde POSIX fonksiyonlarını, 
    Windows sistemlerinde ise Windows API fonksiyonlarını kullanmaktadır. Tabi bu fonksiyonlar da ilgili sistemdeki sistem fonksiyonlarını
    çağırmaktadır. Örneğin biz Linux sistemlerinde fopen fonksiyonunu kullanmış olalım:

    fopen (user mode) ---> open (user mode) ---> sys_open (kernel mode)

    fopen fonksiyonu bize FILE * türünden bir dosya bilgi göstericisi vermektedir. Aslında FILE typedef edilmiş bir yapıdır:

    typedef struct {
        ...
        ...
        ...
    } FILE;

    Pekyii bu yapının içerisinde hangi bilgiler vardır? Bir kere fopen dosyayı gerçekte UNIX/Linux sistemlerinde open POSIX 
    fonksiyonunu kullanarak açtığına göre bir biçimde onun içerisinde open fonksiyonundan elde edilen dosya betimleyicisi bulunacaktır:

    typedef struct {
        ...
        int fd;
        ...
    } FILE;

    Standart dosya fonksiyonlarının en önemli özellikleri bir "cache sistemi" oluşturmalarıdır. Burada "cache" terimi daha uygun olmaısna karşın 
    daha çok "tampon (buffer)" terimi kullanılmaktadır. Bu nedenle C'nin dosya fonksiyonlarına "tamponlu (buffered) IO fonksiyonları" denilmektedir.
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Aşağıda iki program verilmiştir. Bu iki program da bir dosyanın bütün karakterlerini ekrana yazdırmaktadır. "a.c" programı
    bu işlemi her defasında read fonksiyonu çağırarak yaparken "b.c" programı bir defasında 512 byte okuma yaparak okunanları 
    bir tampona yerleştirip oradan alıp yazdırmaktadır. Dolayısıyla "b.c" programının daha hızlı çaışması beklenir. Çünkü bu program 
    sistem fonksiyonlarını daha az çağırmaktadır. 
---------------------------------------------------------------------------------------------------------------------------*/

/* a.c */

#include <stdio.h>
#include <stdlib.h>
#include <fcntl.h>
#include <unistd.h>

void exit_sys(const char *msg);

int main(int argc, char *argv[])
{
    int fd;
    char ch;
    ssize_t result;

    if (argc != 2) {
        fprintf(stderr, "wrong number of arguments!..\n");
        exit(EXIT_FAILURE);
    }

    if ((fd = open(argv[1], O_RDONLY)) == -1)
        exit_sys("open");

    while ((result = read(fd, &ch, 1)) > 0) 
        putchar(ch);

    if (result == -1)
        exit_sys("read");

    putchar('\n');

    close(fd);

    return 0;
}

void exit_sys(const char *msg)
{
	perror(msg);

	exit(EXIT_FAILURE);
}

/* b.c */

#include <stdio.h>
#include <stdlib.h>
#include <fcntl.h>
#include <unistd.h>

void exit_sys(const char *msg);

#define BUFSIZE     512

int main(int argc, char *argv[])
{
    int fd;
    char buf[BUFSIZE];
    ssize_t result;

    if (argc != 2) {
        fprintf(stderr, "wrong number of arguments!..\n");
        exit(EXIT_FAILURE);
    }

    if ((fd = open(argv[1], O_RDONLY)) == -1)
        exit_sys("open");

    while ((result = read(fd, buf, BUFSIZE)) > 0) {
        for (int i = 0; i < result; ++i)
            putchar(buf[i]);
    }
        
    if (result == -1)
        exit_sys("read");

    putchar('\n');

    close(fd);

    return 0;
}

void exit_sys(const char *msg)
{
	perror(msg);

	exit(EXIT_FAILURE);
}

/*--------------------------------------------------------------------------------------------------------------------------
    İşte standart C fonksiyonları da yukarıdaki örnekte olduğu gibi sistem fonksiyonlarını daha az çağırmak için bir tampon
    kullanmaktadır. Biz örneğin fgetc fonksiyonu ile bir byte bile okumak istesek fgetc bir taponlukluk bilgiyi okur ve bize 
    onun içerisinde bir byte'ı verir. Biz daha sonra yeniden fgetc fonksiyonunu çağırdığımızda fgetc zaten tamponda daha önce okunmuş olan 
    bilgi yığını olduğu için read fonksiyonu ile okuma yapmaz bize doğrudan tampondan verir. Tabii tampondaki her byte okunduktan sonra 
    (yani tamponun sonuna gelindiğinde) fgetc yeniden read fonksiyonunu çağıracak ve tamponu yeniden dolduracaktır. 

    fopen fonksiyonun geri döndürdüğü FILE türündne yapının ieçrisinde aslında bu tamponu yönetmek için gerekli olan bilgiler de 
    bulunmaktadır. 

    Standart C fonksiyonlarının kullandıkları default tampon büyüklüğü <stdio.h> içerisinde BUFSIZ sembolik sabitiyle ifade edilmiştir. 
    (Tabii bu BUFSIZ değerini değiştirmenin bir anlamı yoktur. Kod çoktan derlenmiştir. Bu sembolik sabit sadece dış dünyaya default durum 
    hakkında bilgi vermek için bulundurulmuştur.)
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>

int main(void)
{
    printf("%d\n", BUFSIZ);     /* 8192 */

	return 0;
} 

/*--------------------------------------------------------------------------------------------------------------------------
    Standart C fonksiyonlarının oluşturdukları bu tampon read/write bir tampondur. Yani yalnızca okuma sırsında da değil yazma sırasında
    da kullanılmaktadır. Örneğin biz fputc fonksiyonu le bir byte'ı dosyaya yazamak istesek bu bir byte aslında bu tampona yazılır. 
    Bu tampon dolduğunda (bu konusunun ayrıntısı ele alınacaktır) ya da fflush fonksiyonu çağrıldığında ya da en kötü olasılıkla
    fclose işlemi sırasında write fonksiyonu çağrılarak diske yazdırılır. Biz tampondaki bilginin aktarılmasını garanti etmek için
    fflush fonksiyonu kullanabiliriz. Tampondaki bilginin write gibi bir fonksiyonla diske yazılması işlemine dosya terminolojisinde
    "flush işlemi" denilmektedir. fflush fonksiyonunun kullanılabilmes için dosyanın "yazma modunda açılmış olması (yani "w", "r+" gibi modlarda)"
    gerekmektedir. 
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
                                            22. Ders 14/01/2023 - Cumartesi
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Anımsanacağı gibi C'nin dosya açmakta kullanılan fopen fonksiyonu bize FILE türünden bir yapı nesnesinin adresini vermektedir. 
    Bu FILE nesnesine "stream" de denilmektedir. Biz Derneğimizde buna genel olarak "dosya bilgi göstericisi" diyoruz. 
    İşte bu FILE yapısının içerisinde söz konusu bu tamponu yönetmek için de bilgiler bulunmaktadır. Örneğin FILE yapısının içerisinde 
    tipik olarak şu bilgiler bulunur:

    - İşletim sistemi düzeyinde okuma/yazma işlemleri için gereken dosya betimleyicisi
    - Tamponun başlangıç adresini tutan bir gösterici
    - Tampondaki aktif noktayı tutan bir gösterici
    - Tamponun uzunluğunu tutan bir eleman ya da tamponun sonunu tutan bir gösterici
    - Diğer bilgiler

    Pekiyi fopen tarafından bu FILE yapısı nasıl tahsis edilmektedir? Standart C kütüphanelerini yazanlar birkaç teknik kullanabilmektedir. 
    Birincisi doğrudan tahsisatın malloc fonksiyonu ile yapılmasıdır. Tabii bu duurmda free işlemi fclose fonksiyonu tarafından yapılacaktır. 
    İkincisi bu FILE yapsı zaten işin başında static düzeyde tahsis edilmiş bir FILE dizisinin içerisinde alınabilir. Örneğin:

    static FILE g_files[FILE_MAX];
    ... 

    C standartlarında FILE yapısının içeriği hakkında bir bilgi verilmemiştir. Bu duurmda bu FILE yapısının içeriği kütüphaneyi 
    yazanlar tarafından istenildiği gibi alınabilir. 
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    fileno isimli POSIX fonksiyonu FILE yapısının içerisindeki dosya betimleyicini bize vermektedir. Yani biz bir dosyayı fopen 
    fonksiyonuyla açıp o dosyanın dosya betimleyicisini elde edebiliriz. fileno fonksiyonunun prototipi şöyledir:

    #include <stdio.h>
    
    int fileno(FILE *stream);

    Fonksiyonun geri dönüş değeri dosya betimleyicisidir. Pekiyi bu fonksiyon başarısız olabilir mi ya da başarısızlığı tespit edebilir mi?
    POSIX standartlarına göre fonksiyon başarısız olabilir. Bu durumda -1 değerine geri döner. Ancak fonksiyonun başarısızlığı tespit etmesi 
    yeterli bir biçimde yapılamayabilir. Fonksiyon FILE yapısının içerisindeki elemana başlangıçta geçersiz bir değer atayıp bu değere
    bakmaktadır. 

    Tabii fileno fonksiyonuyla FILE yapısı içerisindeki dosya betimleyicisini alıp onunla işlem yapınca onun gösteridği dosya göstericisi 
    değiştirilmiş olur. Pek çok gerçekleştirim bu durumda soruna yol açmamaktadır. Ancak bu konuda dikkat etmek gerekir. fileno fonksiyonu
    kısıtlı biçimde bazı zorunlu durumlarda kullanılmalıdır. 
    
    Aşağıdaki örnekte dosya önce fopen fonksiyonuyla açılıp fileno fonksiyonuyla dosya betimleyicisi elde edilmiş ve sonra o betimleyici ile
    okuma yapılmıştır. 

---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>

void exit_sys(const char *msg);

int main(void)
{
   	FILE *f;
	int fd;
	char buf[10 + 1];
	ssize_t result;

	if ((f = fopen("test.txt", "r")) == NULL) {
		fprintf(stderr, "cannot open file!..\n");
		exit(EXIT_FAILURE);
	}

	if ((fd = fileno(f)) == -1)
		exit_sys("fileno");

	if ((result = read(fd, buf, 10)) == -1)
		exit_sys("read");

	buf[result] = '\0';
	puts(buf);

	fclose(f);

	return 0;
} 

void exit_sys(const char *msg)
{
	perror(msg);

	exit(EXIT_FAILURE);
}

/*--------------------------------------------------------------------------------------------------------------------------
    fileno POSIX fonksiyonunun mantısksal olarak tersini yapan fdopen isimli bir POSIX fonksiyonu da vardır. (fdopen bir standart 
    C fonksiyonu değildir). fdopen fonksiyonu open POSIX fonksiyonuyla açıp betimleyicisini elde ettiğimiz dosyaya ilişkin dosya 
    bilgi göstericisini (FILE *) bize verir. Yani fdopen sanki o  dosyayı fopen ile açmışız gibi bir durum oluşturmaktadır. 
    fdopen fonksiyonunun prototipi şöyledir:

     #include <stdio.h>

    FILE *fdopen(int fd, const char *mode);

    Fonksiyonun birinci parametresi open fonksiyonu ile elde edilen dosya betimleyicidir. İkinci parametre dosyanın fopen fonksiyonundaki açış modudur. 
    Tabii buradaki açış modunun open fonksiyonuyla dosya açılırkenki mod ile uyuşması gerekir. Fonksiyon başarı durumunda dosya bilgi 
    göstericisine başarısızlık durumunda NULL adrese geri döner. errno değeri uygun biçimde set edilir. 

    Aşağıdaki örnekte önce open POSIX fonksiyonu ile dosya açılmış sonra dosya betimleyicisi kullanılarak fdopen fonksiyonu ile 
    dosya bilgi göstericisi elde edilmiştir. İşlemlere standart C fonksiyonlarıyla devam edilmiştir. fclose işlemi zaten bu betimleyiciyi 
    kapacağı için ayrıca close fonksiyonu çağrılmamıştır. 
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <fcntl.h>

void exit_sys(const char *msg);

int main(void)
{
	int fd;
	FILE *f;
	int ch;

	if ((fd = open("test.txt", O_RDONLY)) == -1)
		exit_sys("open");

	if ((f = fdopen(fd, "r+")) == NULL) 
		exit_sys("fdopen");

	while ((ch = fgetc(f)) != EOF)
		putchar(ch);

	if (ferror(f)) {
		fprintf(stderr, "cannot read file!..\n");
		exit(EXIT_FAILURE);
	}

	fclose(f);

	return 0;
} 

void exit_sys(const char *msg)
{
	perror(msg);

	exit(EXIT_FAILURE);
}

/*--------------------------------------------------------------------------------------------------------------------------
    Standart C'nin <stdio.h> fonksiyonları tamponlamayı üç moda (ya da stratejiye) göre farklı biçimlerde yapmaktadır. 
    Üç tamponlama modu şöyledir:

    Tam Tamponlamalı Modu (Full Buffering): Burada okuma sırasında tampon tamamen doldurulur. Tamponun sonuna gelindiğinde tampon 
    yeniden doldurulur. Yazma sırasında da tampona yazılır. Tamponun sonuna gelindiğinde tampona yazılmış olanlar flush edilir. 
    (Tabii her zaman fflush ve fclose zaten flush işlemini yapmaktadır.)

    Satır Tamponlamalı Mod (Line Buffering): Bu modda tampon tamamen doldurulmaz. Yalnızca tek satırlık bilgi ('\n' karakterş dahil olmak üzere)
    tampona çekilmektedir. Okuma sırasında bu tampondan byte'lar verilir. Yazma sırasına yine tampona yazılır. flush işlemi '\n' 
    karakteri tampona yazılınca (ya da fflush ve fclose fonksiyonları çağrılınca) yapılmaktadır. Satır tamponlamalı mod tipik olarak
    text dosyalar için kullanılmaktadır. Binary dosyalar için bu mod kullanılabilse de anlamsızdır. 

    Sıfır Tamponlamalı Mod (No Buffering): Burada tampon hiç kullanılmaz. Doğrudan ilgili aşağı seviyeli fonksiyonlarla (yani read ve write POSIX 
    fonksiyonlarıyla) aktarım yapılır.

    Satır tamponlaması kişilere biraz tuhaf gelebilmektedir. Çünkü satır tamponlaması yapabilmek için standart C kütüphanesinin okuma sırasında
    '\n' karakterini görmesi gerekir ki bazı durumlarda bunun etkin bir biçimde yapılabilme olanağı yoktur. Ancak bazı durumlarda zaten 
    aygıt sürücüler bize satırsal bilgi vermektedir. Standart kütüphaneleri disk dosyaları için satır tamponlaması yaparken aslında
    çoğu kez '\n' karakterine kadar değil tüm tampon kadar okuma yapmaktadır. Ancak '\n' karakteri tampona yazıldığında flush işlemi 
    yapmaktadırlar. C standartları bu üç tamponlama biçimini belirtmiş olsa da detaylar konusunda bir açıklama yapmamıştır. 
    Dolayısıyla kütüphaneyi gerçekleştirenler satır tamponlaması ile okuma yapılırken '\n' karakterine kadar değil tüm tamponu da
    doldurabilmektedir. C standartlarında tamponlama stratejisi için "niyet" belirtilmiştir. Ancak yukarıda da belirttiğimiz gibi 
    detay belirtilmemiştir. 

    Tamponlama modu ile ilgili iki önemli soru gündeme gelmektedir?

    1) Dosyanın default tamponlama modu nedir?
    2) Dosyanın tamponlama modu nasıl değiştirilmektedir?

    fopen fonksiyonu ile dosya açıldığında dosyanın default tamponlama modu hakında C standartlarında bir şey söylenmemiştir. 
    Bu durum "bunun herhangi bir biçimde olabileceği" anlamına gelmektedir.Fakat mevcut standart C kütüphaneleri genel olarak 
    default durumda "tam tamponlamalı (full buffered)" modu esas almaktadır. Ancak standartlarda "stdin", "stdout" ve "strderr" 
    dosyaları için bazı şeyler söylenmiştir. Bir dosyanın tamponlama modu dosya fopen fonksiyonuyla açıldıktan sonra ancak henüz 
    hiçbir işlem yapmadan "setbuf" ve "setvbuf" standart C fonksiyonlarıyla değiştirilebilmektedir. Dosya üzerinde herhangi bir 
    işlem yaptıktan sonra bu fonksiyonların çağrılması "tanımsız davranışa (undefined behavior)" yol açmaktadır. "setvbuf" fonksiyonu işlevsel olarak 
    "setbuf" fonksiyonunu zaten kapsamaktadır. 

---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    setbuf fonksiyonu temel olarak kullanılan tamponun yerini değiştirmek için tasarlanmıştır. Fonksiyonun prototipi 
    şöyledir:

    #include <stdio.h>

    void setbuf(FILE *stream, char *buf);

    Fonksiyonun birinci parametresi dosya bilgi göstericisini, ikinci parametresi yeni tamponun yerini belirtmektedir. Bu tamponun BUFSIZ 
    uzunluğunda olması gerekir. Eğer ikinci parametre NULL adres olarak girilirse bu durumda dosya "sıfır tamponlamalı moda" 
    sokulmaktadır. Fonksiyon başarıyı kontrol edememektedir. 

    Aşağıdaki örnekte setbuf fonksiyonu ile dosya için kullanılacak tamponun yeri değiştirilmiştir. fgetc işlemi sonrasında bu 
    tamponun doldurulduğuna dikkat ediniz.  
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>

int main(void)
{
	FILE *f;
	char mybuf[BUFSIZ];
	int ch;

	if ((f = fopen("test.txt", "r")) == NULL) {
		fprintf(stderr, "cannot open file!..\n");
		exit(EXIT_FAILURE);
	}

	setbuf(f, mybuf);

	ch = fgetc(f);
	putchar(ch);

	for (int i = 0; i < 512; ++i)
		putchar(mybuf[i]);
	putchar('\n');

	fclose(f);

	return 0;
} 

/*--------------------------------------------------------------------------------------------------------------------------
    setvbuf fonksiyonu ile hem tamponun yeri, hem büyüklüğü hem de tamponlama modu değiştirilebilmektedir. Fonskiyonun prototipi 
    şöyledir:

    #include <stdio.h>

    int setvbuf(FILE *stream, char *buf, int mode, size_t size);

    Fonkiyonun birinci parametresi dosya bilgi göstericisini (stream) belirtir. Üçüncü parametre değiştirilecek tamponlama modunu 
    belirtmektedir. Bu parametre şu değerlerden birini alabilmektedir:

    _IONBF (unbuffered)
    _IOLBF (line buffered)
    _IOFBF (fully buffered)

    İkinci parametre tamponu değiştirmek için kullanılmaktadır. Bu parametre NULL adres geçilirse tamponun yeri dğeiştirilmez. Son 
    parametre ise tamponun yeni uzunluğunu belirtmektedir. Programcı ikinci parametreye NULL adres geçip son parametre yoluyla tamponun 
    büyüklüğünü de değiştirebilir. Bu duurmda tamponu setvbuf kendisi tahsis edecektir. Eğer tamponlama modu ikinci parametreye 
    _IONBF geçilerek sıfır tamponlamalı mod olarak ayarlanırsa artık ikinci ve dördündü parametrenin bir önemi kalmamaktadır. 
    Fonksiyon başarı durumunda 0 değerine başarısızlık durumunda sıfır dışı bir değere geri dönmektedir. POSIX sistemlerinde errno 
    değeri yine uygun biçimde set edilmektedir. 

    glibc kütüphanesinde stebuffer ve setlinebuf isimli iki fonksiyon da bulunmaktadır. Ancak bu foksiyonların taşınabilirliği yoktur. 

    Aşağıdaki örnekte bir dosya fopen fonksiyonuyla açılmış ve "satır tamponlamalı moda" geçirilmiştir. Yukarıda da belirtildiği gibi 
    C standartları tamponlama modları için mutlak uyulması gereken kuralları açıkça belirtmemiştir. Örneğin glibc kütüphanesi normal 
    dosyalarda satır tamponlaması sırasında satır sonuna kadar değil tamponun tamamını doldurmaktadır. Ancak '\n' karakteri dosyaya 
    yazıldığında flush işlemi yapmaktadır. 
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>

int main(void)
{
	FILE *f;
	char mybuf[512];
	int ch;

	if ((f = fopen("test.txt", "r")) == NULL) {
		fprintf(stderr, "cannot open file!..\n");
		exit(EXIT_FAILURE);
	}

	if (setvbuf(f, mybuf, _IOLBF, 512) != 0) {
		fprintf(stderr, "cannot set buffer!..\n");
		exit(EXIT_FAILURE);
	}

	ch = fgetc(f);
	putchar(ch);

	for (int i = 0; i < 512; ++i)
		putchar(mybuf[i]);
	putchar('\n');

	fclose(f);

	return 0;
} 

/*--------------------------------------------------------------------------------------------------------------------------
    Çeşitli standart C kütüphanelerinin özellikle stdio fonksiyonlarının gerçekleştirimini üşenmeden inceleyebilirsiniz. Alternatifler 
    şunlar olabilir:

    - uclibc (Mikro C kütüphanesi): https://elixir.bootlin.com/uclibc-ng/latest/source
    - musl libc kütüphanesi: http://www.musl-libc.org/
    - diet libc kütüphanesi: http://www.fefe.de/dietlibc/
    - Plauger'in "The C Standard Library" kitabında gerçekleştimini yaptığı kütüphane: https://github.com/topics/c-standard-library 
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    C'nin <stdio.h> dosyası içerisinde FILE * türünden yani "stream" belirten üç değişken ismi bulnmaktadır: stdin, stdout ve stderr.
    Bu değişkenler fopen fonksiyonun geri döndürdüğü FILE nesnesi türünden adres belirtmektedir. Dolayısıyla C'nin standart dosya fonksiyonlarında 
    bunları kullanabiliriz. Örneğin aslında:

    printf(...);

    çağrısı ile aşağıdaki fprintf çağrısının bir farkı yoktur:

    fprintf(stdout, ...);

    stdin, stdout ve stderr dosya bilgi göstericileri (streams) programcı tafaından açılmamıştır ve programcı tarafından kapatılmamalıdır.
    Programcı bunları doğrudan kullanabilir. Şüphesiz UNIX/Linux sistemlerinde stdin dosya bilgi göstericisinin gösterdiği FILE nesnesinin 
    içerisinde 0 numaları betimleyici, stdout FILE nesnesinin içerisinde 1 numaralı betimleyici ve stderr FILE nesnesinin içerisinde 2 numaralı betimleyici 
    vardır. 
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    C standartları herhangi bir dosyanın default tamponlaması hakkında bir şey söylememiş olsa da "stdin", "stdout" ve "stderr" 
    dosyalarının default tamponlaması hakkında şunları söylemiştir:

    - stdin ve stdout dosyaları default durumda "eğer interaktif olmayan bir aygıta yönlendirilmişse işin başında tam tamponlamalı"  moddadırlar.
    Ancak bu dosyalar "interaktif olan bir aygıta yönlendirilmişse işin başında tam tamponalamlı olamazlar, satır tamponlamalı ya da
    sıfır tamponlamalı" olabilirler. Klavye ve ekran yani terminal "interaktif aygıt" kabul edilmektedir. Ancak disk dosyaları interaktif aygıt
    kabul edilmemektedir. 

    - stderr dosyası ister interaktif olamayan aygıta yönlendirilmiş olsun isterse interaktif aygıta yönlendirilmiş olsun işin başında
    tam tamponlamalı olamaz. Ancak satır tamponlamalı ya da sıfır tamponlamalı olabilir. 

---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
                                                    23. Ders 15/01/2023 - Pazar
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Örneğin Windows sistemlerindeki C derleyicilerinde default durumda dosyay yönlendirme yapılmamışsa stdout sıfır tamponlamalı 
    stdin satır tamponlamalıdır. Ancak UNIX/Linux sistemlerinde stdout ve stdin dosyaları satır tamponlamalıdır. Aşağıdaki örnekte bu durum anlaşılabilir.

    #include <stdio.h>

    int main(void)
    {
        printf("ankara");		/* windows sistemierinde yazı gözükecek UNIX/Linux'ta gözükmeyecek */

        for (;;)
            ;

        return 0;
    }

    Tabii program sonlanırken stdin, stdout ve stderr dosyaları zaten derleyiciler tarafından kapatılacağı için her durumda 
    bu flush işlemi yapılacaktır. Örneğin aşapıdaki programda programın çalışması bitince her sistemde yazı görünecektir:

    #include <stdio.h>

    int main(void)
    {
        printf("ankara");		

        return 0;
    }

    stdout dosyası default terminale yönlendirilmişken satır tamponlamalı ya da sıfır tamponlamalı modda olabiliyorsa bir yazının ekrana 
    çıkmasını nasıl garanti edebiliriz? Mademki stdout terminale yönlendirildiğinde en kötü olasılıkla satır tamponlamalı olabilir 
    o zaman yazının sonuna '\n' karakteri koyarız. Örneğin:

    #include <stdio.h>

    int main(void)
    {
        printf("ankara\n");		/* Hem Windows'ta hem de Linux sistemlerinde yazı görülecek */

        for (;;)
            ;

        return 0;
    }

    Ancak burada imleç aynı zamanda aşağı satıra geçirilmektedir. Pekiyi imleç aşağı satıra geçirilmeden yazının ekrana çıkması nasıl 
    garanti edilebilir? Bunun iki yolu vardır. Birincisi stdout dosyasını fflush(stdout) çağrısıyla flush etmektir:

    #include <stdio.h>

    int main(void)
    {
        printf("ankara");		
        fflush(stdout);

        for (;;)
            ;

        return 0;
    }
	
    İkincisi stdout dosyasını her ihtimale karşı açıkça sıfır tamponlamalı moda çekmektir:

  #include <stdio.h>

    int main(void)
    {
        setvbuf(stdout, NULL, _IONBF, 0);		/* setbuf(stdout, NULL */
        printf("ankara");		

        for (;;)
            ;

        return 0;
    }

    C derleyicilerinin hemen hepsinde stdin dosyasından okuma yapıldığında okuma yapan fonksiyonlar öne stdout dosyasını flush 
    etmektedir. Standartlarda bu durum garanti edilmemiştir. Ancak derleyicilerin hemen hepsi böyle yapmaktadır. Örneğin:

    #include <stdio.h>

    int main(void)
    {
        
        printf("ankara");	

        getchar();		/* Hem Windows hem de UNIX/Linux sistemlerindeki derleyicilerde stdout flush edilecek */

        return 0;
    }

---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    stdin dosyası hem Windows hem de UNIX/Linux sistemlerinde dosyaya yönlendirilmemişse satır amponlamalı moddadır. Dolayısıyla 
    biz klavyedne bir karakter bile okumak istesek UNIX/Linux sistemlerinde read fonksiyonu 0 numaralı betimleyici ile çağrılarak 
    bir satırlık bilgi okunup tampona yerleştirilmektedir. Artık tamponda bilgi olduğu sürece okuma fonksiyonları tampondakileri okuyacaktır. 
    Örneğin üst üste ik getchar çağrısı ile iki karakteri stdin dosyasından okumak isteyelim:

    ch1 = getchar();
    ch2 = getchar();

    Birinci getchar fonksiyonu bizden bir satır alarak onu stdin dosyasının tampona yerleştirir. Tabii tamponun sonunda '\n' karaketeri de
    bulunacaktır. İkinci getchar tampon boş olmadığı sürece artık klavyeden giriş istemeyip tampondan girişi karşılayacaktır. 
    Yukarıdaki örnekte biz ilk getchar fonksiyonunda klavyeden "a" karakterine basıp ENTER tuşuna basalım. Bu duurmda tamponda şu karakter olacaktır:

    a\n

    İlk getchar bu 'a' karaekterini ikinci getchar ise '\n' karakterini alacaktır. Biz getchar fonksiyonunu üçüncü kez çağırdığımızda 
    artık yeni bir staır istenecektir. Yani stdin dosyasındna okuma yapan fonksiyonlar tampon boşsa read fonksiyonunu çağırarak bizden 
    bir satırlık bilgi istemektedir. Aşağıdaki programla test işlemini yapabilirsiniz:

    #include <stdio.h>

    int main(void)
    {
        int ch;

        ch = getchar();
        printf("%c (%d)\n", ch, ch);
        
        ch = getchar();
        printf("%c (%d)\n", ch, ch);

        return 0;
    }

    Tabii scanf, getchar, gets gibi fonksiyonların hepsi ortak tampondan çalışmaktadır. Yani bu fonksiyonların hepsi stdin dosyasındna 
    okuma yapar. stdin dosyasının da bir tane tamponu vardır. 
     
    Pekiyi biz gerçekten ikinci getchar fonksiyonu ile yeni bir klavye girişi yapmak istiyorsak bunu nasıl sağlayabiliriz? stdin dosyasının 
    flushedilmesi geçersiz bir işlemdir. Zira C'de "read-only" dosyalar flush edilemezler. Bunun için özel bir fonksiyon da bulundurulmamıştır. 
    O zaman tek yapılacak şey '\n' karakterini görene kadar stdin dosyasından karakter karakter okuma yapmaktır. Bu işlem şöyle bir döngü 
    ile yapılabilir:

	while(getchar() != '\n')
		;

    Tabii sonraki anlatımlarda görüleceği üzere EOF durumunun da kontrol edilmesi daha uygun olur. Bu nedenle aşağıdaki gibi bir fonksiyon
    bu iş için kullanılabilir:

    void clear_stdin(void)
    {
        int ch;

        while ((ch = getchar()) != '\n' && ch != EOF)
            ;
    }

    Maalesef bu işlemin daha pratik bir yolu yoktur. Örneğin:

    #include <stdio.h>

    void clear_stdin(void)
    {
        int ch;

        while ((ch = getchar()) != '\n' && ch != EOF)
            ;
    }

    int main(void)
    {
        int ch;

        ch = getchar();
        printf("%c (%d)\n", ch, ch);
        
        clear_stdin();

        ch = getchar();
        printf("%c (%d)\n", ch, ch);

        return 0;
    }

---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    stdin dosyası default durumda pek çok sistemde terminal aygıt sürücüsüne (yani klavyeye) yönlendirilmiş durumdadır. 
    Biz stdin dosyasında okuma yaptığımızda EOF ile karşılaşabiliriz. Çünkü stdin bir dosyaya yönlendirdildiğinde dosyanın sonuna
    gelinmiş de olabilir. Pekiyi stdin defaut durumda klavyeden okuma yaparken dosya sonu kavramı ne olacaktır? İşte terminal aygıt sürücüsü 
    bazı özel tuş kombinasyonlarında yalancı bir EOF etkisi oluşturmaktadır. Windows sistemlerinde Ctrl+z tuşu UNIX/Linux sistemlerinde 
    Ctrl+d tuşu bu amaçla kullanılmaktadır. Örneğin:

    ch = getchar();

    Burada Windows sistemlerinde Ctrl+z tuşuna UNIX/Linux sistemlerinde Ctrl+d tuşuna basıldığında "dosya sonuna gelme etkisi" yaratılacak ve 
    getchar fonksiyonu EOF değerine (-1) gei dönecektir. Tabii bu tuş kombinasyonlarına basıldığında gerçekte dosya sonuna gelme gibi bir durum 
    oluşmamaktadır. Bu yalancı bir etkidir. Yani daha sonra stdin dosyasından yine okuma yapılabilir. Bu nedenle stdin tamponunu boşaltırken 
    kullanıcının EOF etkisi yaratmak isteyebileceğine de dikkat edilmelidir:

    void clear_stdin(void)
    {
        int ch;

        while ((ch = getchar()) != '\n' && ch != EOF)
            ;
    }
---------------------------------------------------------------------------------------------------------------------------*/


/*--------------------------------------------------------------------------------------------------------------------------
    C'de stdin dosyasından okuma yapan standart fonksiyonlar şunlardır:

    getchar
    scanf
    gets (C11'de kaldırılıdı)
    gets_s (C11 ile birlikte eklendi ancak "isteğe bağlı (optional), VS ve glibc kütüphanelerinde yok")

    Bunların hepsi aynı tampondan çalışmaktadır. Şimdi bu fonksiyonlar üzerinde duralım.
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    getchar fonksiyonu stdin dosyasındna bir karakter okur. Tabii önce tampona bakar. Tamponda en az bir karakter varsa onu verir. 
    Tampon tamamen boşsa klavyedne bir satır okuyarak tamponu doldurur. Ondan sonra karakteri verir. Aslında gets ve scanf gibi 
    fonksiyonların hepsi getchar kullanılarak yazılmıştır. Yani temel fonksiyon getchar fonksiyonlarıdır. 
    getchar fonksiyonu dosya sonuna gelindiğinde ya da IO hatası olduğunda EOF (-1) değerine geri dönmektedir. getchar fonksiyonunun prototipi 
    şöyledir:

    #include <stdio.h>

    int getchar(void);

    Eğer fonksiyonun geri dönüş değeri char olsaydı bu durumda 0xFF gibi bir okumayla EOF değeri birbirinden ayırt edilemezdi.
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    gets fonksiyonu C99'da "derecated" yapılmış ve C11'de C'den kaldırılmıştır. Ancak hala derleyiciler bunu muhafaza etmektedir. 
    gets fonksiyonu stdin dosyasından karakter karakter okuma yapar ve okuduğu karakterleri verilen bir diziyeyerleştirir. gets fonksiyonu
    '\n' karakterini de okur ancak onun yerine diziye '\0' karakterini yerleştirir. Yani gets fonksiyonu aslında stdin tamponunu da tamamen
    boşaltmaktadır. Tabii gets fonksiyonu çağrıldığında stdin tamponunda zaten karakterler varsa gets klavyeden bir giriş beklemedne onları okuyup 
    geri dönecektir. 

    gets fonksiyonunun prototipi şöyledir:

    char *gets(char *s);

    gets fonksiyonu parametresiyle girilen adresin aynısıyla geri döner. Ancak henüz hiçbir karakter okunmadan EOF ile karşılaşılırsa
    gets NULL adresle geri dönmektedir.

    gets fonksiyonu aşağıdaki gibi yazılabilir.
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>

char *mygets(char *s)
{
	int ch;
	size_t i;

	for (i = 0; (ch = getchar()) != '\n' && ch != EOF; ++i)
		s[i] = ch;

	if (i == 0 && ch == EOF)
		return NULL;

	s[i] = '\0';
	
	return s;

}

int main(void)
{
	char buf[64];

	mygets(buf);
	puts(buf);

	return 0;
}

/*--------------------------------------------------------------------------------------------------------------------------
    gets fonksiyonun problemi parametre olarak verdiğimiz dizinin her zaman taşırılabilme olasılığıdır. Fonksiyonun dizi unuzunluğunu da
    parametre olarak alması gerekirdi. İşte C11 ile birlikte isteğe bağlı biçimde standartlara eklenmiş olan gets_s bununu yapmaktadır.
    gets_s fonksiyonun prototipi şöyledir:

    char *gets_s(char *s, rsize_t n);

    Buradaki rsize_t türü de yine "isteğe bağlı typedef edilmesi gereken" bir türdür. Aşağıdak gets_s fonksiyonun muhtemel bir gerçekleştirimi
    verilmiştir. 
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>

char *mygets_s(char *s, size_t n)
{
	int ch;
	size_t i;

	for (i = 0; i < n - 1; ++i) {
		if ((ch = getchar()) == '\n' || ch == EOF)
			break;
		s[i] = ch;
	}
		
	s[i] = '\0';

	if (i == 0 && ch == EOF)
		return NULL;
	
	return s;
}

int main(void)
{
	char buf[3];

	mygets_s(buf, 3);
	printf("%s\n", buf);

	return 0;
}

/*--------------------------------------------------------------------------------------------------------------------------
    Bazı programcılar gets_s fonksiyonu derleyicilerde bulunmadığı için onun işlevselliğini fgets fonksiyonu ile karşılamaya çalışmaktadır. 
    fgets fonksiyonun prototipi şöyledir:

    char *fgets(char *s, size_t n, FILE *f);

    Ancak fgets fonksiyonu ile eğer belirtilen uzunluktan daha kısa bir satır girilmişse '\n' karakterini de diziye yerleştirmektedir. 
    Bu durumda programcının bu '\n' karakterini kendisinin aşağıdaki gibi silmesi gerekmektedir:

    char buf[64];
	char *str;

	fgets(buf, 64, stdin);
	if ((str = strchr(buf, '\n')) != NULL)
		*str = '\0';

---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    scanf fonksiyonu işlevsel olarak printf fonksiyonun tersi gibidir. Prototipi şöyledir:

    int scanf(const char *format, ...);

    Fonksion stdin dosyasındna karakterleri tek tek okur. Format karakterlerine uygunsuzluk tespit ettiği noktada uygunsuz olan 
    o karakteri tampona geri yazar ve işlemini sonlandırır. scanf fonksiyonu başarılı bir biçimde yerleştirilen değerin sayısına geri 
    dönmektedir. Tabii bu değer 0 da olabilir. scanf henüz hiçir karakter okuyamadan EOF ile kaşılaşırsa EOF değerine geri döner. 
    scanf her zaman baştaki boşluk karakterlerini (leading space) ve girişler arasındaki boşluk karakterlerini atmaktadır. 
    Ancak sonraki boşluk kaakterlerini ('\n' de dahil olmak üzere) atmamaktadır. 

    Aşağıda scanf kullanımına ilişkin bir örnek verilmiştir. 
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>

void clear_stdin(void)
{
	int ch;

	while ((ch = getchar()) != '\n' && ch != EOF)
		;
}

int disp_menu(void)
{
	int option;
	int result;

	do {
		printf("1) Add record \n");
		printf("2) Delete record \n");
		printf("3) List record \n");
		printf("4) Quit\n");

		printf("\nChoose an item:");
		if ((result = scanf("%d", &option)) != 1 || option < 0 || option > 4) {
			printf("Invalid option!..\n");
			clear_stdin();
		}
	} while (result != 1);


	return option;
}

int main(void)
{
	int option;

	for (;;) {
		option = disp_menu();

		switch (option) {
			case 1:
				printf("add record...\n");
				break;
			case 2:
				printf("delete record...\n");
				break;
			case 3:
				printf("list record...\n");
				break;
			case 4:
				goto EXIT;
		}
	}

EXIT:
	return 0;
}

/*--------------------------------------------------------------------------------------------------------------------------
    Bir dosyadan okunan karakter beğenilmezse sanki hiç okunmamış gibi bir etki oluşturmak için (yani o karakteri tampona geri bırakmak için)
    ungetc isimli bir standart C fonksiyonu buundurulmuştur:

    #include <stdio.h>

    int ungetc(int c, FILE *stream);

    Fonksiyon başarı durumunda tampona bırakılan karakterin aynsına, başarısızlık durumunda EOF değerine geri dönmektedir. 
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Bir dosayı byte byte okurken fgetc fonksiyonundan faydalanırız. Standart C fonksiyonları tamponlu çalıştığına göre 
    gereksiz bir biçimde sistem fonksiyonları tekrar tekrar çağrılmayacaktır. Ancak öte yandan fonksiyon çağırmanın da bir maliyeti 
    vardır. İşte C standartlarında fgetc yerine getc isimli alternatif bir fnksiyon da bulundurulmuştur. getc fonksiyonu makro olarak 
    yazılabilmektedir. Yani iki fonksiyon arasınaki tek fark getc fonksiyonunun bir makro biçiminde yazılabilmesidir. getc fonksiyonun prototipi de 
    şöyledir:

    #include <stdio.h>

    int getc(FILE *stream);

---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    UNIX/Linux sistemlerinde her prosesin o anda "sistem genelinde tek olan (unique)" bir "proses id" değeri vardır. 
    Proses id değeri prosesin kontrol bloğuna erişmek için bir anahtar olarak kullanılmaktadır. Yani biz işletim sistemine 
    bu proses id değerini verdiğimizde işletim sistemi çok hızlı bir biçimde bu id değerinden hareketle prosesin kontrol bloğuna 
    erişebilmektedir. 
    
    Proseslerin id değerleri pid_t türüyle temsil edilmiştir. pid_t türü işaretli bir tamsayı türü olmak koşuluyla <sys/types.h> ve
    <unistd.h> dosyalarında typedef edilmiş durumdadır. 

    Sistem boot edildiğinde boot kodu 0 numaralı id'ye sahip proses biçimine dönüştürülmektedir. (Buna "swapper" ya da "pager" da denilebilmektedir.)
    Daha sonra da bu 0 numaralı id bir daha sistemde kullanılmamaktadır. Sistemde ikinci yaratılan proses 1 numaralı id'ye sahip olan "init" isimli prosestir. 
    0 numaralı pros yok edildiği için sistemdeki bütün proseslerin atası bu "init" posesidir. 

    İşletim sisteminin çekirdeği tipik olarak yeni yaratılan bir proses için proses id değerini bir sayaç ile vermektedir. Her proses yaratıldığında
    bu sayaç değeri bir artırılır. Sayaç sona geldiğinde yeniden başa geçilir ve bitmiş proseslerin id'leri kullanılır.
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    O anda çalışmakta olan programa ilişkin proses id değeri getpid isimli POSIX fonksiyonu ile elde edilebilmektedir:

    #include <unistd.h>

    pid_t getpid(void);

    Fonksiyon başarız olamaz. 
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <unistd.h>

int main(void)
{
	pid_t pid;

	pid = getpid();
	
	printf("%lld\n", (long long)pid);		/* printf("%jd\n", (intmax_t)pid) */
	
	return 0;
}

/*--------------------------------------------------------------------------------------------------------------------------
                                                24. Ders 21/01/2023 - Cumartesi
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Prosesler prosesler tarafından sistem fonksiyonlarıyla yaratılmaktadır. Bir prosesi yaratan prosese o prosesin "üst prosesi (parent process)",
    yaratılan prosese de üst prosesin "alt prosesi (child process)" denilmektedir. Her prosesin bir üst prosesi vardır. Bir prosesin 
    üst prosesi getppid fonksiyonu ile elde edilmektedir. Fonksiyonun prototipi şöyledir:

    #include <unistd.h>

    pid_t getppid(void);

    Fonksiyon başarısız olamamaktadır. 
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <unistd.h>

int main(void)
{
    pid_t pid, ppid;

    pid = getpid();
    printf("pid = %lld\n", (long long)pid); 

    ppid = getppid();
    printf("ppid = %lld\n", (long long)ppid); 

    return 0;
}

/*--------------------------------------------------------------------------------------------------------------------------
    Bir prosesin üst prosesi sonlanırsa bu tür proseslere "öksüz (orphan) prosesler" denilmektedir. Sistem böyle bir durumda
    1 numaralı id'ye sahip olan "init" prosesini öksüz duruma düşmüş prosesin üst prosesi olarak atamaktadır. Dolayısıyla her 
    zaman prosesin bir üst prosesi bulunmaktadır. 

    Sistemlerde prosesler konusunda bazı limitler söz konusu olabilmektedir. Çünk her proses bir kaynak kullanmaktadır. Bu kaynakların da 
    o makine bir limiti vardır. Örneğin Linux sistemlerinde sistem genelinde aynı anda var olabilecek toplam proseslerin sayısı 
    /proc/sys/kernel/threads-max dosyasında belirtilmektedir. Burada belirtilen değer "toplam porseslerin ve thread'lerin" sayıdır. 
    (Linux sistemlerinde aslında thread'ler de prosesler gibi kaynak kullanmaktadır.) Yine Linux sistemlerinde belli bir kullanıcının yaratabileceği 
    maksimum proses ve thread sayısı da söz konusudur. Bu değer getrlimit fonkisyonuyla ya da ulimit kabuk komutuyla elde edilebilir. 
    Tabii root prosesi (proses id'si 0 olan porsesler ve bu yeterliliğe (cabapility) sahip olan prosesler) bu sınırlamaya tabi değildir. 
    Linux sistemlerinde "proses id'lerin yeniden başa geçmeden alabileceği maksimumn değer de "/proc/sys/kernel/max_pid" dosyasında
    belirtilmektedir. Aşağıdaki bir Ubuntu makinede bu limitler gösterilmiştir. Ancak bu limitler makineden makineye değişebilmektedir. 
   
    parallels@ubuntu-linux-20-04-desktop:~$ cat /proc/sys/kernel/threads-max
    15071
    parallels@ubuntu-linux-20-04-desktop:~$ cat /proc/sys/kernel/pid_max
    4194304
    parallels@ubuntu-linux-20-04-desktop:~$ ulimit -u
    7535

    Bu değerler aslında o anda ya da kalıcı olarak değiştirilebilmektedir. Bu değerlerin boot edilene kadar değiştirilmesi bu dosyalara 
    yeni değerlerin yazılmasıyla yapılabilir. Ya da sysctl kabuk komutu ile yapılabilir. Kalıcı değişiklik için sistem boot edilirken 
    başvurulan bazı konfigürasyon dosyalarından faydalanılmaktadır. Örneğin /etc/sysctl.conf dosyasına yeni limitler girilirse
    sistem her açıldığında bu limitlerle açılacaktır. Aslında bu limitler "kernel parametreleri" yoluyla da değiştirilebilmektedir. 
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    UNIX/Linux sistemlerinde bir proses yaratmanın yegane yolu "fork" isimli POSIX fonksiyonunu kullanmaktır. fork fonksiyonu 
    doğrudan işletim sisteminin bu işi yapan sistem fonksiyonunu çağırmaktadır. Linux sistemlerinde sys_fork isimli fonksiyon ve 
    bunun daha genel biçimi olan sys_clone sistem fonksiyonları bu işi yapmaktadır. fork fonksiyonunun prototipi şöyledir:

    #include <unistd.h>

    pid_t fork(void);    

    fork Türkçe "çatal" anlamına gelmektedir. "Akışın çatallanması" gibi bir benzetmeyle bu isim verilmiştir. fork bir prosesin 
    tamamen özdeş bir kopyasını oluşturur. (Bunu klonlama makinesine giren orada klonu çıkartılan bir insan olarak düşünebilirsiniz.)
    Yani fork fonksiyonu şunları yapmaktadır:

    1) Yeni bir proses kontrol blok yaratır. fork işlemini yapan prosesin proses kontrol bloğunn içeriğini yeni yaratılan prosesin 
    kontrol bloğuna kopyalar. Böylece üst proses ile yeni yaratılan alt proses tamamen aynı özelliklere sahip olmaktadır.

    2) fork bu fonksiyonu çağıran prosesin bellek alanının da kopyasını yeni yaratılan proses için oluşturmaktadır. Böylece 
    her iki proses de aynı koda ve data ve heap alanlarına sahip olacaktır. Ancak buınlar birbirlerinden ayrıdır. 

    Yukarıdaki işlemler fork fonksiyonunun içinde yapılmaktadır. fork fonksiyonundan hem bu fonksiyonu çağıran proses hem de 
    yeni yaratılan proses çıkmaktadır. Ancak bunların bellek alanları ayrı olduğu için artık birinin yapacağı değişikliği diğeri 
    görmeyecektir. fork fonksiyonu bir klonlama yapmaktadır. Yeni bir prosesi kendi prosesiyle aynı özelliklere ve aynı bellek alanı 
    ile yaratmaktadır. fork sırasında prosesin kontrol bloğu yeni yaratılan prosese kopyalndığı için üst proses ile alt proses 
    aynı kullanıcı ve grup id'sine sahip olur. (Bir kişi klonlama makinesine girip klonu çıkartıldığında makineden iki kişi çıkacaktır. 
    Bu iki kişinin de anıları aynı olacaktır. Ancak artık bunların yaşamları farklıdır. Birisinin başına gelen şeyler makineden çıktıktan sonra
    ona özgü olacaktır.)

    fork işlemini yapan proses üst proses (parent process) durumundadır. Yeni yaratılan proses ise alt proses (child process) durumundadır. 
    Tabii alt proses yeni bir proses id'ye sahip olacaktır. Alt prosesin üst prosesi fork fonksiyonu uygulayan proses olacaktır. 
    fork fonksiyonu başarısız olabilir. fork başarısızlık durumunda -1 değerine geri dönmektedir 

    Pekiyi yeni proses hangi noktada yaratılmaktadır? Tabii fork fonksiyonu içerisinde. Yeni yaratılan prosesin (alt prosesin) akışı da 
    fork fonksiyonu içerisinde başlatılacaktır. Bu durumda her iki proses de fork fonksiyonunun içerisinden çıkacaktır. İşte üst proses (yani fork 
    işlemini yapan proses) "alt prosesin id" değeri ile, alt proses ise "0 değeri ile" fork fonksiyonun çıkacaktır. Böylece programcı 
    fork çıkışında üst proses ile alt prosese farklı işlemler yaptırabilmektedir. Alt prosesin fork içerisinden 0 ile çıkması alt prosesin 
    proses id'sinin 0 olduğu anlamına gelmemektedir. Alt prosesin proses id'si alt proses içerisidne getpid fonksiyonuyla elde 
    edilebilmektedir. 

    fork işleminin tipik kalıbı şöyledir:

    pid_t pid;
    ...

    if ((pid = fork()) == -1)
        exit_sys("fork");
    if (pid != 0) {         /* parent process */
        ...
    }
    else {                  /* child process */
        ...
    }

    Aşağıdaki örnekte fork fonksiyonu ile bir proses yaratılmış ve çeşitli proses id'ler üst ve alt proseslerde yazdırılmıştır. 
    Bu örnekte üst proseste fork fonksiyonunun alt prosesin proses id değeri ile geri döndüğüne dikkat ediniz. 
    Denemenin makinede şöyle bir sonuç elde edilmiştir:

    Parent pid: 549376
    Parent's parent pid: 536568
    fork return value: 549377
    common code...
    Child pid: 549377
    Child's parent pid: 549376
    Common code...
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>

void exit_sys(const char *msg);

int main(void)
{
    pid_t pid;

    if ((pid = fork()) == -1)
        exit_sys("fork");

    if (pid != 0) {     /* parent process */
        printf("Parent pid: %lld\n", (long long)getpid());
        printf("Parent's parent pid: %lld\n", (long long)getppid());
        printf("fork return value: %lld\n", (long long)pid);
    }
    else {             /* child process */
        printf("Child pid: %lld\n", (long long)getpid());
        printf("Child's parent pid: %lld\n", (long long)getppid());
    }

    printf("Common code...\n");
    
    sleep(1);

    return 0;
}

void exit_sys(const char *msg)
{
	perror(msg);

	exit(EXIT_FAILURE);
}

/*--------------------------------------------------------------------------------------------------------------------------
    fork işleminde en fazla kafa karıştıran noktalardan biri fork fonksiyonundan iki akışın çıkması durumudur. Burada genellikle 
    yeni öğrennelerin gözden kaçırdığı birkaç nokta vardır:

    1) fork sırasında fork işlemini yapan prosesin (yani üst prosesin) tüm bellek alanının yani onun kod, data, stack ve heap alanlarının 
    özdeş bir kopyası oluşturulmaktadır. Yani fork işlemini yapan prosesin kod, data stack ve heap alanlarının hepsi alt proseste de 
    bulunmaktadır. Örneğin:

    if ((pid = fork()) == -1)
        exit_sys("fork");

    if (pid != 0) {
        ...
    }
    else {
        ...
    }

    Bu kod bu haliyle hem üst proseste hem de alt proseste bulunacaktır. Yani fork işleminden sonra bu kodlardan aslında iki tane vardır. Bizim buradaki 
    temel amacımız fork çıkışında kodu aynı olan iki farklı prosese farklı şeyleri yaptırmaktır. İşte bunu sağlamanın yolu fork 
    fonksiyonunun geri dönüş değerinden faydalanmaktır. 

    2) Yeni öğrenen kişilere iki prosesin de fork fonksiyonundan çıkması tuhaf gelebilmektedir. Aslında burada bir tuhaflık yoktur. 
    Şöyle ki: Prosesin yaratılması ve bellek alanlarının kopyalanması zaten fork içerisinde yapılmaktadır. fork fonksiyonunu çağıran proses 
    (üst proses) fork'tan çıkacaktır. Kopyası çıkartılan alt proses de çalışmaya fork içerisinden başlamaktadır. Bu durumda alt proses de fork fonksiyonundan 
    çıkacaktır. 

    Tabii fork fonksiyonundan çıkınca artık üst proses ile alt prosesin yaşamları farklı olabilmektedir. Örneğin üst proses 
    bir global değişkenin değerini değiştirse alt proses bunu değişmiş olarak görmez. Çünkü o global değişkenin üst proseste ve alt 
    proseste farklı kopyaları vardır. Üst proses kendi global değişkenini değiştirmektedir. Yani fork işleminden çıkıldığında üst ve alt prosesin
    her şeyi aynı olsa da artık bunlar kendi yollarına gideceklerdir. (Bu durumu klon makinesinden çıkan iki kişinin durumuna benzetebiliriz. 
    Klon makinesinden çıkar çıkmaz bu iki kişinin her şeyi aynıdır. Ancak bunan sonra bu kişiler bağımsız kişiler oldukları için başlarına 
    farklı olaylar gelecektir. Birisinin maruz kaldığı bir duruma diğeri maruz kalmayacaktır.)

    Aşağıdaki örnekte fork işlemi sonrasında üst proses g_x global değişkenine yeni bir değer atamıştır. Sonra alt proseste bu 
    global değişkenin değeri yazdırılmıştır. Tabii alt proses üst prosesin yaptığı bu değişikliği görmeyecektir. Çünkü aslında 
    iki prosesin de bellek alanlkarı tamamen fork içerisinde kopyalama yöntemiyle ayrıştırılmıştır. 
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>

void exit_sys(const char *msg);

int g_x = 10;

int main(void)
{
    pid_t pid;

    if ((pid = fork()) == -1)
        exit_sys("fork");

    if (pid != 0) {     /* parent process */
       g_x = 100;
    }
    else {             /* child process */
       sleep(1);
       printf("%d\n", g_x);     /* 10 */
    }

    printf("Common code...\n");
    
    sleep(1);

    return 0;
}

void exit_sys(const char *msg)
{
	perror(msg);

	exit(EXIT_FAILURE);
}

/*--------------------------------------------------------------------------------------------------------------------------
    fork işleminde yeni proses yaratıldığında hangi proses akışının fork fonksiyonundan önce çıkacağının bir garantisi yoktur. 
    Bu işletim sisteminin çizelgeleme algoritmalarına bağlı olarak değişebilmektedir. 
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Aşağıdaki örnekte "Common Code" yazısı 8 defa ekranda görünecektir. Çünkü ilk fork işlemindne sonra ikinci fork işlemini 
    iki proses yapacaktır. Böylece ikinci fork işlemindne sonra aynı koda sahip 4 proses oluşacaktır. Sonra bu 4 proses de üçüncü 
    fork işlemini yapacaktır. O halde üçüncü fork işleminden toplam 8 proses çıkacaktır. Buradaki sleep fonksiyonuna takılmayınız.
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <unistd.h>

int main(void)
{
    fork();
    fork();
    fork();

    printf("Common code...\n");
    sleep(1);

    return 0;
}

/*--------------------------------------------------------------------------------------------------------------------------
    Benzer biçimde yine aşağıdaki kodda ekrana 8 tane 3 sayısı basılacaktır.
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <unistd.h>

int main(void)
{
    int a = 0;
    fork();
    ++a;
    fork();
    ++a;
    fork();
    ++a;

    printf("%d\n", a);
    sleep(1);

    return 0;
}

/*--------------------------------------------------------------------------------------------------------------------------
    fork işlemi sırasında üst prosesin (fork işlemini yapan prosesin) proses kontrol bloğunun yeni yaratılan alt prosesin 
    proses kontrol bloğuna kopyalandığını belirttik. Bu nedenle alt prosesin "kullanıcı id'si, grup id'si, çalışma dizini" ve 
    daha pek çok özellikleri üst prosesle aynıdır. Pekiyi dosya betimleyici tablosunun durumu ne olacaktır? Örneğin biz 
    bir dosya açöış olsak sonra fork yapımış olsak alt proseste bu dosyanın durumu ne olacaktır?

    fork işlemi sırasında işletim sistemi üst prosein dosya betimleyici tablousu içerisindeki dosya nesnelerinin adreslerini de 
    alt prosesin dosya betimleyici tablosuna kopylamaktadır. Ancak dosya nesnelerinin kopyalarında çıkartmamaktadır. Böylece fork 
    işleminin sonunda üst prosesin dosya betimleyici tablosunun slotları ile alt prosesin dosya betimleyici tablosunun slotları yani 
    dosya betimleyicileri aynı dosya nesnesini gösteriyor durumda olur. Bu tür kopyalamalara "sığ kopyalama (shallow copy)" de 
    denilmektedir. Mademki açık dosyaya ilişkin tüm bilgiler dosya nesnesinde tutulmaktadır o halde fork işleminden sonra proseslerden 
    biri bir dosyanın dosya göstericisini değiştirse diğer proses bunu değişmilş olarak görecektir. Tabii fork işlemi sırasında
    dosya nesnelerinin referans sayaçları da bir artırılmaktadır. Benzer biçimde aslında işin başında açık olan 0, 1 ve numaralı betimleyiciler 
    login işlemi öncesinde yaratılmış durrumdadır. Her fork işleminde bu betimleyicilere ilişkin dosya nesnelerinin kopyaları çıkartılmamaktadır. 
    Prosesler aslında genellikle aynı 0, 1 ve 2 numaralı dosya nesnelerini göstermektedir. 

    Aşağıdaki örnekte önce bir dosya açılmış sonra üst proses dosya göstericisini 50'inci offset'e konumlandırmıştır. Üst prosesle alt proses 
    aynı dosya nesnelerini gördüğü için bu durumdan alt proses etkilenecektir. Alt proseste yapılan okuma 50'inci offset'ten itibaren 
    yapılacaktır.
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <fcntl.h>
#include <unistd.h>

void exit_sys(const char *msg);

int main(void)
{
    int fd;
    pid_t pid;
    char buf[10 + 1];
    ssize_t result;

    if ((fd = open("sample.c", O_RDONLY)) == -1)
        exit_sys("open");

    if ((pid = fork()) == -1) 
        exit_sys("fork");

    if (pid != 0) {
        lseek(fd, 50, SEEK_SET); 
    }
    else {
        sleep(1);
        if ((result = read(fd, buf, 10)) == -1)
            exit_sys("read");
        buf[result] = '\0';
        puts(buf);
    }

    close(fd);

    sleep(1);

    return 0;
}

void exit_sys(const char *msg)
{
	perror(msg);

	exit(EXIT_FAILURE);
}

/*--------------------------------------------------------------------------------------------------------------------------
    C'nin standart dosya fonksiyonlarının bir tamponlama mekanizmasıyle çalıştığını görmüştük. Bu durumda biz bir dosyaya 
    fopen fonksiyonu ile açtığımız bir dosyaya bir şeyler yazıp henüz tampon flush edilmeden fork yaparsak tüm bellek alanının kopyası
    çıkartılacağı için bu tamponun da flush edilmemiş bir kopyası oluşacaktır. Bu durum tasarımda sorunlara yol açabilir. Programcının bu durumu 
    dikkate alıp fork işleminden önce fflush yapması gerekebilir. 

    Aşağıdaki örnekte printf fonksiyonu Linux sistemlerinde default durumda "satır tamponlamalı" olan stdout dosyasının tamponuna bilgileri yazmıştır.
    Ancak "\n" karakteri tampona yazılmadığı için flush işlemi de yapılmamıştır. fork işlemi ile birlikte bu tamponun da kopyası çıkarılacağından 
    dolayı ekranda iki tane "Ok" yazısı görünecektir. 

---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>

void exit_sys(const char *msg);

int main(void)
{
    pid_t pid;

    printf("Ok");

    if ((pid = fork()) == -1)
        exit_sys("fork");

    printf("\n");

    return 0;
}

void exit_sys(const char *msg)
{
	perror(msg);

	exit(EXIT_FAILURE);
}

/*--------------------------------------------------------------------------------------------------------------------------
                                                    25. Ders 22/01/2023 - Pazar
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    UNIX/Linux sistemlerinde prosesi sonlandırmak için _exit isimli POSIX fonksiyonu kullanılmaktaır. Bu fonksiyon C'nin 
    standart exit fonksiyonuna benzemektedir. 

    #include <unistd.h>

    void _exit(int status);

    Fonksiyon parametre olarak prosesin "exit kodunu" almaktadır. Tabii bir proses sonlanmadan önce prosesin sistem genelinde 
    tahsis etmiş olduğu kaynaklar boşaltılmaktadır. Yani örneğin biz open fonksiyonu ile birtakım dosyalar açmışsak _exit işlemi
    sırasında bütün bu dosyalar kapatılacaktır. Linux sistemlerinde _exit fonksiyonu doğrusan işletim sisteminin sys_exit isimli
    sistem fonksiyonunu çağırmaktadır. Tabii asıl prosesin sonlandırılması bu sistem fonksiyonuı tarafından yapılmaktadır. 
    Yine geleneksel olarak başarılı sonlnamalar için 0 değeri, başarısız sonlanmalar için sıfır dışı değerler kullanılmaktadır. 

    C'nin standart exit fonksiyonun da prototipi şöyledir:

    #include <stdlib.h>

    void exit(int status);

    C'nin exit fonksiyonu prosesin sonlandırılması için UNIX/Linux sistemlerinde aslında _exit POSIX fonksiyonunu çağırmaktadır:

    exit ----> _exit ----> sys_exit (Linux)

    exit standart C fonksiyonu standart C kütüphanesinde yapılan bazı işlemleri de geri almaktadır. Örneğin exit fonksiyonu önce 
    atexit fonksiyonu ile kaydetterilmiş olan fonksiyonları ters sırada çağırır, sonra tmpfile fonksiyonu ile yaratılmış geçici dosyaları 
    siler ve dosya bilgi göstericilerine (streams) ilişkin tamponları flush eder sonra da bunları kapatır.

    C'de programcı programı içerisinde exit fonksiyonunu hiç çağırmamışsa akış main fonksiyonunu bitirdiğinde main fonksiyonunun geri 
    dönüş değeri ile exit fonksiyonu çağrılmaktadır. Yani C'de main fonksiyonu derleyici tarafından adeta exit(main()) gibi çağrılmaktadır. 
    Yani C'de sonlandırmalar aslında her zaman exit (ya da abort) fonksiyonu ile yapılmaktadır. abort fonksiyonu ise "abnormal" 
    sonlandırmalar için kullanılmaktadır. UNIX/Linux sistemlerinde abort standart C fonksiyonu SIGABRT sinyali oluşturarak programı 
    sonlandırmaktadır. 

    C'de program standart exit fonksiyonu ile sonlandırılmalıdır. Çünkü exit fonksiyonu yukarıda ele aldığımız bazı gerekli son 
    işlemleri de yapmaktadır. Ancak yine de bazen programın doğrusan _exit POSIX fonksiyonu ile sonlandırılması gerekebilmektedir. 
    
    Aşağıdaki örnekte program exit fonksiyonu ile değil _exit fonksiyonu ile sonlandırılmıştır. Bu nedenle atexit ile kaydedilen 
    foo fonksiyonu program sonlanırken çağrılmayacaktır. Aynı zamanda dosya tamponları da flush edilmeyeceğinden dolayı printf 
    fonksiyonu ile ekrana yazılmak istenen ancak satır tamponlaması nedeniyle henüz yazılamayan "ok" yazısı da ekranda görülmeyecektir. 
    Burada _exit çağrısını kaldırırsanız. Akış main fonksiyonunu bitirince exit standart C fonksiyonu çağrılacağı için bir sorun kalmayacaktır.
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>

void foo(void)
{
    fprintf(stderr, "foo\n");
}

int main(void)
{
    atexit(foo);

    printf("ok");

    _exit(0);

    return 0;       
}

/*--------------------------------------------------------------------------------------------------------------------------
    _exit fonksiyonunun parametresi olan exit kodunun hangi değerde olduğu işletim sistemini ilgilendirmemektedir. Yani işletim 
    sistemi bu değeri aslında kullanmamaktadır. İşletim sistemi exit kodunu alır ve saklar. Bunu prosesi yaratan üst proses isterse
    ona verir. Ancak onun hangi değerde olduğu ile ilgilenmez. exit kodunun değeri üst prosesle alt prosesin arasındaki bir 
    anlaşma ile anlam kazanmaktadır. 
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Üst proses fork fonksiyonu ile alt prosesi yarattıktan sonra onun sonlanamasını bekleyebilir ve alt proses sonlandığında 
    onun exit kodunu alabilir. Bunun için wait ve waitpid isimli POSIX fonksiyonları kullanılmaktadır. waitpid fonksiyonu wait 
    fonksiyonunu işlevsel olarak kapsamaktadır. (Zaten önce wait fonksiyonu vardı, onun yetersizlikleri görülünce waitpid fonksiyonu
    tasarlandı).

    wait fonksiyonunun prototipi şöyledir:

    #include <sys/wait.h>

    pid_t wait(int *wstatus);

    wait fonksiyonu herhangi bir alt proses sonlanana kadar "blokede" fonksiyonu çağıran thread'i bekletir. Burada blokede bekleme
    terimi CPU zamanı harcamadan uykuda kalmayı belirtmektedir. Tabii wait fonksiyonu çağrıldığında alt proseslerden biri sonlanmış da 
    olabilir. Bu durumda wait fonksiyonuyu blokeye (yani beklemeye) yol açmaz. wait fonksiyonu başarı durumunda exit kodunu aldığı prosesin 
    id değeri ile geri dönmektedir. Böylece programcı çok sayıda alt prosesin söz konusu olduğu durumda hangi alt prosesin exit kodunu 
    aldığını buradan hareketle anlayabilmektedir. Fonksiyon parametresiyle aldığı int nesnesinin içerisine sonlanan prosesin exit kodunu 
    ve sonlanma nedenine ilişkin bazı bilgileri yerleştirmektedir. 

    Normal biçimde sonlanmamış (yani bir sinyal ile sonlanmış) proseslerde exit kodu oluşmamaktadır. O halde programcının prosesin 
    exit kodunu alabilmesi için onun normal bir biçimde sonlanmış olduğunu belirlemesi gerekmektedir. İşte <sys/wait.h> içerisindeki 
    WIFEXITED makrosu ile bu belirleme yapılabilmektedir. Bu makroya wait fonksiyonuna geçirilmiş olan int nesne verilir. Makro bu 
    nesnenin bazı bitlerinden alt prosesin normal sonlanıp sonlanmadığını anlar ve eğer alt proses normal bir biçimde sonlanmışsa 
    sıfır dışı herhangi bir değere, normal bir biçimde sonlanmamışsa sıfır değerine geri döner. Benzer biçimde biz prosesin anormal 
    bir biçimde bir sinyal dolayısıyla sonlanıp sonlanmadığını da WIFSIGNALED makrosuyla tespit edebiliriz. Proses SIGSTOP sinyali ile
    geçici süre durdurulmuş da olabilir. Bu durum da WIFSTOPPED makrosu ile tespit edilebilmektedir. Prosesin exit kodu ise 
    WEXITSTATUS makrosuyla elde edilmektedir. Yine bu makroya wait fonksiyonuna geçirilen int nesne argüman olarak verilmektedir. 
    Programcı wait fonksiyonuna argüman olarak NULL adres de geçebilir. Bu durumda fonksiyon exit koduyla ilgili bir yerleştirme 
    yapmaz. Ancak yine ilk alt prosesin bitmesini bekler. 

    Eğer wait fonksiyonu çağrıldığında zaten üst prosesin yarattığı herhangi bir alt proses yoksa ya da fonksiyona geçersiz bir adres
    geçilmişse fonksiyon başarısız olabilmektedir. 

    wait fonksiyonunun tasarımında şu problemler vardır:

    - wait fonksiyonu ile biz belli bir alt prosesi bekleyememekteyiz. wait çağrıldığında henüz hiçbir alt proses sonlanmamışsa wait
    fonksiyonu ilk sonlanan alt prosesin exit kodunu alır. 

    - wait fonksiyonu çağrıldığında eğer zaten birden fazla alt proses sonlanmış durumdaysa POSIX standartları hangi alt prosesin 
    exit kodunun elde edileceği konusunda bir garanti vermemektedir. Yani bu durumda wait fonksiyonunun ilk sonlanan alt prosesin exit kodunu alması garanti 
    edilmemiştir.  

    Aşağıdaki örnekte üst proses fork fonksiyonu ile alt prosesi yaratmıştır ve wait fonksiyonu ile onu beklemiştir. 
    Alt proses normal bir biçimde sonlanmışsa onun exit kodunu alıp ekrana yazdırmıştır.
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/wait.h>

void exit_sys(const char *msg);

void child_proc(void)
{
    for (int i = 0; i < 10; ++i) {
        printf("child running: %d\n", i);
        sleep(1);    
    }

    exit(100);
}

int main(void)
{
    pid_t pid;
    int status;

    if ((pid = fork()) == -1)
        exit_sys("fork");

    if (pid == 0)
        child_proc();

    printf("parent waiting for child to exit...\n");

    if (wait(&status) == -1)
        exit_sys("wait");

    if (WIFEXITED(status))
        printf("child exited with exit code %d\n", WEXITSTATUS(status));

    printf("Ok, parent continues running...\n");

    return 0;       
}

void exit_sys(const char *msg)
{
	perror(msg);

	exit(EXIT_FAILURE);
}

/*--------------------------------------------------------------------------------------------------------------------------
    Aşağıdaki örnekte ise üst proses wait fonksiyonu çağırmadan alt proses sonlanmıştır. Tabii bu durumda üst proses hiç beklemeden 
    alt prosesin exit kodunu alıp yoluna devam edecektir. 
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/wait.h>

void exit_sys(const char *msg);

void child_proc(void)
{
    printf("child terminates...\n");

    exit(100);
}

int main(void)
{
    pid_t pid;
    int status;

    if ((pid = fork()) == -1)
        exit_sys("fork");

    if (pid == 0)
        child_proc();
        
   for (int i = 0; i < 10; ++i) {
        printf("parent running: %d\n", i);
        sleep(1);   
    }

    if (wait(&status) == -1)
        exit_sys("wait");

    if (WIFEXITED(status))
        printf("child exited with exit code %d\n", WEXITSTATUS(status));

    printf("Ok, parent continues running...\n");

    return 0;       
}

void exit_sys(const char *msg)
{
	perror(msg);

	exit(EXIT_FAILURE);
}

/*--------------------------------------------------------------------------------------------------------------------------
    Tabii üst proses ne kadar fork yapmışsa o kadar sayıda wait yapmalıdır. Çünkü her wait fonksiyonu bir alt prosesin 
    sonlanma bilgilerini alacaktır.
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/wait.h>

#define NCHILDS     5

void exit_sys(const char *msg);

void child_proc(int val)
{
    srand(val);

    sleep(rand() % 5 + 1);

    exit(val);
}

int main(void)
{
    pid_t pids[NCHILDS];
    int status;

    printf("parent is waiting for childs to exit...\n");

    for (int i = 0; i < NCHILDS; ++i) {
        if ((pids[i] = fork()) == -1)
            exit_sys("fork");
        if (pids[i] == 0)
            child_proc(100 + i);
    }

    for (int i = 0; i < NCHILDS; ++i) {
        if (wait(&status) == -1)
            exit_sys("wait");

        if (WIFEXITED(status))
            printf("child exited with exit code %d\n", WEXITSTATUS(status));
    }

    printf("Ok, parent continues running...\n");

    return 0;       
}

void exit_sys(const char *msg)
{
	perror(msg);

	exit(EXIT_FAILURE);
}

/*--------------------------------------------------------------------------------------------------------------------------
    waitpid fonksiyonu wait fonksiyonun daha gelişmiş bir biçimidir. Fonksiyonun prototipi şöyledir:

    #include <sys/wait.h>

    pid_t waitpid(pid_t pid, int *stat_loc, int options);

    Fonksiyonun birinci parametresi beklenecek alt prosesin proses id değerini belirtir. Bu sayede programcı belli bir alt prosesi bekleyebilmektedir. 
    Bu birinci parametre aslında birkaç biçimde geçilebilmektedir. Eğer bu parametre negatif bir proses id değeri olarak geçilirse 
    bu durumda fonksiyon proses grup id'si bu değerin pozitifi olan herhangi bir alt prosesi beklemektedir. Eğer bu parametre -1 
    olarak geçilirse bu durumda fonksiyon tamamen wait fonksiyonundaki gibi davranmaktadır. Yani herhangi bir alt prosesi beklemektedir.
    Eğer bu parametre 0 olarak geçilirse fonksiyon proses grup id'si waitpid fonksiyonunu çağıran prosesin id'si ile yanı olan 
    herhangi bir alt prosesi beklemektedir. Tabii normal olarak bu parametreye programcı pozitif olan bir proses id geçer. Bu durumda
    fonksiyon  o alt prosesi bekleyecektir. (Tabii bu parametreye geçilen proses id o prosesin bir alt prosesi değilse fonksiyon yine
    başarısız olmaktadır.) Fonksiyonun ikinci parametresi exit bilgisinin yerleştirileceği int türden nesnesnin adresini alır. Üçüncü 
    parametre bazı özel değerlerin bit düzeyinde OR'lanmasıyla oluşturulabilmektedir:

    WNOHANG: Bu durumda waitpid eğer alt proses henüz sonlanmamışsa bekleme yapmaz, başarısızlıkla sonuçlanır. 
    WUNTRACED, WCONTINUED: Prosesin durdurulması ve devam ettirilmesi ile ilgili bilginin elde edilmesinde kullanılmaktadır. 

    Tabii bu üçüncü parametre genellikle 0 geçilmektedir. 0 geçilmesi bu bayraklardan hiçbirinin kullanılmadığı anlamına gelmektedir. 
    O halde aslında wait(&status) çağrısı ile waitpid(-1, &status, 0) eşdeğerdir. 

    waitpid fonksiyonunda da ikinci parametre NULL adres geçilebilir. Bu durumda proses beklenir ama exit bilgileri elde edilmez. 

    waitpid fonksiyonu da başarı durumunda beklenen proses id değeri ile başarısızlık durumunda -1 değeriyle geri dönmektedir. 

    Aşağıdaki örnekte 5 tane alt proses yaratılmış ancak bunlar herhangi bir sırada değil yaratım sırasına göre waitpid fonksiyonu 
    ile beklenmiştir. 
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/wait.h>

#define NCHILDS     5

void exit_sys(const char *msg);

void child_proc(int val)
{
    srand(val);

    sleep(rand() % 5 + 1);

    exit(val);
}

int main(void)
{
    pid_t pids[NCHILDS];
    int status;

    printf("parent is waiting for childs to exit...\n");

    for (int i = 0; i < NCHILDS; ++i) {
        if ((pids[i] = fork()) == -1)
            exit_sys("fork");
        if (pids[i] == 0)
            child_proc(100 + i);
    }

    for (int i = 0; i < NCHILDS; ++i) {
        if (waitpid(pids[i], &status, 0) == -1)
            exit_sys("wait");

        if (WIFEXITED(status))
            printf("child exited with exit code %d\n", WEXITSTATUS(status));
    }

    printf("Ok, parent continues running...\n");

    return 0;       
}

void exit_sys(const char *msg)
{
	perror(msg);

	exit(EXIT_FAILURE);
}

/*--------------------------------------------------------------------------------------------------------------------------
    Programcının fork fonksiyonu ile her yarattığı alt prosesi wait fonksiyonları ile beklemesi iyi bir tekniktir. Aksi halde
    sonraki paragrafta ele alacağımız gibi "hortlak (zombie)" proses problemi olulşabilmektedir. 
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Biz kabuk üzerinden program çalıştırdığımızda fork işlemini kabuk uygulamaktadır. Dolayısıyla çalıştırılan programın exit 
    kodunu da üst proses olan kabuk almaktadır. İşte biz $? ile kabuk üzerinde son çalıştırılan programın exit kodunu 
    elde edebiliriz. Örneğin:

    ./sample
    echo $?
    100

---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    UNIX/Linux sistemlerinde prosesler konusunda çokça karşılaşılan "zombie (hortlak)" proses biçiminde bir kavram vardır. 
    Zombie sözcük anlamı olarak "tam ölememiş canlılar" için kullanılmaktadır. Bir alt proses sonlandığında işletim sistemi onun 
    kaynaklarını boşaltmaktadır. Örneğin prosesin bellek alanı tamamen sisteme iade edilmektedir. Prosesin açmış olduğu dosyalar
    kapatılmaktadır. Ancak işletim sistemi alt prosesin exit kodunu üst prosese iletebilmek için proses kontrol bloğunu proses bittiğinde
    hemen serbest bırakmamaktadır. Proesesin exit kodu proses kontrol bloğunda saklanmaktadır. İşletim sistemi bu exit kodunu
    üst proses herhangi bir zaman isteyebilir diye proses kontrol bloğunu (Linux'taki task_struct yapısı) sisteme iade etmez. 
    Böylece bir alt proses bittiğinde eğer üst proses wait fonksiyonlarıyla alt prosesin exit kodunu henüz almamışsa "kendisi bitmiş 
    ama proses kontrol bloğu boşaltılamamış" bir durum oluşmaktadır. İşte bu duruma UNIX/Linux dünyasında "zombie process" denilmektedir. 
    Zombie proseslerde prosesin id değeri de "üst proses wait ya da waitpid fonksiyonunu kullanabilir" diye sisteme iade edeilmemektedir.
    
    Alt ve üst proseslerin sonlanması şu biçimlerde olabilmektedir:

    1) Üst proses alt prosesten önce sonlanmış olabilir. Bu durumda alt proses "öksüz (orphan)" duruma düşer. Sistem de 1 numaralı 
    id'ye sahip olan "ini"t" prosesini öksüz prosesin üst prosesi olarak atar. Daha sonra alt proses sonlandığında init prosesi alt prosesin exit kodunu 
    alarak onun zombie duruma düşmesini engeller.
    
    2) Alt proses üst prosesten daha önce sonlanmıştır. İşte bu durumda eğer üst proses wait fonksiyonlarını henüz uygulamamışsa
    alt proses zombie durumda kalır. Tabii üst proses wait fonksiyonlarını uyguladığı anda alt proses zombie olmaktan kurtulur.

    3) Alt proses üst prosesten önce sonlanmıştır. Ancak üst proses de wait fonksiyonlarını uygulamadan sonlanmıştır. Bu durumda yine işletim istemi
    artık exit kodunu alacak bir üst proses kalmadığı için alt prosesi zombie olmaktan çıkartır. Yani onun proses kontrol bloğunu ve id değerini boşaltır. 

    O halde zombie proses yalnızca şu süreçte ortaya çıkamktadır: "Alt proses sonlanmıştır ancak üst proses wait fonksiyonlarını uygulamadan 
    çalışmasına devam etmektedir."
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
                                                            26. Ders 28/01/2023 - Cumartesi
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Şimdi bir "zombie" proses durumu oluşturalım. Yapacağımız şey alt prosesi sonlandırıp üst prosesin wait fonksiyonlarını uygulamadan
    yoluna devam etmesini sağlamaktır. Zombie prosesler "ps -l" komutunda "defunct" olarak gösterilmektedir. Bunların "proses durumları da (prcess state)"
    "Z" harfi ile belirtilmektedir. Örneğin:

    kaan@kaan-virtual-machine:~/Study/Unix-Linux-SysProg$ ps -la
    F S   UID     PID    PPID  C PRI  NI ADDR SZ WCHAN  TTY          TIME CMD
    0 S  1000   10612    1868  0  80   0 -   622 hrtime pts/1    00:00:00 sample
    1 Z  1000   10613   10612  0  80   0 -     0 -      pts/1    00:00:00 sample <defunct>
    4 R  1000   10621    1618  0  80   0 -  3540 -      pts/0    00:00:00 ps

---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>

void exit_sys(const char *msg);

int main(void)
{
	pid_t pid;

	if ((pid = fork()) == -1)
		exit_sys("fork");

	if (pid != 0) {			/* üst proses */
		for (int i = 0; i < 60; ++i) {
			printf("parent process continues running: %d\n", i);
			sleep(1);
		}
	}
	else {					/* alt proses */
		printf("child terminates...\n");

		exit(EXIT_SUCCESS);
	}

	return 0;
}

void exit_sys(const char *msg)
{
	perror(msg);

	exit(EXIT_FAILURE);
}

/*--------------------------------------------------------------------------------------------------------------------------
    Zombie proses oluşmasının şu sorunları vardır:

    - Üst prosesin ömrü fazla değilse genellikle üst prosesin zombie proses oluştruması ciddi bir soruna yol açmaz. Ancak üst proses
    uzun süre çalışıyorsa (günlerce, aylarca) zombie prosesler önemli bir sistem kaynağının harcanmasına yol açabilmektedir. 

    - Zombie proseslere ilişkin proses id değerleri o proses zombie'likten kurtulana kadar sistem tarafından kullanılamamaktadır. 
    Sürekli zombie proses üreten bir program proses id'lerin tükenmesine bile yol açabilmektedir. 
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Pekiyi zombie proses oluşmasının engellenmesinin tek yolu wait fonksiyonlarını uygulamak mıdır? Çünkü wait fonksiyonları
    uygulandığında üst proses alt proses bitene kadar blokede bekleycektir. Halbuki bazı uygulamalarda üst prosesin yoluna devam etmesi 
    ve bloke olmaması istenir. İşte zombie oluşmasının otomatik engellenmesi için iki yöntem kullanılmaktadır:

    1) Alt proses bittiğinde SIGCHLD sinyalinde üst proses wait fonksiyonlarını uygularsa üst proses blokede kalmadan zombie durumunu engelleyebilir. 

    2) Biz alt prosesin exit kodunu almak istemediğimizi işletim sistemine söylersek işletim sistemi alt proses bittiğinde onu zombie
    duruma sokmadan onun kaynaklarını boşaltabilmektedir. 

    Bu iki zombie engelleme yöntemi de "sinyal (signal)" denilen konu ile ilgildir. Bu konu ileride ele alınacaktır.
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Modern işletim sistemlerinin büyük çoğunluğunda prosese özgü ismine "çevre değişkenleri (environment variables)" denilen 
    bir veri yapısı bulundurulmaktadır. Çevre değişkenleri anahtar-değer çiftlerini tutan anahtar verildiğinde onun değerini 
    bize veren "sözlük (dictionary)" tarzı bir veri yapısı organizasyonudur. Tabii sözlük tarzı veri yapıları pek çok nesne yönelimli
    programlama dilinin standart kütüphanesinde "map", "set", "dictionary", "hashtable" gibi isimlerle bulunmaktadır. Ancak 
    çevre değişkenleri bir sözlük veri yapısının basit bir biçimde işletim sistemi tarafından aşağı seviyeli bir gerçekleştirimidir. 
    
    Çevre değişkenleri konusunda anahtar-değer çiftlerinin anahtarlarına "çevre değişkeni (environment variable)" denilmektedir. 
    O anahatara karşı gelen değere de "o çevre değişkeninin değeri" denir. Çevre değişkenlerinin anahtarları da değerleri de birer 
    yazı biçimindedir. Örneğin anahtar "ankara" yazısı olabilir, onun değeri de "06" yazısı olabilir. Anahtar "eskisehir" yazısı olabilir
    onun değeri de "26" yazısı olabilir. 

    Çevre değişkenleri ve değerleri pek çok işletim sisteminde prosesin bellek alanı içerisinde tutulmaktadır. Örneğim Windows sistemleri, 
    UNIX/Linux sistemleri tipik olarak çevre değişkenlerini proses bellek alanı içerisinde özel bir alanda tutmaktadır. 
    Bu konu çerçevesinde programcının şu işlemleri yapabilmesi gerekmektedir:

    - Bir çevre değişkeni (yani anahtar) verildiğinde onun değerini elde etmek.
    - Prosesin çevre değişken listesine yeni bir anahtar-değer çifti eklemek
    - Prosesin tüm çevre değişken listesini elde etmek.

    UNIX/Linux sistemlerinde prosesin çevre değişkenlerinin (yani anahtarların) büyük harf-küçük harf duyarlılığı vardır. Ancak Windows sistemlerinde
    çevre değişkenlerinin büyük harf-küçük harf duyarlılığı yoktur. Genel olarak çevre değişkenleri (yani anahtarlar) boşluk karakterleri 
    içermemektedir. 
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Bir çevre değişkeni (yani anahtar) verildiğinde onun değerini elde etmek için getenv isimli standart C fonksiyonu kullanılabilir. 
    Fonksiyonun prototipi şöyledir:

    #include <stdlib.h>

    char *getenv(const char *name);

    Fonksiyon parametre olarak çevre değişkeninin ismini (yani anahtarı) alır geri dönüş değeri olarak onun değerinin bulunduğu bellek adresini 
    verir. Fonksiyonun geri döndürdüğü adres prosesin adres alanı içerisindeki statik düzeyde tahsis edilmiş bir alanın adresidir. 
    Fonksiyon eğer ilgili çevre değişkeni yoksa NULL adrese geri dönmektedir. Fonksiyonun geri dönüş değeri const olmayan bir gösterici olsa da
    programcı geri döndürülen bu adresteki yazıyı değiştirmeye çalışmamalıdır. C standartlarında bu değiştirme durumu işletim sisteminin
    isteğine bırakılmış olsa da UNIX/Linux sistemlerinde bu durum tanımsız davranışa yol açmaktadır. getenv fonksiyonu başarısızlık durumunda 
    errno değişkenini herhangi bir değerle set etmemektedir. 

    Aşağıdaki örnekte komut satırından alınan çevre değişkeninin değeri stdout dosyasına yazdırılmıştır.
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>

int main(int argc, char *argv[])
{
	char *value;

	if (argc != 2) {
		fprintf(stderr, "wrong number of arguments!..\n");
		exit(EXIT_FAILURE);
	}

	if ((value = getenv(argv[1])) == NULL) {
		fprintf(stderr, "environment variable not found: %s\n", argv[1]);
		exit(EXIT_FAILURE);
	}

	puts(value);

	return 0;
}

/*--------------------------------------------------------------------------------------------------------------------------
    Prosesin çevre değişkenleri fork işlemi sırasında üst prosesten alt prosese aktarılmaktadır. Zaten çevre değişkenleri 
    prosesin bellek alanaında saklandığından fork işlemi de prosesin bellek alanının bir kopyasını oluşturduğundan bu işlemin 
    doğal sonucu olarak üst prosesin çevre değişkenleri alt prosese aktarılmaktadır. Örneğin biz kabuk üzerinden bir program 
    çalıştırdığımızda kabuğun çevre değişkenleri bizim programımıza aktarılacaktır. 

    Kabuğun çevre değişken listesi env kabuk komutuyla her satırda "anahtar=değer" biçiminde görüntülenebilmektedir. 

    Pekiyi kabuk programındaki çevre değişkenleri nasıl oluşturulmuştur? İşte prosesler birbirlerini yaratırken kabuk prosesine gelene 
    kadar bazı prosesler çevre değişkenlerine eklemeler yapmaktadır. Örneğin kabuk programını çalıştıran login programı "HOME", "USER"
    "SHELL" gibi çevre dğeişkenlerini prosesin çevre değişken listesine eklemektedir. Benzer biçimde kabuk da pek çok çevre değişkenini
    çevre değişken listesine eklemiş durumdadır. Yani biz programımızı kabuk üzerinden çalıştırırken kümülatif olarak çeşitli prosesler
    çevre değişken listesine çeşitli çevre değişkenlerini eklemiş olmaktadır. Örneğin biz kabuk üzerinde "cd" komutunu kullandığımızda
    kabuk PWD isimli çevre değişkeninin değerini o anda geçilen dizin biçiminde değiştirmektedir. chdir POSIX fonksiyonu bunu yapmaz. 
    Kabuktaki "cd" komutu bunu yapmaktadır. 

    Kabuk üzerinde bir çevre değişkenini başına $ olacak biçimde yazarsak kabuk sanki o yazı yerine onun değerine ilişkin yazıyı oraya
    yazmışız gibi davranmaktadır. Örneğin biz kabul üzerinde $PATH yazarsak kabuk bu $PATH yazısını kaldırıp onun yerine onun değerini 
    oraya yerleştirecektir. (Aynı işlem Windows sistemlerinde %NAME% ile yapılmaktadır.)
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
                                                    27. Ders 29/01/2023 - Pazar
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Prosesin çevre değişken listesine yeni bir anahtar-değer çifti eklemek için setenv ve putenv isimli POSIX fonksiyonları kullanılmaktadır. 
    Bu fonksiyonlar standart C fonksiyonları değildir. C'de prosesin çevre değişken listesine ekleme yapan standart bir fonksiyon yoktur.

    setenv fonksiyonunun prototipi şöyledir:

    #include <stdlib.h>

    int setenv(const char *name, const char *value, int overwrite);

    Fonksiyonun birinci parametresi çevre değişkeninin ismini ikinci parametresi onun değerini alır. Üçüncü parametre eğer o çevre değişkeni zaten varsa
    onun değerinin değiştirilip değiştirilmeyeceğini belirtir. Bu parametre sıfır dışı bir değer olarak geçilirse çevre değişkeninin değeri 
    değiştirilir. Sıfır geçilirse değiştirilmez ve fonksiyon yine başarıyla geri döner. Fonksiyon başarı durumunda 0 değerine, başarısızlık durumunda -1
    değerine geri dönmektedir. Başarısızlık durumunda errno değeri uygun biçimde set edilmektedir. 

    Aşağıdaki örnekte komut satırı argümanı ile verilen çevre değişkenleri setenv fonksiyonu ile prosesin çevre değişken listesine 
    eklenmiş ve sonra getenv fonksiyonu ile onların değerleri elde edilmiştir. Girişin aşağıdaki gibi yapılması gerekir:

    ./sample ali=100 veli=200 selami=300

    Program '=' karakterini strchr fonksiyonu ile aramış eğer onu bulursa '=' karakteri yerine '\0' karakterini yerleştirmiştir. 
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

int main(int argc, char *argv[])		
{
	char *str;

	if (argc == 1) {
		fprintf(stderr, "too few arguments!..\n");
		exit(EXIT_FAILURE);
	}

	for (int i = 1; i < argc; ++i)	{
		if ((str = strchr(argv[i], '=')) == NULL) {
			fprintf(stderr, "invalid argument: %s\n", argv[i]);
			continue;
		}
		*str = '\0';
		if (setenv(argv[i], str + 1, 1) == -1)
			perror("setenv");
	}

	for (int i = 1; i < argc; ++i) {
		if ((str = getenv(argv[i])) == NULL) {
			fprintf(stderr, "environment variable not found: %s\n", argv[i]);
			continue;
		}
		printf("%s ---> %s\n", argv[i], str);
	}

	return 0;
}

/*--------------------------------------------------------------------------------------------------------------------------
    putenv fonksiyonu da yine prosesin çevre değişken listesine ekleme yapmak için kullanılmaktadır. Fonksiyonun prototipi şöyledir:
    
    #include <stdlib.h>

    int putenv(char *str);

    Fonksiyon parametre olarak "anahtar=değer" biçiminde bir yazı almaktadır. Fonksiyon ilgili çevre değişkeni zaten varsa her zaman 
    onun değerini güncellemektedir. Eğer yazıda '=' karakteri kullanılmazsa boş değeri boş olan (yani elde edildiğinde yalnızca null karakter
    veren bir çevre değişkeni oluşturulmaktadır. Fonksiyon yine başarı durumunda 0 değerine başarısızlık durumunda -1 değerine geri döner ve
    errno değişkeni uygun biçimde set edilir.) putenv fonksiyonunda verilen adres doğrudan prosesin çevre değişken listesi olarak kullanılmaktadır. 
    Verilen adresteki bilginin program çalıştığı sürece kalıcı olmasına dikkat ediniz. 

    Aşağıdaki örnekte yine program aşağıdakine benzer çalıştırılmalıdır:

    ./sample ali=100 veli=200
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

int main(int argc, char *argv[])		
{
	char *str;
	
	if (argc == 1) {
		fprintf(stderr, "too few arguments!..\n");
		exit(EXIT_FAILURE);
	}

	for (int i = 1; i < argc; ++i)	
		if (putenv(argv[i]) == -1)
			perror("putenv");

	/* ... */

	return 0;
}

/*--------------------------------------------------------------------------------------------------------------------------
    Aşağıdaki örnekte putenv fonksiyonu ile prosesin çevre değişken listesine bir ekleme yapılmıştır. Sonra buradaki anahtar değer
    çifti program içerisinde değiştirilmiştir. Prosesin çevre değişken listesinin nasıl organize edildiği izleyen paragrafta ele alınmaktadır.
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

void exit_sys(const char *msg);

int main(void)
{
    char *value;
    char env[1024] = "city=istanbul";

    if (putenv(env) == -1)
        exit_sys("setenv");
    
    if ((value = getenv("city")) == NULL) {
        fprintf(stderr, "cannot find environment variable \"city\"!..\n");
        exit(EXIT_FAILURE);
    }

    puts(value);
    
    strcpy(env, "village=urla");

    if ((value = getenv("village")) == NULL) 
        fprintf(stderr, "cannot find environment variable \"village\"!..\n");

    puts(value);
    
    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/*--------------------------------------------------------------------------------------------------------------------------
    UNIX/Linux sistemlerinde genel olarak çevre değişkenleri bir gösterici dizisi yoluyla tutulmaktadır. Her çevre dğeişkeni aslında 
    "anahtar=değer\0" biçiminde bir yazı olarak oluşturulmakta ve bu yazıların başlangıç adresleri de bir gösterici dizisinde saklanmaktadır. 
    Bu gösterici dizisinin sonunda da NULL adres bulunmaktadır. Bu gösterici dizisinin başlangıç adresi environ isimli bir global 
    göstericiyi gösteren göstericiyle tutulmaktadır. Yani prosesin çevre değişken listesi aşağıdaki gibi bir veri yapısıyla oluşturulmuştur:

    environ ---->   adres   ---> ali=100\0
                    adres   ---> veli=200\0
                    adres   ---> selami=300\0
                    ...
                    NULL

    Aslında putenv fonksiyonu bizim "anahtar=değer" biçiminde verdiğimiz yazının adresini eğer anahtar yoksa doğrudan
    bu gösterici dizisine eklemektedir. Örneğin:

    char s[] = "ayse=500";

    putenv(s);

    environ ---->   adres   ---> ali=100\0
                    adres   ---> veli=200\0
                    adres   ---> selami=300\0
                    ...
                    s dizisinin adresi  ----> ayse=500\0
                    NULL

    Maalesef bu environ global değişkeninin extern bildirimi herhangi bir başlık dosyasında bulundurulmamıştır. Prosesin çevre 
    değişken listesine erişmek isteyen programcıların bu extern bildirimini kendilerinin yapması gerekmektedir. Örneğin:

    extern char **environ;

    O halde prosesin bütün çevre değişkenlerinin listesini almak oldukça kolaydır. Aşağıdaki örnekte prosesin tüm çevre değişkenlerinin listesi 
    elde edilmiştir. 
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>

extern char **environ;

int main(void)		
{
	for (int i = 0; environ[i] != NULL; ++i)
		puts(environ[i]);

	return 0;
}

/*--------------------------------------------------------------------------------------------------------------------------
    getenv fonksiyonu aşağıdaki gibi basit bir biçimde gerçekleştirilebilir. 
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

extern char **environ;

char *mygetenv(const char *name)
{
	char *str;

	for (int i = 0; environ[i] != NULL; ++i) {
		if ((str = strchr(environ[i], '=')) != NULL)	
			if (!strncmp(name, environ[i], str - environ[i]))
				return str + 1;
	}

	return NULL;
}

int main(void)		
{
	char *val;

	if ((val = mygetenv("xxx")) == NULL) {
		fprintf(stderr, "environment variable not found!..\n");
		exit(EXIT_FAILURE);
	}
	puts(val);

	return 0;
}

/*--------------------------------------------------------------------------------------------------------------------------
    Prosesin çevre değişkenlerine ilşkin gösterici dizisi ve onların gösterdikleri yerler prosesin bellek alanı içerisindedir. 
    fork işlemi sırasında üst prosesin tüm bellek alanının bir kopyası oluşturulduğuna göre alt prosesin çevre değişken listesi üst
    prosesinkini aynısı olacaktır. Ancak fork işleminden sonra üst proses ya da alt proses çevre değişken listesinde bir değişiklik 
    yaparsa artık yalnızca o değişiklik o prosese özgü olacaktır. Çünkü fork işlemi sırasında kopyalama yapıldıktan sonra artık üst prosesle
    alt prosesin bellek alanlarını biribirinden tamamen ayrılmış olur. 
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Bir çevre değişkeni unsetenv isimli POSIX fonksiyonuyla prosesin çevre değişken listesinden silinebilmektedir. Fonksiyonun prototipi
    şöyledir:

     #include <stdlib.h>

    int unsetenv(const char *name);

    Fonksiyon çevre değişkenin ismini almaktadır. Başarı durumunda 0 değerine başarısızlık durumunda -1 değerine geri önder ve errno 
    uygun biçimde set edilir. Eğer ilgili çevre değişkeni zaten yoksa fonksiyon bir şey yapmaz ancak başarılı bir biçimde geri dönmektedir. 

    Aşağıdaki örnekte komut satırından alınan bir çevre değişkeninin önce değeri yazdırılmış sonra o çevre değişkeni silinmiş, sonra da 
    o çevre değişkeninin yeniden değeri elde edilmek istenmiştir. 
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>

void exit_sys(const char *msg);

int main(int argc, char *argv[])
{
	char *value;

	if (argc != 2) {
		fprintf(stderr, "wrong number of arguments!..\n");
		exit(EXIT_FAILURE);
	}

	if ((value = getenv(argv[1])) == NULL) {
		fprintf(stderr, "environment variable not found: %s\n", argv[1]);
		exit(EXIT_FAILURE);
	}

	puts(value);

	if (unsetenv(argv[1]) == -1)
		exit_sys("ensetenv");

	if ((value = getenv(argv[1])) == NULL) {
		fprintf(stderr, "environment variable not found: %s\n", argv[1]);
		exit(EXIT_FAILURE);
	}	
	
	puts(value);

	return 0;
}

void exit_sys(const char *msg)
{
	perror(msg);

	exit(EXIT_FAILURE);
}

/*--------------------------------------------------------------------------------------------------------------------------
    Pekiyi biz programımızı çalıştırdığımızda belli bir çevre dğeişkeninin zatenvar olmasını nasıl sağlayabiliriz? 
    Çevre değişkenleri fork sırasında alt prosese aktarıldığına göre biz eğer kabul programın (bash) çevre değişken listesine 
    bir ekleme yaparsak kabuk bizim programınızı çalıştırırken fork yapacak ve onun çevre değişkenleri bizim programımıa geçecektir. 
    Pekiyi kabuk programının çevre değişken listesine nasıl ekleme yapabiliriz? İşte bu işlem şöyel yapılabilmektedir:

    kaan@kaan-virtual-machine:~/Study/Unix-Linux-SysProg$ CITY=Eskisehir
    kaan@kaan-virtual-machine:~/Study/Unix-Linux-SysProg$ export CITY

    Komut satırında "anahtar=değer" biçiminde bir yazı yazıp ENTER tuşuna basarsak biz kabuk dili için bir kabuk değişkeni yaratmış 
    oluruz. Bu kabuk değişkeninin aynı zamanda kabuğun çevre değişkeni yapılması için export komutu kullanılmaktadır. Tabii bu iki 
    komut tek hamlede de verilebilmektedir:

    export CITY=Eskisehir

    Bu durumda hem kabuk değişkeni yaratılmış olur hem de bu değişken prosesin çevre değişkeni yapılır. 

    Kabuk üzerinde yukarıdaki gibi çevre değişkeni oluşturduğumuzda bunun kalıcılığı olmaz. Yani bu çevre değişkeni o kabuk programının 
    çevre değişkeni olur. Biz başka terminal açsak o başka bir proses olacağı için bu çevre dğeişkeni orada bulunmayacaktır. Pekiyi bunun kalıcılığını
    nasıl sağlayabiliriz? İşte bunu sağlamak için kabukların "startup" dosyaları kullanılmaktadır. Kabukların startup dosyaları kabuğun nasıl çalıştırıldığına 
    bağlı olarak değişmektedir. Kabuk programları üç biçimde çalıştırılabilmektedir:

    1) Interactive login shell
    2) Interatictine Non-login shell
    3) Non-interactive shell

    "Interactive shell" demek "komut satrına düşüen kullanıcının komuyt verip çalıştırdığı shell" demektir. "login shell" demek bize "user name" ve
    "password" soran shell demektir. "Non-interactive shell" tek bir komutu çalıştırıp işlemini sonlandıran shell demektir. 
    Değişik kabuk programlarının startup dosyaları farklıdır. Biz burada bash üzerinde duracağız. bash kabuğunun "user manuel" dokümanındaki
    ilgili bölüm aşağıdaki bağlantıdan incelenebilir:

    https://www.gnu.org/software/bash/manual/html_node/Bash-Startup-Files.html

    Eğer bash "Interactive login shell" biçiminde çalıştırılmışsa önce /etc/profile dosyasını çalıştırır sonra sırasıyla aşağıdaki dosyalardan 
    hangisini ilk bulursa yalnız onun içerisindeki komutları çalıştırmaktadır:
    
    ~/.bash_profile
    ~/.bash_login
    ~/.profile 

    Eğer bash "interactive non-login shell" olarak çalıştırılırsa (örenğin masaüstünden) bu durumda  bash ~/.bashrc dosyasındaki 
    komutları çalıştırmaktadır. Bu duurmda biz .bashrc dosyasına export ile çevre değişkeni eklersek masaüstünden terminali açtığımızda 
    o çevre değişkeni kabuk üzerinde ekli olarak görünecektir. Tabii programcı hem "interactive login shell" hem de "interactive non-login"
    shell için aynı komutların çalıştırılmasını isteyebilir. Bunu sağlamanın pratik bir yolu komutları ~/.bashrc dosyasına yazıp ~/.bash_profile
    içerisinden bu dosyanın çalıştırılmasını aşağıdaki gibi sağlamktır:

    if [ -f ~/.bashrc ]; then . ~/.bashrc; fi

    Eğer bash interactive olmayan bir biçimde (-c seçeneği ile) çalıştırılırsa bu durumda BASH_ENV isimli bir çevre dğeişkenini araştırır. 
    Eğer bulursa onun değerinin belirttiği script dosyasını çalıştırır. 
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Pekiyi çevre değişkenlerine neden gereksinim duyulmaktadır? Çevre değişkenleri birtakım aşağı seviyeli işlemlerin paramtrik hale
    getirilmesi için kullanılmaktadır. Yani aşağı seviyeli bazı işlemlerin basit bir biçimde dışarıdan değiştirilmesine olanak 
    sağlamaktadır. Bazı çevre değişkenleri bazı POSIX fonksiyonları tarafından kullanılmaktadır. Örneğin exec fonksiyonlarının 
    p'li biçimleri prosesin PATH çevre değişkenine başvurmaktadır. Ya da örneğin dinamik bir kütüphane yüklenirken işletim sisteminin 
    yükleyicisi prosesin LD_LIBRARY_PATH çevre değişkenine başvurmaktadır. Bazen çevre değişkenleri uygulama programcıları tarafından da kullanılmaktadır. 
    Örneğin biz programımız içerisinde bir dosyanın yerini belirlemek isteyelim. Ancak kullanıcı bu dosyayı farklı bir yere yerleştirebiliyor olsun.
    Bunu bir çevre değişkeni ile ayarlanabilir hale getirebiliriz:

    char *data_path = "datafile.dat";
	char *value;
	FILE *s;

	if ((value = getenv("DATA_LOCATION")) != NULL)
		data_path = value;

	if (f = fopen(data_path, "r")) == NULL) {
		fprintf(stderr, "cannot open file!..\n");
        exit(EXIT_FAILURE);
	}
	...

    Örneğin gcc derleyicisi <...> biçiminde include edilmiş dosyaların yerlerini aynı zamanda C_INCLUDE_PATH isimli bir çevre değişkeninde de aramaktadır. 
    Yani derleyici standart include dosyalarının bulunduğu yerin dışında bu çevre değişkeni ile belirtilen dizinlere de bakmaktadır. 
    Tabii birden fazla dizin belirtilebilir bu durumda ':' ile onları ayırmak gerekir. Örneğin:

    export C_INCLUDE_PATH=/home/kaan:/home/kaan/Study

---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Bir program dosyasını çalıştırmak için ismine "exec fonksiyonları" denilen bir grup POSIX fonksiyonu kullanılmaktadır. 
    Bu fonksiyonların yaptıkları işlemler birbirine benzerdir. Ancak fonksiyonların parametrik yapıları arasında bazı farklılıklar vardır. 
    exec fonksiyonlarını şunlardır:

    execl
    execle
    execlp
    execv
    execve (Linux'ta sistem fonksiyonu olarak yazılmıştır)
    execvp
    fexecve (Linux'ta execveat sistem fonksiyonu)

    Ayrıca POSIX standartlarında tanımlı olmasa da da GNU C kütüphanesinde execvpe isimli bir exec fonksiyonu da bulunmaktadır. 
    Yine Linux sistemlerine özgü bir biçimde execveat isimli bir fonksiyon da vardır.

    Aslında UNIX/Linux sistemleri bu exec fonksiyonlarının hepsini sistem fonksiyonu biçiminde bulundurmamaktadır. Örneğin Linux sistemlerinde 
    execve fonksiyonu bir sistem fonksiyonu biçiminde yazılmıştır. Taşınabilir exec fonksiyonları bu sistem fonksiyonunu çağıran kütüphane
    fonksiyonları biçiminde gerçekleştirilmiştir. Benzer biçimde Linux'a özgü biçimde "execveat" fonksiyonu da bir sistem fonksiyonu 
    biçimine gerçekleştirilmiştir. 
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    exec fonksiyonları prosesin yaşamına başka bir kodla devam etmesini sağlamaktadır. exec fonksiyonlarına biz "çalıştırılabilen bir program dosyasını"
    parametre olarak veririz. exec fonksiyonları o anda çalışmakta olan programon kodlarını bellekten atıp onun yerine bizim vediğimiz
    program dosyasının kodlarını bellee yükler ve o kodu çalıştırır. exec işlemi ile prosesin kontrol bloğunda ciddi bir değişiklik yapılmaz. 
    Yani prosesin id'si kullanıcı id'si, grup id'si prosesin çalışma dizini vs. değişmez. Exec işlemleriyle prosesin yalnızca kodu 
    değiştirilmektedir. Örneğin sample programının içerisinde biz exec fonksiyonlarıyla "mample" programını çalıştırmak istediğimizde
    "sample" programının bellekteki kodu kaldırılır onun yerine "mample" programının kodu belleğe yüklenir ve "mample" program kodu 
    çalıştırılır. Ancak prosesin kontrol bloğundaki bilgiler değişmez. Yani proses yaşamına başka bir kodla devam eder.
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
                                                    28. Ders 04/02/2023 - Cumartesi
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    exec fonksiyonlarının isimlerinin sonlarında bulunan "l" harfi (execl, execlp) komut satırı argümanlarının tek tek bir liste 
    biçiminde verileceğini belirtmektedir. Fonksiyonların isimlerinin sonundaki "v" harfi ise komut satırı argümanlarının bir dizi (vector)
    biçiminde verileceğini belirtir. Fonksiyonların isimlerinin sonlarındaki "p" harfi (path) aramanın PATH çevre değişkenine bakılarak yapılacağı, 
    "e" harfi (environment)ise  prosesin çevre değişkenlerinin exec sırasında değiştirileceği anlamına gelmektedir. Yukarıda da belirtildiği 
    gibi Linux sistemlerinde execl, execv, execlp, execvp, execle fonksiyonları aslında execve sistem fonksiyonu fonksiyonu çağrılarak 
    gerçekleştirilmiştir. fexecve ise Linux sistemlerinde execveat sistem fonksiyonu çağrılarak gerçekleştirilmiştir. Biz burada 
    bu fonksiyonların üzerinde tek tek duracağız. 

    Tüm exec fonksiyonları başarı durumunda geri dönmezler. Çünkü zaten başarı durumunda bu fonksiyonlar başka bir programı 
    yüklemiş ve çalıştırmış durumda olurlar. Bu fonksiyonlar başarısızlık durumunda yine -1 değerine geri dönerler ve errno değeri
    uygun biçimde set edilir. 
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    execl fonksiyonunun prototipi şöyledir:

    #include <unistd.h>

    int execl(const char *path, const char *arg0, ... /*, (char *)0 */);                                               

    Fonksiyonun birinci parametresi çalıştırılacak olan programın yol ifadesini almaktadır. Bu yol ifadesi mutlak ya da göreli
    olabilir. Fonksiyonun diğer parametreleri sırasıyla çalıştırılacak programa geçirilecek komut satırı argümanlarının listesini 
    belirtir. Birinci komut satırı argümanının (argv[0]) her zaman program ismi olacak biçimde oluşturulması genel bir beklenti ve C standartlarında
    öngörülen bir durumdur. Programcı exec uygularken bunu sağlamak zorunda değildir. Ancak bunun sağlanmaması kötü bir tekniktir. 
    Fonksiyon değişken sayıda (... parametresine dikkat ediniz) argüman aldığı için argüman listesinin sonunda NULL adresin bulunması gerekmektedir. 
    Ancak C'de "default argüman dönüştürmesi (default argument conversion)" denilen kurala göre eğer argümanın karşılığında bir parametre 
    türü belirtilmemişse "int türünden küçük türler int türüne, float ise double türüne dönüştürülerek" fonksiyona yollanmaktadır. 
    Burada programcının NULL adres sabitini yalnızca NULL sembolik sabiti biçiminde belirtmemesi gerekir. Çünkü NULL sembolik sabiti düz sıfır
    olarak da define edilmiş olabilir. Benzer biçimde programcı burada NULL adres sabiti için düz sıfır da geçmemelidir. Uygun olan durum
    düz sıfır değerinin ya da NULL sembolik sabitinin bir adres türüne (tipik olarak char * türüne) dönüştürülerek aktarılmasıdır. 
    Yukarıda da belirtildiği exec fonksiyonları başarı durumunda zaten geri dönmezler. Başrısızlık durumunda -1 değerine geri dönerler ve 
    errno değişkeni uygun biçimde set edilir. Örneğin:

    if (execl("mample", "mample", "ali", "veli", "selami", (char *)0) == -1)
		exit_sys("execl");

	/* unreachable code */

    Burada execl ile prosesin çalışma dizininde bulunan "mample" programı çalıştırılmak istenmiştir. Diğer argümanlar mample programının 
    main fonksiyonunun argv parametresine geçirilecek komut satırı argümanlarını belirtmektedir. 

    exec fonksiyonları çeşitli nedenlerle başarısız olabilir. Örneğin çalıştırılacak program dosyası bulunamayabilir, bulunduğu halde proses
    dosya için "x" hakkına sahip olmayabilir, çalıştırılabilen dosyanın formatı bozulmuş olabilir. Bu durumlarda ernno değeri uygun biçimde set edilir. 

    Aşağıdaki örneği inceleyiniz. Aşağıdaki sample programı çalıştırıldığında ekranda şu yazıların çıkması gerekir:

    sample running...
    mample running...
    mample
    ali
    veli
    selami
---------------------------------------------------------------------------------------------------------------------------*/

/* sample.c */

#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>

void exit_sys(const char *msg);

int main(void)
{
	printf("sample running...\n");
	
	if (execl("mample", "mample", "ali", "veli", "selami", (char *)0) == -1)
		exit_sys("execl");

	/* unreachable code */

	return 0;
}

void exit_sys(const char *msg)
{
	perror(msg);

	exit(EXIT_FAILURE);
}

/* mample.c */

#include <stdio.h>

int main(int argc, char *argv[])
{
    printf("mample running...\n");

    for (int i = 0; i < argc; ++i)
        puts(argv[i]);

    return 0;
}

/*--------------------------------------------------------------------------------------------------------------------------
    Mademki exec fonksiyonları başarılı olduğunda zaten geri dönmemektedir. O halde exec işlemi aşağıdaki gibi de yapılabilir:

    exec(.....);
    exit_sys("exec);

    Burada exec zaten başarılı olduğunda akış aşağıya geçmeyecektir. Başarısız olduğunda akış aşağıya geçecektir. Bu durumda kontrol 
    yapmaya aslında gerek yoktur. Fakat biz kursumuzda genel olarak exec işlemini aşağıdaki gibi yapacağız:

    if (exec(....) == -1)
        exit_sys("exec");
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    fork işlemi ile yeni bir proses yaratılıp yeni prosesin üst proses ile aynı kodu çalıştırması sağlanıyordu. exec işlemi ile ise
    prosesin kodunun atılıp başka bir programın kodu çalıştırılıyordu. Pekiyi biz hem kendi programımız devam etsin hem de başka bir 
    programı da çalıştıralım istiyorsak bunu nasıl yapabiliriz? İşte bu durumda yalnızca fork ya da yalnızca exec işe yaramamaktadır.
    fork ve exec fonksiyonlarının birlikte kullanılması gerekmektedir. Şöyle ki: Üst proses önce fork yapar, alt proseste exec işlemini 
    uygular. Yani başka bir programın kodunu alt proses çalıştırmış olur. Bu işlem tipik olarak şöyle yapılabilir:

    pid_t pid;

    if ((pid = fork()) == -1)
        exit_sys("fork");

    if (pid == 0) 
        if (exec(...) == -1)
            exit_sys("exec");

    /* Yalnızca üst prosesin akışı buraya gelir */

     Burada exec başarılı olursa zaten artık alt prosesin bellek alanı boşaltılıp yeni program yüklenecektir. exec başarısız olursa 
    zaten alt proses sonlandırılmıştır. Tabii yukarıdaki kalıp && operatörüyle de şöyle oluşturulabilir:

    pid_t pid;

    if ((pid = fork()) == -1)
        exit_sys("fork");

    if (pid == 0 && exec(...) == -1)
        exit_sys("exec");

    /* Yalnızca üst prosesin akışı buraya gelir */

    Tabii üst prosesin yine alt prosesi wait fonksiyonlarıyla beklemesi gerekmektedir. exec işlemi yapılmış olsa da bu bakımdan değişen
    bir şey yoktur. Çalıştırılan programa ilişkin prosesin üst prosesi yine fork işlemi yapan prosestir. Örneğin:

    pid_t pid;

    if ((pid = fork()) == -1)
        exit_sys("fork");

    if (pid == 0 && exec(...) == -1)
        exit_sys("exec");

    /* Yalnızca üst prosesin akışı buraya gelir */
    
    if (waitpid(pid, NULL, 0) == -1)
        exit_sys("waitpid");

    Bazen fork işleminden sonra üst proses alt proseste bazı ayarlamalar yaptıktan sonra exec uygulamak isteyebilir. Örneğin:

    pid_t pid;

    if ((pid = fork()) == -1)
        exit_sys("fork");

    if (pid == 0) {
        /* alt proseste bazı işlemler */
        if (exec(...) == -1)
            exit_sys("exec");
        /* unreachable code */
    }

    /* Yalnızca üst prosesin akışı buraya gelir */
    
    if (waitpid(pid, NULL, 0) == -1)
        exit_sys("waitpid");

    Aalında fork ve exec nadiren tek başına uygulanmaktadır. Genellikle fork ve exec bir arada yukarıdaki kalıp eşiliğinde 
    kullanılmaktadır. 

    Aşağıdaki örnekte üst proses "/bin/ls" programını çalıştırıp yoluna devam etmiştir.
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/wait.h>

void exit_sys(const char *msg);

int main(void)
{
	pid_t pid;

	printf("sample running...\n");

	if ((pid = fork()) == -1)
		exit_sys("fork");

	if (pid == 0 && execl("/bin/ls", "/bin/ls", "-l", (char *)0) == -1) 
		exit_sys("execl");

	printf("ok, parent continues...\n");

	if (waitpid(pid, NULL, 0) == -1)
		exit_sys("waitpid");

	return 0;
}

void exit_sys(const char *msg)
{
	perror(msg);

	exit(EXIT_FAILURE);
}

/*--------------------------------------------------------------------------------------------------------------------------
    fork/exec işlemlerinde kişilerin kafasını karıştıran bir durum oluşmaktadır. Kişiler haklı olarak şöyle düşünmektedir: 
    "fork işlemi ile üst prosesin bellek alanı alt proses için kopyalandığına göre ve alt proseste de exec yapıldığında alt prosesin
    bellek alanı hemen boşaltılacağına göre burada üst prosesin bellek alanı gereksiz biçimde alt prosese kopyalanmış olmuyor mu?"
    Gerçekten de böyle bir durum söz konusudur. Ancak işlemcilerin "sayfalama (paging)" mekanizmaları sayesinde aslında fork işlemi sırasında
    modern işlemcilerde "copy on write" mekanizması işletilmektedir. Yani aslında bugün kullandığımız işlemcilerde fork işlemi sırasında
    işletim sistemi üst prosesin bellek alanını zaten alt prosese bütünsel olarak kopyalamamaktadır. Bu kopyalama işlemi gerektiğinde
    yapılmaktadır. Bu mekanizmaya "copy on write" denilmektedir. Bu konuda bilgiler ileride verilecektir. Ancak eski sistemlerde 
    "copy on write" mekanizması ya yoktu ya da etkin olarak gerçekleştirilemiyordu. Bu durum gerçekten eski sistemlerde bir problemdi.
    Bu nedenle bu eski sistemler zamanında fork fonksiyonunun bellek kopyalamasını yapmayan (minimal düzeyde yapan) vfork isminde
    bir benzeri de bulundurulmuştur. vfork fonksiyonu eskiden POSIX standartlarında bulunuyordu. 2008'den itibaren POSIX standratlarından kaldırılmıştır. 
    Fakat glibc kütüphanesi bu fonksiyonu bulundurmaya devam etmektedir. Zaten yukarıda da belirttiğimiz gibi modern sistemlerde artık vfork fonksiyonuna 
    gereksinim de kalmamıştır. vfork tamamen fork işlemi yapar. Ancak üst prosesin bellek alanını alt prosese kopyalamaz. Çünkü vfork exec için düşünülmüştür. 
    Yani vfork işleminden sora exec yapılmalıdır. Eğer vfork işleminden sonra exec yapılmayıp sanki fork yapılmış gibi program devam ettirilirse "tanımsız davranış 
    (undefined behavior)" oluşmaktadır. vfork fonksiyonunun prototipi fork ile aynı biçimdedir:

    #include <unistd.h>

    pid_t vfork(void);

    Eski POSIX standartlarına göre vfork işleminden sonra yalnızca _exit fonksiyonu ya da exec fonksiyonları çağrılabilir
    Bunun dışında başka bir fonksiyon çağrılamaz. Yani vfork başarılı ise biz ya _exit ile prosesi sonlandırmalıyız ya da exec 
    uygulamalıyız. Tabii exec de başarısız olursa _exit ile (exit ile değil) alt prosesi sonlandırmalıyız. Başka bir fonksiyonun kullanılamamasının nedeni 
    o fonksiyonların kodlarının alt prosese kopyalanmamış olmasındandır.
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    execv fonksiyonu işlevsel olarak execl fonksiyonu ile aynıdır. Ancak bu fonksiyon çalıştırılacak program için komut satırı argümanlarını
    bir gösterici dizisi biçiminde ister. Fonksiyonun prototipi şöyledir:

    #include <unistd.h>

    int execv(const char *path, char * const *argv);

    Fonksiyonun birinci parametresi çalıştırılacak program dosyasının yol ifadesini belirtir. İkinci parametresi ise komut satırı
    argümanlarının bulunduğu char türden gösterici dizisinin başlangıç adresini almaktadır. Yani bizim komut satırı argümanlarını 
    bir gösterici dizisine yerleştirip onun adresini vermemiz gerekir. Bu gösterici dizisinin son elemanı NULL adres olmalıdır. 
    Tabii bu durumda tür dönüştürmesi yapmaya gerek yoktur. Örneğin:

    char *argv[] = {"/bin/ls", "-l", NULL};
    ...

    execv("/bin/ls", argv);
    exit_sys("execv");

    execv fonksiyonun ikinci parametresindeki const niteleyicisinin yerine dikkat ediniz. Burada const adresi geçirilen gösterici 
    dizisinin const olduğunu belirtmektedir. O gösterici dizilerinin gösterdiği adresteki yazıların const olduğunu belirtmemektedir. 

    Aşağıdaki execv fonksiyonun kullanımına bir örnek verilmiştir.
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/wait.h>

void exit_sys(const char *msg);

int main(void)
{
	pid_t pid;
	char *argv[] = {"/bin/ls", "-l", NULL};

	printf("sample running...\n");

	if ((pid = fork()) == -1)
		exit_sys("fork");

	if (pid == 0 && execv("/bin/ls", argv) == -1) 
		exit_sys("execl");

	printf("ok, parent continues...\n");

	if (waitpid(pid, NULL, 0) == -1)
		exit_sys("waitpid");

	return 0;
}

void exit_sys(const char *msg)
{
	perror(msg);

	exit(EXIT_FAILURE);
}

/*--------------------------------------------------------------------------------------------------------------------------
    execv ne zaman tercih edilebilir? İşte bazen execl fonksiyonu yerine execv fonksiyonunun kullanılması daha uygun olabilmektedir. 
    Örneğin biz sample isimli bir program yazalım. Bu program da komut satırı argümanlarıyla aldığı programı çalıştırsın. Örneğin:

    ./sample /bin/ls -l

    Eğer böyle bir programı execl ile yazamaya çalışırsak bunu pratik bir biçimde başaramayız. Çünkü çalıştıracağımız programın kaç komut 
    satırı argümanı ile çalıştırılacağını baştan bilmemekteyiz. Aşağıda böyle bir programa örnek verilmiştir. Programı aşağıdaki gibi 
    çalıştırarak test ediniz:

    ./sample /bin/ls -l
    ./sample /bin/cp sample.c x.c
    ./sample mample ali veli selami
---------------------------------------------------------------------------------------------------------------------------*/

/* sample.c */

#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/wait.h>

void exit_sys(const char *msg);

int main(int argc, char *argv[])
{
	pid_t pid;
	
    if (argc == 1) {
		fprintf(stderr, "wrong number od arguments!..\n");
		exit(EXIT_FAILURE);
	}

	printf("sample running...\n");

	if ((pid = fork()) == -1)
		exit_sys("fork");

	if (pid == 0 && execv(argv[1], &argv[1]) == -1) 
		exit_sys("execv");

	printf("ok, parent continues...\n");

	if (waitpid(pid, NULL, 0) == -1)
		exit_sys("waitpid");

	return 0;
}

void exit_sys(const char *msg)
{
	perror(msg);

	exit(EXIT_FAILURE);
}

/*--------------------------------------------------------------------------------------------------------------------------
    exec fonksiyonlarının iki p'li versionu vardır: execlp ve execvp. Bu p'li versiyonların prototipleri p'siz versiyonlarla aynıdır. 
    Yalnızca ilk parametrenin anlamı farklıdır. Fonksiyonların prototipleri şöyledir:

    #include <unistd.h>

    int execlp(const char *file, const char *arg0, ... /*, (char *)0 */);
    int execvp(const char *file, char *const argv[]);
    
    exec fonksiyonlarının p'li versiyonları şöyle çalışmaktadır:

    - Eğer bu fonksiyonların birinci parametrelerinde belirtilen dosya isminde hiç "/" karakteri kullanılmamışsa bu fonksiyonlar
    önce PATH çevre değişkeninin değerini getenv fonksiyonuyla alıp buradaki yazıyı ':' karakterlerinden parçalara ayırırlar. 
    Bu ':' karakterlerinin arasındaki yazıların dizin belirttiğini varsayarlar. Sonra exec yapılacak dosyayı sırasıyla bu dizinlerde
    ararlar. Eğer bulurlarsa onu exec yaparlar, bulamazlarsa bu fonksiyonlar başarısız olur. Tabii bu fonksiyonlar PATH çevre değişkeninde
    belirtilen dizinlerdeki aramayı baştan sona doğru yaparlar ve ilk bulduğu dizindek programı exec işlemine sokarlar. PATH çevre değişkeninin 
    değerinin aşağıdakine benzer bir biçimde bulunması gerekmektedir:

    "/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/usr/local/games:/snap/bin"

    - Eğer p'li exec fonksiyonlarının birinci parametresiyle belirtilen dosya isminde en az bir "/" karakteri varsa bu durumda 
    fonksiyonlar PATH çevre değişkenine başvurmazlar. Birinci parametresiyle belirtilen göreli ya da mutlak yol ifadesinden hareketle
    dosyanın yerini belirlemeye çalışırlar. Başka bir deyişle bu durumda fonksiyonların p'li versiyonlarının p'siz verisyonlarından 
    hiçbir farkı kalmamaktadır. Örneğin:

    execlp("ls", ...);          /* PATH çevre değişkenine başvurulur */
    execlp("./mample", ...);    /* PATH çevre değişkenine başvurulmaz */
    execlp("a/mample", ...);    /* PATH çevre değişkenine başvurulmaz */    

    exec fonksiyonlarının p'li versyonları eğer dosya isminde hiç "/" karakteri yoksa ve PATH dizinlerinde dosyayı bulamazsa prosesin 
    çalışma dizinine bakmamaktadır. Yani bu durumda yalnızca PATH eçvre değişkenindeki dizinlere bakmaktadır. Tabii PATH eçvre değişkeninde
    o andaki prosesin çalışma dizini "." ile de belirtilebilir. Örneğin:

    "/bin:/usr/bin:/:."

    Buradaki "." prosesin çalışma dizinini belirtmektedir. Bizx PATH eçvre değişkeninin sonuna dizinler ekeleybiliriz. Örneğin:

    PATH=$PATH:/home/kaan

    Tabii bunun kalıcı hale getirilmesi için kabuk programının startup dosyalarına yerleştirilmesi gerekir. Prosesin çalışma 
    dizininin PATH çevre değişkenine eklenmesi güvenlik zafiyeti nedeniyle iyi bir teknik kabul edilmemektedir. Örneğin:

    PATH=$PATH:.

    exec fonksiyonlarının p'li versiyonları PATH çevre değişkenini bulamazsa ne olacaktır? POSIX standartları bu durumdaki davranışın
    sistemden sisteme değişebileceğini (implementation dependent) belirtmektedir. Pek çok sistem (örneğin Linux ve BSD) bu durumda sanki 
    PATH çevre değişkeni "/bin:/usr/bin" biçimindeymiş gibi davranmaktadır.

    exec fonksiyonlarının p'li versiyonları (execlp ve execvp) PATH dizinlerinde tek tek dosyayı aramaktadır. Ancak bu fonksiyonlar dosyayı bir 
    dizinde bulduğunda ve onu sistem fonksiyonuyla (execve) çalıştırmaya çalıştığında EINVAL ve ENOEXEC errno değerini alırsa dosyanın bir 
    kabuk dosyası (shell script) olduğundan çalıştırılamadığı sonucunu çıkartmaktadır ve bu durumda dosyayı /bin/sh (default shell) programı ile çalıştırmaktadır.
    Ancak exec fonksiyonlarının diğer versiyonları EINVAL ve ENOEXEC hatalarında bunu yapmamaktadır. Bunu yalnızca exec fonksiyonlarının p'li 
    versiyonları yapmaktadır. Exec fonksiyonlarının p'li versyonları PATH dizinlerinin birinde dosyayı sistem fonksiyonuyla (execve) çalıştırmaya 
    çalıştığında EACCESS errno değeri ile başarısız olurlarsa dosyayı sonraki PATH dizinlerinde aramaya devam ederler. Ancak bu arama sırasında 
    bu fonksiyonlar artık dosyayı diğer PATH dizinlerinde bulamazlarsa EACCESS errno değeri ile başarısız olurlar. 

    Aşağıda execlp fonksiyonuna bir örnek verilmiştir. 
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/wait.h>

void exit_sys(const char *msg);

int main(void)
{
	pid_t pid;
	
	printf("sample running...\n");

	if ((pid = fork()) == -1)
		exit_sys("fork");

	if (pid == 0 && execlp("ls", "ls", "-l", (char *)0) == -1) 
		exit_sys("execv");

	printf("ok, parent continues...\n");

	if (waitpid(pid, NULL, 0) == -1)
		exit_sys("waitpid");

	return 0;
}

void exit_sys(const char *msg)
{
	perror(msg);

	exit(EXIT_FAILURE);
}

/*--------------------------------------------------------------------------------------------------------------------------
    Aşağıda execvp kullanımına örnek verilmiştir. 
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/wait.h>

void exit_sys(const char *msg);

int main(int argc, char *argv[])
{
	pid_t pid;

	if (argc == 1) {
		fprintf(stderr, "wrong number od arguments!..\n");
		exit(EXIT_FAILURE);
	}

	printf("sample running...\n");

	if ((pid = fork()) == -1)
		exit_sys("fork");

	if (pid == 0 && execvp(argv[1], &argv[1]) == -1) 
		exit_sys("execv");

	printf("ok, parent continues...\n");

	if (waitpid(pid, NULL, 0) == -1)
		exit_sys("waitpid");

	return 0;
}

void exit_sys(const char *msg)
{
	perror(msg);

	exit(EXIT_FAILURE);
}

/*--------------------------------------------------------------------------------------------------------------------------
    Şimdi kabuk üzerinden programları neden "./sample" biçiminde çalıştırdığımız artık anlaşılabilir. Kabuk programları önce fork
    yapıp alt proseste exec foksiyonlarının p'li versiyonlarıyla programları çalıştırmaktadır. Dolayısıyla biz programı "sample" biçiminde
    çalıştırmak istediğimizde bu p'li versiyonlar bu programı PATH dizinlerinde bulamayacaktır. Ancak biz programı "./sample" biçiminde 
    çalıştırmak istediğimizde bu fonksiyonlar artık PATH çevre değişkenine bakmayacaktır. 

    Pekiyi kabuk programları neden exec fonksiyonlarının p'li versyionlarını kullanmaktadır? Bunun birinci sebebi kolaylık sağlamak 
    içindir. Örneğin "ls" komutunu biz "/bin/ls" biçiminde kullanmak istemeyiz. Bunun ikinci sebebi güvenliktir. Eskiden durum böyle değilken 
    programın çalışma dizinine gerçek komutlarla aynı isimli komutlar yerleştirerek hileli işlemler yapmaya yaltenenler olmuştur. 
    İşte bu nedenle PATH dizinlerinin içerisinde prosesin çalışma dizini de yerleştirilmez. Eğer durum böyle olmasaydı bazen
    hatalı yazılmış komutlarla istenmeden başka programlar da çalıştırılabilirdi. Örneğin dizinimizde "co" diye bir program olsun biz "cp"
    yerine yanlışlıkla "co" yazarsak bu programımızı istemeden de çalıştırabiliriz.  
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
                                                29. Ders 05/02/2023 - Pazar
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Daha önce yapmış olduğumuz myshell kabuk programına fork/exec işlemini ekleyelim. Programın bu versiyonu önce "internal" 
    komutlara bakacak, eğer internal komutlarda verilen komutu bulmazsa onu fork/exec ile program dosyası gibi çalıştıracaktır.
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <errno.h>
#include <limits.h>
#include <unistd.h>
#include <sys/wait.h>

#define MAX_CMD_LINE        4096
#define MAX_CMD_PARAMS      128

typedef struct tagCMD {
    char *name;
    void (*proc)(void);
} CMD;

void parse_cmd_line(char *cmdline);
void cd_proc(void);
void exit_sys(const char *msg);

char *g_params[MAX_CMD_PARAMS];
int g_nparams;
char g_cwd[PATH_MAX];

CMD g_cmds[] = {
    {"cd", cd_proc},
    {NULL, NULL}
};

int main(void)
{
    char cmdline[MAX_CMD_LINE];
    char *str;
    int i;
    pid_t pid;

    if (getcwd(g_cwd, PATH_MAX) == NULL)
        exit_sys("fatal error (getcwd)");

    for (;;) {
        printf("CSD:%s>", g_cwd);
        if (fgets(cmdline, MAX_CMD_LINE, stdin) == NULL)
            continue;
        if ((str = strchr(cmdline, '\n')) != NULL)
            *str = '\0';
        parse_cmd_line(cmdline);
        if (g_nparams == 0)
            continue;
        if (!strcmp(g_params[0], "exit"))
            break;
        for (i = 0; g_cmds[i].name != NULL; ++i)
            if (!strcmp(g_params[0], g_cmds[i].name)) {
                g_cmds[i].proc();
                break;
            }
        if (g_cmds[i].name == NULL) {
            if ((pid = fork()) == -1) {
                perror("fork");
                continue;
            }
            if (pid == 0 && execvp(g_params[0], &g_params[0]) == -1){
                fprintf(stderr, "command not found or cannot execute!\n");
                continue;
            }
            if (wait(NULL) == -1)
                exit_sys("wait");
        }
    }

    return 0;
}

void parse_cmd_line(char *cmdline)
{
    char *str;

    g_nparams = 0;
    for (str = strtok(cmdline, " \t"); str != NULL; str = strtok(NULL, " \t"))
        g_params[g_nparams++] = str;
    g_params[g_nparams] = NULL;
}

void cd_proc(void)
{
    char *dir;

    if (g_nparams > 2) {
        printf("too many arguments!\n");
        return;
    }  
    if (g_nparams == 1) {
        if ((dir = getenv("HOME")) == NULL)
            exit_sys("fatal error (getenv");
    }
    else 
        dir = g_params[1];

    if (chdir(dir) == -1) {
        printf("%s\n", strerror(errno));
        return;
    }

    if (getcwd(g_cwd, PATH_MAX) == NULL)
        exit_sys("fatal error (getcwd)");
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/*--------------------------------------------------------------------------------------------------------------------------
    exec fonksiyonlarının başarısızlığının nedeni olabilecek çeşitli errno değerleri vardır. Bunların en önemlilerinden birkaçı 
    şunlardır:

    ENOENT (No such file or directory): Dosya bulunamamıştır.

    EACCESS (Permission denied): Dosya bulunmuştur ancak proses dosyaya "x" hakkına sahip değildir. 
    
    ENOEXEC (Exec format error): Dosya bulunmuştur. Proesin dosyaya "x" hakkı da vardır. Ancak dosyanın formatı çalıştırmaya uygun değildir. 
    Yani dosya çalıştırılabilir bir dosya değldir ya da dosyanın başında "shebang" yoktur.
    
    EINVAL (Invalid argument): Dosya bulunmuştur, proses dosyaya "x" hakkına sahiptir. Ancak dosya bu sistem tarafından desteklenen 
    "çalıştırılabilir (executable)" bir formata sahip değildir. 

    Yukarıdada belirttiğimiz gibi exec fonksiyonlarının p'li versiyonları (execlp ve execvp) PATH dizinlerinde tek tek dosyayı aramaktadır. 
    Ancak bu fonksiyonlar dosyayı bir dizinde bulduğunda ve onu sistem fonksiyonuyla (execve) çalıştırmaya çalıştığında EINVAL ve ENOEXEC errno 
    değerini alırsa dosyanın bir kabuk dosyası olduğundan çalıştırılamadığı sonucunu çıkartmaktadır ve bu durumda dosyayı 
    /bin/sh (default shell) programı ile çalıştırmaktadır. Ancak exec fonksiyonlarının diğer versiyonları EINVAL ve ENOEXEC hatalarında bunu 
    yapmamaktadır. Bunu yalnızca exec fonksiyonlarının p'li versiyonları yapmaktadır. Exec fonksiyonlarının p'li versyonları PATh dizinlerinin 
    birinde dosyayı sistem fonksiyonuyla (execve) çalıştırmaya çalıştığında EACCESS errno değeri ile başarısız olurlarsa dosyayı sonraki 
    PATH dizinlerinde aramaya devam ederler. Ancak bu arama sırasında bu fonksiyonlar artık dosyayı diğer PATH dizinlerinde bulamazlarsa 
    EACCESS errn değeri ile başarısız olurlar. 
    
    Bu davranışın anlamı izleyen bölümlerde başka paragraflarda açıklanacaktır.
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    exec fonksiyonlarının iki tane e'li biçimleri vardır: execle ve execve. Buradaki "e" harfi "environment" yani çevre değişkenleri
    anlamında isme eklenmiştir. 

    Anımsanacağı gibi çevre değişkenleri prosesin bellek alanında bulunduruluyordu ve fork işlemi sırasında üst prosesin bellek
    alanının alt prosese kopyalanmasıyla alt prosese geçiriliyordu. Ancak exec işlemleri prosesin bellek alanını ortadan kaldırıp 
    yeni bir program kodunu yüklediğine göre prosesin eçvre değişkenleri ne olacaktır? İşte exec işlemi sırasında prosesin bellek 
    alanı boşaltılıp yeni program için prosesin bellek alanı yeniden oluşturulurken çevre değişkenleri de sıfırdan oluşturulabilmektedir. 
    Bunu exec fonksiyonlarının e'li versiyonları yapmaktadır. Exec fonksiyonlarının e'siz versiyonları o andaki prosesin çevre değişkenlerinin
    aynısını exec yapılan programın bellek alanına taşımaktadır. Yani biz exec fonksiyonlarının e'siz versiyonlarını kullandığımızda
    exec yapmadan önceki çevre değişkenleriyle exec yapıldıktan sonraki programın çevre değişkenleri aynı olacaktır. 

    execle ve execve fonksiyonlarının prototipleri şöyledir:

    #include <unistd.h>

    int execle(const char *path, const char *arg0, ... /*, (char *)0, char *const envp[]*/);
    int execve(const char *path, char *const argv[], char *const envp[]);

    execle fonksiyonun birinci parametresi yine çalıştırılacak dosyanın yol ifadesini almaktadır. Diğer parametreler programa 
    geçirilecek komut satırı argümanlarını belirtir. Bu argüman listesinin sonu yine NULL adresle bitirilmelidir. Bu NULL adresten sonra
    son parametre char türden bir gösterici dizisi olmalıdır. Bu gösterici dizisi çevre değişkenlerini "anahtar=değer\n" biçiminde
    tutan yazıların başlangıç adreslerinden oluşmalıdır (yani environ global değişkeninde olduğu gibi).Bu fonksiyonlardaki çevre değişkenleri
    için oluşturulan gösterici dizilerinin sonunda NULL adres olmalıdır. 

    execve fonksiyonu da benzerdir. Bu fonksiyon da önce çalıştırılacak programın yol ifadesini alır. Sonra komut satırı argümanlarını 
    bir gösterici dizisi olarak sonra da çevre değişkenlerini bir gösterici dizisi olarak almaktadır. 

    Aşağıdaki execve fonkisyonunun kullanımına bir örnek verilmiştir. Burada komut satırı argümanlarıyla verilen program execve 
    fonksiyonu ile çalıştırmaktadır. execve için çevre değişken listesi bir gösterici dizisi biçiminde oluşturulmuştur. mample 
    programı içerisinde hem komut satırı argümanları hem de prosesin çevre değişkenleri yazdırılmıştır. Testi şöyle yapabilirsiniz:

    ./sample mample ali veli selami

    Şöyle bir çıktı elde edeceksiniz:

    sample running...
    ok, parent continues...
    mample running...

    command line arguments:

    mample
    ali
    veli
    selami

    Envirionment variables:

    city=eskisehir
    PATH=/bin:/usr/bin
    name=ali

-----------------------------------------------------------------------------------------------------------------------*/

/* sample.c */

#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/wait.h>

void exit_sys(const char *msg);

int main(int argc, char *argv[])
{
	pid_t pid;
	char *env[] = {"city=eskisehir", "PATH=/bin:/usr/bin", "name=ali", NULL};
	
    if (argc == 1) {
		fprintf(stderr, "wrong number od arguments!..\n");
		exit(EXIT_FAILURE);
	}

	printf("sample running...\n");

	if ((pid = fork()) == -1)
		exit_sys("fork");

	if (pid == 0 && execve(argv[1], &argv[1], env) == -1) 
		exit_sys("execve");

	printf("ok, parent continues...\n");

	if (waitpid(pid, NULL, 0) == -1)
		exit_sys("waitpid");

	return 0;
}

void exit_sys(const char *msg)
{
	perror(msg);

	exit(EXIT_FAILURE);
}

/* mample.c */

#include <stdio.h>

extern char **environ;

int main(int argc, char *argv[])
{
    printf("mample running...\n\n");

    printf("command line arguments:\n\n");
    for (int i = 0; i < argc; ++i)
        puts(argv[i]);

    printf("\nEnvirionment variables:\n\n");

    for (int i = 0; environ[i] != NULL; ++i)
        puts(environ[i]);

    return 0;
}

/*--------------------------------------------------------------------------------------------------------------------------
    Aşağıdaki execle fonksiyonunun kullanımına bir örnek verilmiştir. execle fonksiyonunda komut satırı argümanlarından sonra 
    çevre değişkenlerini belirten gösterici dizisi argüman olarak geçilmelidir.
---------------------------------------------------------------------------------------------------------------------------*/

/* sample.c */

#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/wait.h>

void exit_sys(const char *msg);

int main(void)
{
	pid_t pid;
	char *env[] = {"city=eskisehir", "PATH=/bin:/usr/bin", "name=ali", NULL};
	
	printf("sample running...\n");

	if ((pid = fork()) == -1)
		exit_sys("fork");

	if (pid == 0 && execle("mample", "mample", "ali", "veli", "selami", (char *)0, env) == -1) 
		exit_sys("exece");

	printf("ok, parent continues...\n");

	if (waitpid(pid, NULL, 0) == -1)
		exit_sys("waitpid");

	return 0;
}

void exit_sys(const char *msg)
{
	perror(msg);

	exit(EXIT_FAILURE);
}

/* mample.c */

#include <stdio.h>

extern char **environ;

int main(int argc, char *argv[])
{
    printf("mample running...\n\n");

    printf("command line arguments:\n\n");
    for (int i = 0; i < argc; ++i)
        puts(argv[i]);

    printf("\nEnvirionment variables:\n\n");

    for (int i = 0; environ[i] != NULL; ++i)
        puts(environ[i]);

    return 0;
}

/*--------------------------------------------------------------------------------------------------------------------------
    Daha önceden de belirtildiği gibi UNIX türevi sistemlerde yalnızca execve fonksiyonu sistem fonksiyonu olarak işletim sistemi
    içerisinde bulunmaktadır. Aslında execl, execlp, execv, execvp, execle foksiyonları execve fonksiyonunu çağıracak biçimde 
    birer kütüphane fonksiyonu biçiminde bulundurulmaktadır. Yani burada "taban (base)" fonksiyon execve fonksiyonudur. 

    Aşağıda execv fonksiyonunun execve kullanılarak basit biçimde yazımına örnek verilmiştir. 
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/wait.h>

void exit_sys(const char *msg);

extern char **environ;

int myexecv(const char *path, char * const *argv)
{
	return execve(path, argv, environ);
}

int main(int argc, char *argv[])
{
	pid_t pid;
		
	if (argc == 1) {
		fprintf(stderr, "wrong number od arguments!..\n");
		exit(EXIT_FAILURE);
	}

	printf("sample running...\n");

	if ((pid = fork()) == -1)
		exit_sys("fork");

	if (pid == 0 && myexecv(argv[1], &argv[1]) == -1) 
		exit_sys("myexecv");

	printf("ok, parent continues...\n");

	if (waitpid(pid, NULL, 0) == -1)
		exit_sys("waitpid");

	return 0;
}

void exit_sys(const char *msg)
{
	perror(msg);

	exit(EXIT_FAILURE);
}

/*--------------------------------------------------------------------------------------------------------------------------
    Aşağıdaki örnekte de execl fonksiyonunun execve kullanılarak nasıl yazıldığı hakkında bir fikir verilmiştir. 
    Burada komut satırı argümanlarının sayısı MAX_ARGS ile sınırlandırılmıştır. 

    Değişken sayıda argüman alan fonksiyonların yazımını inceleyiniz.
---------------------------------------------------------------------------------------------------------------------------*/

/* sample.c */

#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/wait.h>
#include <stdarg.h>

#define MAX_ARG		4096

void exit_sys(const char *msg);

extern char **environ;

int myexecl(const char *path, const char *arg0, ...)
{
	va_list vl;
	char *args[MAX_ARG + 1];
	char *arg;
	int i;

	va_start(vl, arg0);

	args[0] = (char *)arg0;
	for (i = 1; (arg = va_arg(vl, char *)) != NULL && i < MAX_ARG; ++i)
		args[i] = arg;
	args[i] = NULL;

	va_end(vl);

	return execve(path, args, environ);
}

int main(int argc, char *argv[])
{
	pid_t pid;
		
    if (argc == 1) {
		fprintf(stderr, "wrong number od arguments!..\n");
		exit(EXIT_FAILURE);
	}

	printf("sample running...\n");

	if ((pid = fork()) == -1)
		exit_sys("fork");

	if (pid == 0 && myexecl("mample", "mample", "ali", "veli", "selami", (char *)0) == -1) 
		exit_sys("myexecl");

	printf("ok, parent continues...\n");

	if (waitpid(pid, NULL, 0) == -1)
		exit_sys("waitpid");

	return 0;
}

void exit_sys(const char *msg)
{
	perror(msg);

	exit(EXIT_FAILURE);
}

/* mample.c */

#include <stdio.h>

extern char **environ;

int main(int argc, char *argv[])
{
    printf("mample running...\n\n");

    printf("command line arguments:\n\n");
    for (int i = 0; i < argc; ++i)
        puts(argv[i]);

    printf("\nEnvirionment variables:\n\n");

    for (int i = 0; environ[i] != NULL; ++i)
        puts(environ[i]);

    return 0;
}

/*--------------------------------------------------------------------------------------------------------------------------
    fexecve isimli fonksiyon execve fonksiyonu gibidir. Ancak bunun tek farkı dosyayı yol ifadesini alarak değil dosya betimleyicisini 
    alarak çalıştırmasıdır. Yani biz çalıştırmak istediğimiz dosyayı zaten open fonksiyonu ile açmışsak bu durumda doğrudan 
    fexecve fonksiyonunu kullanabiliriz. Fonkisyon prototipi şöyledir:

    #include <unistd.h>

    int fexecve(int fd, char *const argv[], char *const envp[]);

    Fonksiyonun birinci parametresi çalıştırılacak dosyanın dosya betimleyicisini almaktadır. Diğer parametreler execve fonksiyonu 
    ile tamamen aynıdır. Bu fonksiyonun birinci parameresinde belirtilen betimleyiciye ilişkin dosya hangi modda açılmış olmalıdır?
    POSIX standartlarında olan ancak Linux tarafından desteklenmeyen O_EXEC bayrağı bunun için kullanılabilir. (O_EXEC bayrağında
    dosyanın "x" hakkına sahip olup olmadığına bakılmaktadır.) Ancak POSIX standartlarında da dosyanın O_RDONLY modunda
    açılabileceği belirtilmiştir. Yani dosya bu modlarda da açılmış olabilir. Linux sistemlerinde O_EXEC bayrağı olmasa da benzer 
    amaçlarla kullanılan standart olmayan O_PATH bayrağı bulunmaktadır. Linux sistemlerinde bu dosya O_PATH bayrağı ile de 
    açılmış olabilir. O halde Linux sistemleri de göz önüne alndığında buradaki dosyanın taşınabilirlik bakımından O_RDONLY modda
    açılması uygun olmaktadır. Programcı bu dosyayı fork işleminden sonra alt proseste exec işleminden önce açabilir. Bu durumda 
    dosyanın alt proseste kapatılması işlemi exec sırasında otomatik yapılmaktadır. Yani exec edilen kodda artık bu dosya açık 
    görülmeyecektir. 

    Aşağıda fexecve fonksiyonun kullanımına bir örnek verilmiştir. Burada dosya alt proseste açılmıştır. 
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <fcntl.h>
#include <unistd.h>
#include <sys/wait.h>

void exit_sys(const char *msg);

extern char **environ;

int main(int argc, char *argv[])
{
	pid_t pid;
	int fd;

	if (argc == 1) {
		fprintf(stderr, "wrong number od arguments!..\n");
		exit(EXIT_FAILURE);
	}
	
	printf("sample running...\n");

	if ((pid = fork()) == -1)
		exit_sys("fork");

	if (pid == 0) {
		if ((fd = open(argv[1], O_RDONLY)) == -1)
			exit_sys("open");
		if (fexecve(fd, &argv[1], environ) == -1)
			exit_sys("fexecve");
	} 

	printf("ok, parent continues...\n");

	if (waitpid(pid, NULL, 0) == -1)
		exit_sys("waitpid");

	return 0;
}

void exit_sys(const char *msg)
{
	perror(msg);

	exit(EXIT_FAILURE);
}

/*--------------------------------------------------------------------------------------------------------------------------
    exec işlemi yapıldığında o ana kadar açık olan dosyaların akibeti ne olacaktır? Anımsanacağı gibi açık dosyaların 
    dosya nesnelerinin adresleri "dosya betimleyici tablosu" denilen bir tabloda tutulmaktadır. Örneğin bir program 100 tane 
    açıp sonra exec işlemi uygulasa yeni çalıştırılacak kod bu 100 dosyanın farkında olmayacaktır. Ancak dosya betimleyici tablosunda
    bu 100 betimleyici çoğu kez gereksiz bir biçimde bulunmaya devam edecektir. İşte UNIX/Linux sistemlerinde her açık dosya için
    "close on exec" isminde bir bayrak da turulmaktadır. Eğer bu bayrak "set" edilmişse bu durumda exec işlemi sırasında bu dosya
    işletim sistemi tarafından kapatılır. Eğer bu bayrak "reset" durumdaysa bu durumda exec işlemi sırasında dosya kapatılmaz
    exec yapılan program kodu dosyanın betimleyicisini bilirse onu kullanmaya devam edebilir. Bu bayrak default olarak "reset" durumdadır. 
    open fonksiyonuyla dosya açılırken açış modunda O_CLOEXEC bayrağı belirtilirse bu bayrak set edilmiş olur. Örneğin:

    fd = open("test.txt", O_RDONLY|O_CLOEXEC);

    Programcı isterse herhangi bir zaman fcntl fonksiyonu ile de bu bayrağı set ya da reset edebilir. Biz bu fonksiyonu henüz görmedik. 
    Ancak bu bayrağın set edilmesi işlem şöyle yapılabilmektedir:

    if (fcntl(fd, F_SETFD, fcntl(fd, F_GETFD) | FD_CLOEXEC)) == -1)
        exit_sys("fcntl");

    Benzer biçimde bu bayrak şöyle de reset edilebilir:

    if (fcntl(fd, F_SETFD, fcntl(fd, F_GETFD) & ~FD_CLOEXEC)) == -1)
        exit_sys("fcntl"); 

    Close on exec bayrağı dosya nesnesinin içerisinde tutulmamaktadır. Aynı dosya nesnesini gösteren farklı proseslerde farklı betimleyiciler
    olabilir. Bu betimleyicilerden birinin close on exec bayrağı set edilmişken diğerinin set edilmemiş olabilir. Yani close onexec bayrağı dosya
    nesnesinin içerisinde değil proses kontrol blok içerisinde başka bir yerdedir. 

    Aşağıdaki örnekte "sample" programı execl ile "mample" programını çalıştırmıştır. Ancak "mample" programı "sample" programının
    açmış olduğu dosyanın betimleyici numarasını bilmediği için "sample" programı komut satırı argümanıyla bu bilgiyi "mample"
    programına iletmiştir. 

    Aşağıdaki programı daha sonra dosyanın close onexec bayrağı set set ederek yeniden deneyiniz:

    if ((fd = open("sample.c", O_RDONLY|O_CLOEXEC)) == -1)
		exit_sys("open");

    Tabii aynı işlem şöyle de yapılabilirdi:

    if ((fd = open("sample.c", O_RDONLY)) == -1)
		exit_sys("open");

	if (fcntl(fd, F_SETFD, fcntl(fd, F_GETFD)|FD_CLOEXEC) == -1)
		exit_sys("fcntl");

    close on exec bayrağı bazı işlemler sırasında işletim sistemi tarafından set ya da reset edilebilmektedir. Örneğin dup ve dup2
    fonksiyonları ile dosya betimleyicisinin kopyası çıkartılırken her zaman yeni betimleyicinin close on exec bayrağı reset durumda 
    olur.
---------------------------------------------------------------------------------------------------------------------------*/

/* sample.c */

#include <stdio.h>
#include <stdlib.h>
#include <fcntl.h>
#include <unistd.h>
#include <sys/wait.h>

void exit_sys(const char *msg);

int main(void)
{
	int fd;
	char buf[10];

	if ((fd = open("sample.c", O_RDONLY)) == -1)
		exit_sys("open");

	sprintf(buf, "%d", fd);

	execl("mample", "mample", buf, (char *)0);
	
	exit_sys("execl");

	/* unreachable code */

	return 0;
}

void exit_sys(const char *msg)
{
	perror(msg);

	exit(EXIT_FAILURE);
}

/* mample.c */

#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>

int main(int argc, char *argv[])
{
    int fd;
    char buf[100 + 1];
    ssize_t result;

    if (argc != 2) {
        fprintf(stderr, "wrong number of arguments!..\n");
        exit(EXIT_FAILURE);
    }

    fd = strtol(argv[1], NULL, 10);
    if ((result = read(fd, buf, 100)) == -1) {
        perror("read");
        exit(EXIT_FAILURE);
    }
    buf[result] = '\0';
    puts(buf);

    close(fd);
     
    return 0;
}

/*--------------------------------------------------------------------------------------------------------------------------
                                                30. Ders 18/02/2023 - Cumartesi
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    exec fonksiyonları ile script dosyaları da çalıştırılabilmektedir. Bu özellik tamamen çekirdekte bulunan sistem fonksiyonları 
    (Linux'ta execve) tarafından sağlanmaktadır. exec fonksiyonları (aslında Linux'ta execve sistem fonksiyonu) eğer çalıştırılmak istenen 
    dosya "çalıştırılabilir bir dosya değilse (örneğin Linux'ta ELF formatı ya da a.out formatı değilse)" bu dosyanın birinci 
    satırını okuyarak onunla özel bir işlem yapmaktadır. Çalıştırılabilir formata sahip olmayan (tipik olarak bir text dosya) 
    bir dosyanın birinci satırı aşağıdaki gibi ise exec fonksiyonları burada özel bir işlem uygular:

    #! [optional SPACE'ler] <executable file yol ifadesi> [isteğe bağlı argüman(lar)]

    Burada #! karakterlerine genellikle "shebang" denilmektedir. Bu karaktrerler hemen satırın başında olmak zorunadadır. 
    Shebang karakterlerinden sonra isteğe bağlı bir ya da birden fazla SPACE karakteri bulundurulabilmektedir. Bundan sonra 
    gerçekten çalıştırılacak "çalıştırılabilir bir dosyanın" yol ifadesi olmalıdır. Bunu isteğe bağlı bir argüman izleyebilir. 
    Örneğin:

    #! /bin/bash 
    #!/bin/bash
    #! /usr/bin/python
    #! make -f

    exec işlemini yapan sistem fonksiyonları eğer exec yapılmak istenen dosya çalıştırılabilir bir dosya değilse (muhtemelen bir text dosya)
    onun birinci satırını okuyarak orada belirtilen çalıştırılabilir dosyayı çalıştırmaktadır. Ancak exec fonksiyonlarının bu işlemi 
    yapabilmesi için exec yapılan dosyanın yine de (text dosyası olmasına karşın) "x" hakkına sahip olması gerekmektedir. Aksi takdirde exec
    fonksiyonları başarısız olur ve yine errno değeri EACCESS biçiminde set edilir. 

    Yukarıdaki biçimde biz bir script dosyasını çalıştırmaya çalıştığımızda aslında asıl çalıştırılan dosya shebang'te belirtilen dosya 
    olmaktadır. Pekiyi shebang'te belirtilen dosya çalıştırılırken ona komut satırı argümanları olarak ne geçirilecektir? 
    Shebang'te belirtilen programın çalıştırılması sırasında bu programa geçirilen komut satır argümanları şöyledir:

    argv[0] ---> shebang'te belirtilen program dosyasına ilişkin yol ifadesi 
    argv[1] ---> Eğer shebang'te çalıştırılabilen programın yanında isteğe bağlı argüman varsa o argüman 
    argv[2] ---> exec fonksiyonunda belirtilen çalıştırılabilir olmayan dosyanın (yani script dosyasının) yol ifadesi 
    argv[3] ve sonrası ---> exec fonksiyonunda belirtilen komut satırı argümanları ancak ilk argüman dahil değil

    Eğer shebang'in yanındaki programın yanında isteğe bağlı argüman verilmemişse bu durumda shebang'te belirtilen programın
    komut satırı argümanları şöyle olacaktır:

    argv[0] ---> shebang'te belirtilen program dosyasına ilişkin yol ifadesi 
    argv[1] ---> exec fonksiyonunda belirtilen çalıştırılabilir olmayan dosyanın (yani script dosyasının) yol ifadesi 
    argv[2] ve sonrası ---> exec fonksiyonunda belirtilen komut satırı argümanları ancak ilk argüman dahil değil

    Burada dikkat edilmesi gereken bir nokta şudur: exec fonksiyonunda belirtilen argv[0] için girilen argüman shebang'te 
    belirtilen programa aktarılmamaktadır. 

    Şimdi çeşitli denemelerle argüman aktarımını anlamaya çalışalım. "test.txt" şöyle olsun:

    #! /home/kaan/Study/Unix-Linux-SysProg/mample ankara

    Burada görüldüğü gibi shebang'te belirtilen programın yanında bir isteğe bağlı argüman vardır. Şimdi mample programının 
    da şöyle yazılmış olduğunu kabul edelim:

    #include <stdio.h>

    int main(int argc, char *argv[])
    {
        printf("mample running...\n");
        
        for (int i = 0; i < argc; ++i)
            puts(argv[i]);
        
        return 0;
    }

    Şimdi aşağıdaki gibi exec yapılmış olsun:

    execl("test.txt", "test.txt", "ali", "veli", "selami", (char *)0);

    Ekranda şunları görmeliyiz:

    mample running...
    /home/kaan/Study/Unix-Linux-SysProg/mample
    ankara
    test.txt
    ali
    veli
    selami

    exec işlemi şöyle yapılmış olsun:

    execl("test.txt", "ali", "veli", "selami", (char *)0);
    
    Ekrana şunlar çıkacaktır:

    mample running...
    /home/kaan/Study/Unix-Linux-SysProg/mample
    ankara
    test.txt
    veli
    selam

    Şimdi de shebang satırı şöyle olsun:

    #!/home/kaan/Study/Unix-Linux-SysProg/mample

    Görüldüğü gibi burada arık shebang'te belirtilen programın yanında isteğe bağlı argüman yoktur. Şimdi exec işlemini şöyle
    yapmış olalım:

    execl("test.txt", "test.txt", "ali", "veli", "selami", (char *)0);  

    mample running...
    /home/kaan/Study/Unix-Linux-SysProg/mample
    test.txt
    ali
    veli
    selami

    Sistemlerde genellikle shebang satırları için maksimum bir uzunluk belirlenmiş durumdadır. Örneğin Linux sistemlerinde 
    eğer shebang satırı uzunsa kernel bunun ilk 127 karakterini dikkate almaktadır. Ancak Linux'ta 5.1 kernel'ı ile birlikte
    bu uzunluk 255'e yükseltilmiştir.

    Shebang'te belirtilen çalıştırılabilir program genellikle "mutlak yol ifadesi" ile belirtilmektedir. Ancak Linux'ta buradaki 
    program "göreli yol ifadesi" ile de belirtilebilmektedir. Örneğin:

    #!mample

    Bu durumda burada belirtilen program exec işlemini yapan prosesin çalışma dizini temel alınarak aranmaktadır. 

    Shebang'te belirtilen programın yanına birden fazla argüman yazabilir miyiz? Örneğin:

    #! /home/kaan/Study/Unix-Linux-SysProg/mample ankara izmir istanbul

    Maalesef bu durumda UNIX türevi sistemler arasında bazı farklılıklar söz konusu olmaktadır. Bu durum POSIX standartlarında
    açık biçimde belirtilmemiş ve işletim sistemini yazanların isteğine bırakılmıştır. Linux ve pek çok sistem bu durumda shebang'te 
    belirtilen programın sağındaki türm argümanları tek bir argümanmış gibi aktarmaktadır. "test.txt" dosyasının yukarıdaki gibi 
    olduğunu varsayalım. Bu dosya aşağıdaki gibi exec yapılmış olsun:

    execl("test.txt", "test.txt", "ali", "veli", "selami", (char *)0);  

    Linux sistemlerinde aşağıdaki gibi bir çıktı elde edilmiştir:

    mample running...
    /home/kaan/Study/Unix-Linux-SysProg/mample
    ankara istanbul izmir
    test.txt
    ali
    veli
    selami

    Bazı UNIX türevi sistemler bu durumda yalnızca boşlukla ayrılmış ilk argümanı (örneğmizde "ankara") programa aktarıp diğerlerini 
    ihmal edebilmektedir. Bu durumda programcının taşınabilirliği sağlamak için shenag dosyasının yanına tek bir argüman yerleştirmesi 
    uygun olmaktadır. 

    Tabii biz bir script dosyasını doğdudan kabuk üzerinden de çalıştırabiliriz. Fark eden bir şey yoktur. Bu durumda zaten kabuk exec 
    işlemini uygulamaktadır. Örneğin "test.txt" dosyası şöyle olsun:

    #!/home/kaan/Study/Unix-Linux-SysProg/mample ankara 

    Şimdi bunu kabul üzerinden çalıştıralım:

    ./test.txt ali veli selami
    mample running...
    /home/kaan/Study/Unix-Linux-SysProg/mample
    ankara
    ./test.txt
    ali
    veli
    selami

    Görüldüğü gibi burada exec işlemini kabuk uygulamıştır. Kabuk exec uygularken dosya ismini yine exec'te ilk komut satırı argümanı 
    olarak kullanır. Ancak exec bunu shebang'te belirtilen programa aktarmamaktadır. 

    Aşağıda shebag programına parametre aktarımının test edilmesi için bir örnek verilmiştir. Burada script (test.txt) programına
    chmod ile "x" hakkı vermeyi unutmayınız.
---------------------------------------------------------------------------------------------------------------------------*/

/* sample.c */

#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/wait.h>

void exit_sys(const char *msg);

int main(void)
{
	pid_t pid;

	if((pid = fork()) == -1)
		exit_sys("fork");

	if (pid == 0) {
		if (execl("test.txt", "test.txt", "ali", "veli", "selami", (char *)0) == -1)
			exit_sys("execl");

		/* Unreachable code */
	}

	if (wait(NULL) == -1)
		exit_sys("wait");


    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/* mample.c */

#include <stdio.h>

int main(int argc, char *argv[])
{
    printf("mample running...\n");

    for (int i = 0; i < argc; ++i)
        puts(argv[i]);
     
    return 0;
}

/* test.txt */

#!/home/kaan/Study/Unix-Linux-SysProg/mample ankara 

/*--------------------------------------------------------------------------------------------------------------------------
    Pekiyi bütün bunların anlamı nedir? Yani shebang ile bir script dosyasının aslında başka bir programı çalıştırmasının ne faydası olabilir?
    Bu mekanizma sayesinde yorumlayıcı yoluyla çalıştırılan dosyaların doğrudan çalıştırılabilmesine olanak sağlanmaktadır. Örneğin
    aşağıdaki gibi "sample.sh" isimli bir bash script dosyası olsun:

    #!/bin/bash

    for i in {1..10}
    do
        echo $i
    done

    Bu program 1'den 10'a kadar sayıları ekrana yazdırmaktadır. Normalolarakbir bash programı aşağıdaki gibi çalıştırılabilir:

    /bin/bash sample.sh

    Burada "sample.sh" dosyasının "x" hakkına sahip olması gerekmez. Ancak biz dosyası doğrudan aşağıdaki gibi çalıştırmak isteyebiliriz:

    ./sample.sh

    Bu durumda dosyanın "x" hakkına sahip olması gerekir. Dosyayı böyle çalıştırmak istediğimizde kabuk program exec işlemi uygulayıp
    "sample.sh" programını çalıştırmak isteyecektir. Sistem fonksiyonu da "sample.sh" programının çalıştırılabilir bir dosya formatına
    sahip olmadığını anladığında shebang satırına bakıp orada belirtilen "/bin/bash" programını çalıştıracaktır. Ancak bu programa 
    scipt dosyasının kendisini argüman olarak geçircektir. Yani program adeta şöyle çalıştırılmış olacaktır:

    /bin/bash sample.sh

    Pekiyi /bin/bash programı buradaki "sample.sh" programını çalıştırırken onun başında shebang satırı bir soruna yol açmayacak mı?
    İşte script dillerinin hemen hepsinde # özellikle bu shebang kullanımını desteklemek içn yorum satırı biçiminde ele alınmaktadır. 
    Aynı durum python, perl, sed, awk gibi dillerde de böyledir. Şimdi bir Python programını shebang ile çalıştıralım. Programın ismi
    "sample.py" olsun:

    #!/usr/bin/python3 

    for i in range(10):
        print(i)
        
    Bu dosyaya "x" vererek biz artık onu komut satırından çalıştırabiliriz:

    ./sample.py

    Aşağıdaki örnekte ekrana 1'den 10'a kadar sayıları yazan "sample.py" isimli bir python programı verilmiştir. Bu program 
    shebang içerdiğinden dolayı komut satırında "x" verilmişse doğrudan aşağıdaki gibi çalıştırılabilmektedir:

    ./sample.py
---------------------------------------------------------------------------------------------------------------------------*/

#!/usr/bin/python3 

for i in range(10):
    print(i)

/*--------------------------------------------------------------------------------------------------------------------------
    Bazen shebang yanında isteğe bağlı argüman gerekebilmektedir. Örneğin make programına bir dosyayı verebilmek için -f seçeneğinin 
    kullanılması gerekir. O halde make için shebang oluşturulurken -f seçeneğinin shebang satırında isteğe bağlı argüman olarak 
    belirtilmesi gerekir. Örneğin:

	#! /bin/make -f

    sample: sample.o
        gcc -o sample sample.o
    sample.o: sample.c
        gcc -c sample.c
        
    clean:
        rm -f *.o
        rm -f sample

    Burada dosyanın "sample.mak" isminde olduğunu düşünelim. Bu dosyaya "x" hakkını verdikten sonra onu aşağıdaki gibi çalıştırmış 
    olalım:

    ./sample.mak

    Bu çalıştırma aslında aşağıdakiyle eşdeğer olacaktır:

    /bin/make -f sample.mak
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Shebang satırında bazı şeylere dikkat etmek gerekir. Örneğin shebang karakterlerinin hemen ilk satırın başından başlatılması gerekir. 
    Aksi taktirde exec fonksiyonları ENOEXEC ile başarısız olacaktır. Eğer shebang karakterlerinin yanındaki dosya bulunamazsa 
    bu durumda exec fonksiyonları ENOENT ile başarısız olur. Eğer dosyanın ilk satırında shebang yoksa yine bu fonksiyonlar 
    errno değerini ENOEXEC ile set ederek başarısz olmaktadır. 
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    exec fonksiyonlarının p'li versiyonları (yani execlp ve execvp) özel bir davranışa sahiptir. Bilindiği gibi bu fonksiyonlar PATH çevre değişkeninde 
    belirtilen dizinlerde exec yapılan dosyayı tek tek aramaktadır. Eğer bunlar çalıştırılabilir olmayan dosyayı "x" hakkına sahip olarak bulup 
    ancak dosyanın başında "shebang" görmezlerse sanki dosyanın başında aşağıdaki gibi bir shebang olduğunu varsaymaktadır:

    #!/bin/sh

    Buradan şu sonuç çıkmaktadır: exec fonksiyonlarının p'li versyionları ile bir shell script dosyasını biz başında shebang satırı 
    olmadan da çalıştırabiliriz. Ancak exec fonksiyonlarının p'siz versyionlarında bunu yapamayız. Öte yandan Linux sistemlerinde 
    zaten execve dışındaki exec fonksiyonlarının sistem fonksiyonu olmadığını anımsayınız. O halde exec fonksiyonlarının p'li versiyonları
    tamamen user modda script dosyasını execve yaptıktan sonra ENOEXEC errno değeri ile fonksiyonun başarısız olduğunu gördüklerinde
    bu kez "/bin/sh" dosyasını execve ile exec yapmaktadır. Dosya isminin içerisinde "/" karakteri kullanılsa bile exec fonksiyonlarının p'li 
    versiyonlarının davranışı yine bu biçimdedir. exec fonksiyonlarının p'li versiyonlarının bu davranışı POSIX'te eskiden isteğe
    bağlı bırakılmıştı. Ancak sonra standartlarda bu davranış zorunlu tutulmuştur. Ancak POSIX standartları çalıştırılacak shell programının
    ne olacağı konusunda bir belirlemede bulunmamıştır.
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Pekiyi shebang'te belirtilen dosyanın kendisi de bir script dosyası olabilir mi? Yani bu shebang işlemi özyinelemeli midir?
    Aslında POSIX standartları bu konuda bir şey söylememiştir. Bu durumda böyle bir işlemin özyinelemeli yapılacağının bir garantisi 
    yoktur. Linux çekirdeği bu tür durumlarda dört kademeye kadar özyineleme yapabilmektedir. Siz de deneme yoluyla bu özyinelemeyi 
    yapıp sonucuna bakabilirsiniz. 
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
                                            31. Ders 18/02/2023 - Pazar
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    system isimli bir standart C fonksiyonu vardır. Bu fonksiyon ilgili sistemdeki kabuk programını (command interpreter)
    interaktif olmayan modda çalıştırarak bizim verdiğimiz bir kabuk komutunun kabuk tarafından çalıştırılmasını sağlar. 
    Böylece biz kabuk üzerinde yazabildiğimiz tüm komutları bir C programının içerisinde bu yolla çalıştırabiliriz. system
    fonksiyonunun prototipi şöyledir:

    #include <stdlib.h>

    int system(const char *command);

    Fonksiyon parametre olarak kabuğa işletilecek komut yazısını almaktadır. Tabii system bir standart C fonksiyonu olduğuna göre
    yalnızca UNIX/Linux sistemlerinde değil diğer tüm sistemlerde de kullanılabilmektedir. Örneğin system fonksiyonu UNIX/Linux sistemlerinde
    "/bin/sh" programını çalıştırırken, Windows sistemlerinde "cmd.exe" programını çalıştırmaktadır. Tabii bir sistemde kabuk programı bulunuyor
    olmak zorunda değildir. Örneğin pek çok gömülü sistemde bir işletim sistemi olmadığı için kabuk programı da yoktur. İşte programcı
    ilgili sistemde kabuk programının olup olmadığını fonksiyonun parametresine NULL adres geçerek test edebilir. Bu durumda system fonksiyonu 
    eğer ilgili sistemde kabuk programı varsa sıfır dışı bir değere yoksa 0 değerine geri dönmektedir. Tabii programcı Windows, UNIX/Linux ve 
    macOS gibi sistemlerde çalışıyorsa böyle bir kontrol yapmaz. 

    Pek çok sistemde kabuk programları "interaktif olmayan (noninteractive)" bir modda çalıştırılabilmektedir. Örneğin UNIX/Linux 
    kabuk programları "-c" seçeneği ile çalıştırılırsa yalnızca bir komutu çalıştırıp sonlanmaktadır. Örneğin:

    bash -c "ls -l; cat sample.c" 

    Benzer biçimde Windows sistemlerinde de "cmd.exe" kabuk programı /C seçeneği ile benzer biçimde çalıştırılabilmektedir. 

    O halde UNIX/Linux sistemlerinde system fonksiyonu kabuk programını "-c" seçeneği ile fork/exec yoluyla çalıştırmaktadır. 
    Eğer system fonksiyonu fork ya da wait işlemini yapamazsa -1 değeri ile geri dönmektedir. Eğer fork yapıp exec yapamazsa sanki _exit(127) biçiminde oluşturulan 
    ve waitpid fonksiyonu ile elde edilen değere (status) geri dönmektedir. Diğer durumlarda (yani fork ve exec başarılı bir biçimde yapılmışsa) system fonksiyonu çalıştırdığı 
    kabuk pogramının waitpid fonksiyonuyla elde edilen değerine (status) geri dönmektedir.  Tabii kabuk programları da interaktif olmayan modda çalıştırılan 
    komutun waitpid fonksiyonu ile elde edilen (status) değerine geri dönerler. Örneğin:

    system("ls -l");

    Burada system fork/exec ile "/bin/sh" programını -c seçeneği ile çalıştırmaktadır. Tabii kabuk programı da "ls" programını 
    fork/exec ile çalıştıracaktır. (Bazen kabuk programları interaktif modda eğer tek bir komut işletiliyorsa boşuna fork yapmayabilir).
    Burada kabuk programı aslında "ls" programının waitpid fonlsiyonu ile elde edilen değeri ile (status) sonlanmaktadır. Dolayısıyla biz aslında system fonksiyonun 
    geri dönüş değeri olarak çalıştırdığımız "ls" programının waitpid fonksiyonu ile elde edilen (status) değeri elde etmiş oluruz. UNIX/Linux sistemlerinde genel 
    olarak kabuk komutları (yani programları) başarı durumunda exit kod olarak 0 değerini oluşturmaktadır. 

    Pekiyi system fonksiyonunun başarısını nasıl tespit edebiliriz? Biz fonksiyonun geri dönüş değerini -1 ve 127 ile test edebiliriz. Örneğin:

    result = system("ls -l") ;

    if (result == -1 || (WIFEXITED(result) && WEXITSTATUS(result) != 0) {
        fprintf(stderr, "command failed!\n");
        exit(EXIT_FAILURE);
    }

    Biz kabuk programını system fonksiyonu ile çalıştırırken komutlar arasına ";" koyarak birden fazla komutun çalıştırılmasını sağlayabiliriz. 
    Genel olarak kabuk bu durumda son komutun exit kodunu bize vermektedir. 

    Aslında programcılar genellikle system fonksiyonu için yalnızca -1 kontrolünü yapmaktadır. Yani çalıştırdıkları komutun başarısını kontrol etmemektedir. Örneğin:

    if (system("any command") == -1)
        exit_sys("system");

    Aşağıda system fonksiyonun kullanımına bir örnek verilmiştir.
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>

void exit_sys(const char *msg);

int main(void)
{
	int result;

	if (system("ls -l > test.txt") == -1) 
        exit_sys("system");
		
	printf("Ok\n");
		
    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/*--------------------------------------------------------------------------------------------------------------------------
    Pekiyi system fonksiyonunu nasıl yazabiliriz? Aşağıda buna bir örnek verilmiştir. Ancak aşağıdaki örnekte bazı noktalar 
    henüz kursumuzda o konu anlatılmadığı için ihmal edilmiştir. Bu noktalar şunlardır:

    - waitpid fonksiyonu sinyalle kesilirse yeniden çalıştırılması gerekir
    - Üst prosesin işlemler sırasında SIGCHLD sinyalini, SIGINT ve SIGQUIT sinyallerini bloke etmesi gerekmektedir. 
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/wait.h>

void exit_sys(const char *msg);

int mysystem(const char *command)
{
	pid_t pid;
	int status;

	if (command == NULL)
		return 1;

	if ((pid = fork()) == -1)
		return -1;

	if (pid == 0) {
		if (execl("/bin/sh", "/bin/sh", "-c", command, (char *)0) == -1)
			_exit(127);
		/* unreachable code */
	}
	if (waitpid(pid, &status, 0) == -1)
		return -1;

	return status;
}

int main(void)
{
	int result;

	result = mysystem("ls");

	if (result == -1 || WIFEXITED(result) && WEXITSTATUS(result) != 0) {
		fprintf(stderr,"command failed!..\n");
		exit(EXIT_FAILURE);
	}
		
	printf("Ok\n");
		
    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/*--------------------------------------------------------------------------------------------------------------------------
    Pekiyi mademki system fonksiyonu bizim için zaten fork/exec işlemlerini yapmaktadır, bu durumda örneğin bir programı çalıştırmak için 
    biz fork/exec kullanmak yerine bu işlemi system fonksiyonu ile yapamaz mıyız? Bu sorunun yanıtı genel olarak bu işlemlerin 
    system fonksiyonu ile yapılabileceğidir. Ancak bu konudaki her türlü gereksinimimizi system fonksiyonu karşılayamaz. 
    Örneğin fork işleminden sonra alt proseste ayarlamalar yapıp exec yapmak isteyebiliriz. Ayrıca system fonksiyonu kendi içerisinde
    kabuk programını çalıştırdığı için daha yavaş ve daha fazla kaynak kullanır durumdadır. Bizim tavsiyemiz bir programı açıkça 
    fork/exec ile çalıştırmak ancak karmaşık işlemleri (örneğin IO redirection, boru vs. gibi) system fonksiyonuyla yapmaktır. 
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Aşağıdaki örnekte kabuk programı system fonksiyonu sayesinde sarmalanmıştır. 
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

int main(void)
{
	char cmd[4096];
	char *str;

	for (;;) {
		printf("CSD>");
		fflush(stdout);

		if (fgets(cmd, 4096, stdin) != NULL)
			if ((str = strchr(cmd, '\n')) != NULL)
				*str = '\0';
			if (!strcmp(cmd, "exit"))
				break;
		if (system(cmd) == -1)
			perror("system");
	}

    return 0;
}

/*--------------------------------------------------------------------------------------------------------------------------
    Biz şimdiye kadar dosyalar için 9 tane erişim bayrağı gördük: S_IRUSR, S_IWUSR, S_IXUSR, S_IRGRP, S_IWGRP, S_IXGRP, S_IROTH, 
    S_IWOTH, S_IXOTH. Bu bayraklar dosyanın "rwx rwx rwx" erişim haklarını belirtmektedir. Ancak aslında dosyaların erişim hakları 9 
    tane değil 12 tanedir. Henüz görmediğimiz bu üç erişim hakkına "set-user-id", "set-group-id" ve "sticky" hakları denilmektedir. 
    Şimdi dikkatimizi bu üç erişim hakkına çevireceğiz. Bu üç erişim hakkı open fonksiyonunda ya da chmod fonksiyonunda sırasıyla 
    S_ISUID, S_ISGID ve S_ISVTX sembolik sabitleriyle kullanılabilmektedir. 
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Komut satırında dosyanın set-user-id bayrağını set etmek için u+s seçeneği kullanılabilir. Örneğin:

    kaan@kaan-virtual-machine:~/Study/Unix-Linux-SysProg$ ls -l sample
    -rwxrwxrwx 1 kaan study 17176 Şub 19 11:46 sample
    kaan@kaan-virtual-machine:~/Study/Unix-Linux-SysProg$ chmod u+s sample
    kaan@kaan-virtual-machine:~/Study/Unix-Linux-SysProg$ ls -l sample
    -rwsrwxrwx 1 kaan study 17176 Şub 19 11:46 sample
    
    Görüldüğü gibi dosyanın set-user-id bayrağı set edildiğinde "x" hakkının yerinde "s" harfi gözükmektedir. Yani eğer dosyanın 
    hem "x" bayrağı hem de set-user-id bayrağı set edilmişse "x" hakkının bulunduğu yerde "s" harfi gözükmektedir. Ancak dosyanın yalnızca set-user-id
    bayrağı set edilmişse "x" hakkının bulunduğu yerde "S" harfi gözükür. Örneğin:

    kaan@kaan-virtual-machine:~/Study/Unix-Linux-SysProg$ ls -l test.txt
    -rw-rw-rw- 1 kaan study 2087 Şub 19 10:49 test.txt
    kaan@kaan-virtual-machine:~/Study/Unix-Linux-SysProg$ chmod u+s test.txt
    kaan@kaan-virtual-machine:~/Study/Unix-Linux-SysProg$ ls -l test.txt
    -rwSrw-rw- 1 kaan study 2087 Şub 19 10:49 test.txt

    Dosyanın set-grup-id bayrağının set edilmesi de chmod komutunda g+s ile yapılmaktadır. İşlem sonrasında yine grup bilgisinin "x"
    hakkı yerinde "s" ya da "S" görünür. chmod komutunda +s kullanılırsa bu durumda dosyanın hem set-user-id hem de set-group-id bayrakları set edilir. 
    Dosyanın sticky bayrağını set etmek için chmod komutunda +t kullanılmaktadır. Bu işlem yapıldığında görüntü olarak grup
    hakkında "x" varsa x hakkının olduğu yerde "t", yoksa orada "T" görülmektedir. 

    chmod fonksiyonunda yukarıda belirttiğimiz bayrakları kullanrak set-user-id, set-group-id ve stick bayraklarını set edebiliriz. 
    Örneğin biz "sample" programını rwsrwxrwx haline şöyle getirebiliriz:

	if (chmod("sample", S_IRWXU|S_IRWXG|S_IRWXO|S_ISUID) == -1)
		exit_sys("chmod");

    Pekiyi zaten var olan bir dosyaya bu özellikleri programlama yoluyla nasıl ekleyebiliriz? Bunun için önce dosyanın erişim 
    haklarının stat, lstat ya da fstat fonksiyonuyla elde edilmesi gerekmektedir. Ondan sonra bu erişim haklarına biz S_ISUID, S_ISGID
    ve S_ISVTX bayraklarını OR işlemiyle ekleyebiliriz. Ancak stat fonksiyonun bize verdiği st_mode değeri dosyanın türünü de 
    içermektedir. Gerçi chmod fonksiyonu bu eksta bitleri dikkate almamaktadır. Ancak yine de stat yapısının st_mode elemanındaki 
    değerin S_IFMT ile maskelemek daha uygundur. (Stevens "Advanced Programming in the UNIX Environment" kitabında böyle yapamıştır.)
    O halde bu işlem şöyle yapılabilir:

    struct stat finfo;

	if (stat("sample", &finfo) == -1)
		exit_sys("stat");

	if (chmod("sample", (finfo.st_mode & ~S_IFMT) | S_ISUID) == -1)     /* ~S_IMT maskelemesi yapılmasa da genel olarak bir sorun oluşmaz */
		exit_sys("chmod");

---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <sys/stat.h>

void exit_sys(const char *msg);

int main(void)
{
	struct stat finfo;

	if (stat("sample", &finfo) == -1)
		exit_sys("stat");

	if (chmod("sample", (finfo.st_mode & ~S_IFMT) | S_ISUID) == -1)
		exit_sys("chmod");

    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/*--------------------------------------------------------------------------------------------------------------------------
    Pekiyi bir dosyanın set-user-id ve set-group-id bayraklarının set edilmiş olmasının ne anlamı vardır? Öncelikle bu bayrakların 
    yalnızca "çalıştırılabilir dosyalar için" anlamlı olduğunu belirtelim. Yani bu bayraklar tasarımda "çalıştırılabilir dosyalar" 
    için düşünülmüştür. Çalıştırılabilir dosyanın set-user-id bayrağı set edilmişse bu dosya exec yapıldığında prosesin etkin kullanıcı 
    id'si işletim sistemi tarafından dosyanın kullanıcı id'si olacak biçimde değiştirilmektedir. Benzer biçimde çalıştırılabilir dosyanın
    set-group-id bayrağı set edilmişse bu dosya exec yapıldığında prosesin etkin grup id'si dosyanın grup id'si olarak değiştirilmektedir. 
    Başka bir deyişle örneğin biz set-user-id bayrağı set edilmiş bir programı çalıştırdığımızda artık prosesimiz etkin kullanıcı id'si sanki o dosyanın 
    sahibiymiş gibi olmaktadır. 

    /bin/passwd programı ile biz kendi parolamızı değiştebilmekteyiz. Ancak bu program sıradan kullanıcılara yazma hakkı verilmemiş olan 
    /etc/passwd ve /etc/shadow dosyalarında değişikler yapabilmektedir. İşte biz /bin/passwd programının set-user-id bayrağı set edildiği için
    onu çalıştırdığımızda sanki program "root" önceliğinde çalışmaktadır. Böylece program bu dosyalarda değişiklik yapabilmektedir. 
    /bin/passwd programının erişim hakları şöyledir:

    -rwsr-xr-x 1 root root 68208 May 28  2020 /bin/passwd

    Aşağıdaki örnekte "sample" programı "mample" programını exec yaparak çalıştırmıştır. Biz bu örnekte mample programını
    derledikten sonra chwon komutuyla sudo ile birlikte kullanıcı id'sini ve group id'sini root olarak değiştirdik.  
    Bu mample programı prosesin gerçek ve etkin kullanıcı ve grup id'lerini ekrana isim olarak yazdırmaktadır. Bu deneyi önce
    mample programının set-user-id bayrağı set edilmeden ve  set edildikten sonra yineleyniz. Aşağıda yapılanlar özetlenmiştir:

    gcc -o sample sample.c
    gcc -o mample mample.c
    ls -l mample
    -rwxr-xr-x 1 kaan study 17088 Şub 19 13:42 mample
    sudo chown root:root mample
    ls -l mample
    -rwxr-xr-x 1 root root 17088 Şub 19 13:42 mample
    ./sample
    Real user id: kaan
    Effective user id: kaan
    Real group id: study
    Effective group id: study
    sudo chmod u+s mample
    ls -l mample
    -rwsr-xr-x 1 root root 17088 Şub 19 13:42 mample
    ./sample
    Real user id: kaan
    Effective user id: root
    Real group id: study
    Effective group id: study
    sudo chmod g+s mample
    ls -l mample
    -rwsr-sr-x 1 root root 17088 Şub 19 13:42 mample
    ./sample
    Real user id: kaan
    Effective user id: root
    Real group id: study
    Effective group id: root
---------------------------------------------------------------------------------------------------------------------------*/

/* sample.c */

#include <stdio.h>
#include <stdlib.h>
#include <sys/wait.h>
#include <unistd.h>

void exit_sys(const char *msg);

int main(void)
{
	pid_t pid;

	if ((pid = fork()) == -1)
		exit_sys("fork");

	if (pid == 0 && execl("mample", "mample", (char *)0) == -1)
		exit_sys("execl");

	if (wait(NULL) == -1)
		exit_sys("wait");

    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/* mample.c */

#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <pwd.h>
#include <grp.h>

void exit_sys(const char *msg);

int main(void)
{
    struct passwd *pass;
    struct group *gr;

    if ((pass = getpwuid(getuid())) == NULL)
        exit_sys("getpwuid");
    printf("Real user id: %s\n", pass->pw_name);

    if ((pass = getpwuid(geteuid())) == NULL)
        exit_sys("getpwuid");
    printf("Effective user id: %s\n", pass->pw_name);

    if ((gr = getgrgid(getgid())) == NULL)
        exit_sys("getgrgid");
    printf("Real group id: %s\n", gr->gr_name);

    if ((gr = getgrgid(getegid())) == NULL)
        exit_sys("getgrgid");
    printf("Effective group id: %s\n", gr->gr_name);

    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/*--------------------------------------------------------------------------------------------------------------------------
                                                32. Ders 25/02/2023 - Cumartesi
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Normal olarak set-user id ve set-group-d bayrakları çalıştırılabilen dosyalar için söz konusudur. Ancak dizinler için de 
    set-group-d bayrağının bir anlamı vardır. Pek çok UNIX türevi sistemde (Linux da buna dahil) bir dizin'in set-group-id bayrağı
    set edilirse Linux o dizin içerisinde open fonksiyonuyla (zaten başka yolu yoktur) ya da mkdir fonksiyonu ile bir dosya ya da dizin 
    yaratıldığında dosyanın grup id'sini prosesin etkin grup id'si olarak değil, o dizin'in grup id'si olarak set etmektedir. BSD sistemlerinde 
    zaten default olarak bir dosya ya da dizin yaratıldığında dosyanın ya da dizin'in grup id'si o dosyanındosya ya da dizin'in içinde bulunduğu 
    dizin'in grup id'si olarak set edilir. O halde Linux'ta open fonksiyonu ile bir dosya ya da dizin yaratılırken dosya ya da dizin'in grup id'si 
    eğer o dosyanın içinde bulunduğu dizin'in set-group-id  bayrağı set edilmemişse prosesin etkin group id'si olarak eğer set edilmişse 
    dizin'in grup id'si olarak set edilmektedir. 
    
    Dizinlerin set-user-id bayraklarının set edilmesi benzer bir etkiye yol açmamaktadır. (Bu durum bazı eski UNIX sistemlerinde denenmiştir ancak
    modern sistemlerde böyle br semantik yoktur.)
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Pekiyi script dosyaları (shebang içeren text dosyaları) için set-user-id ve set-group-id bayrakları set edilebilir mi?
    Bu işlem ilk zamanlar uygulanmışır. Ancak güvenlik açığı nedeniyle sonra uygulamadan kaldırılmıştır. Bugünkü modern UNIX/Linux 
    sistemleri script dosyalarının set-user-id ve set-group-id bayrakları set edilmiş olsa bile onları dikkate almamaktadır. Buradaki 
    güvenlik açığı ilginç bir biçimde aşağıdaki gibi oluşmaktadır:

    - Script dosyasının ismi "x.txt" olsun. Eğer bu dosyanın set-user-id ve set-group-id bayrakları dikkate alınsaydı bu durumda
    exec fonksiyonları bu dosyayı açıp shebang satırında bulunan programı çalıştırırken prosesin etkin kullanıcı ve/veya grup id'sini 
    "x.txt" dosyasının kullanıcı ve/veya grup id'si olarak set ederdi. Bu durumda da eğer birisi örneğin "y.txt" sembolik bağlantı dosyası oluşturup bu 
    dosyanın "x.txt" dosyasını göstermesini sağlarsa ve bu "y.txt" ile exec yaparsa bu durumda aslında exec fonksiyonu sembolik bağlantıyı izleyecek
    ve "x.txt" dosyasını çalıştıracaktır. Ancak exec fonksiyonları bu "x.txt" dosyasının shebang satırındaki programı çalıştırırken yine
    komut satırı argümanı olarak "y.txt" dosyasını kullanacaktır. İşte tam bu sırada birisi bu "y.txt" dosyasınının sembolik bağlantısını değiştirirse
    maalesef prosesin etkin kullanıcı id'si "x.txt"nin kullanıcı id'si olarak buradaki başka dosyayı çalıştırır. 
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Pekiyi dosyaların sticky bayraklarının ne işlevi vardır? Aslında sticky bayrağı tasarımda başka bir amaçla düşünülmüşür. 
    Eski sistemlerde çalıştırılabilen dosyaların çalıştırılması sonrasında programın bellekten atılmaması gibi bir ip ucu oluşturmaktadır. 
    Ancak modern sistemlerde böyle bir etkinin bir anlamı kalmadığı için sticky bayrağı da ilk tasarlandığı zamanki işlevinden tamamen kopmuştur. 
    Bugün sticky bayrağı değişik sistemlerde değişik amaçlarla kullanılabilmektedir. POSIX standartları eskiden sticky bayrağı üzerinde
    açıklama yapmıyordu. Ancak belli zamandan sonra sticky için şöyle bir işlevsellik tanımlanmıştır: Bir dizin'in sticky bayrağı 
    set edilirse dizine prosesin yazma hakkı olsa bile dizin içerisindeki başkalarına ait (yani kullanıcı id'si başka) olan 
    dosyalar silinememekte ve ismi değiştirilememektedir. Bugünkü sistemlerde dizin dışında diğer dosyaların sticky bayraklarının set edilmiş 
    olup olmamasının işlevsel bir anlamı yoktur. Örneğin Linux sistemlerinde /tmp dizininin sticky bayrağı et edilmişir ve bu dizine
    yazma hakkı verilmiştir. Bu durumda biz bu dizinde dosya yaratabiliriz, kendi dosyamızı silebiliriz. Ancak başkalarının dosyalarını silemeyiz.
    /tmp dizininin erişim hakları şöyledir:

    drwxrwxrwt 19 root root 65536 Şub 25 10:05 /tmp
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Daha önceden de belirttiğimiz gibi bir prosesin "gerçek kullanıcı id'si (real user id)" ve "etkin kullanıcı id'si (effective user id)", 
    "gerçek grup id'si (real group id)" ile de "etkin grup id'si (effective group id)" aynı olmaktadır. Ancak set-user-id ve et-group-id bayrakları 
    set edilmiş çalıştırılabilir programlar çalıştırıldığında bu id'ler farklı gelebilmektedir. Örneğin prosesimizin gerçek kullanıcı id'si ve
    etkin kullanıcı id'si "kaan" olsun. Biz set-user-id bayrağı set edilmiş "/bin/passwd" programını exec yaptığımızda prosesimizin gerçek kullanıcı 
    id'si "kaan" olmaya devam eder ancak etkin kullanıcı id'si "root" olur. Dosya işlemlerinde teste her zaman etkin id'ler sokulmaktadır.
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Gerçek kullanıcı id'si ve gerçek grup id'si, etkin kullanıcı id'si ve etkin grup id'si dışında bir de 
    "saklı kullanıcı id'si (saved set user id)" ve "saklı grup id'si (saved set group id)" denilen iki id daha vardır. 
    Bir proses exec uyguladığında programın set-user-id ve set-group-id bayrakları set edilmiş olsun ya da olmasın her zaman 
    kernel yeni etkin kullanıcı id'sini ve yeni etkin grup id'sini saklı kullanıcı id'si ve saklı grup id'si olarak set etmektedir. 
    Örneğin prosesimizin gerçek kullanıcı id'si "kaan" ve etkin kullanıcı id'si "kaan", gerçek grup id'si "study" ve "etkin grup id'si "study" 
    olsun. Şimdi biz set-user-id bayrağı set edilmiş olan "/bin/passwd" programını exec ile çalıştıralım. Arık prosesimizin gerçek kullanıcı id'si "kaan", 
    etkin kullanıcı id'si "root" olacaktır. Gerçek group id'si "study" ve etkin grup id'si "study" olarak kalacaktır.    
    İşte kernel aynı zamanda bu yeni etkin kullanıcı ("root" id'sini kastediyoruz) ve grup id'sini  prosesin "saklı kullanıcı id'si (saved set user id)" 
    ve saklı grup id'si olarak da set etmektedir. O halde prosesimizin id'leri artık şöyle olacaktır:

    gerçek kullanıcı id'si: kaan
    etkin kullanıcı id'si: root
    saklı kullanıcı id'si: root
    gerçek grup id'si: study
    etkin grup id'si: study
    saklı grup id'si: study

    Bu işlem set-user id ya da set-group-id bayrağı set edilmemiş programlar çalıştırılıken de yürütülmektedir. Örneğin prosesimizin
    gerçek kullanıcı id'si "kaan", etkin kullanıcı id'si "kaan", gerçek grup id'si "study" ve etkin grup id'si "study" olsun. 
    Biz de set-user-id bayrağı set edilmemiş olan bir programı exec yapmaış olalım. Yeni id'ler şöyle olacaktır:

    gerçek kullanıcı id'si: kaan
    etkin kullanıcı id'si: kaan
    saklı kullanıcı id'si: kaan
    gerçek grup id'si: study
    etkin grup id'si: study
    saklı grup id'si: study

    Tabii saklı kullanıcı id'si ve saklı grup id'si yine porses kontrol bloğu içerisinde (Linux'taki task_struct yapısı) saklanmaktadır. 
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    O anda çalışmakta olan prosesin (yani kendi prosesimizin) gerçek ullanıcı id'si getuid isimli POSIX fonksiyonuyla, etkin kullanıcı 
    id'si geteuid isimli POSIX fonksiyonuyla elde edilebilmektedir. Fonksiyonların prototipleri şöyledir:

    #include <unistd.h>

    uid_t getuid(void)
    uid_t geteuid(void)

    uid_t türü <unistd.h> ve <sys/types.h> osyaları içerisinde bir tamsayı türü olacak biçimde typedef edilmiştir. Bu fonksiyonlar başarısız
    olamamaktadır. 

    O anda çalışmakta olan prosesin gerçek grup id'si getgid POSIX fonksiyonu ile, etkin grup id'si ise getegid fPOSIX fonksiyonu ile 
    elde edilebilmektedir. Fonksiyonların prototipleri şöyledir:

    #include <unistd.h>

    gid_t getgid(void);
    gid_t getegid(void);

    Bu fonksiyonlar da başarısız olamamaktadır. 

    POSIX standartlarında saklı id'leri alan fonksiyonlar yoktur. Ancak Linux sistemlerinde bu işlemi yapacak fonksiyon bulunmaktadır.
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>
#include <unistd.h>
#include <pwd.h>
#include <grp.h>

void exit_sys(const char *msg);

int main(void)
{
	uid_t ruid, euid;
	gid_t rgid, egid;
	struct passwd *pass;
	struct group *grp;

	ruid = getuid();
	if ((pass = getpwuid(ruid)) == NULL)
		exit_sys("getpwuid");

	printf("Real User Id: %s (%ju)\n", pass->pw_name, (uintmax_t)ruid);

	euid = geteuid();

	if ((pass = getpwuid(euid)) == NULL)
		exit_sys("getpwuid");

	printf("Effective User Id: %s (%ju)\n", pass->pw_name, (uintmax_t)euid);

	rgid = getgid();
	if ((grp = getgrgid(rgid)) == NULL)
		exit_sys("getgrgid");

	printf("Real Group Id: %s (%ju)\n", grp->gr_name, (uintmax_t)rgid);

	egid = getegid();

	if ((grp = getgrgid(egid)) == NULL)
		exit_sys("getgrgid");

	printf("Effective Group Id: %s (%ju)\n", grp->gr_name, (uintmax_t)egid);

    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/*--------------------------------------------------------------------------------------------------------------------------
    Prosesin kullanıcı ve grup id'lerini set etmek için setuid, setgid, seteuid ve setegid POSIX fonksiyonları bulundurulmuştur. 
    Ancak bu fonksiyonların sematiği kişiler biraz karmaşık gelmektedir. Biz burada bu fonksiyonları tek tek açıklayacağız.
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    setuid fonksiyonun prototipi şöyledir:

    #include <unistd.h>

    int setuid(uid_t uid);

    Her ne kadar fonksiyonun ismi sanki yalnızca prosesin "gerçek kullanıcı id'sini" değişterecek gibi görünüyorsa da aslında
    fonksiyon şöyle davranmaktadır: 

    1) Prosesin önceliği uygunsa (appropriate privilege) yani prosesin etkin kullanıcı id'si 0 ise ya da Linux sistemlerinde proses bu işi yapacak
    yeterliliğe (capability) sahipse (CAP_SETUID) fonksiyon prosesin hem gerçek kullanıcı id'sini, hem etkin kullanıcı id'sini hem de saklı 
    kullanıcı id'sini parametresi ile belirtilen kullanıcı id'si yapar. 

    2) Eğer prosesin önceliği uygun değilse (yani root değilse ya da Linux'ta CAP_SETUID yeterliliği yoksa) bu durumda setuid fonksiyonu
    eğer parametresi ile belirtilen uid değeri prosesin gerçek ya da saklı kullanıcı id'si ile aynı ise proesin yalnızca etkin kullanıcı id'sini
    parametresi ile belirtilen id olarak değiştirir. Bu koşullar sağlanmıyorsa fonksiyon başarısız olmaktadır. Pekiyi bunun anlamı nedir? 
    Bu işlem set-user-id prgramların kısmen geri daha sonra dönüp yeniden önceliği geri almasını sağlamak için düşünülmüştür. Saklı id'lerin
    kullanımasının tek nedeni de budur. Şöyle ki:

    - Biz kaan prosesi olarak set-user-id bayrağı set edilmiş root programını çalıştırdığımızı düşünelim. Şimdi bizim id'lerimiz
    şöyle olacaktır:

    Gerçek kullanıcı id'si: kaan
    Etkin kulanıcı id'si: root
    Saklı kullanıcı id'si: root

    Şimdi biz sonraki pragrafta göreceğimiz seteuid fonksiyonu ile geri dönüp prosesin yetkisini azaltarak onun etikin kullanıcı id'sinin 
    kaan olmasını sağlayalım. Bu udurmdaki id'ler şöyle olacaktır:
    
    Gerçek kullanıcı id'si: kaan
    Etkin kulanıcı id'si: kaan
    Saklı kullanıcı id'si: root

    İşte şimdi bu noktada biz setuid fonksiyonu ile yeniden root önceliğine dönebiliriz. Çünkü bizim şu anda uygun önceliğimiz olmasa da
    saklı kullanıcı id'miz hala root durumundadır. Yani programlar önceliği yükse birtakım işlemler yapıp sonra önceliği düşürüp sonra da yüksek 
    önceliğe geri dönmek için saklı id'ler uydurulmuştur. 

    setuid fonksiyonu başarı durumunda 0 değerine, başarısızlık durumunda -1 değerine geri döner ve errno uygun biçimde set edilir. 
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    seteuid fonksiyonu setuid fonksiyonunun yalnızca etkin kullanıcı id'sini set eden biçimidir. Genellikle setuid yerine bu fonksiyon 
    tercih edilmektedir. Fonksiyonun prototipi şöyledir:

    #include <unistd.h>

    int seteuid(uid_t uid);

    Fonksiyonun çalışması şöyledir:

    1) Prosesin önceliği uygunsa (appropriate privilege) yani prosesin etkin kullanıcı id'si 0 ise ya da proses Linux sistemlerinde bu işi yapacak
    yeterliliğe (capability) sahipse (CAP_SETUID) fonksiyon prosesin yalnızca etkin kullanıcı id'sini parametresiyle belirtilen id olarak değiştirir. 
    Gerçek kullanıcı id'si ve saklı kullanıcı id'si değiştirilmez. 

    2)  Eğer prosesin önceliği uygun değilse (yani root değilse ya da Linux'ta CAP_SETUID yeterliliği yoksa) bu durumda seteuid fonksiyonu
    eğer parametresi ile belirtilen uid değeri prosesin gerçek ya da saklı kullanıcı id'si ile aynı ise proesesin yalnızca etkin kullanıcı id'sini
    parametresi ile belirtilen id olarak değiştirir.

    Görüldüğü gibi eğer prosesin önceliği uygun değilse zaten setuid fonksiyonu ile seteuid fonksiyonu arasında bir fark kalmamaktadır. 

    Bu durumda geri dönüş senaryosu tam olarak şöyle gerçekleştirilir. Yine prosesimizin id'leri şöyle olsun:

    Gerçek kullanıcı id'si: kaan
    Etkin kulanıcı id'si: kaan
    Saklı kullanıcı id'si: kaan

    Şimdi biz set-user-id bayrağı set edilmiş bir programı exec yapalım. Id'lerimiz şöyle olacaktır:

    Gerçek kullanıcı id'si: kaan
    Etkin kulanıcı id'si: root
    Saklı kullanıcı id'si: root

    Şimdi çalıştırdığımız program kaan olarak bazı şeyleri yapmak istesin o zaman şu çağrıyı yapacaktır:

    seteuid(getuid());

    Şimdi prosesin id'leri şöyle olacaktır:

    Gerçek kullanıcı id'si: kaan
    Etkin kulanıcı id'si: kaan
    Saklı kullanıcı id'si: root

    Burada saklı kullanıcı id'sinin değişmediğine dikkat ediniz. Şimdi proses kaan olarak bazı şeyleri yaptıktan sonra yeniden root olmak istesin:

    seteuid(0);

    Tabii aynı işlem setuid(0) ile de yapılabilirdi. Şimdi prosesin id'leri şöyle olacaktır:

    Gerçek kullanıcı id'si: kaan
    Etkin kulanıcı id'si: root
    Saklı kullanıcı id'si: root

    Eğer saklı kullanıcı id'si diye bir kavram uydurulmuş olmasaydı geri dönüş yapılamazdı. 
    
    seteuid fonksiyonu başarı durumunda 0 değerine başarısızlık durumunda -1 değerine geri önmektedir. errno uygun biçimde set edilmektedir. 
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    setgid fonksiyonun temel semantiği setuid fonksiyonunda olduğu gibidir. Fonksiyonun prototipi şöyledir:

    #include <unistd.h>

    int setgid(gid_t gid);

    Fonksiyon şöyle çalışmaktadır:

    1) Prosesin önceliği uygunsa (appropriate privilege) yani prosesin etkin kullanıcı id'si 0 ise ya da Linux sistemlerinde proses bu işi yapacak
    yeterliliğe (capability) sahipse (CAP_SETGID) fonksiyon prosesin hem gerçek grup id'sini, hem etkin grup id'sini hem de saklı 
    grup id'sini parametresi ile belirtilen grup id'si yapar. 

    2) Eğer prosesin önceliği uygun değilse (yani root değilse ya da Linux'ta CAP_SETGID yeterliliği yoksa) bu durumda setgid fonksiyonu
    eğer parametresi ile belirtilen gid değeri prosesin gerçek ya da saklı grup id'si ile aynı ise prosesin yalnızca etkin grup id'sini
    parametresi ile belirtilen grup id olarak değiştirir.

    Buradaki amaç tamamen set-group-id bayrağı set edilmiş programların grup id'lerini geri döndürüp yeniden eski değere set edebilmesidir.
    
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    setegid fonksiyonun temel semantiği de seteuid fonksiyonunda olduğu gibidir. Fonksiyonun prototipi şöyledir:

    #include <unistd.h>

    int setegid(gid_t gid);

    Fonksiyon şöyle çalışmaktadır:

    1) Prosesin önceliği uygunsa (appropriate privilege) yani prosesin etkin kullanıcı id'si 0 ise ya da Linux sistemlerinde proses bu işi yapacak
    yeterliliğe (capability) sahipse (CAP_SETGID) fonksiyon prosesin yalnızca etkin grup id'sini parametresiyle belirtilen grup id'i olarak değiştirmektedir.

    2) Eğer prosesin önceliği uygun değilse (yani root değilse ya da Linux'ta CAP_SETGID yeterliliği yoksa) bu durumda setegid fonksiyonu
    eğer parametresi ile belirtilen gid değeri prosesin gerçek ya da saklı grup id'si ile aynı ise prosesin yalnızca etkin grup id'sini
    parametresi ile belirtilen grup id olarak değiştirir.

    Yani eğer prosesin önceliği uygun değilse bu durumda setgid ile setegid fonksiyonları arasında bir fark kalmamaktadır. 

    setgid ve setegid fonksiyonları yine grup id bakımından geriye dönüşü sağlamak için düşünülmüştür. Şöyleki, prosesimizin 
    işin başında id'leri şöyle olsun:

    Gerçek kullanıcı id'si: kaan
    Etkin kulanıcı id'si: kaan
    Saklı kullanıcı id'si: kaan
    Gerçek grup id'si: study
    Etkin grup id'si: study
    Saklı grup id'si: study

    Şimdi biz set-group-id bayrağı set edilmiş bir programı çalıştıralım. Program dosyasının kullanıcı id'si "ali", grup id'si ise
    "test" olsun. Biz exec yaptığımızda id'lerimiz şöyle olacaktır:

    Gerçek kullanıcı id'si: kaan
    Etkin kulanıcı id'si: kaan
    Saklı kullanıcı id'si: kaan
    Gerçek grup id'si: study
    Etkin grup id'si: test
    Saklı grup id'si: test

    Şimdi biz grup olarak geçmişe dönüp bazı şeyleri yapmak isteyelim:

    setegid(getgid());

    Tabii burada setgid fonksiyonunu da kullanabilirdik. Şimdi prosesimizin id'leri şöyle olacaktır:

    Gerçek kullanıcı id'si: kaan
    Etkin kulanıcı id'si: kaan
    Saklı kullanıcı id'si: kaan
    Gerçek grup id'si: study
    Etkin grup id'si: study
    Saklı grup id'si: test

    Şimdi eski grup id'ye yenidne geri dönmek isteyelim:

    setegid(test_gid);

    Tabii burada yşne setgid fonksiyonu da kullanılabilirdi. Görüldüğü gibi grup temelinde geri dönüp yeniden aynı etkin grup id'ye 
    sahip olabilmek için saklı grup id'den faydalanılmıştır. 
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Bizim prosesimizin kullanıcı id'leri şöyle olsun:

    Gerçek kullanıcı id'si: root
    Etkin kulanıcı id'si: root
    Saklı kullanıcı id'si: root

    Şimdi biz aşağıdaki gibi bir çağrı yaparsak artık geri dönüş olanağımız kalmaz:

    setuid(uid_kaan);

    Çünkü uygun öceliğe sahip olan program setuid fonksiyonunu uyguladığında yalnızca kullanıcı etkin id'si değil, gerçek kullanıcı id'si
    ve saklı kullanıcı id'si de değişmektedir. Yani bu işlem sonucunda kullanıcı id'leri şöyle olacaktır:
    
    Gerçek kullanıcı id'si: kaan
    Etkin kulanıcı id'si: kaan
    Saklı kullanıcı id'si: kaan
        
    Ancak biz şu çağrıyı yapmış olsaydık geri dönebilirdik:

    seteuid(uid_kaan);

    Şimdi kullanıcı id'leri şöyle olacaktır:

    Gerçek kullanıcı id'si: root
    Etkin kulanıcı id'si: kaan
    Saklı kullanıcı id'si: root

    Şimdi artık setuid ya da seteuid fonksiyonu ile geri dönüş mümkündür. 
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Yukarıdaki fonksiyonlara ek olarak setreuid ve setregid isimli iki yardımcı fonksiyon da bulundurulmuştur. Aslında bu fonksiyonlara 
    mutlak anlamda gerek yoktur. Ancak bazı işlemleri kolaytırmaktadır. Bu fonksiyonlar ilk kez BSD UNIX sistemlerinde kullanılmış 
    daha sonra POSIX standartlarına dahil edilmiştir. Bu fonksiyonların ana amacı tek hamlede gerçek kullanıcı ve etkin kullanıcı id'lerini,
    gerçek grup id ve etkin grup id'lerini değiştirebilmektedir. Genellikle gerçek id'lerle etkin id'leri yer değiştirmek amacıyla bu 
    fonksiyon kullanılmaktadır. 
    
    setreuid fonksiyonunun prototipi şöyledir:

    #include <unistd.h>

    int setreuid(uid_t ruid, uid_t euid);

    Fonksiyon parametre olarak değiştirilmek istenen gerçek kullanıcı id'sini ve grup id'sini almaktadır. Eğer bunlardan herhangi biri
    değiştirilmek istenmiyorsa bu durumda o parametre için -1 girilir. 

    Fonksiyon şöyle çalışmaktadır:

    1) Eğer proses uygun önceliğe sahipse (yani root ise ya da Lİnux sistemlerinde CAP_SETUID yeteneğine sahipse) her iki id'yi de
    değiştirir.

    2) Eğer proses uygun önceliğe sahip değilse fonksiyon yalnızca etkin kullanıcı id'sini değiştirir. Ancak bunu yapılabilmesi için
    prosesin gerçek kullanıcı id'sinin ya da saklı kullanıcı id'sinin argüman olarak geçilen id ile aynı olması gerekmektedir. 

    3) POSIX standartlarında bu fonksiyon ile gerçek kullanıcı id'sinin etkin kullanıcı id'si ya da saklı kullanıcı id'si biçiminde 
    değiştirilip değiştirilemeyeceği "belirsiz (unspcified)" bırakılmıştır. Linux sistemlerinde setreuid fonksiyonu "prosesin gerçek kulalnıcı id'sini
    etkin kullanıcı id'si olarak" değiştirebilmektedir. Ancak saklı kullanıcı id'si olarak değiştirememektedir. 

    Bu fonksiyon eğer set edilmek istenen etkin kullanıcı id'si (yani hedef etkin kullanıcı id'si) prosesin o andaki gerçek kullanıcı id'sine 
    eşit değilse bu durumda saklı kullanıcı id'sini de etkin kullanıcı id'si olarak set etmektedir. Aynı zamanda fonksiyon yine eğer gerçek kullanıcı 
    id'si set ediliyorsa saklı kullanıcı id'sini yine hedef etkin kullanıcı id'si olarak set etmektedir. Fonksiyonun parametrelerinden 
    biri bile uygunsuzsa fonksiyon başarısız olmaktadır. Fonksiyon başarı durumunda 0 değerine başarısızlık durumunda -1 değerine geri döner ve errno 
    değeri uygun biçimde set edilir. Örneğin:

    setreuid(getuid(), getuid());

    Burada çağrı sonucunda prosesin gerçek kullanıcı id'si değişmeyecektir. Ancak prosesin etkin kullanıcı id'si ve saklı kullanıcı id'si 
    gerçek kullanıcı id'si olarak set edilecektir. Artık geri dönüş mümkün değildir. Örneğin:

    setreuid(geteuid(), getuid());

    Burada prosesin kullanıcı id'si ile etkin kullanıcı id'si yer değiştirilmiştir. Örneğin prosesin çağrı öncesindeki kullanıcı id'leri 
    şöyle olsun:

    Gerçek kullanıcı id'si: kaan 
    Etkin kulanıcı id'si: root
    Saklı kullanıcı id'si: root

    Şimdi şu çağrıyı yapalım:

    setreuid(geteuid(), getuid());

    Şimdi id'ler şöyle olacaktır:

    Gerçek kullanıcı id'si: root 
    Etkin kulanıcı id'si: kaan
    Saklı kullanıcı id'si: root

    Buradan eski duruma şöyle dönebiliriz:

    setreuid(geteuid(), getuid());

    Gerçek kullanıcı id'si: kaan 
    Etkin kulanıcı id'si: root
    Saklı kullanıcı id'si: root

    Tabii yukarıda da belirttiğimiz gibi bu fonksiyonda prosesin uygun önceliği yoksa kulalnıcı id'sinin etkin kullanıcı id'si olarak 
    değiştirilip değiştirilemeyeceği POSIX sistemlerinde belirsiz bırakılmıştır. Ancak Linux ve BSD bunu yapabilmektedir. 

---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    setregid fonksiyonunun prototipi şöyledir:

    #include <unistd.h>

    int setregid(gid_t rgid, gid_t egid);

    setregid fonksiyonu da setereuid fonksiyonu ile grup temelinde benzer semantiğe sahiptir: 

    1) Eğer proses uygun önceliğe sahipse (yani root ise ya da Lİnux sistemlerinde CAP_SETGID yeteneğine sahipse) fonksiyon her iki id'yi de
    değiştirir.

    2) Eğer proses uygun önceliğe sahip değilse fonksiyon etkin grup id'sini değiştirir. Ancak bunu yapılabilmesi için
    prosesin gerçek grup id'sinin ya da saklı grup id'sinin argüman olarak geçilen id ile aynı olması gerekmektedir.  

    3) Fonksiyon uygun önceliğe sahip değilse gerçek grup id'sini saklı grup id'si olarak dğeiştirebilmektedir. 
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Yukarıda da belirttiğimiz gibi POSIX standartlarında saklı kullanıcı ve grup id'lerini almanın bir yolu yoktur. Ancak Linux sistemleri
    bir sistem fonksiyonu yoluyla buna izin vermektedir. getresuid ve getresgid fonksiyonları bütün id'leri tek hamlede elde etmeye izin vermektedir. 

    #define _GNU_SOURCE         /* See feature_test_macros(7) */
    #include <unistd.h>

    int getresuid(uid_t *ruid, uid_t *euid, uid_t *suid);
    int getresgid(gid_t *rgid, gid_t *egid, gid_t *sgid);

    Fonksiyonlar ilgili nesnelerin adreslerini alıp değerleri oraya yerleştirmektedir. Başarı duurmunda 0, başarısızlık durumunda -1
    değerine geri dönmektedir. 

    Aşağıdaki örnekt prosesin gerçek, etkin ve saklı kullanıcı id'leri getresuid fonksiyonuyla elde edilip ekrana yazdırılmıştır. 
---------------------------------------------------------------------------------------------------------------------------*/

 #define _GNU_SOURCE  

#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>
#include <unistd.h>
#include <pwd.h>

void exit_sys(const char *msg);

int main(void)
{
	uid_t ruid, euid, ssuid;
	struct passwd *pass;
	
	if (getresuid(&ruid, &euid, &ssuid) == -1)
		exit_sys("getresuid");

	if ((pass = getpwuid(ruid)) == NULL)
		exit_sys("getpwuid");

	printf("Real User Id: %s (%ju)\n", pass->pw_name, (uintmax_t)ruid);

	if ((pass = getpwuid(euid)) == NULL)
		exit_sys("getpwuid");

	printf("Effective User Id: %s (%ju)\n", pass->pw_name, (uintmax_t)euid);

	if ((pass = getpwuid(ssuid)) == NULL)
		exit_sys("getpwuid");

	printf("Saved Set User Id: %s (%ju)\n", pass->pw_name, (uintmax_t)ssuid);
	
    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/*--------------------------------------------------------------------------------------------------------------------------
                                                33. Ders 26/02/2023 - Pazar
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Linux sistemlerinde getresuid ve getresgid fonksiyonlarının bir de set'li versiyonları vardır. Bu fonksiyonlar da birer sistem 
    fonksiyonu olarak gerçekleştirilmiştir. Bu fonksiyonlar POSIX standartlarında bulunmamaktadır:

    #define _GNU_SOURCE         /* See feature_test_macros(7) */
    #include <unistd.h>

    int setresuid(uid_t ruid, uid_t euid, uid_t suid);
    int setresgid(gid_t rgid, gid_t egid, gid_t sgid);

    Fonksiyonlar sırasıyla gerçek, etkin ve saklı id'leri alarak proses için set işlemi yapmaktadır. Set işlemi için şu koşullar bulunmaktadır:

    Uygun önceliğe sahip olmayan prosesler gerçek, etkin ve saklı id'lerini ancak o andaki gerçek, etkin ve saklı id'lerinden biri 
    olarak değiştirebilirler. Uygun önceliğe sahip olan prosesler bunları herhangi bir biçimde değiştirebilirler. Yine fonksiyon 
    herhangi bir parametrede uygunsuz bir durumla karşılaşırsa tüm işlem başarısız olur ve -1 değeri ile geri döner. Başarı durumunda fonksiyo 
    0 ile geri dönmektedir. 
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    İlk zamanlar UNIX sistemlerinde prosesler tek bir grup ile ilişkilendirilmişti. Sonra bir prosesin birden fazla grup ile 
    ilişkili olması gerektiği anlaşıldı ve bu durum "ek gruplar (supplementary grorups)" kavramı sisteme dahil edilerek gerçekleştirildi. 
    Ek gruplar konusu uzun süredir POSIX standartlarının içerisinde var olan ve neredeyse tüm UNIX türevi sistemlerin desteklediği 
    bir özelliktir.

    Bir kullanıcının gerçek bir grubu vardır. Dolayısıyla işin başında gerçek grup id'si ve etkin grup id'si bu gruptur. Anımsanacağı 
    gibi dosya erişimlerinde test işlemlerine etkin kullanıcı id'si ve etkin grup id'si girmektedir. Yine anımsanacağı gibi bir dosyanın 
    rwx biçimindeki hangi üçlü kısmının open fonksiyonunda ve diğer fonksiyonlarda dikkate alınacağı şöyle belirleniyordu:

    if (prosesin etkin kullanıcı id'si == 0)
        <proses her şeyi yapabilir >
    else if (prosesin etkin kullanıcı id'si == dosyanın kullanıcı id'si)
        <dosyanın rwx owner hakları dikkate alınır>
    else if (prosesin etkin grup id'si ya da ek gruplarından birinin id'si == dosyanın grup id'si)
        <dosyanın rwx grup hakları dikkate alınır>
    else
        <dosyanın rwx other hakları dikkate alınır>

    Buradan görüldüğü gibi grup kontrolü yapılırken yalnızca prosesin etkin grup id'si değil aynı zamanda ek grup id'leri de 
    eşdeğer düzeyde etkili olmaktadır. Yani örneğin prosesimizin etkin grup id'si "study" olsun. Ancak ek grupları da "work" ve 
    "test" olsun. Erişmeye çalıştığımız dosyanın grup id'si "test" ise her ne kadar bizim etkin grup id'miz "test" değilse de
    ek gruplarımızdan biri "test" olduğu için biz bu dosya ile aynı gruptan proses kabul ediliriz. 

    Bir prosesin gerçek kullanıcı ve gerçek grup id'leri login prosesi tarafından /etc/passwd dosyasına başvurularak belirlenmektedir.
    İşte login programı prosesin ek gruplarını da /etc/group dosyasına bakarak belirlemektedir. Anımsanacağı gibi /etc/group dosyasındaki 
    her satır bir gruba ilişkin bilgileri barındırıyordu. Satırın sonundaki son eleman ise o gruba ek grup olarak dahil olan kullanıcıları belirtmektedir. 
    Örneğin:

    ...
    sys:x:3:
    adm:x:4:syslog,kaan
    tty:x:5:syslog
    disk:x:6:
    ...

    Burada syslog kullanıcısı hem adm grubuna hem de tty grubuna ek grup olarak üye biçimdedir. kaan kullanıcısı da ek grup olarak adm 
    grubuna üyedir. Tabii login prosesinin bir kullanıcının ek gruplarını belirleyebilmesi içn /etc/group dosyasındaki tüm satırları 
    gözden geçirmesi gerekmektedir. 

    Bu durumda pseudo kod olarak login programı şöyle yazılmıştır:

    1) user name ve password iste (bunu terminal programı da yapıyor olabilir)
    2) /etc/passwd ve /etc/shadow dosyalarına başvurarak doğrulamayı yap
    3) Kullanıcının ek grup'larını tespit etmek için /etc/group dosyasını dolaş ve kullanıcının ek gruplarını elde et
    4) setuid fonksiyonuyla prosesin gerçek, etkin ve saklı kullanıcı id'sini /etc/passwd dosyasında belirtilen biçimde set et.
    5) setgid fonksiyonuyla prosesin gerçek, etkin ve saklı grup id'sini /etc/passwd dosyasında belirtilen biçimde set et.
    6) chdir fonksiyonuyla prosesin çalışma dizinini /etc/passwd dosyasında belirtildiği gibi set et
    7) exec ile /etc/passwd dosyasında belirtilen programı çalıştır.

    Genel olarak login rpogramı fork/exec değil yalnızca exec yapmaktadır. Biz shell'den çıkınca normalde yeniden login programı
    çalıştırışmaktadır. 

    Tabii prosesin ek grupları da diğer bilgilerde olduğu gibi prosesin kontrol bloğunda saklanmaktadır.
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    O anda çalışmakta olan prosesin ek grup id'leri getgroups isimli POSIX fonksiyonu ile elde edilebilmektedir. Fonksiyonun 
    prototipi şöyledir:

    #include <unistd.h>

    int getgroups(int gidsetsize, gid_t grouplist[]);

    Fonksiyonun ikinci parametresi ek grup id'lerinin yerleştirileceği gid_t türünden dizini başlangıç adresini belirtir. 
    Birinci parametre ise bu dizinin uzunluğunu belirtmektedir. Fonksiyon başarı durumunda diziye yerleştirdiği eleman sayısına, başarısızlık
    durumunda -1 değerine geri dönmektedir. Pekiyi biz bu fonksiyona geçireceğimiz dizinin uzunluğunu nasıl belirleyebiliriz?
    Daha ileride göreceğimiz gibi <limits.h> içerisinde NGROUPS_MAX isimli bir sembolik sabit vardır. Bu sembolik sabit ilgili sistemindeki
    proseslerin sahip olabileceği maksimum grup sayısını belirtmektedir. Ancak maalesef bu sembolik sabit "Runtime Increasable Values"
    grubundadır. Yani bu değer sistem açıldıktan sonra artırılmış olabilir. Gerçek değer ise sysconf fonksiyonuyla elde edilmektedir. 
    Ancak sysconf fonksiyonun çağrılması zahmetlidir. Bu fonksiyounun özel bir durum olarak birinci parametresi 0 geçilirse 
    zaten fonksiyon bize o kullanıcının ek gruplarının sayısını vermektedir. Biz de bu sayı kadar alanı malloc ile tahsis edebiliriz. 
    Fonksiyondaki diğer önemli bir nokta fonksiyonun aynı zamanda prosesin etkin grup id'sini de verdiğimiz diziye yerleştirip yerleştirmeyeceğinin 
    sistemdem sisteme değişebileceğidir. Linux sistemleri her zaman prosesin etkin kullanıcı id'sini de bu diziye yerleştirmektedir. 
    NGROUPS_MAX sembolik sabitine bu değer dahil değildir. Yani buradan hareketle dizi uzunlu belirlenecekse bu değerden bir fazla değer
    kadar alan malloc ile tahsis edilmelidir. Ancak birinci parametre 0 geçilirse zaten geri döndürülen değere bu değer dahildir. 
    Özetle fonksiyonun çağrılmasında şu yöntemler izlenebilir:

    1) Dizi NGROUPS_MAX + 1 uzunlukta açılıp fonksiyon başarısız olursa sysconf fonksiyonu ile gerçek değer elde edilebilir. 
    Ya da doğrudan sysconf fonksiyonu kullanılabilir. 

    2) Dizi uzunluğu büyük bir değer olarak tespit edilebilir. Ancak fonksiyonun başarısı kontrol edilebilir. 

    3) Fonksiyonun birinci parametresine 0 geçilerek fonksiyon çağrılabilir. Elde edilen değerden hareketle malloc fonksiyonu ile
    tam istenen uzunlukta alan tahsis edilebilir. 

    Aşağıdaki örnekte prosesin ek grup id'leri alınıp ekrana (stdout dosyasına) yazdırılmıştır. Linuz sistemlerinde bu listeye
    prosesin etkin grup id'siin de dahil edildiğine dikkat ediniz. 
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>
#include <unistd.h>
#include <grp.h>

void exit_sys(const char *msg);

int main(void)
{
	gid_t *sgids;
	int ngroups;
	struct group *grp;

	if ((ngroups = getgroups(0, NULL)) == -1)
		exit_sys("getgroups");

	if ((sgids = (gid_t *)malloc(ngroups * sizeof(gid_t))) == NULL) {
		fprintf(stderr, "cannot allocate memory!..\n");
		exit(EXIT_FAILURE);
	}

	if (getgroups(ngroups, sgids) == -1)
		exit_sys("getgroups");

	for (int i = 0; i < ngroups; ++i) {
		if ((grp = getgrgid(sgids[i])) == NULL)
			exit(EXIT_FAILURE);
		if (i != 0)
			printf(", ");
		printf("%ju (%s)", (uintmax_t)sgids[i], grp->gr_name);
	}
	printf("\n");

	free(sgids);
	
    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/*--------------------------------------------------------------------------------------------------------------------------
    POSIX standartlarında prosesin ek gruplarını set eden bir fonksiyon bulundurulmamıştır. Ancak işletim sistemlerinde bunu 
    yapan mecburen bir sistem fonksiyonu bulundurulmak zorudadır. Linux sistemlerinde ve diğer pek çok UNIX türevi sistemde
    setgroups isimli fonksiyon ilgili sistem fonksiyonunu çağırarak bu işi yapmaktadır. Fonksiyonun prototipi şöyledir:

    #include <grp.h>

    int setgroups(size_t size, const gid_t *list);

    Fonksiyonun Fonksiyonun ikinci parametresi set edilecek ek grupların listesini belirtmektedir. Bu listeye prosesin etkin 
    grup id'si dahil edilmemelidir. Birinci parametres ise bu dizinin uzunluğunu belirtir. Fonksiyon başarı durumunda 0, başarısızlık 
    durumunda -1 değerine geri döner. Tabii fonksiyonu herkes çağıramaz. Fonksiyonun başarılı olması için prosesin uygun 
    önceliğe (appropriate priveleges)" sahip olması gerekmektedir. (Yani prosesin etkin kullanıcı id'si 0 (root) olması ya da 
    Linux sistemlerinde CAP_SETGID yeterliliğine sahip olması gerekir.)

    Aşağıdaki program set-user-id bayrağı set edilmiş sahibi root olan bir program dosyasına dönüştürülmüştür. Program aşağıdaki gibi derlenmiştir:

    gcc -o sample sample.c 

    Sonra program dosyasının sahibi root olarak değiştirilmiştir. Ondan sonra da program dosyasının set-user-id bayrağı set edilmiştir:

    sudo chown root sample
    ls -l sample
    -rwxr-xr-x 1 root study 17400 Şub 26 12:18 sample
    sudo chmod u+s sample
    ls -l sample
    -rwsr-xr-x 1 root study 17400 Şub 26 12:18 sample

    Burada önce dosyanın modunun değiştirildiğine daha sonra set-user-id bayrağının set edildiğine dikkat ediniz. Çünkü
    chown POSIX fonksiyonu dosyanın set-user-id ve set-group-id bayraklarını reset etmektedir. chown fonksiyonun dokğmantasyonunu
    dikkatlice bir kez daha okuyunuz. 

    Aşağıdaki programda önce prosesin ek grupları elde edilmiş sonra ek gruplara bir grup dahil edilip setgroups fonksiyonuyla 
    prosesin ek grupları set edilmiştir. setgroups işleminde prosesin ekin kullanıcı id'si 0 olduğu için başarılı olmaktadır. 
    En sonunda program setuid fonksiyonu ile asıl kullanıcının gerçeki etkin ve saklı kullanıcı id'leriyle çalışmaya devam ettirilmiştir. 
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>
#include <unistd.h>
#include <grp.h>

void exit_sys(const char *msg);

int main(void)
{
	gid_t *sgids;
	int ngroups;
	struct group *grp;
	uid_t euid;

	euid = geteuid();

	if ((ngroups = getgroups(0, NULL)) == -1)
		exit_sys("getgroups");

	if ((sgids = (gid_t *)malloc((ngroups + 1) * sizeof(gid_t))) == NULL) {
		fprintf(stderr, "cannot allocate memory!..\n");
		exit(EXIT_FAILURE);
	}

	if (getgroups(ngroups, sgids) == -1)
		exit_sys("getgroups");

	for (int i = 0; i < ngroups; ++i) {
		if ((grp = getgrgid(sgids[i])) == NULL)
			exit(EXIT_FAILURE);
		if (i != 0)
			printf(", ");
		printf("%ju (%s)", (uintmax_t)sgids[i], grp->gr_name);
	}
	printf("\n");

	sgids[ngroups] = 0;

	if (setgroups(ngroups + 1, sgids) == -1)
		exit_sys("setgroups");

	free(sgids);

	if (setuid(getuid()) == -1)		/* prosesin gerçek, etkin ve saklı kullanıcı id'leri gerçek kullanıcı id'si haline getiriliyor */
		exit_sys("setuid");

	printf("success...\n")	;
	
    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/*--------------------------------------------------------------------------------------------------------------------------
    fork işlemi sırasında üst prosesin tüm ek grupları alt prosese aktarılmaktadır. Yani örneğin biz kabuk üzerindne bir program çalıştırdığımızda
    kabuk prosesinin ek grupları bizim prosesimize kabuğun uyguladığı fork neticesinde aktarılmış olacaktır. Tabii kabuk prosesinin de
    ek kullanıları aslında login programı tarafından set edilmektedir. 
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Aslında bir POSIX fonksiyonu olmasa da Linux, BSD ve pek çok UNIX türevi sistemlerde initgroups isimli bir fonksiyon da
    bulunmaktadır. Bu fonksiyon /etc/group dosyasını dolaşarak belli bir kullanıcının bütün ek grup bilgilerini elde eder ve
    setgroups fonksiyonu ile bunları set eder. Yani tipik olarak login programı aslında bu initgroups fonksiyonunu çağırmaktadır. 
    Fonksiyonun prototipi şöyledir:

    #include <grp.h>

    int initgroups(const char *user, gid_t group);

    Fonksiyon birinci parametresiyle kullanıcının ismini alır. /etc/group dosyasına başvurarak kullanıcının ek grup id'lerini elde 
    eder. Sonra da setgroups fonksiyonunu uygulayarak prosesin ek gruplarını set eder. Tabii fonksiyonun bu işlemi yapabilmesi için 
    yine uygun önceliğe sahip olması gerekmektedir. Fonksiyon başarı durumunda 0 değerine başarısızlık durumunda -1 değerine döner ve 
    errno uygıun biçimde set edilir. Fonksiyonun ikinci parametresi /etc/group dosyasından elde edilen ek gruplara dahil edilecek 
    ekstra bir grubu belirtmektedir. Tipik olarak login prosesi prosesin etkin grup id'sini bu listeye eklemek için fonksiyonun 
    ikinci parametresini prosesin etkin grup id'si ile çağırmaktadır. 
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Bugünkü masaüstü işletim sistemleri "zaman paylaşımlı (time sharing)" bir çalışma ortamı oluşturmaktadır. Zaman paylaşımlı çalışma 
    fikri ilk kez 1957 yılında uygulanmış ve sonra aktif bir biçimde işletim sistemlerine sokulmuştur. Dolayısıyla buün kullandığımı UNIX/Linux, 
    Windows ve macOS sistemleri zaman paylaşımlı çalışma uygulamaktadır. 

    Proses terimi çalışmakta olan programın bütün bilgilerini içermektedir. Programın bağımısız çizelgelenen akışlarına "thread"
    denilmektedir. Thread'ler 90 yıllarda işletim sistemlerine sokulmuştur. Bir proses tek bir thread'le çalışmaya başlatılır. 
    Buna prosesin "ana thread'i (main thread)" denir. Diğer thread'ler sistem fonksiyonlarıyla programcı tarafından yaratılmaktadır. 

    Zaman paylaşımlı çalışmada proseslerin thread'leri işletim sistemi tarafından CPU'ya atanır. O thread'in CPU'da belli bir süre 
    çalışmasına izin verilir. O süre dolduğunda thread'in çalışmasına ara verilip başka thread benzer biçimde CPU'ya atanmaktadır. 
    Tabii çalışmasına ara verilen thread'in bilgileri proses kontrol bloğuna kaydedilmekte ve çalışma sırası yeniden o thread'e 
    geldiğinde thread en son kesilen noktadan çalışmasına devam etmektedir. 

    Bir thread'in zaman paylaşımlı bir biçimde çalıştırıldığı parçalı çalışma süresine "quanta süresi" ya da İngilizce "time quantum"
    denilmektedir. Quanta süresinin ne kadar olacağı işletim sisteminin tasarımına bağlıdır. Bir thread'in çalışmasına ara verilmesi ve
    sıradaki thread'in CPU'ya atanması sürecine ise İngilizce "task switch" ya da "context switch" denilmektedir. Tabii bu işlem de 
    belli bir zaman çerçevesinde yapılabilmektedir.  Eğer quanta süresi uzun tutulursa interaktivite azalır. Quanta süresi tutulursa 
    zamanın önemli kısmı "context switch" için harcanır dolayısıyla "birim zamanda yapılan iş miktarı (throughput)" düşer. 
    Quanta süresi çeşitli faktörlere bağlı olarak değişebilmektedir. UNIX/Linux sistemleri rotalama 60 ms. civarında Windows sistemleri
    ortalama 20 ms. civarında bir quanta süresi uygulamaktadır. 

    Zaman paylaşımlı sistemde kulalnıcı sanki tüm proseslerin aynı anda çalıştığını sanmaktadır. Halbuki bu bir illüzyondur. 
    Aslında programlar sürekli ara verilip çalıştırılmaktadır. Bu işlem çok hızlı yapıldığı için sanki programlar aynı anda çalışıyromuş gibi 
    bir algı oluşmaktadır. 

    Pekiyi bir thread CPU atanmışken onun quanta süresini doldurması ve CPU'dan kopartılması nasıl sağlanmaktadır? İşte bu işlem 
    hemen her zaman donanım kesmeleri yoluyla yapılmaktadır. Sistem donanımında periyodik kesme oluşturan bir mekanizma vardır. 
    Buna "timer kesmesi" ya da UNIX/Linux dünyasında "jiffy" denilmektedir. Eski Linux sistemleri makineler yavaş olduğu için 
    timer kesme periyodunu 10 ms. olarak ayarlamaktaydı. Ancak makineler hızlanınca artık bu periyor uzun süredir 1 ms. biçiminde 
    ayarlanmaktadır. Yani her 1 milisaniyede bir aslında donanım kesmesi yoluyla kernel kodu devreye girmektedir. Bu kesme kodu da
    60 ms. gibi bir zaman dolduğunda thereadler arası geçiş (context) switch yapmaktadır. Threda akışının bu biçimde quanta süresi 
    dolduğunda donanım kesmesi yoluyla zorla ara verilmesine işletim sistemleri dünyasında "preemtive" işletim sistemleri denilmektedir.
    UNIX/Linux, Windows ve macOS sistemleri preemptive işletim sistemleridir. Artık pek çok işlemci ailesi bu biçimdeki donanım 
    kesmeleri oluşturan timer devrelerini CPU'nun içerisine de eklemiştir. Ancak X86 ve X64 sistemlerinde timer sistemi için genel olarak 
    eskiye uyum bakımından Intel 8254 ve onun ileri versiyonları olan ve ismine "PIT (Programmable Interval Timer)" denilen devreler 
    aktif olarak kullanılmaktadır. Preemtive sistemlere bir alternatif olarak "non-preemptive" ya da "cooperative multitask" da denilen 
    sistemler bulunmaktadır. Bu sistemlerde bir thread çalıştığında kendi rızası ile CPU'yu birakır. Eğer CPU bırakmazsa diğer 
    threadler çalışma fırsatı bulamazlar. Bu patolojik duruma "diğer thread'lerin açlıktab ölmesi (starvation)" denilmektedir. 
    Tabii bu sistemler artık çok kısıtı kullanılmaktadır. PalmOS, eski Windows 3.X sistemleri böyleydi. 
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
                                                            34. Ders 04/03/2023 Cumartesi
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Pekiyi sistemimizde birden fazla CPU (ya da çekirdek) varsa zaman paylaşımlı çalışma nasıl yürütülmektedir? Aslında değişen bir 
    şey yoktur. Bu durum tıpkı yemek verilen bir kurumda yemeğin birden fazla koldan fazla verilmesi gibidir. İşletim sisteminin
    zaman paylaşımlı çalışma için oluşturduğu kuyruğa işletim sistemleri dünyasında "çalıştırma kuyruğu (run queue)" denilmektedir. 
    Bu çalıştırma kuyruğu çok CPU söz konusu olduğunda her CPU için oluşturulmaktadır. Böylece her CPU yine zaman paylaşımlı bir biçimde
    çalıştırma kuyruğundaki thread'leri çalıştırmaktadır. Yani yukarıda açıkladığımız temel prensip değişmemektedir. Tabii burada
    işletim sisteminin bazı kararları da vermesi gerekir. Örneğin yeni bir thread (ya da proses) yaratıldığında bunun hangi CPU'ya atanacağı
    gibi. Bazen işletim sistemi thread'i bir CPU'nun çalıştırma kuyruğuna atar. Ancak diğer kuyruklar daha boş hale gelirse (çünkü o sırada
    çeşitli prosesler ve thread'ler sonlanmış olabilir) işletim sistemi başka bir CPU'nun çalıştırma kuyruğundaki thread'i kuyruğu daha boş olan
    CPU'nun çalıştırma kuyruğuna atayabilir. (Biz bir süpermarkette işin başında boş bir kasanın kuyruğuna girmiş olabiliriz. Sonra başka bir kasadaki
    kuyruk çok azalmış duruma gelebilir. Biz de o kuyruğua geçmeyi tercih ederiz. İşletim sistemi de buna benzer davranmaktadır.) Linux işletim sistemi,
    Windows sistemleri ve macOS sistemleri buna benzer bir çizelgeleme algoritması kullanmaktadır. Bir ara Linux O(1) çizelgelemesi denilen 
    bir yöntem denemiştir. Bu yöntemde işletim sistemi tek bir çalıştırma kuyruğu kullanıyordu. Hangi CPU'daki parçalı çalışma süresi biterse
    bu kuyruktan seçme yapılıyordu. 

    Çok CPU'lu zaman paylaşımlı çalışmada CPU sayısı artırıldıkça total performans artacaktır. Çünkü CPU'lar için düzenlenen çalıştırma 
    kuyruklarında daha az thread bulunacaktır. 
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Zaman paylaşımlı çalışmada en önemli kavramlaran biri de "bloke olma (blocking)" denilen kavramdır. İşletim sistemi bir thread'i
    CPU'ya atadığında o thread "dışsal bir olaya ilişkin bir işlem başlattığı zaman" thread uzun süre bekleme yapabileceğinden dolayı 
    işletim sistemi o thread'i çalıştırma kuyruğundan çıkartır, "bekleme kuyruğu (wait queue)" denilen bir kuyruğa ekler. Böylece zaten 
    bekleyecek olan thread boşuna CPU zamanı harcamadan pasif bir biçimde bekletilmiş olur. Örneğin bir thread klavyeden bir şey okumak 
    istesin. İşletim sistemi thread'i bloke ederek çalıştırma kuyruğundan çıkartır ve onu bekleme kuyruğuna alır. Artık o thread çalıştırma
    kuyruğunda olmadığından zaman paylaşımlı çalışmada işletim sistemi tarafından ele alınmaz. Beklenen dışsaş olay (örneğin klavye okuması)
    gerçekleştiğinde thread yeniden çalıştıra kuyruğuna yerleştirilir. Böylece çalışma aynıo prensiple devam ettirlir. İşletim sistemi
    bekleme kuyruklarındaki thread'lere ilişkin olayların gerçekleştiğini birkaç biçimde anlayabilmektedir. Örneğin bir soket okuması 
    yapıldığında eğer sokete henüz bilgi gelmemişse işletim sistemi thread'i bloke eder. Sonra network kartına paket geldiğinde network 
    kartı bir donanım kesmesi oluşturur. İşletim sistemi devreye girer. İşletim sistemi eğer gelen paket soketten okuma yapacak thread'e ilişkinse 
    bu kesme kodunda (interrupt hanler) aynı zamanda o thread'i blokeden kurtarır. Ya da örneğin wait gibi bir işlemde işletim sistemi wait işlemini 
    yapan thread'i bloke ederek wait kuyruğna yerleştirir. Alt proses bittiğinde _exit sistem fonksiyonunda bu wait kuruklarına bu sistem fonksiyonu bakar
    ve ilgili thread'lerin blokesini çözer. sleep gibi bir fonksiyonda ise işletim sistemi bekeleme zamanını kendisi hesaplar. Bekleme zamanı dolunca
    thread'in blokesini çözer. Genel olarak işletim sistemleri her olayın için ayrı bir wait kuyruğu oluşturmaktadır. Örneğin aygıt sürücüler kendi wait kuyruklarını oluşturup bloke 
    işlemlerini kendileri yapmaktadır. 

    Thread'in çalıştırma kuyruğundan çıkartılıp wait kuyruğuna alınması nasıl ve kimin tarafından yapılmaktadır? Böyle bir işlem
    user modda sıradan prosesler tarafındna yapılamaz. Hemen her zaman kernel modda işletim sisteminin sistem fonksiyonları tarafından yapılmaktadır. 
    Yani thread'in bloke olması programın çalışması sırasında çağrılan bir sistem fonksiyonu (ya da aygıt sürücü fonksiyonu) tarafından 
    yapılmaktadır.
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Thread'ler "IO yoğun (IO bound)" ve "CPU yoğun (CPU bound)" olmak üzere ikiye ayrılmaktadır. IO yoğun thread'ler kendisine 
    verilen quanta süresini çok az kullanıp hemen bloke olan thread'lerdir. CPU yoğun thread'ler ise kendisine verilen quanta süresini 
    büyük ölçüde kullanan thread'lerdir. Örneğin bir döngü içerisinde sürekli hesap yapan bir thread CPU yoğun bir thread'tir. 
    Ancak aşağıdaki gibi bir thread IO yoğun thread'tir:

    for (;;) {
        scanf("%d", &val);
        if (val == 0)
            break;
        printf("%d\n", val);
    }

    Burada bu thread çok az CPU zamanı harcamaktadır. Zamanının büyük kısmını uykuda geçirecektir. IO yoğun ve CPU yoğun thread kavramı
    işletim sistemi için değil durumun insanlar tarafından anlaşılması için uydurulmuş kavramlardır. İşletim sistemi bu biçimde
    thread'leri ayırmamaktadır. Bir sistemde yüzlerde IO yoğun thread olsa bile sistemi bu durum çok fazla yormaz. Ancak çok sayıda
    CPU yoğun thread sistemi yavaşlatacaktır. 
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Bir programda iki nokta arasında geçen zaman sistemin o anki yüküne bağlı olarak dğeişebilmektedir. Örneğin sistemde çok sayıda CPU 
    yoğun thread varsa iki nokta arasındaki zaman çok daha uzayabilir. 

    Aşağıdaki programı önce bir kez çalıştırınız sonra kabul üzerinden komut satırının sonuna & koyarak çok sayıda çalıştırınız. 
    Programın döngüde harcadığı gerçek zaman uzayacaktır. Biz bu programda C'nin time fonksiyonunu kullandık. Bu fonksiyon saniye 
    temelinde çözünürlüğe sahiptir. clock isimli standart C fonksiyonu Linux sistemlerinde CPU zamanını verdiği için bu deneyde
    kullanılamamaktadır. Ancak ileride zaman ölçme konusu ayrı başlık altında değerlendirilecektir. 
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <time.h>

int main(void)
{
	time_t start, stop;

	start = time(NULL);

	for (long long i = 0; i < 10000000000; ++i)
		;

	stop = time(NULL);

	printf("%lld\n", (long long) (stop - start));
	
    return 0;
}

/*--------------------------------------------------------------------------------------------------------------------------
    Aslında bir programın toplam zamanı "time" sisimli kabuk komutuyla da ölçülebilmektedir. Komut basit bir biçimde şöyle kullanılabilir:

    time sample

    time komutundan şöyle bir çıktı elde edilmektedir:

    real	1m38,360s
    user	0m18,597s
    sys	0m0,052s
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Kabuk üzerinde satırın sonuna & yerleştirilirse bu durumda kabuk fork/exec yapar ancak wait ile bekleme yapmaz. 
    Dolayısıyla yeniden hemen kabuk promptuna düşülür. Bu komutta çalıştırılan programlara birer numara verilmektedir. "fg"
    komutuyla bu numara veridliğinde ilgili program yeniden "foreground" hale getirilebilmektedir. Satırın sonuna & yerleştirilmesi 
    yalnızca wait yapılmamayı sağlamaz aynı zamanda bu işlemin henüz görmediğimiz sinyal konusuyla ilgili etkileri de vardır. 
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Modern kapasiteli mikroişlemcilerde "sayfalama (paging)" denilen önemli bir mekanizma vardır. Örneğin Intel işlemcileri 
    bu sayfalama mekanizmasına 80386 modelleriyle birlikte sahip olmuştur. ARM Cortex A serisi işlemcilerin de bu mekanizmaları vardır. 
    Itanium, PowerPC gibi işlemcilerde de sayafalama mekanizması bulunmaktadır. Genellikle koruma mekanizmasına sahip işlemciler
    sayfalama mekanizmasına da sahip olurlar. Ancak koruma mekanizmasına sahip olduğu halde sayfalama mekznizmasına sahip olmayan 
    işlemciler de vardır. Ayrıca işlemcilerdeki bu sayfalama mekznizması genel olarak aktif ve pasif duruma getirilebilmektedir. 
    Yani işlemci sayfalama mekanizmasına sahip olduğu halde sistem programcısı bu mekanizmayı açmayabilir ve kullanmayabilir. 
    İşlemciler reset edildiğinde sayfalama mekanizması pasif durumdadır. 
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Sayfalama mekanizmasında fiziksel RAM aynı zamanda "sayfa (page)" denilen arışıl bloklara ayrılır. Sayfa uzunluğu sistemden
    sisteme hatta aynı işlemcide işlemcinin modundan moduna değişebilir. Ancak en tipik kullanılan sayfa uzunluğu 4096 (4K) byte'tır.
    Gerçekten de bugün Linux, Windows ve macOS sistemleri 4K'lık sayfalar kullanmaktadır. Sayfalama mekanizması etkin hale getirildiğinde
    işlemci RAM'deki her sayfaya bir sayfa numarası karşılık getirir. Örneğin ilk 4096 byte 0'ıncı sayfaya, sonraki 4096 byte
    1'inci sayfaya ilişkindir. Sayfalar bu biçimde ilk sayfa 0'dan başlatılarak ardışıl biçimde numaralandırılmaktadır. 
    Yani her byte aslında bir sayfa içerisinde bulunur. 

    Bir program içerisinde kullanılan yani derleyicinin ürettiği adresler aslında gerçek fiziksel adresler değildir. Bu adreslere 
    "sanal adres (virtual address)" denilmektedir. Derleyici kodu sanki geniş bir RAM'de program tek başına çalışacakmış gibi üretmektedir. 
    Örneğin 32 bit işlemcilerin kullanıldığı bir Linux sisteminde derleyici sanki program 4GB'lik RAM'de tek başına 4MB'den itibaren program
    yüklenecekmiş gibi kod üretmektedir. Yani örneğin 32 bit Linux sistemlerinde (Windows ve macOS'te de böyle) sanki derleyiciler 
    program 4 GB bellekte 4 MB'den itibaren tek başlarına yüklenecekmiş gibi bir kod üretmektedir. Her program derlendiğinde aynı biçimde kod üretilmektedir. 
    Çünkü derleyicinin ürettiği bu adresler sanal adreslerdir. Pekiyi her program aynı biçimde sanki RAM'in 4MB'sinden başlanarak ardışıl bir biçimde yüklenecekmiş 
    gibi bir koda sahipse bu programlar nasıl çalışmaktadır?

    İşte sayfalama mekanizmasına sahip olan CPU'lar aslında "sayfa tablosu (page table)" denilen bir taloya bakarak çalışırlar. 
    Sayfa tablosu sanal sayfa numaralarını fiziksel sayfa numaralarına eşleyen bir tablodur. Sayfa tablosunun görünümü aşağıdaki gibidir:

    Sanal Sayfa No              Fiziksel Sayfa No
    ...                         ....
    4562                        17456
    4563                        18987
    4564                        12976
    ...                         ...

    Şimdi işlemcinin aşağıdaki gibi bir makine kodunu çalıştıdığını düşünelim:

    MOV EAX, [05C34782]

    Burada makine komutu bellekte 05C34782 numaralı adresten başlayan 4 byte erişmek istemektedir. İşlemci önce bu adres değerinin 
    kaçıncı sanal sayfaya karşılık geldiğini hesaplar. Bu hesap işlemci tarafından oldukça kolay bir biçimde yapılır. Sayı 12 kere sağa ötelenirse
    başka bir deyişle sayının sağındaki 3 hex digit kaldırılırsa bu sanal adresin kaçıncı sanal sayfaya karşılık geldiği bulunabilir:

    05C34782 >> 12 = 05C34 (sanal sayfa no, decimal 23604) 

    Artık işlemci sayfa tablosunda 0x5C34 yani desimal 23604 numaralı girişe bakar. Sayfa tablosunun ilgili kısmı şöyle olsun:

    Sanal Sayfa No  (decimal/hex)   Fiziksel Sayfa No (desimal/hex)
    ...                         ....
    23603 (5C33)                      47324 (B8DC)
    23604 (5C34)                      52689 (CDD1)
    23605 (5C35)                      29671 (73E7)
    ...                         ...

    Burada 23604 (5C34) numaralı sanal sayfa 52689 (CDD1) fiziksel sayfasına yönlendirilmiştir. Pekiyi işlemci hangi fiziksel adrese erişecektir? İşte
    bizim sanal adresimiz 05C34782 idi. Bu adres iki kısma ayrıştırılabilir:

    05C24   Sanal sayfa no (hex)
    782     Sayfa offset'i (hex)

    Bu durumda işlemci aslında fiziksel RAM'de 52689 (CDD1)'uncu fziksel sayfanın 1922 (782) byte'ına erişecektir. O zaman gerçek bellekteki erişim 
    adresi 52689 (CDD1) * 4096 (1000) + 1922 (782) olacaktır. 

    Burada özetle anlatılmak istenen şey şudur: İşlemci her bellek erişiminde erişilecek sanal adresi iki kısma ayırır: Sanal Sayfa No ve 
    Sayfa Offset'i. Sonra sayfa tablosuna giderek sanal sayfa numarasına karşı gelen fiziksel sayfa numarasını elde eder. O fiziksel sayfanın 
    sayfa offet'i ile belirtilen byte'ına erişir. Örneğin şöyle bir fonksiyon çağırmış olalım:

    foo();

    Derleyicimiz de şöyle bir kod üretmiş olsun:

    CALL 06F14678  (hex)

    Burada 06F14678 foo fonksiyonunun sanal bellek adresidir. Derleyici bu adresi üretmiştir. Ancak program çalışırken işlemci bu adresi 
    ikiye ayırır (hex olarak konuşacağız):

    06F146      Sanal Sayfa No (hex)
    678         Sayfa Offseti (hex)

    Sonra sayfa tablosuna gider ve 06F146 sayfasının hangi fiziksel sayfaya yönlendirildiğini tespit eder. Bu fiziksel sayfanın hex olarak 
    7C45 olduğuna düşünelim. O zaman işlemcinin erişeceği fiziksel adres 7C45000 + 678 hex adresi olacaktır. 

---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Buraya kadar şunları anladık:

    - Derleyici 32 bit bir sistemde sanki program 4GB'lik bir RAM'de tek başına 4MB'ye yüklenerek çalıştırılacakmış gibi bir kod
    üretmektedir. 

    - İşlemci kod çalıştırırken her bellek erişiminde sayfa tablosuna bakıp aslında o sanal adresleri fiziksel adreslere dönüştürmektedir. 

    Pekiyi sayfa tablosunu kim oluşturmaktadır? Sayfa tablosu işletim sistemi tarafından proses belleğe yüklenirken (exec fonksiyonları tarafından)
    oluşturulmaktadır. İşletim sisteminin yükleyicisi (loader) programı 4K'lık parçalara ayırarak sanal sayfa numaraları ardışıl ancak 
    fiziksel sayfa numaraları ardışıl olmayacak biçimde fiziksel RAM'e yüklemektedir. Yani işletim sistemi fiziksel RAM'deki boş sayfalara bakar. 
    Programın 4K'lık kısımlarını bu fiziksel RAM'deki boş sayfalara yükler ve sayfa tablosunu buradan hareketle oluşturur. 

    Aslında sayfa tablosu bir tane değildir. İşletim sistemi her proses için ayrı bir sayfa tablosu oluşturmaktadır. CPU'lar sayfa tablolarını 
    belli bir yazmacın gösterdiği yerde ararlar (Örneğin Intel işlemcilerinde sayfa tablosu CR3 yazmacının gösterdiği yerdedir.)
    İşletim sistemi thread'ler arası geçiş (context switch) yapıldığında çalışmasına ara verilen thread ile yeni geçilen thread'in 
    aynı prosesin thread'leri olup olmadığına bakar. Eğer yeni geçilen thread ile çalışmasına ara verilen thread aynı prosese ilişkinse sayfa tablosu 
    değiştirilmez. Çünkü anı prosesin thread'leri aynı sanal bellek alanını kullanmaktadır. Ancak yeni geçilen thread kesilen thread'le farklı 
    proseslere ilişkinse işletim sistemi CPU'nun gördüğü sayfa tablosunu da değiştirmektedir. Böylece aslında her prosesin akışı çalışırken 
    CPU o prosesin sayfa tablosunu gösterir durumda olur. 

    Her prosesin sayfa tablosu birbirinden farklı olduğu için iki farklı proseslerdeki sanal adresler aynı olsa bile bu adreslerin 
    fiziksel karşılıkları farklı olacaktır. Örneğin aynı programı iki kez çalıştıralım. Bu durumda bu iki proses için işletim sistemi iki farklı 
    sayfa tablosu kullanıp aynı sanal adresleri farklı fiziksel sayafalara yönlendirecektir. Böylece aslında aynı sanal adreslere sahip olan 
    programlar farklı fiziksel adreslere sahip olacaktır. 
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Konu ile ilgili sorular ve kısa cevapları şöyledir:

    Soru: Bir programı debugger ile inceliyorum. Orada bir nesnenin adresini görüyorum. Bu adres nasıl bir adresitir?
    Yanıt: Bu adres sanal adrestir. İşlemci bu adrese erişildiğinde aslında sayfa tablosu yoluyla fiziksel olan başka bir adrese erişir.

    Soru: İki farklı programaa sanal 5FC120 adresi kullanılıyorsa bunlar fiziksel RAM'de aynı yeri yeri mi gösteriyordur?
    Yanıt: Hayır, çünkü işletim sistemi her proses için farklı bir sayfa tablosu oluşturmaktadır. Bir thread çalışırken işlemci 
    o thread'e ilişkin prosesin sayfa tablosunu kullanıyor durumdadır. Dolayısıyla bu iki farklı proseste işletim sistemi sayfa 
    tablolarının ilgili sayfalarını aslında farklı fiziksel sayfalara yönlendirmiş durumdadır. 

    Soru: 32 bit bir derleyicinin ürettiği kodun aslında sanki 4GB belleğe tek başına 4MB'den itibaren yüklenecekmiş gibi 
    üretildiği söylendi. Sanal bellek alanındaki bu 4MB boşluğun anlamı nedir?
    Yanıt: Bunun çok özel bir anlamı yoktur. Bir kere NULL adres için en az bir sayfa gerekmektedir. Pek çok işletim sistemi
    güvenlik amacıyla ve bazı başka nedenlerden dolayı sanal bellek alanının belli bir bölümünü boş bırakmaktadır. Windows'ta da
    bu alan 4MB'dir. Ancak programın minimal yüklenme adresi 64K'ya kadar düşürülebilmektedir. 

    Soru: CPU sayfa tablosunun yerini nereden biliyor?
    Yanıt: CPU'lar sayfa tablosunu özel bir yazmacın gösterdiği yerde arayacak biçimde tsarlanmıştır. Dolayısla context switch sırasında
    aslında işletim sistemi yazmacın değerini değiştirmektedir. Yani işletim sistemi aslında tüm proseslerin sayfa tablolarını 
    fiziksel RAM'da oluşturur. Context switch sırasında yalnızca sayfa tablosunun yerini belirten ilgili yazmacın değerini değiştirir. 

    Soru: Sayfalama mekanizması CPU'nun çalışmasını yavaşlatmaz mı?
    Yanıt: Teorik olarak sayfalama mekanizması CPU'nun çalışmasını yavaşlatabilir. Ancak bugünkü CPU'ların çalışma hızları zaten bu sayfalama
    mekaznizmasının aktif olduğu durumla belirlenmektedir. Dolayısıyla donanımsal olarak sayfalama mekaziması iyi bir biçimde oluşturulduğu için 
    buradaki hız kaybı önemsenecek ölçüde değildir. Ayrıca işlemciler sayfa tablosuna erişimi azaltmak için zaten onun bazı bölümlerini kendi içlerindeki
    bir cache sisteminde tutabilmektedir. Ayrıca sayfa girişlerine hızlı erişim için işlemciler TLB (Translation Lookaside Buffer) denilen bir 
    cache mekanizması da oluşturmaktadır. 

    Soru: Sayfalama mekanizmasına ne gerek vardır? 
    Yanı: Bu durum izleyen paragraflarda ele alınacaktır.
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
                                                        35. Ders 05/03/2023 - Pazar
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    İşletim sistemi her proses için ayrı bir sayfa tablosu oluşturduğuna göre ve bu sayfa tablosunda aynı sanal sayfa numaralarını 
    zaten farklı fiziksel sayfalara yönlendirdiğine göre aslında hiçbir proses diğerinin alanına erişemez. Yani proseslerin birbirlerinin
    alanlarına erişmesi zaten sayfalama mekznizmasıyla engellenmiş olmaktadır. Bu duruma "sayfalama mekanizması ile proseslerin fiziksel
    bellek alanlarının izole edilmesi" denilmektedir. Örneğin aşağıdaki gibi iki prosesin sayfa tablosu söz konusu olun:

    Proses-1
    
    Sanal Sayfa No  (decimal/hex)   Fiziksel Sayfa No (desimal/hex)
    ...                         ....
    23603 (5C33)                      47324 (B8DC)
    23604 (5C34)                      52689 (CDD1)
    23605 (5C35)                      29671 (73E7)
    ...                         ...

    Proses-2
    
    Sanal Sayfa No  (decimal/hex)   Fiziksel Sayfa No (desimal/hex)
    ...                         ....
    23603 (5C33)                      84523 (14A2b)
    23604 (5C34)                      62981 (F605)
    23605 (5C35)                      42398 (A59E)
    ...                         ...

    İki prosesin sayfa tablosunda Fiziksel Sayfa Numaraları birbirinden ayrıldığında zaten bu iki proses asla birbirlerinin alanlarına
    erişemeyecektir. 
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Pekiyi 32 bit bir mimaride işletim sisteminin sayfa tablosu yukarıdaki şekillere göre ne kadar yer kaplar? 32 bit mimaride
    fiziksel RAM en fazla 4GB olabilir. Proseslerin sanal bellek alanları da 4GB'dir. O halde toplam sayfa sayısı 
    4GB/4K = 2^32/2^12 = 2^20 = 1 MB olur. Her sayfa tablosu girişi Intel mimarisinde 4 byte'tır. Dolayısıyla yukarıdaki şekillere göre
    bir prosesin sayfa tablosu 4MB yer kaplar. Bu alan sayfa tablosu için çok büyüktür. Bu nedenle işlemcileri tasarlayanlar 
    sayfa tablolarının kapladığı alanı küçültmek için sanal adresleri iki parçaya değil üç ya da dört parçaya ayırma yoluna gitmişlerdir. 
    Gerçekten de örneğin Intel'in 32 bit mimarisinde bir sanal adres üç parçaya ayrılmaktadır. Bu ayrıntı kursumuzun konusu dışındadır ve
    Derneğimizde "80X86 ve ARM Sembolik MAkine Dilleri" kursunda ele alınmaktadır. Biz bu kursumuzda çeşitli gösterimlerde sanal adresleri
    ikiye ayırcağız. 
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Biz yukarıda 32 bit sistemlere göre örnekler verdik. Pekiyi 64 bit sistemlerde durum nasıldır? 64 bit sistemlerde fiziksel RAM'in
    teorik büyüklüğü 2^64 = 16 exabyte olmaktadır. Dolayısıyla prosesin sanal bellek alanı da bu kadar olacaktır. Burada eğer 
    sanal adres iki parçaya ayrılırsa sayfa tablolarının aşırı büyük yer kaplaması kaçınılmazdır. Bu nedenle 64 bit sistemlerde 
    genellikle işlemcileri tasarlayanlar sanal adresleri dört parçaya ayırmaktadır. Bu konu yine kursumuzun kapsamı dışındadır. 
    Ancak 64 bit sistemlerde değişen bir şey yoktur. Program yine çok geniş bir sanal belleğe sanki tek başına yüklenecekmiş gibi derlenir. 
    Yine işletim sistemi proses için sayfa tablosu oluşturarak sanal sayfa numaralarını gerçek fiziksel sayfa numaralarına yönlendirir. 
    Tabii pek çok işletim sistemi 16 exabyte sanal bellek alanı çok büyük olduğu için bunu kısıtlama yoluna gitmektedir. Örneğin Linux
    yalnızca 256 TB alanı kullanmaktadır. Windows ise yalnızca 16 TB alan kullanır. Bu alanlar bile bugün için çok büyüktür. 

    Sayfa tablolarının gerçek organizasyonu için kurs dokğmanlarında /doc/ebooks klasöründe Inetl'in AMD'nin ve ARM işlemcilerinin orijinal dokümanları 
    bulundurulmuştur. 
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Pekiyi sayfalama (paging) mekanizmasının ne faydası vardır? İşte sayfalama mekanizmasının iki önemli işlevi vardır:

    1) Sayfalama mekanizması programların fiziksel RAM'e ardışıl yüklenmesinin zorunluluğunu ortadan kaldırır. Böylece "bölünme (fragmentation)"
    denilen olgunun olumsuz etkisini azaltar.

    2) Sayfalama mekanizması "sanal bellek (virtual memory)" denilen olgunun gerçekleştirimi için gerekmektedir. 
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Bölünme (fragmentation) bellek yönetimi konusunda önemli bir problemdir. Bir nesnenin belleğe yüklenmesi ardışıl bir biçimde 
    yapılırsa zamanla yükleme boşaltma işlemlerinin sonucunda bellekte küçük sok sayıda alana olulmaktadır. Bu küçük alanlar ardışıl olmadığı için
    genellikle bir işe yaramaktadır. Küçük alanların toplamı oldukça büyük miktarlara varabilmekte ve toplam belleğin önemli miktarını ,
    kaplayabilmektedir. Bu olguya "bölünme (fragmentation)" denilmektedir. Bölünmenin engellenmesi için ardışıl yükleme zorunluluğunun 
    ortadan kaldırılması gerekir. Bu durumda bellek bloklara ayrılır. Yüklenecek nesne bloklara bölünerek ardışıl olmayacak biçimde 
    boş bloklara ataır. Ancak nesnenin hangi parçasının hangi bloklardda olduğu da bir biçimde kaydedilir. Bu teknik hem RAM yönetiminde hem de 
    disk yönetiminde benzer biçimde kullanılmaktadır. Ancak bloklama yönetmiyle bölünme ortadan kaldırılmaya çalışıldığında  başka bir problem bu sefer
    ortaya çıkmaktadır. Nesnelerin son bloklarında kullanılmayan alanlar kalabilmektedir. Bu da bir çeşit bölünmedir. Bu bölünme drumuna 
    "içsel bölünme (internal fragmentation)" denilmektedir. İçsel bölünmede yapılabilecek bir şey yoktur. Ancak içsel bölünmenin etkisi diğerine göre daha 
    az olmaktadır. 
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Sanal bellek (virtual memory) bir programın tamamının değil belli kısmının belleğe yüklenerek disk ile RAM arasında yer değiştirmeli 
    bir biçimde çalıştırılmasına yönelik bir mekanizmadır. Bu mekanizma sayesinde örneğin 100MB'lık bir programın başlangıçta yalnızca 
    64K'lık kısmı RAM'e yüklenebilir. Sonra program çalışmaya başlar. Çalışma sırasında programın bellekte olmayan bir kısmına erişildiğinde
    programın o kısmı o anda diskten belleğe yüklenir ve çalışma devam ettirilir. 

    Sanal bellek kullanımında yine fiziksel RAM sayfalara ayrılır. Her sayafa bir numara verilir. İşletim sistemi RAM'in hangi sayfasının 
    hangi programın neresini tuttuğunu bir biçimde oluşturduğu veri yapılarıyla bilir duruma gelir. Bir programın RAM'd eolmayan bir sayfasının 
    diskten RAM'e yüklenmesine "swap in" denilmektedir. Ancak zamanla RAM'deki tüm fiziksel sayfalar dolu duruma gelir. Bu durumda işletim sistemi
    bir programın bir parçasını RAM'e çekmek için RAM'deki bir sayfayı boşaltmak durumunda kalır. Bu işleme ise "swap out" denilmektedir. 
    Tabii işletim sistemi hangi programın RAM'deki hangi sayfasının boşaltılacağı konusunda iyi bir kara vermek durumundadır. İşletim sistemine 
    göre "gelecekte kullanılma olasılığı en düşük olan sayfanın" RAM'den atılması en iyi yöntemdir. 

    Bu durumda bir program çalışırken aslında sürekli bir biçimde disk ile RAM arasında yer değiştirmeler yapılmaktadır. Bu yer değiştirmelere
    genel olarak işletim sistemi dünyasında "swap" işlemi denilmektedir. Şüphesiz swap işlemi yavaş bir işlemdir ve toplam performas üzerinde 
    en önemli zayıflatıcı etkilerden birini oluşturmaktadır. Swap işlemlerinin olumsuz etkisini azaltmak için ilk akla gelen fiziksel RAM'i büyütmektir. 
    Ancak fiziksel RAM'in büyütülmesi maliyet içermektedir. Bugünkü SSD'ler hard disklere göre oldukça iyi performans göstermektedir. 
    Dolayısıyla bilgisayarımızda har disk yerine SSD varsa swap işlemleri daha hızlı yürütülecektir. Şüphesiz en önemli unsur aslında 
    sayfaların yer değiştirilmesi konusunda uygulanan algoritmalardır. Bunlara "page replacement" algoritmaları denilmektedir. Tabii bugünkü 
    işletim sistemleri bilinen en iyi algoritmaları zaten kullanmaktadır. 
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Pekiyi işletim sistemi programın RAM'de olmayan bir sayfasını yüklemek istediğinde RAM'den sayfa boşaltacağı zaman ya boşaltılacak sayfa
    üzerinde yazma işlemleri (update) yapıldıys ane olacaktır? İçeriği değiştirilmiş olan sayfanın RAM'den atılırken öecburen diskte saklanması gerekir. 
    İşte işletim sistemleri bu işlemler için diskte ismine "swap file" ya da "page file" denilen dosyalar tutmaktadır. Değiştieilmiş olan 
    sayfaları bu dosyalara yazmaktadır. Linux işletim sistemi swap alanı olarak genellikle ayrı bir disk bölümünü kullanmaktadır. Ancak
    herhangi bir dosya da swap dosyası olarak kullanılabilmektedir. Kullanılacak swap disk alanının ya da dosyalarının toplamı bazen önemli olabilmektedir. 
    Çünkü sistemin toplam sanal bellek kapasitesi bu swap dosyalarıyla da ilgilidir. Linux sistemlerinde o andaki toplam swap alanları
    /proc/swaps dosyasından elde edilebilir. Ya da swapon -s komutuyla aynı bilgi elde edilebilir. 

    Pekiyi sistemin kullandığı swap alanı dolarsa ne olur? İşte bu durumda sistemin sanal bellek limiti dolmuş kabul edilir. Yapılacak şey 
    sisteme yeni swap alanları eklemektir. Bunun Linux'ta nasıl yapılacağını ilgili kaynaklardan öğrenebilrsiniz. 
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Pekiyi işletim sistemi programı belleğe yüklerken baştan kaç sayfayı yüklemektedir? İşte buna "minimum working set" denilmektedir. 
    İşetim sistemleri genel olarak bir program için en yüklenecebilecek sayfa sayısını belirlemişl durumdadır. Böylece yüklenmiş her programın 
    en azından "minimum working set" kadar sayfası RAM'de bulunmak zorundadır. 
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Pekiyi sanal bellek mekanizması nasıl gerçekleştirilmektedir? İşte işlemciler sanal bellek mekanizmasını oluşturabilmek için özel 
    bir biçimde taarlanmıştır. İşlemci ne zaman sanal adresi fiziksel adrese dönüştürmek için sayfa tablosuna başvursa eğer sayfa tablosunda
    o sanal adrese bir fiziksel sayfa karşılık getirilmemişse ismine "page fault" denilen bir içsel kesme (intterupt) oluşturmaktadır. Örneğin:

    Sanal Sayfa No  (decimal/hex)   Fiziksel Sayfa No (desimal/hex)
    ...                         ....
    23603                       84523 
    23604                       -
    23605                       42398 
    23606                       - 
    23607                       73245
    ...                         ...

    Burada Fiziksel Sayfa Numarasındaki "-" sembolleri o sanal sayafaya bir fiziksel sayfanın karşı getirilmediğini belirtmektedir. 
    Dolayısıyla örneğin işlemci 23604 numaralı, 23606 numaralı sanal sayfalar için dönüştürme yapmak isteiğinde "page fault" oluşturacaktır. 
    İşte "page fault"" denilen kesme oluştuğunda işletim sisteminin kesme kodu devreye girer. Buna "page fault handler" denilmektedi. Bütün 
    swap mekanizması bu işletim sisteminin kesme kodu tarafındna yapılmaktadır. İşletim sisteminin u kesme kodu (page fault handler) önce
    hangi prosesin hangi sayfaya erişmek istediğini tespit eder. Sonra onun diskteki karşılığını bulur ve yer değiştirme işlemini yapar. 
    Tabii bu kesme kodu yer değiştirme işlemini yaptıktan sonra artık sayfa tablosunu da güncellemektedir. İşletim sisteminin kesme kodu bittiğinde
    kesmeye yol açan makine komutu yenidne çalıştırılarak akış devam ettirilmektedir. Bu komut yenidne çalıştırıldığında artık sayfa tablosu 
    düzeltidliği için page fault olulşmayacaktır. Bu durumda bir pram çalıştırılşmak istendiğinde işletim sistemi aslında programın az sayıda 
    sayfasını RAM'e yükleyip sayfa tablosunun o sayfalar dışındaki fiziksel sayna numaralarını "-" haline getirir. Böylece yukarıda açıklanan mekanizma
    eşliğinde kesiksiz çalışma sağlanacaktır.

    Pekiyi ya erilşmek istenen sanal adres uydurma bir adresse ne olacaktır? İşte işletim sisteminin page fault kemse kodu (handler)
    öncelikle erişilme istenen adresin o proses için legal bir adres olup olmadığına bakmaktadır. Eğer erişilmek istenen adres legal bir adres değilse
    arık hiç swap işlemi yapılmadan porses cezalandırılır ve sonlandırılır. Yani her türlü sanal adresin diskte bir karşılığı yoktur. 
    Biz bir göstericiye rastgele bir adres yerleştirip oraya erişmek istesek aslında proses bu page fault kesme kodu tarafından 
    sonlandırılmaktadır. 

    O halde sanal bellek mekanizması tipik olarak işlemci ve işletim sistemi tarafından olarak şöyle gerçekleştirilmektedir:

    1) Proses bir sanal adrese erişmeye çalışır
    2) İşlemci sanal adresi parçalarına ayırır ve sayfa tablosuna başvurularak
    3) Sayfa tablosunda ilgili sayfaya bir fiziksel sayfa karşı getirilmişse sorun oluşmaz çalışma normal olarak devam eder. 
    Ancak sanal sayfaya bir fiziksel adres karşı getirilmemişse (şekilde onu "-" ile gösterdik) bu durumda işlemci "page fault" denilen
    içsel kesmeyi oluşturur.
    4) Page fault kesmesi için kesme kodunu işletim sistemini yazanlar bulundurmuştur. Bu kod önce erişilmek istenen adresin geçerli 
    bir adres olup olmadığına bakar. Eğer erişilmek istenen adres geçerli bir adres değilse proses sonlandırılır. Eğer geçerli bi adresse
    page fault kesme kodu "swap mekanizması" ile programın o kısmını RAM'e yükler, sayfa tablosunu günceller ve kesme kodundan çıkar. 
    Artık işelemci fault oluşturan makine komutuyla çalışmasına devam eder. Ancak sayfa tablosu düzeltildiği için bu kez fault oluşturmaz. 
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Pekiyi işletim sisteminin "bellek yönetimi (memory management)" kısmını yazanlar hangi bilgileri tutmak zorundadır? 
    İşte işletim sistemleri tipik olarak bu mekanizma için şu bilgileri kernel alanı içerisinde oluşturmak zorundadır:

    1) Tüm fiziksel RAM'deki tüm sayfaların "free" olup olmadığına ilişkin tablo
    2) Bir fiziksel sayfanın free değilse hangi proses tarafından kullanıldığına ilişkin bilgi
    3) Swap dosyalarının yerleri ve organizasyonu
    4) Hani proseslerin hangi sayfalarının o anda fiziksel RAM'de hangi fiziksel sayfalarda bulunduğu
    5) Diğer başka bilgiler

    Bellek yönetimi (mameory management) bir işletim sisteminin en önemli ve en zor yazılan alt sistemlerden biridir. 
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Pekiyi sanal bellek toplamda bize ne sağlamaktadır? Şüphesiz sanal bellek mekanizmasının en önemli faydası RAM yeterli olmasa bile
    çok sayıda büyük programın aynı anda çalışır durumda tutulabilmesidir. Bizim elimizde 8GB RAM olsa bile biz onlarca büyük programı 
    çalışır durumda tutabiliriz. Ancak yukarıda da belirtldiği gibi işletim sistemi bir swap alanı bulundurmaktadır. Eğer bu swap alanı 
    dolarsa başka bir limit nedeniyle "out of memory" durumu oluşablmektedir. Bu nedenle eğer programlar çok fazla bellek kullanıyorsa
    bu swap alanlarının büyütülmesi de gerekebilir. 
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Sayfalama ve sanal bellek mekanizmasında işletim sistemi de o anda sanal bellek alanı içerisinde bulunmak zorundadır. Pekiyi 
    işletimin sisteminin kodları sayfa tablosunda sanal belleğin neresindedir? İşte genellikle işletim sistemi tasarımcıları
    sanal bellek alanını "user sapace" ve "kernel space" olarak ikiye ayırmaktadır. "user space" genellikle sanal bellek alanının düşük 
    anlamlı kısmında, kernel space ise yüksek anlamlı kısmında bulundurulur. Örneğin 32 bit Linux sistemleri 4GB'lik sanal bellek alanını 
    şöyle ayırmıştır:

    32 Bit Linux Proses Sanal Bellek Alanı

    3 GB        User Space
    1 GB        Kernel Space

    Bu durumda 32 bir Linux sistemlerinde bir programın kullanabileceği maksimum sanal bellek 3 GB'dir. (Windows ta 2GB user space için, 
    2 GB kernel space için kullanılmıştır.) 64 bit Linux sistemlerinde ise prosesin sanal bellek alanı şöyle organize edilmiştir:

    
    64 Bit Linux Proses Sanal Bellek Alanı

    128 TB        User Space
    128 TB        Kernel Space

    Görüldüğü gibi aslında teorik sanal bellek 16 exabyte olduğu halde 64 bit Linuz sistemleri yalnızca 256 TB sanal belleğe
    izin vermektedir. 

    Proseslerin sayfa tablolarında kernel alanınının içeriği hep aynıdır. Yani context switch yapılsa bile kernel kodları hep aynı 
    sanal adreslerde bulunmaktadır. 
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Biz bir program içerisinde yüksek miktarda dinamik tahsisat yaptığımızda ne olur? Linux sistemlerinde malloc fonksiyonu
    brk ya d sbrk denilen sistem fonksiyonunu çağırabilmektedir. Ancak arka planda sanal bellek bakımından şunlar gerçekleşir:

    - İşletim sistemi malloc ile tahsis edilen alanı sayfat tablosunda oluşturur. Oluştururken de tahsis edilen alanın 
    toplam swap alanından küçük olduğunu garanti etmeye çalışır. Çünkü malloc ile tahsis edlen alan eninde sonunda swap dosyası içerisinde 
    bulundurulacaktır. 

    - İşletim sistemi swap dosyasının boyutu yeterliyse tahsisatı kabul etmektedir. Ancak sistemden sisteme değişebilecek biçimde
    bu sırada swap dosyasında tahsisat yapılabilir ya da yapılmayabilir. Eğer swap dosyasında o anda tahsisat yapılırsa bu durumda 
    swap alanı ciddi biçimde azalacak ve belki de başka proses artık aynı tahsisatı yapamayacaktır. Ancak işletim sistemi swap dosyasında 
    tahsisatı henüz yapmayabilir. Bu işlemi dinamik alan kullanıldığında yapabilir. Genellikle Linux sistemleri bu yola başvurmaktadır. 
    Lieratürde dinamik alan için swap dosyasında baştan yer ayrılmasına "alanın commit edilemsi" denilmektedir. 

    Aşağıdaki 3GB RAM olan 2GB swap alanına sahip 64 bit Linux sisteminde 5GB alan dinamik olarak tahsis edilmek istenmiştir. 
    Burada tahsisat başarılı gibi gözükse de athsis edilen alan kullanılırken swap alanı yetersizliğinden dolayı sinyal oluşacak 
    ve proses sonlandırılacaktır.

    O halde 64 bit Linux sistemlerinde biz teorik olarak her biri 128 TB olan onlarca programı bir arada çalıştırabiliriz. Ancak 
    bunun için swap alanımızın da yeterli büyüklükte diskte oluşturulmuş olması gerekir. Swap alanının yetersizliği durumunda bir sinyal 
    ile proses sonlandırılmaktadır. 
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>

int main(void)
{
	char *pc;

	pc = (char *)malloc(5000000000);
	if (pc == NULL) {
		fprintf(stderr, "cannot allocate memory!..\n");
		exit(EXIT_FAILURE);
	}

	for (long i = 0; i < 5000000000; ++i)
		pc[i] = 0;

	printf("ok\n");

	getchar();

    return 0;
}

/*--------------------------------------------------------------------------------------------------------------------------
                                            36.Ders 11/03/2023 - Cumartesi
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Anımsanacağı gibi işletim sistemi sayfa tabloları yoluyla proseslerin bellek alanlarını tam olarak birbirinden izole
    etmektedir. Dolayısıyla bir proses istese de başka bir prosesin bellek alanına erişememektedir. Ancak ismine "paylaşılan bellek alanları 
    (shared memory)" denilen bir teknik ile işletim sistemi farklı proseslerin aynı fiziksel sayfaya erişimini sağlayabilmektedir. 
    Şöyle ki: İşteim sistemi iki prsesin sayfa tablosunda farklı sanal sayfaları aynı fiziksel sayfaya eşlerse bu iki proses farklı sanal adreslerle
    aslında aynı fiziksel sayfayı görüyor durumda olur. Örneğin:

        Proses-1 Sayfat Tablosu

    Sanal Sayfa Numarası            Fiziksel Sayfa Numarası
    ...                             ...
    987                             1245
    988                             1356
    999                             1412
    ...                             ...

    Proses-2 Sayfa Tablosu

    Sanal Sayfa Numarası            Fiziksel Sayfa Numarası
    ...                             ...
    356                             7645
    357                             1356
    358                             489
    ...                             ...

    Görüldüğü gibi birinci prosesin 988'inci sanal sayfa numarası ikinci prosesin 357'inci sanal sayfa numarasıyla aynı fiziksel 
    adrese yönlendirilmiştir.
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Aslında sayfa tablolarında her bir sayfanın da ayrıca bir "özellik bilgisi (attribute)" vardır. Yani sayfa tablolarının formatı
    daha gerçekçi bir biçimde şöyledir:

    Sanal Sayfa No          Fiziksel Sayfa No       Sayfa özelliği
    ...                     ...                     ...

    Sayfa özelliği o fiziksel sayfanın "read only" mi, "read/write" mı "execute" özelliğine sahip mi olduğunu belirtmektedir. 
    Ayrıca bir fiziksel sayfa "user mode" ya da "kernel mode" sayfa olarak belirlenebilmektedir. İşletim sistyemi prosesin tüm fiziksel 
    sayfalarını "user mode" olarak ancak kernel'ın tüm sayfalarını "kernel mode" olarak ayarlamaktadır. User mode bir proses yalnızca 
    user mode sayfalara erişebilmektedir. Kernel mode sayfalara erişememektedir. Eğer user mode bir proses kernel mode sayfaya erişmek 
    isterse işlemci bir "içsel kesme (fault)" oluşturmakta ve işletim sistemi devreye girerek prosesi sonlandırmaktadır. Ancak kernel mode 
    bir proses hem kernel mode sayfalara hem de user mode sayfalara erişebilmektedir. Bizim prosesimiz user mode'da çalışmaktadır. User mode 
    prosesler bir user mode sayfaya erişirken işlemci erişim biçimine bakar ve duruma göre yine içsel kesme oluşturur. User mode bir proses
    user mode ancak read-only bir sayfaya yazma yaparsa içsel kesme (page fault) oluşturulmaktadır. Bu durumda işletim sistemi prosesi cezalandırarak
    sonlandırma yoluna gitmektedir. Ayrıca pek çok işlemci ailesinde bir kodun bir fiziksel sayfada çalışabilmesi için o kodun "execute" 
    özelliğine sahip bir fiziksel sayfada bulunması gerekmektedir. Bu mekanizma altında örneğin bir proses "execute" olmayan bir fiziksel 
    sayfadaki bir fonksiyonu çağırmak isterse yine işlemci içsel kesme (page fault) oluşturmaktadır. Örneğin C derleyicileri string'leri
    ELF formatında özel bir bölüme (section) yerleştirirler ve işletim sisteminin yükleyicisi de (UNIX/Linux sistemlerindeki exec fonksiyonları)
    bu sayfaları sayfa tablosunda oluştururken bu sayfaların özelliklerini "read-only" yaparlar. Böylece biz bir string'i değiştirmek istediğimizde
    koruma mekanizması yüzünden prosesimiz sonlandırılır. Zaten C'de string'lerin güncellenmesi "tanımsız davranış (undefined behavior)" olarak 
    belirtilmektedir. Benzer biçimde derleyiciler genellikle global const nesneleri de yine "read-only" bölümlere (sections) yerleştirmektedir. 
    (Ancak yerel const nesneler stack'te olduğu için read-only yerleştirilememektedir.) 
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Aynı programın ikinci kez çalıştırıldığını düşünelim. Bu durumda her şeyi ynı olan iki program çalışıyor durumda olacaktır.
    Ancak bu iki proses biribirinden bağımsız olduğuna göre bu iki prosesin farklı sayfa tablolrı vardır ve aslında bu iki prosesin
    bellek alanı tamamen izole edilmelidir. İşte işletim sistemleri bu tür durumlarda "copy on write" denilen bir mekanizma uygulamaktadır. 
    Bu mekanzimada işletim sistemi bir program ikinci kez çalıştırıldığında sayfa tablosunda önceki çalıştırma ile aynı fiziksel 
    sayfaları eşler. Ancak bu sayfaları "read-only" biçimde işaretler. Proseslerden biri bu sayfaya yazma yaptığında içsel kesme (page fault)
    oluşur, işletim sistemi devreye girer tam yazma yapıldığı sırada o sayfanın bir kopyasını oluşturup iki prosesin fiziksel sayfalarını birbirinden 
    ayırır. Böylece iki proses baştan aynı fiziksel sayfaları paylaşırken daha sonra bu fiziksel sayfalar biribirinden ayrıştırılmaktadır. 
    Bu mekanizma sayesinde aslında hiç yazma yapılmayan fiziksel sayfaların boşuna bir kopyası oluşturulmamış olur. Örneğin ikinci Çalıştırılan
    programın makine kodlarının bulunduğu sayfalar aslında hiç güncellenmemektedir. Bu durumda iki kopyanın aynı fiziksel sayfayı görmesinde
    bir sakınca yoktur. İşletim sistemleri dinamik kütüphanelerde de benzer tekniği kullanmaktadır. Bir dinamik kütüphane iki farklı 
    proses tarafından kullanıldığında mümkün olduğunca bu proseslerin sayfa tabloları aynı fiziksel sayfaları gösterir. Ancak proseslerden biri
    dinamik kütüphanedeki bir sayfada değişiklik yaparsa o noktada bu sayfanın kopyasından oluşturulmaktadır.
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    İşletim sistemleri dünyasında bir prosesin başka bir proses bilgi göndermesi ve başka bir prosesten bilgi almasına 
    "proseslerarası haberleşme (interprocess communication - IPC)" denilmektedir. Burada bilgi gönderip almadan kastedilen şey 
    aslında byte yığınlarını gönderip almadır. Proseslerarası haberleşme önemli bir konudur. Çünkü sayfa tabloları yoluyla 
    biribirinden izole edilmiş proseslerin başka yöntemlerle birbirleriyle haberleşme gerekebilmektedir. Bir program başka 
    bir programa bir şeyler gönderebilir, o program da bunları işleyebilir. Proseslerarası haberleşmenin en bariz örneği "client-server"
    sistemlerdir. Bu sistemlerde client program server programa bir istek gönderir. Server program da bu isteği yerine getirip sonuçları 
    client programa gönderir. Bu mekanizmanın kurulabilmesi için proseslerarası haberleşme denilen mekanizmanın kullanılması gerekir. 
    Benzer biçimde "dağıtık sistemlerde (distributed systems)" de esas olarak proseslerarası haberleşme mekanizması kullanılmaktadır. 

    Proseslerarası haberleşme mekanizmaları iki bölümde ele alınıp incelenmektedir:

    1) Aynı makinenin prosesleri arasında haberleşme
    2) Farklı makinelerin prosesleri arasında haberleşme

    Aynı makinenin prosesleri arasında haberleşme işletim sisteminin sağladığı özel yöntemlerle gerçekleştirilmektedir. Farklı makinenin
    prosesleri arasında haberleşme için ortak uyulması gereken bazı kuralların belirlenmiş olması gerekir. Bu ortak kurallara "protokol (protocol)" 
    denilmektedir. Farklı makinelerin prosesleri arasında haberleşme için çeşitli protokol aileleri oluşturulmuştur. Ancak bunlardan en 
    yaygın kullanılanı "IP (Internet Protocol)" denilen protokol ailesidir. Biz kursumuzda önce aynı makinenin prosesleri arasında haberleşme yöntemlerini
    inceleyeceğiz daha sonra farklı makinelerin prosesleri arasında haberleşme yöntemleri üzerinde duracağız. 
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Aynı makinenin prosesleri arasında haberleşme için çeşitli işletim sistemlerinde biribirine benzer yöntemler geliştirilmiştir. 
    Örneğin "boru (pipe)" UNIX/Linux sistemleriyle Windows sistemleri arasında benzer biçimde yürütülür. Paylaşılan bellek alanları 
    (shared memory)" yine benzer biçimde uygulanmaktadır. Ancak bazı işletim sistemlerinde o sisteme özgü özel yöntemler de olabilmektedir. 
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Proseslerarası haberleşme mekanizmasının iki yönü vardır. Birincisi iki prosesin haberleşeceği bir ortamın oluşturulmasıdır.
    İkincisi ise bu ortamın senkronize bir biçimde kullanılmasıdır. Yani proseslerarası haberleşme bir senkronizasyon sağlanarak 
    gerçekleştirilmelidir. 
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    En yaygın kullanılan proseslerarası haberleşme yöntemi "boru (pipe)" denilen yöntemdir. Boru haberleşmesi hem bir ortam sunarken
    senkronizasyonu da kendi içerisinde sağlamaktadır. Bu nedenle boru haberleşmesi kolay kullanılabilen bir IPC yöntemidir. 
    Boru haberleşmeleri "isimsiz boru haberleşmeleri" ve "isimli boru haberleşmeleri" olmak üzere ikiye ayrılmaktadır. İsimsiz boru
    haberleşmelerine İngilizce "unnamed pipe" ya da "anonymous pipe" denilmektedir. İsimli boru haberleşmelerine ise İngilizce
    "named pipe" ya da "fifo" denilmektedir. 
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Boru aslında FIFO tarzında çalışan bir kuyruk sistemidir. Bir proses boruya yazma yapar, diğeri de borundan yazılanları 
    okur. UNIX/Linux sistmlerinde borular birer dosya gibi ele alınmaktadır. Dolayısıyla boruya yazma işlemi "write" fonksiyonu 
    ile borudan okuma işlemi ise "read" fonksiyonu ile yapılmaktadır. Yazan taraf boruya bir grup byte'ı yazdığında okuyan taraf 
    bunları aynı sırada okur.

    Boruların belli bir uzunlukları vardır. Eskiden BSD ve Linux sistemlerinde boru uzunlukları 4096 byte (bir sayfa) büyüklüğündeydi.
    Linux daha sonra default boru uzunluğunu 65536'ya (16 sayfaya) yükseltmiştir. 

    UNIX/Linux sistemlerinde borular tek yönlüdür. Bu nedenle proseslerden biri boruya yazma yaparken diğeri okuma yapar. 
    (Halbuki örneğin Windows sistemlerinde borular çift yönlüdür.) Borunun tek yönlü olması demek iki prosesin de yazdıklarının aynı boruya 
    yazılması demektir. P1 prosesi boruya yazma yapıp yine P1 prosesi borudan okuma yaparsa kendi yazdığını okur. Bunun da bir anlamı olmaz. 
    Halbuki çift yönlü borularda borudan hem okuma hem yazma yapılabilmektedir. Borudan okuma yapıldığında karşı tarafın yazdığı okunur.
    Ancak UNIX/Linux sistemlerindeki borular tek yönlüdür. Dolayısıyla haberleşmede bir taraf yazma yaparken diğer taraf okuma yapmalıdır.
    Eğer borularla karşılıklı okuma yazma yapılmak isteniyorsa iki boru kullanılmalıdır.  
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Borulara write POSIX fonksiyonu ile yazma yapılırken yazılmak istenen byte kadar boruda yer yoksa write işlemi blokeye 
    yol açar ve boruda yazılmak istenen miktar kadar boş alan oluşana kadar ilgili thread blokede bekletilir. Örneğin biz boruya
    50 byte yazmak isteyelim. eğer boruda en az 50 byte'lık boş yer varsa biz bloke olmadan bu işlemi yaparız ve write fonksiyonu 50 
    değeri ile geri döner. Ancak boruda örneğin 40 byte boş yer varsa bu durumda write fonksiyonu 50 byte'lık yer açılana kadar 
    blokede bekler. 50 byte'lık yer açıldığında bu 50 byte'ı boruya yazar ve 50 değeri ile geri döner. Böylece bir proses sürekli
    boruya yazma yapar ancak karşı taraf borudan okuma yapmazsa boru dolar en sonunda write fonksiyonu blokede bekler. Karşı taraf 
    borudan okuma yaptığında boruda yer açılmaktadır. 

    Borulara yazma işlemi atomik düzeyde yapılmaktadır. Farklı prosesler aynı boruya aynı anda yazma yapsalar bile bu yazılanlar 
    iç içe geçmez. Ancak borularda PIPE_BUF denilen bir sembolik sabit değeri vardır. Eğer iki proesten en az biri bu PIPE_BUF değerinden 
    daha yüksek miktarda byte'ı boruya yazmak isterse bu durumda iç içe geçme oluşabilir. Yani birden fazla prosesin aynı boruya 
    aynı zamanda yazma yapması durumunda iç içe geçmenin olmaması için yazılanların PIPE_BUF sembolik sabitinden daha küçük ya da ona eşit olması gerekir. 
    PIPE_BUF pek çok sistemde (Linux'ta da böyle) 4096 değerindedir. Burada önemli bir nokta şudur: Biz PIPE_BUF değerinden daha fazla
    byte'ı boruya yazmak istediğimizde yine tüm bilgi boruya yazılana kadar bloke oluşmaktadır. Ancak bu durumda iç içe geçmeme garanti
    edilememektedir. Ayrıca proses borunun uzunluğundan fazla bilgiyi boruya yazmaya çalışabilir. Bu durumda yine tüm bilgi boruya yazılana
    kadar bloke oluşmaktadır.

    Normal olarak borulara yazma yaparken write tüm byte'lar yazılana kadar bloke oluşturduğuna göre write fonksiyonun yazılmak istenen 
    byte sayısı ile geri dönmesi beklenir. Gerçekten de hemen her zaman böyle olmaktadır. Ancak write fonksiyonu ile boruya yazma yapılırken 
    bir sinyal oluşursa bu durumda POSIX standartları kısmi yazma yapılabileceğini söylüyorsa da Linux sistemlerinde bu durumda boruya hiçbir şey yazmadan 
    write fonkisyonu başarısız olur ve -1 değeri ile geri döner. errno değişkeni de EINTR değeriyle set edilir. Linux sistemlerinde yine write fonksiyonu boruda 
    yeterince yer yoksa ve blokede bekliyorsa sinyal oluştuğunda boruya bir şey yazmadan -1 ile geri dönmektedir. 
    (Yani blokeli boru yazımlarında POSIX standartlarına göre kısmi yazım söz konusu olabilirse de Linux sistemlerinde "kısmi yazım (partial write)" 
    işlemi yapılmamaktadır.)

    Boruya 0 byte yazılmak istenirse bu durum POSIX standartlarında "unspecified" bırakılmıştır. Ancak pek çok UNIX türevi sistem
    (Linux'ta da böyle) 0 byte yazma durumunda boruya bir şey yazmamakta basit bazı kontroller yapıp sonlanmaktadır. Eğer bu kontrollerde
    bir sorun yoksa write fonksiyonu 0 ile geri dönemektedir. 
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    read fonksiyonu ile borudan okuma yapılırken read fonksiyonu eğer boru tamamen boşsa en az 1 byte boruda olana kadar blokeye
    yol açar. Ancak boruda en az 1 byte bilgi varsa read okuyabildiği kadar byte'ı okur, blokeye yol açmadan hemen okuyabildiği 
    byte sayısı ile geri döner. Yani read tüm byte'lar okunan kadar değil, en az bir byte okunana kadar beklemeye yol açmaktadır. 
    Bu bakımdan write gibi davranmamaktadır. Örneğin biz borudan 50 byte okumak isteyelim. Ancak boruda 10 byte bulunuyor olsun. read 
    fonksiyonu 50 byte okunana kadar beklemez. O 10 byte'ı okur, bu 10 değeri ile geri döner. Ancak boruda hiç bilgi yoksa read 
    blokede en az 1 byte boruda olana kadar blokede bekleyecektir. Örneğin biz borudan 50 byte okumak isteyelim. Ancak boruda 
    hiç bilgi olmasın. read fonksiyonu blokede bekler. O sırada bir proses boruya 10 byte yazmış olsun. Şimdi read bu 10 byte'ı alarak 
    işlemini sonlandırır ve 10 değeri ile geri döner. 
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Pekiyi boru haberleşmesi nasıl sonlandırılmaktadır? Boruyu kesinlikle yazan tarafın kapatması gerekir. Bu durumda okuyan taraf önce
    boruda kalanları okur. Artık boruda bir şey okunacak bir şey kalmamışsa ve yazan taraf da boruyu kapatmışsa read fonksiyonu 0 değeri ile geri döner. 
    Normalde read fonksiyonu boruda hiç bilgi yoksa blokede beklemektedir. Ancak eğer boruya yazma potansiyelinde hiçbir betimleyici 
    kalmadıysa bu durumda read fonksiyonu bloke olmadan 0 özel değeri ile geri döner. O halde sonlandırma şöyle yapılamldır: Önce 
    yazan taraf boruyu kapatmalıdır. Sonra okuyan taraf boruda kalanları okumalı ve read fonksiyonu 0 ile geri döndüğünde okuyan taraf da 
    boruyu kapatmalıdır. 

    Boru haberleşmesinde eğer boruyu yanlış bir biçimde önce okuyan taraf kapatırsa yazan taraf boruya yazma yaptığında SIGPIPE isimli
    bir sinyal oluşmaktadır. Bu sinyal de prosesin sonlanmasına yol açacaktır. Yani okuma tarafı kapatılmış bir boruya yazma yapmak 
    normal bir durum değildir. Ancak yazma tarafı kapatılmış bir borudan okuma yapmaya çalışmak normal bir durumdur. Bu durumda read 
    boruda bir şey kalmadıysa 0 ile geri dönecektir.
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    İsimsiz boru haberleşmesi üst ve alt prosesler arasında yapılabilen bir haberleşmedir. İsimsiz boru haberleşmesi tipik olarak
    şu aşamalardan geçilerek gerçekleştirilir:

    1) Üst proses henüz fork ile alt prosesi yaratmadan önce pipe isimli POSIX fonksiyonu ile isimsiz boruyu yaratmalıdır. pipe
    fonksiyonunun prototipi şöyledir:

    #include <unistd.h>

    int pipe(int pipefd[2]);

    pipe fonksiyonu int türden bir dizinin başlangıç adresini parametre olarak alır. Protoipteki dekleratör bir gösterici dekleratörüdür. 
    pipe fonksiyonu boruyu yaratır. Borudan okuma yapmak ve boruya yazma yapmak için iki dosya betimleyicisi oluşturur. O betimleyicilerin
    numaralarını da bizim fonksiyona geçirdiğimiz iki elemanlı int bir diziye yerleştirir. Dizinin ilk elemanına borudan okuma yapmak için 
    kullanılacak betimleyiciyi, ikinci elemanına ise boruya yazma yapmak için kullanılacak betimleyiciyi yerleştirmektedir. 
    Tabii bu betimleyiciler dosya betimleyici tablosunda tahsis edilmiş durumdadır. Bu betimleyicilerin gösterdiği dosya 
    nesneleri boruya erişmek için gereken bilgileri tutmaktadır. Bize verilen dizinin ilk elemanına yerleştirilen betimleyici read-only, 
    dizinin ikinci elemanına yerleştirilen betimleyici ise write-only bir betimleyicidir. Yani biz ilk betimleyici ile yalnızca read 
    işlemi ikinci betimleyici ile yalnızca write işlemi yapabiliriz. pipe fonksiyonunun dosya betimleyici tablosundaki en düşük numaralı
    boş betimleyicileri vereceği POSIX standartlarında garanti edilmiştir. Ancak pipe fonksiyonun verdiği iki betimleyicinin hangisinin düşük numaralı 
    betimleyici olacağının bir garantisi yoktur. 

    2) Boru yaratıldıktan sonra üst prosesin fork işlemi ile alt prosesi yaratması gerekir. fork işlemiyle birlikte üst prosesteki
    tüm betimleyiciler alt proseste de aynı değerlerle aynı dosya nesnelerini gösterir biçimde oluşturulacaktır. Yani artık üst 
    alt ve alt prosesler aynı numaralı betimleyicilerle boruya erişebilir durumda olur.

    3) Artık üst ve alt prosesler arasında haberleşme için bir karar verilmelidir. Kim yazacak kim okuyacaktır? Bundan sonra 
    boruya yazma ve okuma potansiyelinde olan birer betimleyici bırakılmalıdır. Yani yazan taraf okuma betimleyicisini okuyan
    taraf yazma betimleyicisini kapatmalıdır. 

    4) Artık okuma ve yazma işlemleri read ve write fonksiyonlarıyla gerçekleştirilebilir. 

    5) Baherleşmeyi sonlandırmak için yazan taraf boruyu kapatır. Okuyan taraf önce boruda kalanları okur, sonra read fonksiyonu
    0 ile geri döner. Sonra da okuyan taraf boruyu kapatır.

---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
                                                37.Ders 12/03/2023 - Pazar
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Aşağıadaki programda üst proses boruya yazma yapmakta alt proses de borudan okuma yapmaktadır. Alt proses üst prosesin yazdığı 
    int sayıları okumaktadır. 
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/wait.h>

void exit_sys(const char *msg);

int main(void)
{
    int pid;
    int fdpipe[2];
    int result;
    
    if (pipe(fdpipe) == -1)
        exit_sys("pipe");

    if ((pid = fork()) == -1)
        exit_sys("fork");

    if (pid != 0)  {
        /* parent writes */

        close(fdpipe[0]);

        for (int i = 0; i < 1000000; ++i)
            if (write(fdpipe[1], &i, sizeof(int)) == -1)
                exit_sys("write");

        close(fdpipe[1]);

        if (wait(NULL) == -1)
            exit_sys("wait");
    }
    else {
        /* child reads */
        int val;

        close(fdpipe[1]);
        
        while ((result = read(fdpipe[0], &val, sizeof(int))) > 0) {
            printf("%d ", val);
            fflush(stdout);
        }
        if (result == -1)
            exit_sys("read");

        close(fdpipe[0]);

        printf("\n");
    }

    return 0;    
}

void exit_sys(const char *msg)
{
	perror(msg);

	exit(EXIT_FAILURE);
}

/*--------------------------------------------------------------------------------------------------------------------------
    Pekiyi isimsiz boru haberleşmesinde neden okuyan taraf yazma betimleyicisini, yazan taraf da okuma betimleyicisini kapatmaktadır?
    İşte read fonksiyonunun 0 ile geri dönmesi için boruya yazma potansiyelinde olan tek bir betimleyicinin bulunuyor olması gerekir. 
    eğer okuyan taraf yazma betimleyicisini kapatmazsa yazan taraf yazma betimleyicisini katapsa bile boruya hala yazma potansiyelinde 
    olan bir betimleyici kaldığı için read fonksiyonu 0 ile geri dönmeyecektir. Bu durumda haberleşmenin sonlandırılması sorunlu 
    hale gelecektir. Yazan tarafın okuma betimleyicisini kapatmasının diğeri gibi kritik bir önemi yoktur. Ancak prensip olarak kullanılmayan
    betimleyicilerin kapatılması iyi bir tekniktir.
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Üst ve alt prosesler arasında haberleşme yapmak kişilere biraz tuhaf gelebilmektedir. Çünkü fork işleminden sonra zaten 
    her iki kod da programı yazan kişi tarafından yazılmış olmaktadır. Ancak üst ve alt prosesler arasında boru haberleşmelerinin
    gerektiği önemli durumlar vardır. 

    Eskiden thread'ler yokken bir işi daha hızlı yapmak için prosesler kullanılıyordu. Üst proses fork işlemi yapıp alt prosesle 
    koordineli bir biçimde işleri paylaşıyordu. O günlerde bu koordinasyonun sağlanması için üst ve alt prosesler arasında haberleşme de 
    gerekiyordu. Thread'lerden sonra artık bu tür işlemler prosesler yerine thread'lerle yapılmaya başlanmıştır.

    Üst ve alt prosesler arasında exec sonrasında da haberleşmeler yapılabilmektedir. Tabii bu durumda exec yapılan alt prosesin 
    exec sonrasında boru betimleyicilerinin numaralarını biliyor olması gerekir. Ancak stdin, stdout ve stderr dosyalarının betimleyicileri
    sabit olduğuna göre exec sonrasında haberleşme bu betimleyiciler yoluyla yapılabilmektedir. 
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Aşağıdaki programda kabuktakine benzer bir boru yönlendirme yapılmıştır. Program komut satırı argümanı olarak aşağıdaki gibi bir 
    yazı almaktadır:

    "prog1 arg1 arg2 ... | prog2 arg1 arg2 ..."

    Program buradaki "|" sembolünün yerini bulur. Sonra bunun ikşi tarafını strtok ile parse ederek iki ayrı gösterici dizisine
    yerleştirir. Sonra üst proses pipe fonksiyonuyla boruyu yaratır. Soldaki ve sağdaki programlar için fork işlemi yapar. 
    Soldaki programı henüz exec ile çalıştırmadan o alt prosesin stdout dosyasını boruya yönlendirir. Benzer biçimde sağdaki 
    programı henüz çalıştırmadan o prosesin de stdin dosyasını boruya yönlendirir. Sonra da exec işlemlerini uygular. 
    Kabuk aşağıdaki gibi bu boru işlemini yapmaktadır.
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/wait.h>

#define MAX_ARG         1024

void exit_sys(const char *msg);
void exit_sys_child(const char *msg);

int main(int argc, char *argv[])
{
    char *ppos, *str;
    char *cmdl[MAX_ARG + 1], *cmdr[MAX_ARG + 1];
    int pipefds[2];
    pid_t pidl, pidr;
    int n;

    if (argc != 2) {
        fprintf(stderr, "wrong number of arguments!..\n");
        exit(EXIT_FAILURE);
    }

    if ((ppos = strchr(argv[1], '|')) == NULL) {
        fprintf(stderr, "invalid argument: %s\n", argv[1]);
        exit(EXIT_FAILURE);
    }
    *ppos = '\0';

    n = 0;
    for (str = strtok(argv[1], " \t"); str != NULL; str = strtok(NULL, " \t"))
        cmdl[n++] = str;
    cmdl[n] = NULL;

    if (n == 0) {
        fprintf(stderr, "invalid argument!..\n");
        exit(EXIT_FAILURE);
    }

    n = 0;
    for (str = strtok(ppos + 1, " \t"); str != NULL; str = strtok(NULL, " \t"))
        cmdr[n++] = str;
    cmdr[n] = NULL;

    if (n == 0) {
        fprintf(stderr, "invalid argument!..\n");
        exit(EXIT_FAILURE);
    }

    if (pipe(pipefds) == -1)
        exit_sys("pipe");

    if ((pidl = fork()) == -1)
        exit_sys("fork");

    if (pidl == 0) {
        close(pipefds[0]);
        if (pipefds[1] != 1) {                  /* bu kontrol normal dureumda yapılmayabilir */
            if (dup2(pipefds[1], 1) == -1) 
                exit_sys_child("dup2");
            close(pipefds[1]);
        }
        
        if (execvp(cmdl[0], cmdl) == -1)
            exit_sys_child("execvp");

        /* unreachable code*/
    }
    
    if ((pidr = fork()) == -1)
        exit_sys("fork");
    
    if (pidr == 0) {
        close(pipefds[1]);
        if (pipefds[0] != 0) {                  /* bu kontrol normal dureumda yapılmayabilir */
            if (dup2(pipefds[0], 0) == -1)
                exit_sys_child("dup2");
            close(pipefds[0]);
        }
 
        if (execvp(cmdr[0], cmdr) == -1)
            exit_sys_child("execvp");

        /* unreachable code*/
    }

    close(pipefds[0]);
    close(pipefds[1]);
    
    if (waitpid(pidl, NULL, 0) == -1)
        exit_sys("waitpid");
    
    if (waitpid(pidr, NULL, 0) == -1)
        exit_sys("waitpid");
    
    return 0;    
}

void exit_sys(const char *msg)
{
	perror(msg);

	exit(EXIT_FAILURE);
}

void exit_sys_child(const char *msg)
{
	perror(msg);

	_exit(EXIT_FAILURE);
}

/*--------------------------------------------------------------------------------------------------------------------------
    Borularla ilgili yardımcı iki ilginç POSIX fonksiyonu vardır: popen ve pclose. popen fonksiyonu bir boru yaratır sonra 
    kabuk programını interaktif olmayan bir biçimde (-c seçeneği ile) çalıştırır. Sonra kabuk programının stdin ya da stdout dosyalarını
    bu yarattığı boruya yönlendirir. Borunun diğer ucunu da fdopen fonksiyonundan faydalanarak bir dosya bilgi göstericisine (stream)
    dönüştürüp bize vermektedir. Fonksiyonun prototipi şöyledir:

    #include <stdio.h>

    FILE *popen(const char *command, const char *mode);

    Fonksiyonun birinci parametresi çalıştırılacak kabuk komutunu belirtir. İkinci parametre yalnızca "r" ya da "w" olabilir. 
    Eğer bu parametre "r" girilirse kabuk komutunun stdout dosyası boruya yönlendirilir. Borunun okuma ucu da bize verilir. 
    Yani biz bize verilen dosyadan okuma yaptığımızda aslında kabuk komutunun stdout dosyasına yazdıklarını okumuş oluruz. 
    Eğer ikinci parametre "w" olarak girilirse bu durumda biz bu dosyaya yazma yaptığımızda aslında kabukta çalıştırdığımız 
    program bunu stdin dosyasından okuyacaktır. Fonksiyon başarısızlık durumunda NULL adrese geri dönmektedir. 

    popen ile yaratılmış olan boru ve dosya bilgi göstericisi pclose fonksiyonu ile yok edilmektedir. pclose fonksiyonunun prototipi de şöyledir:

    #include <stdio.h>

    int pclose(FILE *stream);

    Fonksiyon dosya bilgi göstericisini parametre olarak alır ve daha önce yapılan işlemleri sonlandırır. pclose fonksiyonu aynı zamanda wait 
    işlemini de uygulamaktadır. (Yani thread pclose çağrısında bloke olabilmektedir.) Fonksiyon başarı durumunda çalıştırdığı kabuk programının 
    wait fonksiyonu ile elde edilen durum bilgisine, başarısızlık durumunda -1 değerine geri dönmektedir. Kabuk programlarının interaktif 
    olmayan modda çalıştırıldıklarına çalıştırdıkları programın durum koduyla (yani wait fonksiyonlarından elde edilen değerleri kastediyoruz) sonlandığını 
    anımsayınız. pclose kontrolü şöyle yapılabilir:

    if ((status = pclose(f)) == -1)
        exit_sys("pclose");
    
    Ancak eğer programcı çalıştırmış olduğu programın da başarısını dikkate almak isterse kontrolü şöyle yapabilir:

    if ((status = pclose(f)) == -1)
        exit_sys("pclose");

    if (WIFEXITED(status))
        printf("Shell exit status: %d\n", WEXITSTATUS(status));
    else
        printf("shell abnormal terminated!..\n");

    Aşağıdaki programda "ls -l" komutu çalıştırılıp onun çıktısı elde edilmiştir. Programda pclose fonksiyonun geri dönüş değerinin 
    alınp kontrol edilmesine genellikle gerek yoktur. 
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>

void exit_sys(const char *msg);

int main(void)
{
    FILE *f;
    int ch;

    if ((f = popen("ls -l", "r")) == NULL)
        exit_sys("popen");

    while ((ch = fgetc(f)) != EOF)
        putchar(ch);

    if ((status = pclose(f)) == -1)
        exit_sys("pclose");

    pclose(f);

    return 0;    
}

void exit_sys(const char *msg)
{
	perror(msg);

	exit(EXIT_FAILURE);
}

/*--------------------------------------------------------------------------------------------------------------------------
    Aşağıdaki örnekte popen fonksiyonu "w" moduyla çağrılmıştır. Bu durumda bizim dosyaya yazdıklarımız aslında boruya yazılacak ve
    "wc" programı da stdin yerine borudan okuma yapacaktır.
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>

void exit_sys(const char *msg);

int main(void)
{
    FILE *f;
    int ch;

    if ((f = popen("wc", "w")) == NULL)
        exit_sys("popen");

    for (int i = 0; i < 100; ++i)
        fprintf(f, "%d\n", i);

    pclose(f);

    return 0;    
}

void exit_sys(const char *msg)
{
	perror(msg);

	exit(EXIT_FAILURE);
}

/*--------------------------------------------------------------------------------------------------------------------------
    popen fonksiyonu ile aldığımız dosya bilgi göstericisinin (stream) tamponlu çalıştığına dikkat ediniz. Dolayısıyla yazdığımız
    şeyler önce tampona aktarılıp oradan boruya aktarılacaktır. Uygulamaya göre gerekirse fflush ile tamponu tazeleyebilirsiniz.
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    İsimsiz borular yalnızca üst ve alt prosesler arasındaki haberleşmelerde kullanılmaktadır. Halbuki isimli borular herhangi 
    iki proses arasında haberleşmede kullanılabilmektedir. İsimli borularla çalışma tipik olarak şu aşamalardan geçilerek yapılır:

    1) Önce ismine "boru dosyası" ya da "fifo dosyası" denilen özel bir dosyanın yaratılması gerekir. Boru dosyaları "ls -l" komutunda
    "p" dosya türü ile gösterilmektedir. Boru dosyaları gerçek disk dosyaları değildir. Yalnızca bir dizin girişi içerirler. 
    Bunların diskte bir içerik olarak karşılıkları yoktur. Bu nedenle boru dosyaları hep 0 uzunlukta görüntülenmektedir. 
    Boru dosyaları open fonksiyonuyla yaratılmaz. Bunları dosyalarını yaratmak için mkfifo isimli POSIX fonksiyonu kullanılmaktadır. 
    mkfifo fonksiyonunun prototipi şöyledir:

    #include <sys/stat.h>

    int mkfifo(const char *path, mode_t mode);  

    Fonksiyonun birinci parametresi yaratılacak boru dosyasının yol ifadesini ikinci parametresi ise erişim haklarını almaktadır.
    Bu erişim hakları yine prosesin umask değeri ile maskelenmektedir. Fonksiyon başarı durumunda 0 başarısızlık durumunda -1 değerine 
    geri dönmektedir. Örneğin:

    if (mkfifo("testfifo", S_IRUSR|S_IWUSR|S_IRGRP|S_IROTH) == -1)
        exit_sys("mkfifo");

    Boru dosyaları manuel olarak da mkfifo isimli kabuk komutuyla yaratılabilmektedir. Örneğin:

    mkfifo myfifo

    Erişim hakları -m seçeneği ile verilebilir. Örneğin:

    mkfifo -m 666 myfifo

    Tabii komut uygulanırken kabuğun umask değeri etkili olmamaktadır. 

    2) İki proses de boru dosyasını open fonksiyonuyla açar. Açım sırasında tipik olarak O_RDONLY ve O_WRONLY modları kullanılmalıdır.
    Boru dosyaları O_RDWR modunda açılabilirse de bu durum genellikle uygun değildir. (Linux boru dosyalarının O_RDWR modunda açılmasına 
    izin vermektedir. Ancak POSIX standratları bu durumu "undefined" bırakmıştır.) Örneğin:

    if ((fd = open("myfifo", O_WRONLY)) == -1)
        exit_sys("open");
        
    Bir proses isimli boruyu O_WRONLY modunda açmışsa başka bir proses boruyu O_RDONLY (ya da O_RDWR modunda) açana kadar open blokede
    beklemektedir. Benzer biçimde bir proses boruyu O_RDONLY modunda açmışsa diğer bir proses boruyu O_WRONLY (ya da O_RDWR modunda) açana kadar 
    oepen fonksiyonu blokede bekler. Tabii boru O_RDWR modunda açılmışsa bloke oluşmaz. Ancak modda açım genel olarak uygun değildir ve POSIX
    standartları bunu "undefined" olarak ele almaktadır. open fonksiyonunun dosya betimleyici tablosundaki en düşük betimleyiciyi verdiğini 
    anımsayınız.

    3) Artık haberleşecek iki proses de boruyu açmıştır. Haberleşme write ve read fonksiyonlarıyla yukarıda belirtildiği gibi 
    yapılır. Yani buradaki haberleşmenin isimsiz boru haberleşmesinden bir farkı yoktur. write ve read fonksiyonları tamamen isimsiz boru
    haberleşmesinde olduğu gibi davranmaktadır.

    4) Haberleşmenin sonunda yine yazan taraf boruyu kapatır, okuyan tarafın read fonksiyonu 0 ile geri döner. Böylece okuyan taraf da
    boruyu kapatır. İsimli boruyu kullanan hiçbir betimleyici kalmadığında isimli borunun içi silinmektedir. Örneğin isimli boruyu iki proses
    de açmış olsun. Birinin yazdığını diğerinin okuduğunu varsayalım. Yazan taraf boruyu kapattıktan sonra okuyan taraf borudakilerin hepsini 
    okumadan boruyu kapatırsa boru içinde kalan bilgiler silinmektedir. 

    5) Eğer boru dosyası proseslerden biri tarafından mkfifo fonksiyonuyla yaratılmışsa unlink ya da remove fonksiyonuyla yine 
    ilgili proses tarafından silinebilir. Eğer boru komut satırından mkfifo komutuyla yaratılmışsa bu durumda yine komut satırından 
    rm komutu ile sisilme yapılabilir. Tabii boru dosyası başka bir haberleşme için de kullabılacaksa silinmeden bekletilebilir. Örneğin:

    if (unlink("mypipe") == -1)
        exit_sys("mypipe")

---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
                                                    38. Ders 18/03/2023 - Cumartesi
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Aşağıdaki örnekte "prog1" programı zaten komut satırında yaratılmış olan "mypipe" dosyasına yazma yapıp, "prog2" programı da 
    bu borudan okuma yapmaktadır. "prog1" programı klavyeden (stdin dosyasından) bir yazı alır. Bu yazıyı borudan "prog2" programına 
    borudan yollar. Ancak bu örnekte prog2 programı borudan ne kadar bilgi okuyacağını bilmemektedir. Dolayısıyla 4096 byte kadar 
    bilgiyi okumak ister. Tabii read fonksiyonu borudan okuma yaparken 4096 byte okunanan kadar blokeye yol açmaz. Okuyabildiği 
    kadar bilgiyi okur okuyabildiği byte sayısına geri döner. Yani böylede prog2 programındaki read fonksiyonu karşı tarafın atomik bir biçimde 
    boruya yazdığı kadar bilgiyi okumaktadır. Haberleşme "prog1" programının klavyeden (stdin dosyasından) "quit" okumasıyla sonlanmaktadır. 
    Bu durumda "prog1" döngüden çıkar boruyu kapatır."prog2"de ise read fonksiyonu 0 ile geri döner. Böylece "proc2" de döngüden 
    çıkar ve boruyu kapatır.
---------------------------------------------------------------------------------------------------------------------------*/

/* prog1.c */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <fcntl.h>
#include <unistd.h>

#define BUFFER_SIZE     4096

void exit_sys(const char *msg);

int main(void)
{
    int fdpipe;
    char buf[BUFFER_SIZE];
    char *str;
    
    if ((fdpipe = open("mypipe", O_WRONLY)) == -1)
        exit_sys("open");

    for (;;) {
        printf("Text:");
        fflush(stdout);
        if (fgets(buf, BUFFER_SIZE, stdin) != NULL)  
            if ((str = strchr(buf, '\n')) != NULL)
                *str = '\0';
        *str = '\0;
        if (*buf == '\0')
            continue;
        if (write(fdpipe, buf, strlen(buf)) == -1)
            exit_sys("write");
        if (!strcmp(buf, "quit"))
            break;
    }

    close(fdpipe);

    return 0;    
}

void exit_sys(const char *msg)
{
	perror(msg);

	exit(EXIT_FAILURE);
}

/* prog2.c */

#include <stdio.h>
#include <stdlib.h>
#include <fcntl.h>
#include <unistd.h>

#define BUFFER_SIZE     4096

void exit_sys(const char *msg);

int main(void)
{
    int fdpipe;
    ssize_t result;
    char buf[BUFFER_SIZE + 1];

    if ((fdpipe = open("mypipe", O_RDONLY)) == -1)
        exit_sys("open");

    while ((result = read(fdpipe, buf, BUFFER_SIZE)) > 0) {
        buf[result] = '\0';
        puts(buf);
    }
    if (result == -1)
        exit_sys("read");
    
    close(fdpipe);

    return 0;    
}

void exit_sys(const char *msg)
{
	perror(msg);

	exit(EXIT_FAILURE);
}

/*--------------------------------------------------------------------------------------------------------------------------
    Yukarıda da belirttiğimiz gibi boru dosyası haberleşecek proseslerden biri tarafından yaratılabilir. Bu durumda bu boru dosyasının 
    onu yaratan proses tarafından silinmesi uygun olur. Fakat boru dosyalarının dışarıdan yaratılması çoğu kez tercih edilmektedir. 
    Çünkü bu durumda iki programın çalıştıma sırasının bir önemi olmaktadır. Halbuki boru dosyası dışarıda yaratılırsa
    programların çalıştırma sıralarının bir önemi olmaz. Anımsanacağı gibi UNIX/Linux sistemlerinde bir dosya remove ya da unlink 
    fonksiyonu ile silindiğinde açık betimleyiciler normal olarak çalışmaya devam eder. Son betimleyiciyi kapatıldığında dosya 
    gerçek anlamda silinmektedir. Aynı durum boru dosyaları için de geçerlidir. 

    Aşağıdaki örnekte "prog1" programı isimli boruyu mkfifo fonksiyonuyla yaratmış ve sonlanmadan önce unlink fonksiyonu ile
    boruyu silmiştir.
---------------------------------------------------------------------------------------------------------------------------*/

/* prog1.c */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <fcntl.h>
#include <sys/stat.h>
#include <unistd.h>

#define BUFFER_SIZE     4096

void exit_sys(const char *msg);

int main(void)
{
    int fdpipe;
    char buf[BUFFER_SIZE];
    char *str;

    if (mkfifo("mypipe", S_IRUSR|S_IWUSR|S_IRGRP|S_IRGRP) == -1)
        exit_sys("mypipe");
    
    if ((fdpipe = open("mypipe", O_WRONLY)) == -1)
        exit_sys("open");

    for (;;) {
        printf("Text:");
        fflush(stdout);
        if (fgets(buf, BUFFER_SIZE, stdin) != NULL)  
            if ((str = strchr(buf, '\n')) != NULL)
                *str = '\0';
        *str = '\0';
        if (*buf == '\0')
            continue;
        if (write(fdpipe, buf, strlen(buf)) == -1)
            exit_sys("write");
        if (!strcmp(buf, "quit"))
            break;
    }

    close(fdpipe);

    if (unlink("mypipe") == -1)
        exit_sys("unlink");

    return 0;    
}

void exit_sys(const char *msg)
{
	perror(msg);

	exit(EXIT_FAILURE);
}

/* prog2.c */

#include <stdio.h>
#include <stdlib.h>
#include <fcntl.h>
#include <unistd.h>

#define BUFFER_SIZE     4096

void exit_sys(const char *msg);

int main(void)
{
    int fdpipe;
    ssize_t result;
    char buf[BUFFER_SIZE + 1];

    if ((fdpipe = open("mypipe", O_RDONLY)) == -1)
        exit_sys("open");

    while ((result = read(fdpipe, buf, BUFFER_SIZE)) > 0) {
        buf[result] = '\0';
        puts(buf);
    }
    if (result == -1)
        exit_sys("read");
    
    close(fdpipe);

    return 0;    
}

void exit_sys(const char *msg)
{
	perror(msg);

	exit(EXIT_FAILURE);
}

/*--------------------------------------------------------------------------------------------------------------------------
    Stream tabanlı haberleşmelerde önemli problemlerden biri de "değişken uzunlukta kayıtların" aktarımıdır. Yani örneğin boruya 
    yazan taraf sürekli farklı uzunluklarda kayıtları boruya yazsa okuyan taraf bu yazılanları nasıl biribirinden ayrıştıracaktır?
    İşte bu tür durumda iki yöntem akla gelmektedir:

    1) Yazan taraf önce değişken uunluktaki kaydın byte miktarını boruya yazar, sonra değişken uzunluktaki kaydı boruya yazar. 
    Okuyan taraf da önce uzunluğu okur sonra o uzunluk kadar yeniden okuma yapar. Bu yöntem etkin ve çoğu zaman tercih edilen yöntemdir. 

    2) Yazan taraf kayıtların sonuna özel bir byte yerleştirir. (Örneğin kayıtlar yazısalsa '\n' gibi bir karatker yerleştirilebilir.)
    Böylece okuyan taraf o özel byte'ı görene kadar okuma yapabilir. Buradaki problem bu özel byte'ın okuyan taraf tarafından nasıl 
    tespit edeileceğidir. read fonksiyonu ile sürekli 1 byte okumak etkin bir yöntem değildir. O zaman bir blok bilginin okunup bir tampona 
    yerleştirilmesi ve o tampondan akıllıca kontrol yapılması yoluna gidilir. Buna benzer yazısal aktarımlarda bazen programcılar 
    kaydın sonuna '\n' karakterini yerleştirip boru betimleyicisinden fdopen fonksiyonu ile dosya bilgi gösterici (stream) elde edip 
    fgets gibi bir fonksiyonla okuma yapma yoluna gidebilmektedir. Ne de olsa fgtes tamponlu biçimde çalıştığı için bizim yapmamız 
    gerekenleri kendisi yapmaktadır. Tabii aslında önce boruyu açıp sonra fdopen fonksiyonunu kullanmak yerine doğrudan fopen fonksiyonuyla
    da boru açılabilir. 

    Aşağıdaki örnekte "prog1" programı bir dizin'in yol ifadesini komut satırı argümanıyla almış o dizindeki dosyaları elde edip
    önce onların uzunluklarını sonra da isimlerini boruya yazmıştır. Okuyan taraf da (prog2 programı) önce uzunluğu sonra içeriği okuyup kayıtları 
    birbirinden ayırabilmiştir. 
---------------------------------------------------------------------------------------------------------------------------*/

/* prog1.c */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <errno.h>
#include <fcntl.h>
#include <dirent.h>
#include <unistd.h>

void exit_sys(const char *msg);

int main(int argc, char *argv[])
{
    int fdpipe;
    DIR *dir;
    struct dirent *de;
    size_t len;

    if (argc != 2) {
        fprintf(stderr, "wrong number of arguments!..\n");
        exit(EXIT_FAILURE);
    }

    if ((dir = opendir(argv[1])) == NULL)
        exit_sys("opendir");

    if ((fdpipe = open("mypipe", O_WRONLY)) == -1)
        exit_sys("open");

    while (errno = 0, (de = readdir(dir)) != NULL) {
        len = strlen(de->d_name);
        if (write(fdpipe, &len, sizeof(size_t)) == -1)
            exit_sys("write");
        if (write(fdpipe, de->d_name, len) == -1)
            exit_sys("write");
    }

    if (errno != 0)
        exit_sys("readdir");

    close(fdpipe);
    closedir(dir);

    return 0;    
}

void exit_sys(const char *msg)
{
	perror(msg);

	exit(EXIT_FAILURE);
}

/* prog2.c */

#include <stdio.h>
#include <stdlib.h>
#include <fcntl.h>
#include <unistd.h>

#define BUFFER_SIZE     4096

void exit_sys(const char *msg);

int main(void)
{
    int fdpipe;
    ssize_t result;
    char buf[BUFFER_SIZE + 1];
    size_t len;

    if ((fdpipe = open("mypipe", O_RDONLY)) == -1)
        exit_sys("open");

    for (;;) {
        if ((result = read(fdpipe, &len, sizeof(size_t))) == -1)
            exit_sys("read");
        if (result == 0)
            break;
        if (read(fdpipe, buf, len) == -1)
            exit_sys("read");
        buf[len] = '\0';
        puts(buf);
    }

    close(fdpipe);

    return 0;    
}

void exit_sys(const char *msg)
{
	perror(msg);

	exit(EXIT_FAILURE);
}

/*--------------------------------------------------------------------------------------------------------------------------
    Aşağıdaki örnekte yukarıda belirttiğimiz yöntemlerin ikincisi kullanılmıştır. Yani her kayıttan sonra özel bir sonlandırıcı 
    karakter boruya eklenmiştir. Biz burada sonlandırıcı karakter için '\0' değil '\n' karakterini tercih ettik. Çünkü 
    C'de '\0' görene kadar okuma yapan standart bir fonksiyon yoktur. Halbuki '\n' görene kadar okuma yapan bir fgets gibi bir standart
    fonksiyon vardır. Aşağıdaki program hakkında şu özet açıklamaları yapmak istiyoruz:

    - Boruya yazan taraf dosya ismini boruya yazdıktan sonra '\n' karakterini de sonlandırıcı oluşturmak amacıyla boruya yazmıştır.
    
    - Okuyan taraf tek tek karakterleri read fonksiyonuyla borudan okumak yerine standart fgets fonksiyonundan faydalanmıştır. 
    Tabii bunun için boruyu açtıktan sonra fdopen fonksiyonuyla ondan bir stream elde etmiştir. Şüphsesiz bu tür durumlarda boru doğrudan 
    fopen fonksiyonuyla da açılabilir. fopen fonksiyonuyla açım alternatifiti "prog3.c" dosyasında verilmiştir. 
    
    - Yazan taraf boruyu kapattığnda fgets fonksiyonu NULL adresle geri dönecektir. Anımsanacağı gibi fgets en az bir byte okursa 
    ikinci parametresi ile bekirtilen adrese, hiç byte okuyamadan EOF ile karşılaşırsa NULL adrese geri dönmektedir.  
---------------------------------------------------------------------------------------------------------------------------*/

/* prog1.c */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <errno.h>
#include <fcntl.h>
#include <dirent.h>
#include <unistd.h>

void exit_sys(const char *msg);

int main(int argc, char *argv[])
{
    int fdpipe;
    DIR *dir;
    struct dirent *de;
    char delim = '\n';
    
    if (argc != 2) {
        fprintf(stderr, "wrong number of arguments!..\n");
        exit(EXIT_FAILURE);
    }

    if ((dir = opendir(argv[1])) == NULL)
        exit_sys("opendir");

    if ((fdpipe = open("mypipe", O_WRONLY)) == -1)
        exit_sys("open");

    while (errno = 0, (de = readdir(dir)) != NULL) { 
        if (write(fdpipe, de->d_name, strlen(de->d_name)) == -1)
            exit_sys("write");
        if (write(fdpipe, &delim, 1) == -1)
            exit_sys("write");
    }

    if (errno != 0)
        exit_sys("readdir");

    close(fdpipe);
    closedir(dir);

    return 0;    
}

void exit_sys(const char *msg)
{
	perror(msg);

	exit(EXIT_FAILURE);
}

/* prog2.c */

#include <stdio.h>
#include <stdlib.h>
#include <fcntl.h>
#include <unistd.h>

#define BUFFER_SIZE     4096

void exit_sys(const char *msg);

int main(void)
{
    int fdpipe;
    char buf[BUFFER_SIZE];
    FILE *fpipe;

    if ((fdpipe = open("mypipe", O_RDONLY)) == -1)
        exit_sys("open");

    if ((fpipe = fdopen(fdpipe, "r")) == NULL)
        exit_sys("fdopen");

    for (;;) {
        if (fgets(buf, BUFFER_SIZE, fpipe) == NULL)
            break;
        printf("%s", buf);
    }

    fclose(fpipe);
    
    return 0;    
}

void exit_sys(const char *msg)
{
	perror(msg);

	exit(EXIT_FAILURE);
}

/* prog3.c */

#include <stdio.h>
#include <stdlib.h>

#define BUFFER_SIZE     4096

void exit_sys(const char *msg);

int main(void)
{
    char buf[BUFFER_SIZE];
    FILE *fpipe;
    
    if ((fpipe = fopen("mypipe", "r")) == NULL)
        exit_sys("fdopen");

    for (;;) {
        if (fgets(buf, BUFFER_SIZE, fpipe) == NULL)
            break;
        printf("%s", buf);
    }

    fclose(fpipe);
    
    return 0;    
}

void exit_sys(const char *msg)
{
	perror(msg);

	exit(EXIT_FAILURE);
}

/*--------------------------------------------------------------------------------------------------------------------------
    Client-Server haberleşme haberleşme konusunda bir tasarım mimarisidir. Genellikle "client-server" denildiğinde konu TCP/IP
    soket haberleşmesi ile ilişkilendirilmektedir. Ancak client-server haberleşme aslında genel bir konudur. Haberleşmedeki ortam 
    değişebilir. Haberleşecek birimler   aynı makinenin prosesleri olabildiği gibi farklı makinelerin prosesleri de olabilmektedir. 
    İşte clinet-server haberleşme aynı makinenin prosesleri arasında borular kullanılarak da yapılabilmektedir. Client-Server 
    haberleşmede iki program söz konusudur: Client program ve server program. Burada asıl işi yapan program server programdır. 
    Client program bir istekte bulunur. Server program da bu isteği karşılar. Client program istekte bulunurken server programa
    "mesaj" adı altında bir bilgi gönderir. Server da client için bir isteği gerçekleştirdikten sonra yine mesaj adı altında 
    client'a bir bilgi göndermektedir. 
    
    Client-Server tarzı haberleşme en çok TCP/IP protokolü ile yapılıyor olsa da borular yoluyla da yapılabilmektedir. 
    Pekiyi borular yoluyla çok client'lı (multiclient) bir client-server uygulama yapmak için kaç boruya ihtiyaç vardır?
    Client programların isteklerini farklı borularla server programa iletmesine gerek yoktur. Client ptogramlar ortak tek bir 
    boru kullanarak isteklerini server programa iletebilirler. Bu durumda server program da belli uzunluktaki kayıtları okuyarak istekleri elde 
    eder. O isteklerin hangi client'tan geldiğini mesajın içerisinden öğrenebilir. Ancak server programın isteğin yanıtını tek bir 
    boruyla client programlara iletmesi mümkün değildir. Mecburen her client için farklı borunun kullanılması gerekir. 
    O halde şunlar söylenebilir:

    - Client programlar tek ve ortak bir boru ile server programa istekte bulunurlar. Bu borunun işin başında yaratılmış olması uygundur.

    - Server program da her client için farklı bir boru ile client'a istek sonucunu gönderir. Server'ın client'a mesaj gönderdiği 
    o client'a özgü boruların client tarafından yaratılması ancak "CONNECT" mesajında serve programa iletilmesi daha uygun bir çözümdür. 
    BU boru yine "DISCONNECT" mesajı sonrasında client program tarafından yok edilir. 

    - Server programın kendisine bağlanmış olan tüm client'ların bilgilerini tutması gerekir. Client'ları birbirinden ayıran "sistem genelinde 
    tek olan (unique)" bir değerin id olarak belirlenmesi uygundur. Bunun için akla ilk gelen proses id'lerin client'ları biribirinden 
    ayırmak için kullanılmasıdır. Bu durumda server program bir id'ye göre client bilgilerine hızlı erişim sağlamalıdır. Bunun için 
    en uygun veri yapısı şüphesiz "dengelenmiş ikili ağaçlar (balanced binary trees)" ya da "hash tabloları (hash tables)". Ancak bilindiği 
    gibi C'de bu veri yapıları C'nin standart kütüphanesinde bulunmamaktadır. Halbuki nesne yönelimli dillerin neredeyse hemen hepsinde 
    "sizlük (dictionary)" veri yapısı denilen bu veri yapıları o dillerin standart kütüphanelerinde hazır biçimde bulunmaktadır. Örneğin 
    C++'taki "map" ya da "unordered_map" isimli sınıflar bu iş için idealdir. 
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
                                                39. Ders 19/03/2023 - Pazar
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Aşağıdaki isimli borular kullanılarak bri client-server haberleşme örneği verilmiştir. Programla ilgili bazı açıklamaları
    veriyoruz:

    - Programda client'ların server'a mesaj göndermesi için kullandıkları borunun işin başında "serverpipe" ismiyle yaratılmış 
    olması gerekmektedir. 

    - Client ile server arasındaki haberleşmeler yazısal biçimde şöyle yapılmaktadır:

    "KOMUT <parametrik bilgiler>"

    Client ve server bu yazıyı parse edip komut ve parametrelerini birbirinden ayırmaktadır. 

    - Server'ın client'a göndereceği mesajlar için kullaılacak borular server tarafından yaratılmaktadır. Bu sırada client 
    "boru yaratılmış mı" diye beklemektedir. 

    - Server her client'a bir id numarası vermektdir. Id numarası olarak proses id'ler değil client borulara ilişkin betimleyici 
    numaraları kullanılmıştır. Server bağlantıyı sağladığında client borusunu yaratır, onun betimleyici numarasını boruya gönderir. 
    Ancak client borusunun ismini client program belirlemektedir. Yani borunun ismi client program tarafından belirlenmekte ancak yaratımı
    server program tarafından yapılmaktadır. 

    - Client'tan server'a gönderilen mesajlar şunlardır:

    CONNECT <boru ismi>
    DISCONNECT_REQUEST
    DISCONNECT
    CMD <kabuk komutu>

    Burada CMD client'ın server'a işlettireceği komutu komutunu belirtmektedir. Yani server client'ın gönderdiği kabuk komutunu işletir. 
    Onun sonucunu client'a yollar. 

    - Server programın client programa gönderdiği mesajlar da şunlardır:

    CMD_RESPONSE <komutun çıktı yazısı>
    DISCONNECT_ACCEPTED
    INVALID_COMMAND <hata yazısı>

    - Client'ın bağlantıyı sonlandırması şöyle bir el sıkışmayla sağlanmıştır:

    1) Önce client server'a DISCONNECT_REQUESTES mesajını gönderir. 
    2) Sonra serve bu mesajı alınca eğer disconnect'i kabul ederse DISCONNECT_ACCEPTED mesajını gönderir
    3) Client son olarak server'a DISCONNECT mesajını göndererek el sıkışmayı sonlandırır. 

    - Client program bir kout satırı oluşturup komutların kullanıcı tarafından uygulanmasını sağlamaktadır. Ancak bağlantının sonlandırılması
    bir dizi el sıkışma gerektirdiği için "quit" komutu sırasında yaptırılmıştır.

    - Server programda client'ların bilgileri için bir veri yapısı oluşturulmamıştır. Zaten client id server'daki dosya betimleyicisi 
    olduğu için böyle bir sözlük veri yapısına ihtiyaç duyulmamıştır. Tabii aslında client'ın pek çok bilgisini server saklamak isteyebilir. 
    Genel olarak böyle bir veri yapısının oluşturulması uygundur.

---------------------------------------------------------------------------------------------------------------------------*/

/* server.c */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>
#include <fcntl.h>
#include <unistd.h>
#include <signal.h>

/* Symbolic Constants */

#define SERVER_PIPE      "serverpipe"
#define MAX_CMD_LEN     1024
#define MAX_MSG_LEN     32768       
#define MAX_PIPE_PATH   1024

/* Type Declaration */

typedef struct tagCLIENT_MSG {
    int msglen;
    int client_id;
    char msg[MAX_MSG_LEN];
} CLIENT_MSG;

typedef struct tagSERVER_MSG {
    int msglen;
    char msg[MAX_MSG_LEN];
} SERVER_MSG;

typedef struct tagMSG_CONTENTS {
    char *msg_cmd;
    char *msg_param;
} MSG_CONTENTS;

typedef struct tagMSG_PROC {
    const char *msg_cmd;
    int (*proc)(const char *msg_param);
} MSG_PROC;

/* Function Prototypes */

void sigpipe_handler(int sno);
int putmsg(const char *cmd);
int get_server_msg(int fdp, SERVER_MSG *smsg);
void parse_msg(char *msg, MSG_CONTENTS *msgc);
void check_quit(char *cmd);
int connect_to_server(void);
int cmd_response_proc(const char *msg_param);
int disconnect_accepted_proc(const char *msg_param);
int invalid_command_proc(const char *msg_param);
void clear_stdin(void);
void exit_sys(const char *msg);

/* Global Data Definitions */

MSG_PROC g_msg_proc[] =  {
    {"CMD_RESPONSE", cmd_response_proc},
    {"DISCONNECT_ACCEPTED", disconnect_accepted_proc},
    {"INVALID_COMMAND", invalid_command_proc},
    {NULL, NULL}
};

int g_client_id;
int g_fdps, g_fdpc;

/* Function Definitions */

int main(void)
{
    char cmd[MAX_CMD_LEN];
    char *str;
    SERVER_MSG smsg;
    MSG_CONTENTS msgc;
    int i;

    if (signal(SIGPIPE, sigpipe_handler) == SIG_ERR)
        exit_sys("signal");

    if ((g_fdps = open(SERVER_PIPE, O_WRONLY)) == -1)
        exit_sys("open");

    if (connect_to_server() == -1)  {
        fprintf(stderr, "cannot connect to server! Try again...\n");
        exit(EXIT_FAILURE);
    }   

    for (;;) {
        printf("Client>");
        fflush(stdout);
        fgets(cmd, MAX_CMD_LEN, stdin);
        if ((str = strchr(cmd, '\n')) != NULL)
            *str = '\0';

        check_quit(cmd);

        if (putmsg(cmd) == -1) 
            exit_sys("putmsg");

        if (get_server_msg(g_fdpc, &smsg) == -1)
            exit_sys("get_client_msg");

        parse_msg(smsg.msg, &msgc);
  
        for (i = 0; g_msg_proc[i].msg_cmd != NULL; ++i)
            if (!strcmp(msgc.msg_cmd, g_msg_proc[i].msg_cmd)) {
                if (g_msg_proc[i].proc(msgc.msg_param) == -1) {
                    fprintf(stderr, "command failed!\n");
                    exit(EXIT_FAILURE);
                }
                break;
            }
        if (g_msg_proc[i].msg_cmd == NULL) {        /* command not found */
            fprintf(stderr, "Fatal Error: Unknown server message!\n");
            exit(EXIT_FAILURE);
        }
    }

    return 0;
}

void sigpipe_handler(int sno)
{
    printf("server down, exiting...\n");

    exit(EXIT_FAILURE);
}

int putmsg(const char *cmd)
{
    CLIENT_MSG cmsg;
    int i, k;

    for (i = 0; isspace(cmd[i]); ++i)
        ;
    for (k = 0; !isspace(cmd[i]); ++i)
        cmsg.msg[k++] = cmd[i];
    cmsg.msg[k++] = ' ';
    for (; isspace(cmd[i]); ++i)
        ;
    for (; (cmsg.msg[k++] = cmd[i]) != '\0'; ++i)
        ;
    cmsg.msglen = (int)strlen(cmsg.msg);
    cmsg.client_id = g_client_id;

    if (write(g_fdps, &cmsg, 2 * sizeof(int) + cmsg.msglen) == -1)
        return -1;

    return 0;
}

int get_server_msg(int fdp, SERVER_MSG *smsg)
{
    if (read(fdp, &smsg->msglen, sizeof(int)) == -1)
        return -1;

    if (read(fdp, smsg->msg, smsg->msglen) == -1)
        return -1;

    smsg->msg[smsg->msglen] = '\0';

    return 0;
}

void parse_msg(char *msg, MSG_CONTENTS *msgc)
{
    int i;

    msgc->msg_cmd = msg;
    
    for (i = 0; msg[i] != ' ' && msg[i] != '\0'; ++i)
        ;
    msg[i++] = '\0';
    msgc->msg_param = &msg[i];
}

void check_quit(char *cmd)
{
    int i, pos;

    for (i = 0; isspace(cmd[i]); ++i)
        ;
    pos = i;
    for (; !isspace(cmd[i]) && cmd[i] != '\0'; ++i)
        ;
    if (!strncmp(&cmd[pos], "quit", pos - i))
        strcpy(cmd, "DISCONNECT_REQUEST");
}

int connect_to_server(void)
{
    char name[MAX_PIPE_PATH];
    char cmd[MAX_CMD_LEN];
    char *str;
    SERVER_MSG smsg;
    MSG_CONTENTS msgc;
    int response;

    printf("Pipe name:");
    fgets(name, MAX_PIPE_PATH, stdin);
    if ((str = strchr(name, '\n')) != NULL)
        *str = '\0';

    if (access(name, F_OK) == 0) {
        do {
            printf("Pipe already exists! Overwrite? (Y/N)");
            fflush(stdout);
            response = tolower(getchar());
            clear_stdin();
            if (response == 'y' && remove(name) == -1)
                return -1;
        } while (response != 'y' && response != 'n');
        if (response == 'n')
            return -1;
    }

    sprintf(cmd, "CONNECT %s", name);

    if (putmsg(cmd) == -1)
        return -1;

    while (access(name, F_OK) != 0)
        usleep(300);

    if ((g_fdpc = open(name, O_RDONLY)) == -1)
        return -1;

    if (get_server_msg(g_fdpc, &smsg) == -1)
        exit_sys("get_client_msg");
    
    parse_msg(smsg.msg, &msgc);

    if (strcmp(msgc.msg_cmd, "CONNECTED"))
        return -1;

    g_client_id = (int)strtol(msgc.msg_param, NULL, 10);

    printf("Connected server with '%d' id...\n", g_client_id);

    return 0;
}

int cmd_response_proc(const char *msg_param)
{
    printf("%s\n", msg_param);

    return 0;
}

int disconnect_accepted_proc(const char *msg_param)
{
    if (putmsg("DISCONNECT") == -1) 
            exit_sys("putmsg");

    exit(EXIT_SUCCESS);

    return 0;
}

int invalid_command_proc(const char *msg_param)
{
    printf("invalid command: %s\n", msg_param);

    return 0;
}

void clear_stdin(void)
{
    int ch;

    while ((ch = getchar()) != '\n' && ch != EOF)
        ;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/* client.c */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <fcntl.h>
#include <unistd.h>
#include <errno.h>
#include <sys/stat.h>

/* Symbolic Constants */

#define SERVER_PIPE         "serverpipe"
#define MAX_MSG_LEN         32768
#define MAX_PIPE_PATH       1024
#define MAX_CLIENT          1024

/* Type Declaration */

typedef struct tagCLIENT_MSG {
    int msglen;
    int client_id;
    char msg[MAX_MSG_LEN];
} CLIENT_MSG;

typedef struct tagSERVER_MSG {
    int msglen;
    char msg[MAX_MSG_LEN];
} SERVER_MSG;

typedef struct tagMSG_CONTENTS {
    char *msg_cmd;
    char *msg_param;
} MSG_CONTENTS;

typedef struct tagMSG_PROC {
    const char *msg_cmd;
    int (*proc)(int, const char *msg_param);
} MSG_PROC;

typedef struct tagCLIENT_INFO {
    int fdp;
    char path[MAX_PIPE_PATH];
} CLIENT_INFO;

/* Function Prototypes */

int get_client_msg(int fdp, CLIENT_MSG *cmsg);
int putmsg(int client_id, const char *cmd);
void parse_msg(char *msg, MSG_CONTENTS *msgc);
void print_msg(const CLIENT_MSG *cmsg);
int invalid_command(int client_id, const char *cmd);
int connect_proc(int client_id, const char *msg_param);
int disconnect_request_proc(int client_id, const char *msg_param);
int disconnect_proc(int client_id, const char *msg_param);
int cmd_proc(int client_id, const char *msg_param);
void exit_sys(const char *msg);

/* Global Data Definitions */

MSG_PROC g_msg_proc[] =  {
    {"CONNECT", connect_proc},
    {"DISCONNECT_REQUEST", disconnect_request_proc},
    {"DISCONNECT", disconnect_proc},
    {"CMD", cmd_proc},
    {NULL, NULL}
};

CLIENT_INFO g_clients[MAX_CLIENT];

/* Function Definitions */

int main(void)
{
    int fdp;
    CLIENT_MSG cmsg;
    MSG_CONTENTS msgc;
    int i;

    printf("Server running...\n");

    if ((fdp = open(SERVER_PIPE, O_RDWR)) == -1)
        exit_sys("open");

    for (;;) {
        if (get_client_msg(fdp, &cmsg) == -1)
            exit_sys("get_client_msg");
        print_msg(&cmsg);
        parse_msg(cmsg.msg, &msgc);
        for (i = 0; g_msg_proc[i].msg_cmd != NULL; ++i)
            if (!strcmp(msgc.msg_cmd, g_msg_proc[i].msg_cmd)) {
                if (g_msg_proc[i].proc(cmsg.client_id, msgc.msg_param)) {
                    
                }
                break;
            }
        if (g_msg_proc[i].msg_cmd == NULL)         
            if (invalid_command(cmsg.client_id, msgc.msg_cmd) == -1)
                continue;
    }
    
    close(fdp);

    return 0;
}

int get_client_msg(int fdp, CLIENT_MSG *cmsg)
{
    if (read(fdp, &cmsg->msglen, sizeof(int)) == -1)
        return -1;

    if (read(fdp, &cmsg->client_id, sizeof(int)) == -1)
        return -1;

    if (read(fdp, cmsg->msg, cmsg->msglen) == -1)
        return -1;
    
    cmsg->msg[cmsg->msglen] = '\0';

    return 0;
}

int putmsg(int client_id, const char *cmd)
{
    SERVER_MSG smsg;
    int fdp;

    strcpy(smsg.msg, cmd);
    smsg.msglen = strlen(smsg.msg);

    fdp = g_clients[client_id].fdp;

    return write(fdp, &smsg, sizeof(int) + smsg.msglen) == -1 ? -1 : 0; 
}

void parse_msg(char *msg, MSG_CONTENTS *msgc)
{
    int i;

    msgc->msg_cmd = msg;
    
    for (i = 0; msg[i] != ' ' && msg[i] != '\0'; ++i)
        ;
    msg[i++] = '\0';
    msgc->msg_param = &msg[i];
}

void print_msg(const CLIENT_MSG *cmsg)
{
    printf("Message from \"%s\": %s\n", cmsg->client_id ? g_clients[cmsg->client_id].path : "", cmsg->msg);
}

int invalid_command(int client_id, const char *cmd)
{
    char buf[MAX_MSG_LEN];

    sprintf(buf, "INVALID_COMMAND %s", cmd);
    if (putmsg(client_id, buf) == -1)
        return -1;

    return 0;
}

int connect_proc(int client_id, const char *msg_param)
{
    int fdp;
    char buf[MAX_MSG_LEN];

    if (mkfifo(msg_param, S_IRUSR|S_IWUSR|S_IRGRP|S_IROTH) == -1) {
        printf("CONNECT message failed! Params = \"%s\"\n", msg_param);
        return -1;
    }

    if ((fdp = open(msg_param, O_WRONLY)) == -1)
        exit_sys("open");

    g_clients[fdp].fdp = fdp;
    strcpy(g_clients[fdp].path, msg_param);

    sprintf(buf, "CONNECTED %d", fdp);
    if (putmsg(fdp, buf) == -1)
        exit_sys("putmsg");

    return 0;
}

int disconnect_request_proc(int client_id, const char *msg_param)
{
    if (putmsg(client_id, "DISCONNECT_ACCEPTED") == -1)
        return -1;

    return 0;
}

int disconnect_proc(int client_id, const char *msg_param)
{
    close(g_clients[client_id].fdp);

    if (remove(g_clients[client_id].path) == -1)
        return -1;

    return 0;
}

int cmd_proc(int client_id, const char *msg_param)
{
    FILE *f;
    char cmd[MAX_MSG_LEN] = "CMD_RESPONSE ";
    int i;
    int ch;

    if ((f = popen(msg_param, "r")) == NULL) {
        printf("cannot execute shell command!..\n");
        return -1;
    }

    for (i = 13; (ch = fgetc(f)) != EOF; ++i)
        cmd[i] = ch;
    cmd[i] = '\0';

    if (putmsg(client_id, cmd) == -1)
        return -1;

    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/*--------------------------------------------------------------------------------------------------------------------------
    Blokesiz boru işlemlerini ele almadan önce fcntl isimli POSIX fonksiyonunu (aynı zamanda bir sistem fonksiyonu olarak bulundurulmaktadır)
    ele almak istiyoruz. fcntl zaten açılmış olan bir dosyanın çeşitli açım özelliklerini değiştirmek için kullanılmaktadır.
    fcntl fonksiyonu sayesinde biz open fonksiyonu ile açım sırasında belirlediğimiz bazı açış bayraklarını daha sonra değiştirebilmekteyiz. 
    fcntl fonksiyonu aynı zamanda open fonksiyonu kullanılmadan yaratılmış olan betimleyicilerin özelliklerini değiştirmekte de kullanılabilmektedir. 
    Örneğin pipe fonksiyonu boruyu yarattıktan sonra bize iki betimleyici vermektedir. Bu iki betimleyiciyi open fonksiyonuyla biz açmadığımız
    için onun bazı özelliklerini ancak fcntl fonksiyonu ile set edebiliriz. fcntl fonksiyonu yalnızca betimleyici bayraklarının set edilmesi için 
    değil onların elde edilmesi için (get edilmesi için) de kullanılmaktadır. Biz daha önce close on exec bayrağını set etmek için fcntl fonksiyonunu 
    zaten kullanmıştık. Ancak orada fonksiyonun genel tanıtımını yapmamıştık. 

    fcntl fonksiyonun prototipi şöyledir:

    #include <fcntl.h>

    int fcntl(int fd, int cmd, ...);

    Fonksyonun birinci parametresi bayrakları set ya da get edilecek betimleyicinin numarasını almaktadır. İkinci parametre ne yapılacağını
    belirtir. Bu parametreye önceden belirlenmiş sembolik sabitlerle define edilmiş bazı değerler girilmektedir. Fonksiyon get etme
    amacıyla kullanılıyorsa iki argümanla çağrılmaktadır. Ancak set etme amacıyla kullnılıyorsa üç argümanla çağrılmaktadır. 
    Fonksiyon başarı durumunda get amaçlı kullanıldıysa ilgili get edilen değere, set amaçlı kullanıldıysa -1 dışındaki herhangi bir değere
    ve başarısızlık durumunda -1 değerine geri dönmektedir. Tabii eğer fonksiyon get amaçlı kullanılıyorsa ve betimleyici ile komut paraetresi 
    doğru bir biçimde verilmişse fonksiyonun başarısız olma olasılığı yoktur. 

    Fonksiyonun ikinci parametresi F_GETFL ve F_SETFL biçiminde girilirse bu durumda fonksiyon "dosya durum bayraklarını (file status flags)"
    ve "erişim modunu (access modes)" get ve set etmektedir. Dosya durum bayrakları (file status flags) şunlardır:

    O_APPEND
    O_DSYNC
    O_NONBLOCK
    O_RSYNC
    O_SYNC

    Biz bu bayraklardan yalnızca O_APPEND bayrağını open fonksiyonunu anlatırken açıklamıştık. Dosya erişim modları da şunlardan oluşmaktadır:

    O_EXEC
    O_RDONLY
    O_RDWR
    O_SEARCH
    O_WRONLY

    Eğer programcı dosya durum bayraklarını F_GETFL ile elde etmek istemişse fonksiyonun geri dönüş değerini dosya durum bayraklarıyla 
    bit AND işlemine sokarak ilgili bayrağın set edilip edilmediğini anlayabilir. Örneğin:

    result = fcntl(fd, F_GETFL);
    if (result & O_APPEND) {
        /* O_APPEND bayrağı set edilmiş */
    }

    Eğer programcı dosya erişim modlarını elde etmek istiyorsa erişim modları ile bit AND işlemini kullanmamlıdır. Bunun için önce
    fonksiyonun geri dönüş değeri O_ACCMODE değeri ile bit AND işlemine sokulup erişim modlarıyla == karşılaştıması yapılmalıdır. 
    Örneğin biz dosyanın O_RDWR modunda açılıp açılmadığını anlam isteyelim. Bu işlemi şöyle yapmamlıyız:

    result = fcntl(fd, F_GETFL);
    if (result & O_RDWR) {          /* dikkat! hatalı kullanım */
        ...
    }

    Bu işlemin şöyle yapılması gerekir:

    result = fcntl(fd, F_GETFL);
    if ((result & O_ACCMODE) == O_RDWR) {          /* doğru kullanım */
        /* O_RDWR bayrağı set edilmiş */
    }

    Şimdi F_SETFL komutuyla O_NONBLOCK bayrağını set etmek isteyelim. İşlemi şöyel yapabiliriz:

    result = fcntl(fd, F_GETFL);
    if (fcntl(fd, F_SETFL, result|O_NONBLOCK) == -1)
        exit_sys("fcntl");

    F_SETFL işleminde hem dosya durum bayraklarının hem de erişim modunun set edilmeye çalışıldığına dikkat ediniz. Diğer 
    bayraklara dokunmadan yalnızca O_NONBLOCK bayrağının set edilmesi için önce get işleminin yapılması gerekir. Şimdi de O_NONBLOCK
    bayrağını clear edelim:

    result = fcntl(fd, F_GETFL);
    if (fcntl(fd, F_SETFL, result & ~O_NONBLOCK) == -1)
        exit_sys("fcntl");

    fcntl fonksiyonunda F_GETFD ve F_SETFD komut kodları "dosya betimleyici bayraklarını" get ve set etmekte kullanılmaktadır. 
    POSIX standartları dosya betimleyici bayrağı olarak yalnızca tek bir bayrak tanımlamıştır. Bu bayrak FD_CLOEXEC bayrağıdır. 
    Dolayısıyla biz bu komut kodu ile yalnızca dosyanın "close on exec" bayrağını get ve set edebiliriz. Biz de zaten daha önce 
    dosyanın close on exec bayrağını alıp set etmiştik. Dosyanın close on exec bayrağı şöyle alınabilir:

    result = fcntl(fd, F_GETFD);
    if (result & FD_CLOEXEC) {
        /* close on exec bayrağı set edilmiş durumda */
    }

    Dosyanın close on exec bayrağını şöyle set edebiliriz:

    result = fcntl(fd, F_GETFD);
    if (fcntl(fd, F_SETFD, result | FD_CLOEXEC) == -1)
        exit_sys("fcntl");

    Dosyanın close on exec bayrağını şöyle clear edebiliriz:

    result = fcntl(fd, F_GETFD);
    if (fcntl(fd, F_SETFD, result & ~FD_CLOEXEC) == -1)
        exit_sys("fcntl");

    Biz dosya betimleyicisini çiftlemek için daha önce dup ve dup2 fonksiyonlarını kullanmıştık. Aslında dosya betimleyicilerinin çiftlenmesi 
    fcntl fonksiyonuyla da yapılabilmektedir. Bunun fcntl fonksiyonunda komut kodu olarak F_DUPFD kullanılır. Bu komut kodunda
    üçüncü parametre de girilmelidir. Fonksiyon üçüncü parametrede belirtilen betimleyici değerine eşit ya da ondan büyük olan düşük 
    boş betimleyiciyi bize verir. Bu bakımdan fcntl ile dosya betimleyicisinin çiftlenmesi dup ve dup2 fonksiyonlarından farklıdır. 
    Anımsanacağı gibi dup fonksiyonu bize ilk boş betimeyiciyi, dup2 fonksiyonu ise ikinci parametresiyle belirttiğimz betimleyiciyi 
    vermektedir. Oysa fcntl fonksiyonu F_DUPFD komut koduyla bize belli bir değerden büyük en düşük betimleyici verir. Örneğin:

    if ((fd2 = fcntl(fd, F_DUPFD, 50)) == -1) 
        exit_sys("fcntl");

    Burada fd'nin çiftlenmiş betimleyicisi 50 ya da ilk büyük betimleyicidir. O halde fcntl ile dup fonksiyonun eşdeğeri şöyledir:

    if ((fd2 = fcntl(fd, F_DUPFD, 0)) == -1)    /* dup ile eşdeğer */
        exit_sys("fcntl");

    Ayrıca fcntl fonksiyonunun F_DUPFD_CLOEXEC biçiminde bir komut daha vardır. Bu komut kodu hep F_DUPFD hem de close on exec 
    bayrağıın set edilmesini birlikye yapmaktadır. Yani özetle bu komut kodu heö dosya betimleyicisini çiftler hem de çiftlenmiş olan 
    yeni betimleyicinin close on exec bayrağını set ederi Örneğin:

    if ((fd2 = fcntl(fd, F_DUPFD_CLOEXEC, 0)) == -1)
        exit_sys("fcntl");

    fd2 betimleyicisinin aynı zamanda close on exec bayrağı set edilmiştir. 

    fcntl fonksiyonunun diğer komut kodları dosya kilitleme gibi özel bazı konulara ilişkindir. Bu bayraklar o konuların anlatıldığı bölümde 
    ele alınmaktadır. 
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    mypipe bir isimli boru dosyası olsun. Aşağıdaki gibi bir işlem yapsak ne olur?

    ls > mypipe

    Bu durumda kabuk programı IO yönlendirmesi yapmak için "mypipe" dosyasını "write" modda open fonksiyonu ile açmak isteyecektir. 
    Ancak "mypipe" isimli boru dosyası olduğu için açım sırasında bloke oluşacaktır. Pekiyi bu blokeden nasıl kurtulunabilir? 
    Tabii başka bir terminalden biz boruyu bu  kez "read" modda açarak. Örneğin:

    cat < mypipe

    Burada yine kabuk programı "mypipe" dosyasını yönlendirme için "read" modda açacaktır. Bu durumda diğer kabuk prosesi 
    blokeden kurtulacaktır. 
---------------------------------------------------------------------------------------------------------------------------*/


/*--------------------------------------------------------------------------------------------------------------------------
    Bir dosyayı (boru dosyaları da diğer aygıt sürücü dosyaları da dahil olmak üzere) açarken kullanılan bayraklardan biri de 
    O_NONBLOCK bayrağıdır. Bu bayrağın normal dosyalarda (regular file) bir etkisi yoktur. Ancak borularda, soketlerde ve özel 
    bazı aygıt sürücülerde bu bayrak önemli bir işlevselliğe sahiptir. Bu işlevselliğe "blokesiz IO işlemleri (Nonblocking IO)" 
    denilmektedir. 

    Blokesiz IO işlemlerinin temel fikri şudur: Bazı aygıtlardan (boru ve soketlerde dahil olmak üzere) okuma yazma yapılırken 
    uzun süre beklemeye yol açabilecek bir bloke durumu oluşabilmektedir. Örneğin biz bir borudan okuma yapmak isteyelim. Ancak boruda 
    hiç byte olmasın. Bu durumda read fonksiyonu blokeye yol açacak ve boruya bilgi gelene kadar program akışı kesilecektir. 
    İşte blokesiz işlemlerde eğer ilgili işlem blokeye yol açabilecekse bloke oluşturulmamakta read ve write fonksiyonları başarısızlıkla
    geri dönmekte ve errno değeri EAGAIN denilen özel bir değerle set edilmektedir. Örneğin biz içerisinde hiç byte olmayan bir borudan 
    read fonksiyonu ile 10 byte okumak isteyelim. Eğer boru default durumda olduğu gibi "blokeli modda" ise read fonksiyonu en az 1 byte 
    boruya yazılana kadar blokede kalır. Ancak eğer blokesiz modda isek bu durumda read bloke olmaz -1 değeriyle geri döner ve errno 
    değeri EAGAIN ile set edilir. Böylece programcı arka planda "mademki boruda bir şey yok o zaman ben de başka bir şey yapayım" 
    diyebilmektedir. Aynı durum write sırasında da olmaktadır. Örneğin blokesiz modda biz bir boruya write işlemi yapmak isteyelim ancak boru tam olarak 
    dolu olsun. Bu durumda write fonksiyonu -1 ile geri döner ve errno değeri EAGAIN değeri set edilir. Blokesiz modda işlemler blokeli modda işlemlere 
    göre oldukça seyrek kullanılmaktadır. 

    İsimli boru dosyaları open fonksiyonuyla O_NONBLOCK bayrağı kullanılarak açılırken artık open fonksiyonunda bloke oluşmaz. 
    Anımsanacağı gibi blokesiz modda open karşı taraf boruyu ters modda açana kadar bloke oluşturuyordu. open fonksiyonunda O_NONBLOCK bayrağı 
    kullanıldığında proses boruyu read modda açtığında henüz karşı taraf boruyu write modda açmamışsa read fonksiyonu boruyu yazma 
    protansiyelinde olan hiçbir betimleyici olmadığı için 0 ile geri döner. 

    İsimli borularda proses boruyu "write" modda açarken normalde blokeli modda open fonksiyonu karşı taraf boruyu "read" modda 
    açana kadar bloke oluşuyordu. Halbuki isimli boruları O_NONBLOCK bayrağı ile "write" modda açmaya çalıştığımızda karşı taraf boruyu henüz 
    "read" modda açmamışsa open başarız olmaktadır. Bu durumda open fonksiyonu errno değerini ENXIO ile set etmektedir.

    İsimli borularda iki taraf da boruyu O_NONBLOCK bayrağı ile açarsa yukarıda anlattığımız nedenden dolayı senkronizasyona dikkat etmek gerekir. 
    Bu tür durumlarda işlemleri kolaylaştırmak için isimli borular blokeli açılıp açılıp (O_NONBLOCK) kullanılmadan sonrasında fcntl fonksiyonu ile blokesiz moda geçilebilir. 

    Prosesler biri boryu blokeli modda diğeri blokesiz modda açabilir. Bu da herhangi bir soruna yol açmaz. 
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
                                                        40. Ders 25/03/2023 - Cumartesi
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Aşağıda isimsiz borularda blokesiz IO örneği verilmiştir. Bu örnekte borular blokesiz moda sokulmuş sonra read ve write 
    işlemleri başarısız olduğunda errno değerine bakılmıştır. Eğer başarısızlığiın nedeni blokesiz IO yüzündense errno EAGAIN 
    özel değerine set edileceği için bu sırada prosesler arka planda başka işlemler yapmıştır. Örnekte kasten üst proseste biraz bekleme 
    yapılmıştır. Dolayısıyla program çalıştırıldığında alt proses read işleminde blokesiz IO yüzünden başarısız olup birtakım arka plan 
    işlemleri yapacaktır. 
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <errno.h>
#include <fcntl.h>
#include <unistd.h>
#include <sys/wait.h>

void exit_sys(const char *msg);
void exit_sys_child(const char *msg);

int main(int argc, char *argv[])
{
    int pipefds[2];
    pid_t pid;
    ssize_t result;
    int val;
    int i;

    if (pipe(pipefds) == -1)
        exit_sys("pipe");

    if (fcntl(pipefds[1], F_SETFL, fcntl(pipefds[1], F_GETFL) | O_NONBLOCK) == -1)
        exit_sys("fcntl");

    if (fcntl(pipefds[0], F_SETFL, fcntl(pipefds[0], F_GETFL) | O_NONBLOCK) == -1)
        exit_sys("fcntl");

    if ((pid = fork()) == -1)
        exit_sys("fork");

    if (pid != 0) {     /* parent writes */
        close(pipefds[0]);  
        sleep(1);
        
        i = 0;
        while (i < 100000) {
            if (write(pipefds[1], &i, sizeof(int)) == -1) 
                if (errno == EAGAIN) {
                    printf("parent background processing...\n");
                    usleep(500);
                    continue;
                }
                else 
                    exit_sys("write");
            ++i;
        }

        close(pipefds[1]);
        if (wait(NULL) == -1)
            exit_sys("wait");
        
    }
    else {              /* child reads */
        close(pipefds[1]);
        while ((result = read(pipefds[0], &val, sizeof(int))) != 0) {
            if (result == -1) 
                if (errno == EAGAIN) {
                    printf("child background processing...\n");
                    usleep(500);
                    continue;
                }
                else 
                    exit_sys_child("read");
            printf("%d\n", val);
        }

        close(pipefds[0]);
    }

    return 0;    
}

void exit_sys(const char *msg)
{
	perror(msg);

	exit(EXIT_FAILURE);
}

void exit_sys_child(const char *msg)
{
	perror(msg);

	_exit(EXIT_FAILURE);
}

/*--------------------------------------------------------------------------------------------------------------------------
    Aşağıda isimli boruların blokesiz modda kullanımına bir örnek verilmiştir. Burada "mypipe" isimli borusunun dışarıda yaratılmış olması 
    gerekir. İki proses de boruyu önce blokeli modda açmış sonra fcntl fonksiyonu ile blokesiz moda geçmiştir. Yukarıda da belirttiğimiz 
    gibi open fonksiyonu ile O_NONBLOCK bayrağı kullanılarak isimli boruların blokesiz modda açılması sırasında senkronizasyona 
    dikkat edilmesi gerekir. Halbuki önce iki prosesin open fonksiyonu ile boruları blokeli modda açıp sonra fcntl fonksiyonu 
    ile blokesiz moda geçirmesi bu senkronizasyon problemini bertaraf etmektedir.
---------------------------------------------------------------------------------------------------------------------------*/

/* proc1.c */

#include <stdio.h>
#include <stdlib.h>
#include <errno.h>
#include <fcntl.h>
#include <unistd.h>

#define BUFFER_SIZE     4096

void exit_sys(const char *msg);

int main(void)
{
    int fdpipe;
    int i;
    
    if ((fdpipe = open("mypipe", O_WRONLY)) == -1)
        exit_sys("open");

    if (fcntl(fdpipe, F_SETFL, fcntl(fdpipe, F_GETFL) | O_NONBLOCK) == -1)
        exit_sys("fcntl");

    i = 0;
    while (i < 100000) {
        if (write(fdpipe, &i, sizeof(int)) == -1) 
            if (errno == EAGAIN) {
                printf("parent background processing...\n");
                usleep(500);
                continue;
            }
            else 
                exit_sys("write");
        ++i;
    }

    close(fdpipe);

    return 0;    
}

void exit_sys(const char *msg)
{
	perror(msg);

	exit(EXIT_FAILURE);
}

/* proc2.c */

/* proc2.c */

#include <stdio.h>
#include <stdlib.h>
#include <errno.h>
#include <fcntl.h>
#include <unistd.h>

#define BUFFER_SIZE     4096

void exit_sys(const char *msg);

int main(void)
{
    int fdpipe;
    ssize_t result;
    int val;
    
    if ((fdpipe = open("mypipe", O_RDONLY)) == -1)
        exit_sys("open");

    if (fcntl(fdpipe, F_SETFL, fcntl(fdpipe, F_GETFL) | O_NONBLOCK) == -1)
        exit_sys("fcntl");

     while ((result = read(fdpipe, &val, sizeof(int))) != 0) {
            if (result == -1) 
                if (errno == EAGAIN) {
                    printf("child background processing...\n");
                    usleep(500);
                    continue;
                }
                else 
                    exit_sys("read");
            printf("%d\n", val);
        }
    
    close(fdpipe);

    return 0;    
}

void exit_sys(const char *msg)
{
	perror(msg);

	exit(EXIT_FAILURE);
}

/*--------------------------------------------------------------------------------------------------------------------------
    Aslında POSIX standartları çeşitli uyum kategorilerini içermektedir. Yani POSIX standartdını destekleyen sistemler 
    onun bazı uyum kategorilerini destekleyip bazılarını desteklemiyor olabilirler. Örneğin XSI (X/Open ya da Open Group anlamına 
    gelmektedir) önemli bir uyum kategorisidir. Bu uyum kategorisi X/Open denilen ya da yeni ismi ile "Single Unix Specification" 
    denilen uyum kategorisini anlatır. Biz kurusumuzda POSIX standartları demekle tüm bu uyum kategerilerini içerecek biçimde 
    bu terimi kullanıyoruz. Halbuki yukarıda da belirtildiği gibi bazı uyum kategorileri dışlanarak da POSIX standartları 
    desteklenebilmektedir. POSIX standartlarında fonksiyonların yanında bu uyum kategorileri belirtilmiştir. 
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    UNIX/Linux dünyasında "IPC fonksiyonları" demekle geleneksel olarak "mesaj kuyrukları, paylaşılan bellek alanları ve semaphore'lar"
    anlaşılmaktadır. "IPC fonksiyonları" yerine "IPC nesneleri" terimi de kullanılabilmektedir. Borular tipik bir IPC mekanizması 
    olduğu halde bu dünyada IPC fonksiyonları denildiğinde borular anlaşılmamaktadır. (Semaphore'lar senkronizasyon konusu ile ilgilidir. 
    Ancak bir anlamda IPC konusuyla da ilgilidir. Biz semapore'ları "thread'lerin anlatıldığı" bölümde ele alacağız.) 

    Yinelemek gerekirse UNIX dünyasında -onların terminolojisiyle- üç IPC mekanizması vardır:

    - Mesaj kuyrukları
    - Paylaşılan Bellek Alanları
    - Semaphore'lar

    Borular birer IPC mekanizması olduğu halde UNIX/Linux dünyasında IPC mekanizması denildiğinde genellikle borular ayrı biçimde 
    ele alınmaktadır.
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    UNIX/Linux dünyasında IPC mekanizması (onların terimi ile) için iki farklı arayüz (fonksiyon grubu) kullanılmaktadır:

    1) Eskiden beri var olan geniş bir taşınabilirliğe sahip olan ismine "System 5 IPC fonksiyonları" ya da "XSI IPC fonksiyonları"
    denilen klasik IPC fonksiyonları.

    2) 1990'lı yılların ortalarında "Real Time Extensions" eklemeleriyle UNIX/Linux dünyasına katılan ismine
    "POSIX IPC fonksiyonları" denilen yeni ve daha modern IPC fonksiyonları.

    Her ne kadar ikinci grup fonksiyonlara "POSIX IPC fonksiyonları" deniliyorsa da her iki fonksiyon grubu da POSIX standartlarında bulunmaktadır. 
    Klasik IPC fonksiyonlarının yanında XSI uyum kategorisi belirteçleri yerleştirilmiştir. 

    Her iki arayüzdeki fonksiyonların parametrik yapıları ve isimleri o arayüze uygun biçimde belirlenmiştir. Bu nedenle örneğin System 5 (XSI) 
    klasik IPC fonksiyonlarının isimlendirmeleri ve kullanımları biribirine benzerdir ve POSIX IPC fonksiyonlarının isimlendirmeleri ve kullanımları 
    birbirine benzerdir. Aşağıda her iki arayüzdeki yaratıcı fonksiyonların isimleri verilmiştir:

    System 5 IPC Fonksiyonların                     POSIX IPC Fonksiyonları
    
    msgget  (mesaj kuyruğu)                         mq_open     (mesaj kuyruğu)
    shmget  (paylaşaılan bellek alanları)           shm_open    (paylaşılan bellek alanaları)
    semget  (semaphore'lar)                         sem_open    (semaphore'lar)

    Pekiyi mademki klasik (System 5) IPC nesneleri 70'lerden beri kullanılmaktadır ve oldukça taşınabilir durumdadır. O halde neden 90'lı yıllarda 
    yeni bir arayüz gereksinimi duyulmuştur? İşte bunun nedeni klasik IPC nesnelerinin genel tasarımında olan bazı problemlerdir. POSIX IPC 
    nesneleriyle bu problem giderilmeye çalışılmıştır. POSIX IPC nesneleri Linux çekirdeğine çok sonraları eklenmiştir. Hala bazı UNIX türevi sistemlerde
    bu fonksiyonlar tam desteklenmemektedir. Yani POSIX IPC nesneleri taşınabilirlik konusunda daha problemlidir. Gerçi seneler içerisinde 
    bu IPC nesneleri daha çok sistem tarafından desteklenmiştir ve bugünlerde bu taşınabilirlik problemi büyük ölçüde ortadan kalkmıştır. 

    Bu IPC mekanizmalarının incelenmesi işlemi iki biçimde yapılabilir. Önce Klasik System 5 IPC nesneleri görülüp sonra bunların POSIX IPC karşılıkları 
    incelenebilir ya da her IPC mekanizması ayrı ayrı klaisk System 5 ve POSIX karşılıkları incelenebilir. Biz bu kursumuzda ikinci yöntemi izleyeceğiz. 

    Pekiyi biz programcı olarak hangi grup IPC fonksiyonlarını kullanmalıyız? İşte bu iki grubun birbilerine göre amaca yönelik bazı avantajları ve dezavantajları
    söz konusu olmaktadır. Ancak artık programcıların özel bir durum yoksa modern POSIX IPC fonksiyonlarını tercih etmesi daha uygundur.
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Haberşelmeler biçimsel olarak "stream tabanlı" ve "mesaj (datagram) tabanlı" olmak üzere ikiye ayrılmektedır. Stream tabanlı
    haberleşme denildiğinde yazan tarafın tek bir hamlede (örneğin write ile) yazdığını okuyan tarafın tek hamlede (tek bir read ile)
    okumasının sorunlu olmadığı kastedilmektedir. Örneğin bir proses tek hamlede haberleşme kanalına 100 bte göndermiş olabilir. 
    Stream tabanlı haberleşmede okuma yapan taraf bu 100 byte'ı tek hamlede değil birden fazla okuma yaparak elde edebilir. 
    Yani stream tabanlı haberleşmede okuyan taraf haberleşme kanalından istediği kadar byte okuyabilmektedir. Burada "stream" terimi
    "dere, pınar, su akışı" anlamlarından hareketle uydurulmuştur. Mesaj (datagram) haberşemelerde ise gönderen taraf bir grup byte'ı
    mesaj adı altında tek hamlede gönderir. Okuyan taraf bunu tek hamlede okumak zorundadır. Örneğin yazan taraf mesaj adı altında 
    haberşeme kanalına 100 byte göndermiş olabilir. Bu 100 byte'lık paketi diğer taraf parça parça okuyamaz. Tek hamlede okumak zorundadır. 
    Yani okuyan taraf bu paketi ya okumaz ya da okursa hepsini okur. 
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Borulardaki haberleşme "stream tabanlı" haberleşmeye tipik bir örnektir. Örneğin biz boruya 100 byte yazdığımızda okuyan taraf bu 
    100 byte'ı tek hamlede okumak zorunda değildir. Örneğin bunu 10'ar 10'ar byte okuyabilir. Oysa mesaj kuyrukları ismi üzerinde mesaj 
    tabanlı haberleşme sağlamaktadır. Yani mesaj kuyruklarında kuyruğa yazan taraf "mesaj" adı altında bir grup byte'ı 
    bir paket olarak yazar. Okuyan taraf da bunu bir paket olarak tek hamlede okur.
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Klasik System 5 IPC mekanizmasında iki farklı prosesin aynı IPC nesnesi üzerinde anlaşabilmesi için "anahtar (key)" ve "id" 
    kavramları kullanılmaktadır. Bu arayüzlerde xxxget fonksiyonlarına programcı bir anahtar verir. Bu anahtar sayısal bir değerdir. 
    İki proses aynı anahtarı verirse aynı nesneyi kullanırlar. Bu xxxget fonksiyonları verilen anahtara ilişkin bir id geri döndürmektedir. 
    Bu id değeri aslında diğer fonksiyonlarda handle olarak kullanılmaktadır. Buradaki bir problem verilen anahtarın tesadüfen sistemdeki başka bir 
    prosesle çakışabilmesidir. Bunun için bazı kontrollerin yapılması gerekebilmektedir. xxxget fonksiyonlarının verdiği id değerleri 
    sistem genelinde "tek (uniqe)" bir değerdir. Yani aslında bu id değeri diğer prosese proseslerarası hanerleşme yöntemleriyle gönderilse 
    diğer proses hiç xxxget işlemi yapmadan doğrudan bu id değerini kullanabilir. Başka bir deyişle birden fazla proses xxxget fonksiyonlarında 
    aynı anahtarı verdiklerinde aslında aynı id'yi elde etmektedir. 

    Klasik System 5 IPC mekanizmasında xxxget fonksiyonlarında kullanılan anahtarlar aslında IPC nesnesinin türüne göre ayrı bir isim alanındadır. 
    Yani 12345 gibi bir anahtar paylaşılan bellek alanları için ayrı bir anahtar mesaj kuyrukları için ayrı bir anahtar durumundadır. 

    Klasik System 5 IPC nesneleri yaratıldıktan sonra xxxctl fonksiyonu ile yok edilene kadar ya da sistem reboot edilene kadar yaşamaktadır. 
    Bu duruma bu terminolojide "kernel persistancy" denilmektedir. Halbuki örneğin borular öyle değildir. Bire isimli boru yaratılmış ve bir 
    proses onu açıp onun içerisine bir şeyler yazmış olsun. Prosesler boruyu kapatınca artık borunun içerisindekiler yok olur. 
    Halbuki klasik Sistem 5 IPC nesnelerinde bir proses IPC nesnesini silmedikten sonra reboot edilene kadar nesnenin içerisindeki bilgiler 
    kalmaya devam etmektedir. 
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Klasik Sistem 5 (XSI) mesaj kuyrularında dört fonksiyon vardır: msgget, msgsnd, msgrcv ve msgctl fonksiyonları. msgget fonksiyonu mesaj kuyruğunu 
    yaratır ya da yaratılmış olanı açar. msgget fonksiyonunu open fonksiyonuna benzetebiliriz. Mesaj kuyuruğuna bir grup byte'ı mesaj olarak 
    yerleştirmek için msgsnd fonksiyonu, mesaj kuyruğundan mesaj almak için msgrcv fonksiyonu ve mesaj kuyruğu üzerinde silme de dahil olmak üzere
    bazı diğer işlemleri yapabilmek için msgctl fonksiyonu kullanılmaktadır. 
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Klaisk Sistem 5 mesaj kuyrukları msgget fonksiyonuyla yaratılabilir ya da zaten var olan mesaj kuyrukları msgget fonksiyonuyla
    kullanım için açılabilir. Fonksiyonun prototipi şöyledir:

     #include <sys/msg.h>

    int msgget(key_t key, int msgflg);

    Fonksiyonun birinci parametresi tamsayı biçiminde bir anahtar belirtmektedir. Fonksiyonun ikinci parametresinde şu bayraklar kullanılabilir:

    IPC_CREAT: Burada ilgili anahtara ilişkin bir mesaj kuyruğu varsa olan mesaj kuyruğu açılır ancak yoksa yeni bir mesaj kuyruğu 
    yaratılır. Buradaki semantik open fonksiyonundaki O_CREAT semantiğine benzemektedir. 

    IPC_EXCL: Bu bayrak tek başına değil IPC_CREAT ile birlikte IPC_CREAT|IPC_EXCL biçiminde kullanılabilir. Semantik open fonksiyonundaki
    O_EXCL bayrağındaki gibidir. Yani daha önce başka kişiler tarafından aynı anahtara ilişkin bir mesaj kuyruğu zaten yaratılmışsa 
    msgget fonksiyonu bu durumda başarısız olur ve EEXIST ile set edilir. 

    Eğer IPC_CREAT kullanılmazsa zaten var olan anahtara ilişkin mesaj kuyruğunun açılmak istendiği anlaşışmaktadır. Bu parametre 
    0 olarak da girilebilir. 

    Eğer programcı mesaj kuyruğunun yaratılma olasılığı varsa (yani IPC_CREAT bayrağı belirtilmişse) aynı zamanda oluşturulacak mesaj kuyruğu için 
    erişim haklarını da belirtmesi gerekir. Mesaj kuyrukları bir dosya olmasa da sanki dosya gibi erişim haklarına sahiptir. 
    Dolayısıyla erişim hakları için yine <sys/stat.h> içerisindeki S_IXXX sembolik sabitleri ya da bunların sayısal değerleri kullanılır. 
    Bu erişim haklarının IPC_CREAT ve IPC_EXCL ile bit OR işlemine sokulması gerekmektedir. Örneğin:

    msgid = msgget(0x12345, IPC_CREAT|S_IRUSR|S_IWUSR|S_IRGRP|S_IROTH);

    Anımsanacağı gibi POSIX 2008 standardı ile bu S_IXXX sembolik sabitlerine sayısal değerler de karşılık getirilmişti. O halde POSIX 2008 
    ve sonarasında bu işlemi şöyle de yapabiliriz:

    msgid = msgget(0x12345, IPC_CREAT|0644);

    Tabii anahtara ilişkin mesaj kuyruğu zaten varsa buradaki erişim haklarının ve O_CREAT bayrağının hiçbir etkisi yoktur. Erişim hakları 
    nesne gerçekten yaratılacaksa kullanılmaktadır.

    msgget fonksiyonunda (diğer xxxget fonksiyonlarında da böyle) birinci parametre olan anahtar IPC_PRIVATE olarak girilirse 
    bu durumda kullanılmayan bir anahtar oluşturulup mesaj kuyruğu yaratılır. msgget fonksiyonu da bu mesaj kuyruğunun id değerine
    geri döner. Örneğin:

      msgid = msgget(IPC_PRIVATE, IPC_CREAT|S_IRUSR|S_IWUSR|S_IRGRP|S_IROTH);

    Burada olmayan bir anahtardan hareketle mesaj kuyruğu yaratıldığı için bir çakışma söz konusu olmayacaktır. Tabii bu durumda 
    bu id değerinin (anahtarı bilmiyoruz) diğer prosese aktarılması gerekmektedir. Bu aktarım da olsa olsa komut satırı argümanıyla 
    ya da başka bir proseslerarası haberleşme yöntemiyle olabilir. IPC_PRIVATE anahtarı makul gibi gözükse de genel olarak kullanışsızdır.

    Bir program mesaj kuyuğunu yaratıp sonlanabilir. Bu durumda yukarıda da belirttiğimiz gibi mesaj kuyruğu yaratılmış biçimde 
    kalmaya devam eder. Ta ki msgctl fonksiyonu ile silinene kadar ya da sistem rebbot edilene kadar.
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
                                                41. Ders 26/03/2023 Pazar
---------------------------------------------------------------------------------------------------------------------------*/   

/*--------------------------------------------------------------------------------------------------------------------------
    Aşağıdaki örnekte program belli bir anahtar kullnarak klasik System 5 mesaj kuyruğunu yaratmıştır. Aynı anahtarı kullanan 
    başa bir proses aynı mesaj kuyruğunu açabilir. Bu durumda aynı anahtarı kullanan proseslerin hepsi aynı id'yi elde eder. 
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <sys/stat.h>
#include <sys/msg.h>

#define MSG_KEY		0x1234567

void exit_sys(const char *msg);

int main(void)
{
	int msgid;

	if ((msgid = msgget(MSG_KEY, IPC_CREAT|S_IRUSR|S_IWUSR|S_IRGRP|S_IROTH)) == -1)
		exit_sys("msgget");

	printf("Ok\n");

    return 0;    
}

void exit_sys(const char *msg)
{
	perror(msg);

	exit(EXIT_FAILURE);
}

/*--------------------------------------------------------------------------------------------------------------------------
    O anda yaratılmış olan klasik System 5 IPC nesnelerini (mesaj kurukları, paylaşılan bellek alanları ve semaphore'lar) 
    komut satırından görüntülemek için "q" isimli komut kullanılmaktadır. Örneğin:

    ------ İleti Kuyrukları --------
    anahtar    iltkiml    sahibi     izinler    kull-bayt    ileti-sayısı
    0x01234567 0          kaan       644        0            0           

    ----- Paylaşımlı Bellek Bölütleri -----
    anahtar    shmid      sahibi     izinler    bayt       ekSayısı durum       
    0x00000000 18         kaan       600        4194304    2          hedef        
    0x00000000 21         kaan       600        524288     2          hedef        
    0x00000000 22         kaan       600        67108864   2          hedef        
    0x00000000 26         kaan       600        524288     2          hedef        
    0x00000000 458815     kaan       600        4194304    2          hedef        

    ------ Semafor Dizileri ------
    anahtar    semkiml    sahibi     izinler    semSayısı

    Bu komut anahtarları hex sistemde yazdırmaktadır. Bizim anahtarları hex olarak vermemize gerek yoktur. ipcs komutu 
    default olarak tüm IPC nesnelerini görüntülemektedir. Ancak -q komut satırı argümanıyla yalnızca mesaj kuyrukları,  
    -m komutuyla yalnızca paylaşılan bellek alanları ve -s komutuyla da yalnızca semaphore nesneleri görüntülenebilir. Örneğin:

    kaan@kaan-virtual-machine:~$ ipcs -q 

    ------ İleti Kuyrukları --------
    anahtar    iltkiml    sahibi     izinler    kull-bayt    ileti-sayısı
    0x01234567 0          kaan       644        0            0     

    Aslında Linux çekirdeği IPC nesneleri yaratıldığında onların bilgilerini proc dosya sisteminde "/proc/sysvipc" dizini içerisinde 
    msg, sem, shm dosyalarının içerisine yamaktadır. ipcs komutu da zaten bu dosyaların içindekilerini görüntülemektedir. 

    Not: proc dosya sistemi bellekte oluşturulan kernel tarafından bir dosya sistemi gibi sürekli güncellenen ve çekirdeğin 
    yaptığı önemli işlemleri dış dünyaya bildirmek amacıyla kullanılan özel bir dosya sistemidir. Kursumuzda proc dosya sistemi ileride 
    ayrı bir bölümde ele alınacaktır. proc dosya sisteminde bazı dosyalar yazılabilir durumda da olabilmektedir. Bu durumda bu dosyalara
    yazma yapıldığında çekirdeğin bazı ayarları da değiştirilmiş olmaktadır.
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Mesaj kuyruğuna bir mesaj göndermek için msgsnd POSIX fonksiyonu kullanılır. Fonksiyonun prototipi şöyledir:

    #include <sys/msg.h>

    int msgsnd(int msqid, const void *msgp, size_t msgsz, int msgflg);

    Fonksiyonun birinci parametresi mesaj kuyruğunun msgget fonksiyonundan elde edilen id değeridir. (Tabii id değerleri sistem genelinde
    tektir (unique). Dolayısıyla proses mesaj kuyruğunun id değerini biliyorsa anahtardan hareketle id elde etmek zorunda değildir.)
    Fonksiyonun ikinci ve üçüncü parametreleri mesajı oluşturan byte yıpının adresini ve uzunluğunu almaktadır. Son parametre gönderim 
    ile ilgili bazı ayrıntıları belirten flag değerleridir. Normal olarak mesaj kuyruğu doluysa (mesaj kuruğunun bazı limitleri vardır)
    msgsnd bloke oluşturmaktadır. eğer mesaj kuyruğu doluj olduğu halde bloke oluşmasın isteniyorsa (yani blokesiz işlem yapılmak isteniyorsa)
    bu durumda fonksiyonun son parametresine IPC_NOWAIT özel değeri geçirilir. Eğer bu değer geçilmeyecekse bu parametre 0 olarak girilebilir.
    (System 5 mesaj kuyruklarında işlem yapmak O_NONBLOCK gibi bir bayrakla değil IPC_NOWAIT bayrağı ile yapılmaktadır.)

    Fonksiyonun ikinci parametresine mesajı oluşturan byte topluluğunun adresinin girileceğini belirtmiştik. Üçüncü parametre de 
    mesaj uzunluğunu belirtmekteydi. İşte mesaj aslında şöyle oluşturulmak zorundadır: Mesajın başında long bir alan olmalıdır. 
    Bu long alan mesajın türünü (öncelik de diyebiliriz) belirtmektedir. Bu mesaj türü 0'dan büyük pozitif bir değer biçiminde girilmelidir. 
    Bu long alandan sonra mesajın byte'ları gelmelidir. Bu long alan ile mesaj byte'ları arşılıl olmalıdır. Bunu sağlamak için programcı tipik 
    olarak bir yapı oluşturur. Örneğin:

    struct MSG {
        long mtype;
        char msg[1024];
    };

    struct MSG msg;

    Burada yapının msg elemanı (yani long kısımdan sonra gelen kısmını temsil eden kısım) için 1024 byte yer ayrılmıştır. 
    Göncerilecek mesaj 1024 byte'tan daha kısa ise burada gereksiz boş alan kalır. 1024'ten daha yüksek bir mesajı bu yapıya yerleştiremeyiz. 
    Bu sorun için ilk akla gelen yöntem yapının mesaj uzunluğuna bağlı olarak dinamik bir biçimde tahsis edilemsidir. 
    Tabii long alandan sonraki adresi pratik bir biçimde elde edebilmemiz için yine long alandan sonra 1 byte uzunlukta 
    bir dizi bulundurabiliriz:

    struct MSG {
        long mtype;
        char msg[1];
    };

    Şimdi mesajın n byte uzunlukta olduğunu tespit etmiş olalım (kontroller koddan kaldırılmıştır):

    struct MSG *msg;

    msg = (struct MSG *)malloc(sizeof(long) + n)
    msg->mtype = 1;
    memcpy(msg->msg, mesage_content);
    ...
    free(msg);

    C99 ve sonrasında bir yapının son elemanı dizi ise o elemanda uzunluk belirtilmeyebilmektedir. Buna C standartlarında "flexible array member" denilmektedir. 
    Örneğin:

     struct MSG {
        long mtype;
        char msg[];
    };

    Tabii derleyici için bu msg elemanı yalnızca bir yer tutucudur. Bunun bir yer tahsis etmez. 

    Tabii bu işlem biraz zahmetlidir. Bu nedenle genellikle programcılar baştan maksimum mesaj uzunluğunu tespit edip buna uygun bir yapı bildirirler. 
    Örneğin kullanılacak maksimum mesaj uzunluğu 8192 olsun:

     struct MSG {
        long mtype;
        char msg[8192];
    };

    msgsnd fonksiyonundaki üçüncü parametre olan mesaj uzunluğuna mesajın başındaki long alan dahil değildir. Yalnızca mesajın kendi 
    uzunluğu dahildir. Yani msgsnd fonksiyonunu kullanırken biz mesaj uzunluğu olarak gerçek mesajın uzunluğunu veririz. 

    Pekiyi mesajın türü ne anlamakta gelmektedir? Mesajın türü iki nedenden dolayı kullanılmaktadır:

    1) Mesajı alan taraf spesifik bir türe ilişkin mesajları alabilir. Örneğin alan taraf türü 10 olan mesajları alırsa 
    kuyruktaki diğer mesajları pas geçer ve ilk 10 türüne sahip olan mesajı alır. Bu da client-server tarzı uygulamalarda 
    tek bir mesaj kuyruğunun kullanılmasını mümkün hale getirmektedir. 

    2) Mesajın türü istenirse "öncelik kuyruğu (priority queue)" gibi de kullanılmaktadır. 

    Mesaj kuyruklarının tıpkı borularda olduğu gibi belli bir limiti vardır. Bu limite gelindiğinde msgsnd fonksiyonu 
    default olarak bloke olur ve mesaj kuyruğunda yer açılana kadar blokede kalır. Böylece tıpkı borularda olduğu gibi bir senkronizasyon 
    da sağlanmış olmaktadır. Ancak yukarıda da belirttiğimiz gibi msgsnd fonksiyonunun son parametresi IPC_NOWAIT girilirse 
    bu durumda mesaj kuyruğunun limiti dolmuşsa msgsnd fonksiyonu blokeye yol açmaz -1 değeri ile geri döner ve errno değişkeni de 
    EAGAIN değeriyle set edilir. 

    msgsnd fonksiyonu başarısızlık durumunda -1 değeri ile geri döner. Mesaj kuyruğu doluysa ve bloke oluşmuşsa zaten henüz geri dönmez. 
    Başarı durumunda fonlsiyon 0 ile geri dönmektedir. 

    Aşağıdaki programda 1000000 tane int değer değer mesaj kuyruğuna bir mesaj biçiminde msgsnd fonksiyonuyla yazılmak istenmiştir. 
    Tabii mesaj kuyruğunun limitleri dolacağı için bu mesajların hepsi kuyruğa yazılamacaktır. Dolayısıyla IPC_NOWAIT parametresi de 
    geçilmediğine göre bloke oluşacaktır. Bu programda mesaj türü (yapının mtype alanı) 1 olarak alınmıştır. Mesaj türü zaten 0 olamaz. 
    Eğer mesaj türüyle programcı ilgilenmeycekse onu herhangi bir değerde tutabilir. 

---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <sys/stat.h>
#include <sys/msg.h>

#define MSG_KEY		0x1234567

struct MSG {
	long mtype;
	int val;
};

void exit_sys(const char *msg);

int main(void)
{
	int msgid;
	struct MSG msg;

	if ((msgid = msgget(MSG_KEY, IPC_CREAT|S_IRUSR|S_IWUSR|S_IRGRP|S_IROTH)) == -1)
		exit_sys("msgget");

	for (int i = 0; i < 1000000; ++i) {
		msg.mtype = 1;
		msg.val = i;

		if (msgsnd(msgid, &msg, sizeof(int), 0) == -1)
			exit_sys("msgsnd");
	}

    return 0;    
}

void exit_sys(const char *msg)
{
	perror(msg);

	exit(EXIT_FAILURE);
}

/*--------------------------------------------------------------------------------------------------------------------------
    Klasik System 5 mesaj kuyruklarından mesaj okumak için msgrcv fonksiyonu kullanılmaktadır. Fonksiyonun prototipi şöyledir:

    #include <sys/msg.h>

    ssize_t msgrcv(int msqid, void *msgp, size_t msgsz, long msgtyp, int msgflg);

    Fonksiyonun birinci parametresi mesaj kuyruğunun id'sini belirtmektedir. Fonksiyonun ikinci ve üçüncü parametreleri kuyruktan alınan 
    mesajın yerleştirileceği alanın adresini ve uzunluğunu almaktadır. Yine buraya geçirilecek adresin ilk byte'larında long 
    bir alan bulunmalıdır. Mesaj bu long alandan sonraki yere yerleştirilir. Dolayısıyla programcı genellikle yine ikinci parametreye
    geçirilecek adresi bir yapı olarak oluşturur. Örneğin:

    struct MSG {
        long mtype;
        char msg[8192];
    };

    struct MSG msg;

    Burada fonksiyonun ikinci parametresine bu yapı nesnesinin adresi geçirilir. Fonksiyon kuyruktaki mesajın türünü ve içeriğini 
    bu yapıya yerleştirecektir. Fonksiyonun üçüncü parametresinde belirtilen uzunluk long alandan sonraki gerçek mesajın uzunluğudur. 
    Örneğin:

    result = msgrcv(msgid, &msg, 8192, ...);

    Fonksiyonun dördüncü parametresi hangi türe ilişkin mesajların alınacağını belirtmektedir. Kuyrukta farklı tür numaralarına (mtype)
    sahip mesajlar bir arada bulunuyor olabilir. Dördüncü parametre bunların alınış biçimini belirtmektedir. Bu parametre 0 olarak girilirse 
    bu durumda msgrcv kuyruktaki tüğr değeri ne olursa olsun ilk mesajı alır. (0 değerinin geçerli bir tür değeri belirtmediğine dikkat ediniz.)
    Eğer bu parametreye biz 0'dan büyük bir değer girersek bu durumda o tür değerine sahip ilk mesaj kuyruktan alınır. Örneğin biz bu parametreye 
    100 girmiş olalım. Kuyrukta da 100 tür değerine sahip kuyruğun farklı yerlerinde 4 tane mesaj olsun. Biz bu durumda 100 tür değerine sahip
    kuyrukta en önceki mesajı alırız. Bu sayede biz kuyrukta belli bir tür değerine sahip mesajları elde edebilmekteyiz. Eğer bu parametre 
    negatif bir değer olarak girilirse bu durumda bu negatif değerin mutlak değerine eşit ya da ondan küçük olan en küçük mesaj tür değerine sahip 
    kuyruktaki ilk mesaj elde edilir. Örneğin kuyruktaki mesajların da mesaj tür değerleri şöyle olsun:

    20 5 30 2 8 40

    Şimdi biz msgrcv fonksiyonu bir döngü içerisinde dördüncü parametresi -10 olacak biçimde çağrımış olalım. -10 değerinin mutlak değeri 10'dur. 
    10'dan küçük ya da 10'a eşit olan en küçük tür değerine sahip olan mesaj 2 tür değerine sahip mesajdır. O halde kuyruktan önce bu mesaj alaınacaktır. 
    Sonra 5 tür değerine sahip olan mesaj sonra da 8 tür değerine sahip olan mesaj alınacaktır. Sonra koşula uygun kuyrukta mesaj kalmayacağına göre msgrcv artık 
    bloke olacaktır. Fonksiyonun dördüncü parametresi negatif girildiğinde artık kuyruk adeta bir öncelik kuyruğu gibi ele alınmaktadır. 
    Ancak burada mesaj türü değeri küçük olanlar daha öncelikli kabul edilmektedir. 

    msgrcv fonksiyonunun son parametresi mesajın alımına ilişkin bazı özellikleri belirtir. POSIX standartlarına göre buradaki bayrak değerleri 
    iki bayraktan oluşabilir (bu iki bayrak birlikte bulunabilir):

    IPC_NOWAIT: Bu durumda blokesiz alım yapılmaktadır. Yani kuyrukta uygun mesaj yoksa msgrcv başarısız olur ve -1 değeri ile geri döner, 
    errno değeri EAGAIN olarak set edilir. 

    MSG_NOERROR: Normal olarak alınan mesajın uzunluğu msgrcv fonksiyonunun üçüncü parametresinde belirtilen tampon uzunluğundan büyükse
    msgrcv başarısız olur ve errno değeri E2BIG değeri ile set edilir. Ancak son parametrede MSG_NOERROR nayrağı kullanılırsa bu durumda
    msgrecv başarılı olur ancak kuyruktaki mesaj kırpılarak verdiğimiz tampona yerleştirilir. 

    Programcı son parametre için özel bir bayrak belirlemek istemiyorsa bu parametreyi 0 olarak geçebilir. 

    msgrcv fonksiyonu başarı durumunda okunan mesajın byte uzunluğu ile balarısızlık durumunda -1 ile geri dönemktedir. Okunan mesajın 
    byte uzunluğuna long alan dahil değildir.

    Burada özellikle bir noktayı vurulamak istiyoruz: Klasik Sistem 5 mesaj kuyruklarında karşı tarafın mesaj kuyruğunu kapatması diye bir 
    durum yoktur. Dolayısıyla borularda olduğu gibi 0 byte okunana kadar yinelenen bir dönü oluşturulamamaktadır. 
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Mesaj kuyruğundan sürekli mesaj okuyan programları yazarken dikkat ediniz. Çünkü bu programlar kuyrukta uygun mesaj olmadığı 
    zaman blokeye yol açarlar. Örneğin:

    for (;;) {
        if (msgrcv(msgid, &msg, sizeof(int), 0, 0) == -1)
            exit_sys("msgrcv");

        printf("Message type: %ld\n", msg.mtype);
        printf("Message content: %d\n", msg.val);
    }	

    Burada mesgrcv kuyruktaki mesajları alıp bitirdikten sonra artık kuyrukta mesaj yoksa bloke oluşacaktır. Pekiyi bu durumda 
    bu program nasıl dönüden çıkacaktır? Tabii en normal durum kuyruktan alınan mesajın incelenip özel bir mesaja gör dönüden çıkmak olabilir. 
    Eğer kuyruktaki tüm mesajların alınıp döngüden çıkılması isteniyorsa bu durumda blokesiz okuma yoluna gidilebilir. Örneğin:

    while (msgrcv(msgid, &msg, sizeof(int), 0, IPC_NOWAIT) != -1)
		printf("Message type: %ld\n", msg.mtype);
		printf("Message content: %d\n", msg.val);
	}	
	if (errno != EAGAIN)
		exit_sys("msgrcv");

    Aşağıdaki örnekte prog1 programı mesaj kuyruğuna 0'dan 1000000'a kadar deeğrleri mesaj olarak yerleştirmektedir. Mesajın tür
    değeri programlar tarafından kullanılmadığı için 1 olarak geçilmiştir. prog2 programı bu değerleri kuyruktan almış 1000000 
    değerini gördüğünde o da kendini sonlandırmıştır. 

    Mesaj kuyruklarında close tarzı bir işlem yoktur. 
---------------------------------------------------------------------------------------------------------------------------*/

/* prog1.c */

#include <stdio.h>
#include <stdlib.h>
#include <sys/stat.h>
#include <sys/msg.h>

#define MSG_KEY		0x1234567

struct MSG {
	long mtype;
	int val;
};

void exit_sys(const char *msg);

int main(void)
{
	int msgid;
	struct MSG msg;

	if ((msgid = msgget(MSG_KEY, IPC_CREAT|S_IRUSR|S_IWUSR|S_IRGRP|S_IROTH)) == -1)
		exit_sys("msgget");

    msg.mtype = 1;
	for (int i = 0; i <= 1000000; ++i) {
		msg.val = i;

		if (msgsnd(msgid, &msg, sizeof(int), 0) == -1)
			exit_sys("msgsnd");
	}

    return 0;    
}

void exit_sys(const char *msg)
{
	perror(msg);

	exit(EXIT_FAILURE);
}

/* prog2.c */

#include <stdio.h>
#include <stdlib.h>
#include <sys/stat.h>
#include <sys/msg.h>

#define MSG_KEY		0x1234567

struct MSG {
	long mtype;
	int val;
};

void exit_sys(const char *msg);

int main(void)
{
	int msgid;
	struct MSG msg;

	if ((msgid = msgget(MSG_KEY, IPC_CREAT|S_IRUSR|S_IWUSR|S_IRGRP|S_IROTH)) == -1)
		exit_sys("msgget");

	for (;;) {
		if (msgrcv(msgid, &msg, sizeof(int), 0, 0) == -1)
			exit_sys("msgrcv");

		if (msg.val == 1000000)
			break;
		printf("Message type: %ld\n", msg.mtype);
		printf("Message content: %d\n", msg.val);
	}	

    return 0;    
}

void exit_sys(const char *msg)
{
	perror(msg);

	exit(EXIT_FAILURE);
}

/*--------------------------------------------------------------------------------------------------------------------------
    Aşağıdaki örnekte prog1.c programı klavyeden (stdin dosyasından) alınınan yazıları sonunda null karakter dahil olmak 
    üzere mesaj kuyruğuna yazmaktadır. Klavyeden "quit" girildiğinde bu mesaj da mesaj kuyruğuna yazılır ve prog1.c programı 
    sonlanır. prog2.c programı da kuyruktan mesajları alarak onları ekrana (stdout dosyasına) yazdırmaktadır. Programlarda yine 
    mesajın tür değeri kullanılmamaktadır, 1 biçiminde kodlanmıştır. 
---------------------------------------------------------------------------------------------------------------------------*/

/* prog1.c */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/stat.h>
#include <sys/msg.h>

#define MSG_KEY		0x1234567

struct MSG {
	long mtype;
	char buf[8192];
};

void exit_sys(const char *msg);

int main(void)
{
	int msgid;
	struct MSG msg;
	char *str;

	if ((msgid = msgget(MSG_KEY, IPC_CREAT|S_IRUSR|S_IWUSR|S_IRGRP|S_IROTH)) == -1)
		exit_sys("msgget");

	msg.mtype = 1;
	for (;;) {
		printf("Message text:");
		fflush(stdout);

		if (fgets(msg.buf, 8192, stdin) == NULL)
			continue;
		if ((str = strchr(msg.buf, '\n')) != NULL)
			*str = '\0';

		if (msgsnd(msgid, &msg, strlen(msg.buf) + 1, 0) == -1)
			exit_sys("msgsnd");
		if (!strcmp(msg.buf, "quit"))
			break;
	}

    return 0;    
}

void exit_sys(const char *msg)
{
	perror(msg);

	exit(EXIT_FAILURE);
}

/* prog2.c */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/stat.h>
#include <sys/msg.h>

#define MSG_KEY		0x1234567

struct MSG {
	long mtype;
	char buf[8192];
};

void exit_sys(const char *msg);

int main(void)
{
	int msgid;
	struct MSG msg;

	if ((msgid = msgget(MSG_KEY, IPC_CREAT|S_IRUSR|S_IWUSR|S_IRGRP|S_IROTH)) == -1)
		exit_sys("msgget");

	for (;;) {
		if (msgrcv(msgid, &msg, 8192, 0, 0) == -1)
			exit_sys("msgrcv");

		if (!strcmp(msg.buf, "quit"))
			break;
		
		printf("Message text: %s\n", msg.buf);
	}	

    return 0;    
}

void exit_sys(const char *msg)
{
	perror(msg);

	exit(EXIT_FAILURE);
}

/*--------------------------------------------------------------------------------------------------------------------------
    Aşağıdaki örnekte prog1.c programı döngü içerisinde önce mesaj tür değerini sonra da mesaj yazısını alıp kuyruğa yollamıştır. 
    prog2.c ise msgrcv fonksiyonunda dördüncü parametrede -100 kullanarak en düşük mesaj tür değeri önce alınacak biçimde 
    mesajları kuyruktan almıştır. Bu örnekte önce prog1 programını çalıştırınız. quit mesajına düşük bir öncelik (yüksek değer) veriniz.
    Sonra prog2 programını çalıştırarak sonuçları gözden geçiriniz. 
---------------------------------------------------------------------------------------------------------------------------*/

/* prog1.c */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/stat.h>
#include <sys/msg.h>

#define MSG_KEY		0x1234567

struct MSG {
	long mtype;
	char buf[8192];
};

void exit_sys(const char *msg);
void clear_stdin(void);

int main(void)
{
	int msgid;
	struct MSG msg;
	char *str;

	if ((msgid = msgget(MSG_KEY, IPC_CREAT|S_IRUSR|S_IWUSR|S_IRGRP|S_IROTH)) == -1)
		exit_sys("msgget");

	for (;;) {		
		printf("Message type:");
		scanf("%ld", &msg.mtype);

		clear_stdin();

		printf("Message text:");
		fflush(stdout);
		
		if (fgets(msg.buf, 8192, stdin) == NULL)
			continue;
		if ((str = strchr(msg.buf, '\n')) != NULL)
			*str = '\0';

		if (msgsnd(msgid, &msg, strlen(msg.buf) + 1, 0) == -1)
			exit_sys("msgsnd");
		if (!strcmp(msg.buf, "quit"))
			break;
	}

    return 0;    
}

void exit_sys(const char *msg)
{
	perror(msg);

	exit(EXIT_FAILURE);
}

void clear_stdin(void)
{
	while (getchar() != '\n')
		;
}

/* prog2.c */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/stat.h>
#include <sys/msg.h>

#define MSG_KEY		0x1234567

struct MSG {
	long mtype;
	char buf[8192];
};

void exit_sys(const char *msg);

int main(void)
{
	int msgid;
	struct MSG msg;

	if ((msgid = msgget(MSG_KEY, IPC_CREAT|S_IRUSR|S_IWUSR|S_IRGRP|S_IROTH)) == -1)
		exit_sys("msgget");

	for (;;) {
		if (msgrcv(msgid, &msg, 8192, -100, 0) == -1)
			exit_sys("msgrcv");

		if (!strcmp(msg.buf, "quit"))
			break;
		
		printf("Message type: %ld Message text: %s\n", msg.mtype, msg.buf);
	}	

    return 0;    
}

void exit_sys(const char *msg)
{
	perror(msg);

	exit(EXIT_FAILURE);
}

/*--------------------------------------------------------------------------------------------------------------------------
    Mesajların type değerinin kullanıldığı tipik örnekler client-server tarzı haberleşme örnekleridir. Şimdi mesaj kuyrukları 
    kullanılarak client-server tarzı bir haberleşme yapmak isteyelim. Bu haberleşmede client'ların server'dan istekte bulunması 
    için tek bir mesaj kuyruğu yeterlidir. Benzer biçimde server'ın da client'lara yanıtı geri döndürmesi için toplamda tek bir 
    mesaj kuyruğu yeterlidir. (Anımsanacağı isimli borlarda server yanıtları iletirken mecburen her client için ayrı bir isimli 
    boru kullanıyordu). Haberleşmenin sistematiği şöyle olabilir:

    - Client program'lar kendi proses id'lerini mesaj tür bilgisi olarak kullanıp mesajı önceden belirlenmiş mesaj kuyruğuna göndeirir. 
    Bu mesaj kuyruğuna "server mesaj kuyruğu" diyelim. 

    - Server program server mesaj kuyruğundan sıraki mesajı okur. (msgrcv fonksiyonun dördüncü parametresi 0 olarak girilirse 
    kuyruktaki sırada mesajlar okunmaktadır.) Bunun hangi client'tan geldiğini anlar. İşlemi yapar. İşlemin sonucunu "client mesaj kuyruğu"
    diye isimlendirdiğimiz mesaj kuyruğuna bir mesaj olarak yollar. Ancak yolladığı mesajın tür değeri client'ın proses id değeridir. 

    - Mesajı gönderen client program client mesaj kuyruğundan mesaj tür bilgisi kendi proses id'si olacak biçimde msgrecv fonksiyonu 
    ile yanıtı elde eder. 

    Burada da görüldüğü gibi client programların hepsi ortak bir mesaj kuyruğundan server yanıtlarını alabilmektedir. Eğer mesaj kuyruğunun 
    böyle bir tür değeri olmasaydı ve mesaj kuyruğundan belli bir tür değerine ilişkin mesaj okunamasaydı bu durum mümkün olamazdı.
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
                                                42. Ders 01/04/2023 - Cumartesi
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Aslında klasik System 5 mesaj kuyruklarıyla client-server haberleşme programı yazılırken tek bir kuyruk da kullanılabilir. 
    Örneğin bu durumda client'lar yine kendi proses id'lerini mesaj tür değeri yaparak kuyruğa server için mesaj bırakır. 
    Server da mesajı işledikten sonra bu kkez yanıtı ilgili prosesin id'sini mesaj tür bilgisi yaparak kuyruğa yazar. Client da 
    kuyruktan kendi mesaj tür bilgisiyle okuma yapabilir. Ancak tek bir kuyruğun  kullanılması aslında iyi bir yöntem değildir. 
    Bu durum haberleşmeyi çok kırılgan hale getirmektedir. Şöyle ki:

    - Bu durum "kilitlenme (deadlock)" denilen soruna kolaylıkla yol açabilmektedir. Mesaj kuyruklarının bir kapasitesi vardır. 
    Kuyruk dolduğunda blokeli yazmalarda kuyruğa mesaj yazacak taraf bloke olmaktadır. Bu senaryoda server bir client'ın isteğini 
    karşılamak için mesaj kuyruğuna yanıt merrsajını yazacağı zaman diğer client'lar istek yaparak mesaj kuyruğunu doldurmuş olabilir. 
    Bu durumda ne client'lar kuyruğa mesaj yazabilir ne de server herhangi bir yanıtı kuyruğa yazabilir. İşte bu durum tipik 
    bir "kilitlenme (deadlock)" durumudur. 

    - Bu modelde client ilk kez server'a kendi proses id'si ile mesaj gönderirken aynı kuyruğa mesajı yazacağı için birazdan 
    aynı proses id ile kuyruktan mesaj almaya çalışırken kendi yazdığı mesajı alabilir. Tabii bunu engellemenin çeşitli yolları da 
    vardır. Örneğin böylesi bir durumda server elde ettiği proses id'nin başına bir bilgi ekleyebilir. Client da okumasını buna göre yapabilir. 

    - Bu model kilitlenme durumu aşılsa bile yavaş olmaktadır. Çünkü kuyrukların bir kapasitesi vardır. Bu kapasite dolduğunda blokeler
    haberleşmeyi yavaşlatabilmektedir. 

    İlk açıkladığımız iki kuyruklu model de her ne kadar "kilitlenmeye daha dirençliyse" kırılgan bir yapı oluşturabilmektedir. 
    Şöyle ki, belli bir client kuyruktan bilgi okumazsa (kasten bunu yapabilir ama client programı da biz yazıyorsak bunu kasten yapmayız)
    kuyruk dolabilir yine bir  kilitlenme oluşabilir. Tabii client program neden kuyuktan mesaj okumayacaktır? Client program da bizim 
    tarafımızdan yazıldığına göre genellikle böyle bir şey olmaz. Ancak client programların başka yerlerinde yanlış bir teknik yüzünden bir bloke oluşsa
    onlar mesajlarını kuyruktan alamayabilirler. Bu durum diğer client'ları olumsuz etkileyebilir. 

    O halde mesaj kuyruklarıyla client-server haberleşme daha sağlam yapılacaksa yine her client için ayrı bir mesaj kuyruğu kullanılabilir. 
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Aslında mesaj kuyruklarına 0 byte'lık mesajlar da gönderilebilir. Bu durumda kuyruğa yine mesaj yazılır. Mesajın tür değeri yine
    0 byte'lık mesajı gönderen kişinin belirlediği tür değeri olarak mesjaı okuyan kişi tarafından elde edilmektedir. Yani 0 byte'lık 
    mesajlar yine kuruğa bir mesaj gibi yazılmaktadır. Bu tür mesajların uzunluğu çekirdek tarafından 1 bye mesajlarmış gibi ele alınmaktadır. 
    Böylece çekirdek sonsuz döngü içerisinde 0 byte mesaj gönderme durumunda mesaj kuyruğunun belli bir süre sonra dolmasına yol açmaktadır. 
    Pekiyi 0 byte'lık mesajlar neden gönderilebilir? İşte genellikle 0 byte uzunluğunda mesajlar "iletişimi sonlandırmak amacıyla" 
    gönderilmektedir. Tabii bazen gönderilecek mesaj gerçekten bir bilgi içermeyip yalnızca bir tür değeri de içeriyor olabilir. 

    Aşağıdaki örnekte prog1 programı klavyeden (stdin dosyasından) aldığı yazıyı mesaj kuyruğuna yazmakta prog2 programı da bunu mesaj kuyruğundan 
    okumaktadır. İletişim sonlandırılacağı zaman prog1 kuyruğa 0 uzunlukta özel bir mesaj tür değeri olan QUIT_MSG mesajını bırakır. 
    prog2 programı da bu özel mesaj tür değerini aldığında işlemini sonlandırmaktadır. 
---------------------------------------------------------------------------------------------------------------------------*/

/* prog1.c */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/stat.h>
#include <sys/msg.h>

#define MSG_KEY				0x1234567
#define NORMAL_MSG			1
#define QUIT_MSG			2

struct MSG {
	long mtype;
	char buf[8192];
};

void exit_sys(const char *msg);

int main(void)
{
	int msgid;
	struct MSG msg;
	char *str;
	size_t len;

	if ((msgid = msgget(MSG_KEY, IPC_CREAT|S_IRUSR|S_IWUSR|S_IRGRP|S_IROTH)) == -1)
		exit_sys("msgget");

	for (;;) {		
		printf("Message text:");
		fflush(stdout);
		
		if (fgets(msg.buf, 8192, stdin) == NULL)
			continue;
		if ((str = strchr(msg.buf, '\n')) != NULL)
			*str = '\0';

		if (!strcmp(msg.buf, "quit")) {
			msg.mtype = QUIT_MSG;	
			len = 0;
		}
		else {
			msg.mtype = NORMAL_MSG;	
			len = strlen(msg.buf) + 1;
		}
			
		if (msgsnd(msgid, &msg, len, 0) == -1)
			exit_sys("msgsnd");

		if (msg.mtype == QUIT_MSG)
			break;
	}

    return 0;    
}

void exit_sys(const char *msg)
{
	perror(msg);

	exit(EXIT_FAILURE);
}

/* prog2.c */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/stat.h>
#include <sys/msg.h>

#define MSG_KEY				0x1234567
#define NORMAL_MSG			1
#define QUIT_MSG			2

struct MSG {
	long mtype;
	char buf[8192];
};

void exit_sys(const char *msg);

int main(void)
{
	int msgid;
	struct MSG msg;

	if ((msgid = msgget(MSG_KEY, IPC_CREAT|S_IRUSR|S_IWUSR|S_IRGRP|S_IROTH)) == -1)
		exit_sys("msgget");

	for (;;) {
		if (msgrcv(msgid, &msg, 8192, 0, 0) == -1)
			exit_sys("msgrcv");

		if (msg.mtype == QUIT_MSG)
			break;
		
		printf("Message type: %ld Message text: %s\n", msg.mtype, msg.buf);
	}	

    return 0;    
}

void exit_sys(const char *msg)
{
	perror(msg);

	exit(EXIT_FAILURE);
}

/*--------------------------------------------------------------------------------------------------------------------------
    System 5 IPC nesnelerinin önemli sorunlarından biri bunların anahtar (key) değerlerinin bir çalışma yaratabilmesidir. 
    Yani bizim belirlediğimiz anahtara ilişkin bir mesaj kuyruğu başkaları tarafından yaratılmış olabilir. Bu tür durumlarda 
    anahtar yerine IPC_PRIVATE özel değerinin kullanılabileceğini belirtmiştik. Ancak bu durumda da elde edilen id değerinin 
    diğer prosese iletilmesi gerekmekteydi. İşte anahtar çakışmasını azaltmak için ftok isimli bir POSIX fonksiyonundan faydalanılmaktadır. 
    Fonksiyonun prototipi şöyledir:

    #include <sys/ipc.h>

    key_t ftok(const char *path, int id);

    Fonksiyonun birinci parametresi olan bir dosyanın yol ifadesini belirtmelidir. İkinci parametre kombine edilecek değeri belirtir. 
    İkinci parametrenin yalnızca düşük anlamlı bir byte'ı kombine işleminde kullanılmaktadır. Bu parametrenin düşük anlamlı byte'ının 
    0 olmaması gerekir. Fonksiyon eğer biz ona aynı yol ifadesini ve aynı i,d değerini veriyorsak bize aynı geri dönüş değerini verir. Eğer biz ona
    farklı bir yol ifadesi ve/veya farklı bir id veriyorsak o bize başka bir geri dönüş değeri verir. Fonksiyonun amacı System 5 IPC nesneleri için
    bir yol ifadesinden hareketle bir anahtar değerin sistem genelinde tek olacak biçimde (unique) oluşturulmasıdır. Böylece her proses
    anahtar üretmekte bu ftok fonksiyonunu kullanırsa ve ftok fonksiynuna kendisine ilişkin bir yol ifadesi ve id değeri verirse sistem genelinde 
    çakışma olmaz. 

    Her ne kadar ftok fonksiyonu sistem genelinde bir anahtar çakışmasını engellemek için düşünülmüşse de maalesef böyle bir 
    garantinin verilmesi mümkün değildir. dosyanın yol ifadesi ve id değerinden hareketle bir tamsayı değerin (key_t değerinin) 
    sistem genelinde tek olacak biçimde üretilmesi mümkün değildir. Standartlar bile bunu garanti altına almamaktadır. Yani iki rpgram
    farklı yol ifadesi ve id değeri verdiğinde bile aynı anahtar değerini elde edebilir (her ne kadar bu olasılık çok düşükse de).
    Libc kütüphanesindeki ftok fonksiyonu dosyanın inode numarasını, dosyanın içinde bulunduğu aygıtın numarasını ve bizim derdiğimiz id
    değerini kombine ederek bir değer üretmektedir. Bu üretim de çakışmama olasılığını sıfırlayamamaktadır. ftok fonksiyonunu kullanırken 
    dosyayı silip aynı isimle yeniden yaratırsak dosyanın inode numarası değişebileceğinden dolayı aynı değeri elde edemeyebiliriz. 

    ftok fonksiyonu başarı durumunda ürettiği anahtar değerine başarısızlık durumunda -1 değerine geri dönmektedir.

    Pekiyi ftok fonksiyonu farklı yol ifadeleri ve/veya id'ler için farklı anahtar değeri üretmeyi garanti etmiyorsa bu fonksiyonun
    kullanımının anlamı var mıdır? Aslında bu soruya "yoktur" yanıtını verebiliriz. Ancak ftok fonksiyonundan hedeflenen şeylerden biri de
    anahtarın sayısal olmasından kurtulunup yazısal hale getirilmesidir. Fakat ne olursa olsun ftok fonksiyonun verdiği değer programcının 
    uyduracağı değerden daha iyi olma eğilimindedir (tabii herkes ftok kullanırsa). 

    Aşağıda ftok kullanımına bir örnek verilmiştir. İki program da aynı yol ifadesi ve aynı ftok id'si ile ftok uygulamış ve aynı değeri 
    elde etmiştir. 
---------------------------------------------------------------------------------------------------------------------------*/

/* prog1.c */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/stat.h>
#include <sys/msg.h>
#include <sys/ipc.h>

#define KEY_NAME			"/home/kaan"
#define KEY_ID				123
#define NORMAL_MSG			1
#define QUIT_MSG			2

struct MSG {
	long mtype;
	char buf[8192];
};

void exit_sys(const char *msg);

int main(void)
{
	int msgid;
	struct MSG msg;
	char *str;
	size_t len;
	key_t key;

	if ((key = ftok(KEY_NAME, KEY_ID)) == -1)
		exit_sys("ftok");
	
	if ((msgid = msgget(key, IPC_CREAT|S_IRUSR|S_IWUSR|S_IRGRP|S_IROTH)) == -1)
		exit_sys("msgget");

	for (;;) {		
		printf("Message text:");
		fflush(stdout);
		
		if (fgets(msg.buf, 8192, stdin) == NULL)
			continue;
		if ((str = strchr(msg.buf, '\n')) != NULL)
			*str = '\0';

		if (!strcmp(msg.buf, "quit")) {
			msg.mtype = QUIT_MSG;	
			len = 0;
		}
		else {
			msg.mtype = NORMAL_MSG;	
			len = strlen(msg.buf) + 1;
		}
			
		if (msgsnd(msgid, &msg, len, 0) == -1)
			exit_sys("msgsnd");

		if (msg.mtype == QUIT_MSG)
			break;
	}

    return 0;    
}

void exit_sys(const char *msg)
{
	perror(msg);

	exit(EXIT_FAILURE);
}

/* prog2.c */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/stat.h>
#include <sys/msg.h>
#include <sys/ipc.h>

#define KEY_NAME			"/home/kaan"
#define KEY_ID				123
#define NORMAL_MSG			1
#define QUIT_MSG			2

struct MSG {
	long mtype;
	char buf[8192];
};

void exit_sys(const char *msg);

int main(void)
{
	int msgid;
	struct MSG msg;
	key_t key;

	if ((key = ftok(KEY_NAME, KEY_ID)) == -1)
		exit_sys("ftok");

	if ((msgid = msgget(key, IPC_CREAT|S_IRUSR|S_IWUSR|S_IRGRP|S_IROTH)) == -1)
		exit_sys("msgget");

	for (;;) {
		if (msgrcv(msgid, &msg, 8192, 0, 0) == -1)
			exit_sys("msgrcv");

		if (msg.mtype == QUIT_MSG)
			break;
		
		printf("Message type: %ld Message text: %s\n", msg.mtype, msg.buf);
	}	

    return 0;    
}

void exit_sys(const char *msg)
{
	perror(msg);

	exit(EXIT_FAILURE);
}

/*--------------------------------------------------------------------------------------------------------------------------
    Mesaj kuyruklarının sistemlerde o sisteme özgü çeşitli kapasite limitleri söz konusu olabilmektedir. POSIX standartları 
    bu kapasite limitleri konusunda bir açıklama yapmamıştır. Ancak Linux sistemlerinde çekirdek mesaj kuyrukları için 
    üç kapasite limiti belirlemektedir:

    1) MSGMAX Limiti: Bu limit bir mesaj kuyruğuna yazılabilecek mesajın mesaj tür değeri haricindeki kısmının maksimum byte 
    uzunluğudur. Herhangi bir proses bu değerin yukarısındaki uzunluktaki bir mesajı kuyruğa yerleştirememektedir. Linux sistemlerinde 
    bu değer default olarak şimdilik 8192'dir. Bu değer proc dosya sisteminde /proc/sys/kernel/msgmax dosyasında belirtilmektedir. Bu değer 
    bu dosyanın içeriği değiştirilerek değiştirilebilmektedir. Ancak bunu yaoabilmek için prosesin uygun önceliğe sahip olması 
    (proses id'sinin 0 olması) gerekir. 

    2) MSGMNI (Maximum Number of Id): Bu limit tüm sistemde yaratılcaka farklı mesaj kuyruklarının maksimum sayısını belirtmektedir. 
    Bu sayı /proc/sys/kernel/msgmni dosyasından elde edilebilir. Linux sistemlerinde bunun default değeri şimdilik 32000'dir. 

    3) MSGMNB (Maximum Number of Bytes): Bu değer bir mesaj kuyruğundaki mesajın tür değeri dışındaki tüm mesajlarının toplam maximum 
    byte sayısıdır. msgsnd fonksiyonu bu değer aşıldığında blokeli işlemlerde bloke olur. Bu değer /proc/sys/kernel/msgmnb dosyasından 
    elde edilebilir. Linux sistemlerinde bu değer şimdilik default durumda 16384'tür. Yani msgsnd fonksiyonu bu değer aşıldığında bloke 
    olur. Ancak bu değer eldeki RAM miktarına bağlı olarak çekirdek tarafındna ayarlanabilmektedir. 

    Buradaki limit değerleri çekirdek parametreleriyle ya da çekirdek derlenirken konfigürasyon parametreleriyle değiştirilebilmektedir. 
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Klasik System 5 mesaj kuyruklarına ilişkin bazı kontrol işlemleri msgctl isimli POSIX fonksiyonu ile yapılmaktadır. Fonksiyonun 
    prototipi şöyledir:

    #include <sys/msg.h>

    int msgctl(int msqid, int cmd, struct msqid_ds *buf);

    Fonksiyonun birinci parametresi mesaj kuyruğunun id değeridir. İkinci parametre uygulanacak işlemi belirtir. Bu uygulanacak işlem 
    şunlardan biri olabilir:

    IPC_STAT
    IPC_SET
    IPC_RMID

    Fonksiyonun üçüncü parametresi msqid_ds isimli yapı nesnesinin adresini almaktadır. Bu yapı <sys/msg.h> içerisinde tanımlnamıştır. 
    POSIX bu yapının olması gereken elemanlarını belirtmiştir. Linux sistemlerinde yapı şöyle bildirilmiştir:

    struct msqid_ds {
        struct ipc_perm msg_perm;   /* Ownership and permissions */
        time_t          msg_stime;  /* Time of last msgsnd(2) */
        time_t          msg_rtime;  /* Time of last msgrcv(2) */
        time_t          msg_ctime;  /* Time of creation or last
                                        modification by msgctl() */
        unsigned long   msg_cbytes; /* # of bytes in queue */
        msgqnum_t       msg_qnum;   /* # number of messages in queue */
        msglen_t        msg_qbytes; /* Maximum # of bytes in queue */
        pid_t           msg_lspid;  /* PID of last msgsnd(2) */
        pid_t           msg_lrpid;  /* PID of last msgrcv(2) */
    };

    Yapının msg_perm elemanı ipc_perm isimli yapı türünden nesnedir. ipc_perm yapısı da şöyle bildirilmiştir:

    struct ipc_perm {
        uid_t uid;                      /* Effective UID of owner */
        gid_t gid;                      /* Effective GID of owner */
        uid_t cuid;                     /* Effective UID of creator */
        gid_t cgid;                     /* Effective GID of creator */
        unsigned short mode;            /* Permissions */
    };

    Buradaki cuid ve cgid elemanları mesaj kuyruğunu ilk yaratan prosesin etkin kullanıcı ve grup id'sini belirtmektedir. Normal olarak 
    uid ve gid elemanları cuid ve cgid elemanlarıyla aynı değerdedir. Ancak daha sonra msgctl fonksiyonu ile bu değerler değiştirilebilmektedir. 
    Yapının mode elemanı da mesaj kuyruğunun erişim haklarını belirtmektedir. msqid_ds yapısının msg_stime, msg_rtime ve msg_ctime
    elemanları mesaj kuyruğuna en son yapılan msgsnd, msgrcv ve msgctl işlemlerinin zamanlarını belirtmektedir. Yapının msg_cbytes 
    elemanı (POSIX standartlarında bu eleman belirtilmemiştir, ancak Linux sistemlerinde bulunmaktadır) mesaj kuyruğundaki tüm mesajların
    mesajın tür değeri haricindeki kısımlarının byte uzunluğunu belirtmektedir. Yapının msg_qnum elemanı ise mesaj kuruğundaki o anda 
    bulunan mesaj sayısını belirtir. Yapının msg_qbytes elemanı mesaj kuruğunun tutabileceği mesaj tür değeri haricindeki kısımların 
    toplam byte sayısını belirtmektedir. Bu değer mesaj kuyruğu yaratılırken Linux sistemlerinde MSGMNB değeri olarak yapıya aktarılmaktadır. 
    Yapının msg_lspid ve msg_lrpid elemanları sırasıyla kuyruğua son msgsnd yapan prosesin id değerini ve kuyruktan son msgrcv yapan prosesin 
    id değerini belirtmektedir. 

    Yapı bildirimindeki msgqnum_t ve msglen_t tür isimleri <sys/msg.h> içerisinde işaretsiz bir tamsayı türü olarak (ama en azından unsigned short
    uzunlukta) bildirilmelidir. 

    Bizim mesaj kuyruğuna mesaj yazabilmemiz için mesaj kuyruğuna "write" hakkına, mesaj kuyrupundan mesaj okuyabilmemiz içim 
    mesaj kuyruğundan "read" hakkına sahip olmamız gerekir. Buradaki erişim kontrolü tıpkı dosyalarda olduğu gibi yapılmaktadır. 
    Ancak "owner" kontrolü burada msqid_ds yapısının msg_perm yapı elemanının uid elemanı ile ve "group" kontrolü ise aynı yapının 
    gid elemanı ile belirlenmeketdir. Normal olarak yukarıda da belirttiğimiz gibi mesaj kuyruğu yaratıldığında ipc_perm yapısının 
    uid ve gid elemanları cuid ve cgid elemanlarıyla aynı değerdedir. Ancak daha sonra izleyen paragraflarda ele alacağımız üzere IPC_SET işlemi 
    ile bunlar farklılaşabilirler. Tabii mesaj kuyruğunun yaratıcısına ilişkin cuid ve cgid değerleri değiştirilememektedir. 

    Fonksiyon başarı durumunda 0 değeri ile başarısızlık durumunda -1 değeri ile geri dönmektedir.   
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------    
    msgctl fonksiyonunun ikinci parametresi IPC_STAT geçilirse bu durumda mesaj kuyruğu bilgileri elde edilerek msgid_ds yapı nesnesinin 
    içine yerleştirilmektedir. Örneğin:

    struct msqid_ds msginfo;
    ...

    if (msgctl(msgid, IPC_STAT, &msgino) == -1)
        exit_sys("msgctl");

    Aşağıda bir mesaj kuyruğu yaratılıp (ya da açılıp) içerisine iki mesaj yerleştirilmiş sonra da msgctl fonksiyonu ile IPC_STAT 
    parametresi kullanılarak mesaj kuyruğu bilgileri elde edilmiştir. 
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdint.h>
#include <sys/stat.h>
#include <sys/msg.h>
#include <sys/ipc.h>

#define KEY_NAME			"/home/kaan"
#define KEY_ID				321

struct MSG {
	long mtype;
	char buf[8192];
};

void exit_sys(const char *msg);

int main(void)
{
	int msgid;
	struct MSG msg;
	key_t key;
    struct msqid_ds msginfo;

	if ((key = ftok(KEY_NAME, KEY_ID)) == -1)
		exit_sys("ftok");

	if ((msgid = msgget(key, IPC_CREAT|S_IRUSR|S_IWUSR|S_IRGRP|S_IROTH)) == -1)
		exit_sys("msgget");

    msg.mtype = 1;
    strcpy(msg.buf, "test");

    if (msgsnd(msgid, &msg, 4, 0) == -1)
        exit_sys("msgsnd");
    
    if (msgsnd(msgid, &msg, 4, 0) == -1)
        exit_sys("msgsnd");

    if (msgctl(msgid, IPC_STAT, &msginfo) == -1)
        exit_sys("msgctl");

    printf("Maximum number of bytes: %ju\n", (uintmax_t)msginfo.msg_qbytes);    /* 16384 ama değişebilir */
    printf("Maximum number of bytes: %ju\n", (uintmax_t)msginfo.msg_qnum);      /* 2 */

    return 0;    
}

void exit_sys(const char *msg)
{
	perror(msg);

	exit(EXIT_FAILURE);
}

/*--------------------------------------------------------------------------------------------------------------------------
    msgctl fonksiyonunun ikinci parametresi IPC_SET olarak girilirse bu durumda mesaj kuyruğuna ilişkin bazı değerler set edilebilmektedir. 
    Ancak bu durumda msqid_ds yapısının tüm elemanları değil yalnızca aşağıda belirtilen elemanları değiştirilmektedir:

    msg_perm.uid
    msg_perm.gid
    msg_perm.mode
    msg_qbytes

    IPC_SET işleminin yapılabilmesi için fonksiyonu çağıran prosesin etkin kullanıcı id'sinin mesaj kuyruğunda belirtilen 
    msg_perm.uid ya da msg_perm.cuid değerine eşit olması ya da prosesin uygun önceliğe sahip olması (root) gerekmektedir. IPC_SET işlemi yapılırken msqid_ds 
    yapısının diğer elemanları zaten dikkate alınmamaktadır. TYani diğer elemanlarda geçersiz değerlerin olması önemli değildir. Tabii programcı yalnızca belli bir 
    değeri değiştrecekse önce IPC_STAT yapıp ondan sonra IPC_SET uygulamalıdır. Çünkü IPC_SET yukarıdaki elemanların hepsinindeğiştirmektedir. 
    msqid_ds yapısının msg_qbytes elemanının değiştirilmesi yalnızca uygun önceliğe sahip (örnein root) prosesler tarafından yapılabilmektedir. 

    Aşağdaıki örnekte mesaj kuyruğuna ilişkin durum bilgisi IPC_STAT parametresiyle elde edilip IPC_SET parametresiyle kuyruğun msg_qbytes
    elemanı değiştirilmiştir. Ancak bunun yapılabilmesi için programın sudo ile çalıştırılması gerekir. 
---------------------------------------------------------------------------------------------------------------------------*/
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdint.h>
#include <sys/stat.h>
#include <sys/msg.h>
#include <sys/ipc.h>

#define KEY_NAME			"/home/kaan"
#define KEY_ID				321

void exit_sys(const char *msg);

int main(void)
{
	int msgid;
	key_t key;
    struct msqid_ds msginfo;

	if ((key = ftok(KEY_NAME, KEY_ID)) == -1)
		exit_sys("ftok");

	if ((msgid = msgget(key, IPC_CREAT|S_IRUSR|S_IWUSR|S_IRGRP|S_IROTH)) == -1)
		exit_sys("msgget");

    if (msgctl(msgid, IPC_STAT, &msginfo) == -1)
        exit_sys("msgctl");

    printf("Maximum number of bytes: %ju\n", (uintmax_t)msginfo.msg_qbytes);   /* muhtemelen 16384 */

    msginfo.msg_qbytes = 30000;

    if (msgctl(msgid, IPC_SET, &msginfo) == -1)
        exit_sys("msgctl");
    
    if (msgctl(msgid, IPC_STAT, &msginfo) == -1)
        exit_sys("msgctl");

    printf("Maximum number of bytes: %ju\n", (uintmax_t)msginfo.msg_qbytes);   /* 30000 */

    return 0;    
}

void exit_sys(const char *msg)
{
	perror(msg);

	exit(EXIT_FAILURE);
}

/*--------------------------------------------------------------------------------------------------------------------------
    Mesaj kuyruğunu silmek için msgctl fonksiyonu IPC_RMID parametresiyle çağrılmalıdır. Mesaj kuyruğunun bu biçimde silinebilmesi 
    için prosesin uygun önceliğe sahip olması (örneğin root olması) ya da prosesin etkin kullanıcı id'sinin msqid_ds yapısındaki 
    ipc_perm.uid ya da ipc_perm.cuid değerine eşit olması gerekmektedir. Yani özetle biz root değilsek başkasının mesaj kuyruğunu silemeyiz. 
    Tabii mesaj kuyrukları bu biçimde silinmezse zaten reboot işleminde otomatik olarak silinmektedir. Mesaj kuyrukları silindiğinde 
    artık o anda mesaj kuyruğunu kullanmakta olan prosesler hemen error ile geri dönmektedir. (Yani dosya sistemind eolduğu gibi gerçek 
    silme tüm kullanan proseslerin kaynağı bırakmasıyla değil o anda yapılmaktadır.) IPC_RMID parametresi kullanılırken artık üçüncü 
    parametreye gereksinimn duyulmamaktadır. Bu parametre NULL oalrak geçilebilir. Örneğin:

    if (msgctl(msgid, IPC_RMID, NULL) == -1)
        exit_sys("msgctl");

    Aşağıda daha önce oluşturulmuş olan mesaj kuyruğu msgctl fonksiyonu ve IPC_RMID parametresi ile silinmiştir. 
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdint.h>
#include <sys/stat.h>
#include <sys/msg.h>
#include <sys/ipc.h>

#define KEY_NAME			"/home/kaan"
#define KEY_ID				123

void exit_sys(const char *msg);

int main(void)
{
	int msgid;
	key_t key;
    
	if ((key = ftok(KEY_NAME, KEY_ID)) == -1)
		exit_sys("ftok");

	if ((msgid = msgget(key, IPC_CREAT|S_IRUSR|S_IWUSR|S_IRGRP|S_IROTH)) == -1)
		exit_sys("msgget");

    if (msgctl(msgid, IPC_RMID, NULL) == -1)
        exit_sys("msgctl");

    return 0;    
}

void exit_sys(const char *msg)
{
	perror(msg);

	exit(EXIT_FAILURE);
}

/*--------------------------------------------------------------------------------------------------------------------------
    Linux'a özgü bir biçimde msgctl fonksiyonunda ikinci parametrede bazı özel değerler de kullanılabilmektedir. Bu özel değerler 
    şunlardır:

    IPC_INFO 
    MSG_INFO 
    MSG_STAT 
    MSG_STAT_ANY 

    Biz kursumuzda standart olmayan bu parametreler üzerinde durmayacağız. Ancak ilgili man sayfalarından ya da başka dokğmanlardan 
    bu parametrelerin işlevleri konusunda bilgdi edinebilirsiniz. 
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Klasik Sistem 5 IPC mekanizması için iki önemli kabuk komutu vardır: ipcs ve ipcrm. Biz daha önce ipcs komutunu görmüştük. Bu 
    komutun /proc/sysvipc dizinindeki msg, sem ve shm dosyalarını okuyarak işlem yaptığını belirtmiştik. İşte ipcrm komutu ise
    belli bir ipc nesnesini silmek için kullanılmaktadır. ipcrm silme işlemini anahtara göre (büyük harfler) ya da id'lere göre (küçük harfler)
    yapabilmektedir. Örneğin mesaj kıuruklarının ipcrm ile silinmesi anahtar belirtilerek -Q seçeneği ile id belirtilerek -q 
    seçeneği ile yapılabilmektedir. Tabii bu komut aslında msgctl fonksiyonunu kullanarak yazılmıştır. Örneğin:

    ipcrm -Q 0x7b050002

    ya da örneğin:

    ipcrm -q 3
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
                                                        43. Ders 02/04/2023 - Pazar
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Daha önceden de belirttiğimiz gibi klasik System 5 IPC nesnelerinin 1990'lı yıllarda alternatif yeni biçimleri oluşturulmuştur. 
    Bunlara halk arasında "POSIX IPC nesneleri" denilmektedir. Bu nesneler sonradan UNIX/Linux dünyasına katıldığı için belli bir süre 
    taşınabilirlik problemlerine sahipti. Ancak artık bu nesneler de yaygın tüm UNIX/Linux sistemlerinde bulunmaktadır. 

    POSIX IPC mekanizmasının klasik System 5 IPC mekanizmasından en önemli farklılıklarından biri IPC nesnesinin belirlenmesi için 
    bir anahtarın değil doğrudan bir dosya isminin kullanılmasıdır. Yani adeta isimli borularda olduğu gibi iki proses bir dosya
    isminde anlaşmaktadır. POSIX IPC nesneleri birer dosya ismiyle temsil edilmiş olsa da bu isimli dosyalar bir dizin girişi 
    biçiminde bulundurulmamaktadır. Daha doğrusu böyle bir zorunluluk yoktur. POSIX standartlarına göre POSIX IPC nesnelerine ilişkin 
    dosya isimleri "kök dizinde bir dosya" belirtmelidir. Örneğin "/my_message_queue" gibi. POSIX buradaki dosya isminin kök dizinde olmasını 
    zorunlu hale getirmemiştir. Ancak bunun işletim sistemine bağlı olduğunu belirtmiştir. Yani programcı eğer ilgili işletim sistemi 
    kabul ediyorsa buradaki dosya ismini başka bir dizindeki dosya ismi gibi verebilir. Ancak taşınabilir programların bu isimleri kök 
    dizinde uydurması gerekmektedir. Her ne kadar isimlerin bile çakışabileceği mümkünse de bu olasılık sayısal anahtarların çakışmasından 
    çok daha düşüktür. 

    POSIX IPC mekanizmasının System 5 IPC mekanizmasından diğer önemli faklılığı POSIX IPC mekanizmasının "dosya işlemlerine" benzetilmesidir. 
    Yani bu işlemler adeta dosya işlemleri gibi ele alınmaktadır. Örneğin klasik System 5 mesaj kuyruğunu birisi msgctl fonksiyonu ile sildiğinde 
    o anda bu kuyruk üzerinde işlem yapan fonksiyonlar başarısızlıkla geri dönerler. Ancak POSIX mesaj kuyruklarında birisi dışarıdan 
    bu mesaj kuyruğunu silse bile, son proses bu mesaj kuyruğunu kapatmadan gerçek silme yapılmamaktadır. Bu durum adeta dosya silmedeki 
    "unlink/remove" fonksiyonlarına benzemektedir. 

    Hem klasik System 5 hem de POSIX IPC nesneleri silinene kadar ya da reboot işlemine kadar hayatta kalmaktadır (kernel persistant). 
    Bu bakımdan bu iki nesne grubu biribirine benzemektedir. 

    Klasik System 5 ve POSIX IPC mekanizmasını yöneten fonksiyonlarda da arayüz bakımından bazı farklılıklar vardır. POSIX IPC fonksiyonunlarının 
    isimlendirme tarzları da farklıdır. Örneğin mesaj kuyruklarını yaratmak için klasik System 5 kuyruklarında msgget fonksiyonu kullanılırken 
    POSIX mesaj kuyruklarında mq_open fonksiyonu kullanılmaktadır. Tabii isimlendirme ve genel kullanım POSIX IPC nesnelerinin arasında tutarlı 
    bir biçimde oluşturulmuştur.

    POSIX IPC nesneleri POSIX'in "real time extension" ekleriyle standartlara dahil edilmiştir. Bu fonksiyonlar bu nedenle libc kütüphanesinin
    içerisinde değil librt kütüphanesinin içerisinde bulunmaktadır. Bu nedenle POSIX IPC nesnelerini kullanan programları derlerken -lrt seçeneğinin
    kullanılması gerekir. Örneğin:

    gcc -o sample sample.c -lrt
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    POSIX mesaj kuyrukları şöyle kullanılmaktadır:

    1) İki proses de (daha fazla proses de olabilir) mesaj kuyruğunu mq_open fonksiyonuyla ortak bir isim altında anlaşarak açar. 
    mq_open fonksiyonunun prototipi şöyledir:

     #include <mqueue.h>

    mqd_t mq_open(const char *name, int oflag, ...);

    Fonksiyon ya iki argümanla ya da dört argümanla çağrılmaktadır. Eğer mesaj kuyruğu zaten varsa fonksiyon iki argümanla çağrılır. 
    Ancak mesaj kuyruğunun yaratılması gibi bir durum söz konusu ise fonksiyon dört argümanla çağrılır. Eğer mesaj kuyruğunun yaratılması 
    söz konusu ise son iki parametre sırasıyla IPC nesnesinin erişim hakları ve "özellikleri (attribute)" girilmelidir. Yani mesaj kuyruğu
    yaratılacaksa adeta fonksiyonun parametrik yapısının aşağıdaki gibi olduğu varsayılmalıdır:

    mqd_t mq_open(const char *name, int oflag, mode_t mode, const struct mq_attr *attr);

    Fonksiyonun birinci parametresi IPC nesnesinin kök dizindeki dosya ismi gibi uydurulmuş olan ismini belirtir. İkinci parametre 
    açış bayraklarını belirtmektedir. Burada open fonksiyonundaki bayrakların bazıları kullanılmaktadır. Açış bayrakları aşağıdakilerden 
    yalnızca birini içermek zorundadır:

    O_RDONLY
    O_WRONLY
    O_RDWR

    Açış bayraklarına aşağıdaki değerlerin bir ya da birden fazlası da bit OR işlemiyle eklenebilir:

    O_CREAT
    O_EXCL
    O_NONBLOCK

    O_CREAT bayrağı yine "yoksa yarat, varsa olanı aç" anlamına gelmektedir. O_EXCL yine O_CREAT birlikte kullanılabilir. 
    Eğer nesne zaten varsa bu durumda fonksiyonun başarısız olmasını sağlar. O_NONBLOCK blokesiz okuma yazma yapmak için 
    kullanılmaktadır. 

    Eğer açış bayrağında O_CREAT belirtilmişse bu durumda programcının fonksiyona iki argüman daha girmesi gerekir. Tabii eğer 
    nesne varsa bu iki argüman zaten kullanılmayacaktır. Yani bu argüman IPC nesnesi yaratılacaksa (yoksa) kullanılmaktadır. 
    Mesaj kuyruğu yaratılırken erişim haklarını tıpkı dosyalarda olduğu gibi kuyruğu yaratan kişi S_IXXX sembolik sabitleriyle
    (ya da 2008 sonrasında doğrudan sayısal biçimde) vermelidir. Eğer mesaj kuyruğu yaratılacaksa son parametre mq_attr isimli yapı türünden 
    bir nesnenin adresi biçiminde girilmelidir. mq_attr yapısı şöyle bildirilmiştir:

    struct mq_attr {
        long mq_flags;       /* Flags: 0 or O_NONBLOCK */
        long mq_maxmsg;      /* Max. # of messages on queue */
        long mq_msgsize;     /* Max. message size (bytes) */
        long mq_curmsgs;     /* # of messages currently in queue */
    };

    Yapının mq_flags parametresi yalnızca O_NONBLOCK içerebilir. max_msg elemanı kuyruktaki tutulacak maksimum mesaj sayısını belirtmektedir. 
    Yapının mq_msgsize elemanı bir mesajın maksimum uzunluğunu belirtmektedir. mq_curmsgs elemanı ise o anda kuyruktaki mesaj sayısını belirtmektedir. 
    Programcı mesaj kuyruğunu yaratırken yapının mq_maxmsg ve mq_msgsize elemanlarına uygun değerler girip mesaj kuyruğunun istediği gibi 
    yaratılmasını sağlayabilir. Yani mesaj kuyruğu yaratılırken programcı mq_attr yapısının yalnızca mq_maxmsg ve mq_msgsize elemanlarını doldurur. 
    Yapının diğer elemanları mq_open tarafından dikkate alınmamaktadır. Ancak bu özellik parametresi NULL adres biçiminde de geçilebilir. 
    Bu durumda mesaj kuyruğu default değerlerle yaratılır. Bu default değerler değişik sistemlerde değişik biçimlerde olabilir. Linux sistemlerinde
    genel olarak default durumda maksimum mesaj mq_maxmsg değeri 10, mq_msgsize değeri ise 8192 alınmaktadır. mq_open fonksiyonunda kuyruk özelliklerini 
    girerken mq_maxmsg ve mq_msgsize elemanlarına girilecek değerler için işletim sistemleri alt ve üst limit belirlemiş olabilirler. Eğer yapının bu 
    elemanları bu limitleri aşarsa mq_open fonksiyonu başarısız olur ve errno değişkeni EINVAL olarak set edilir. Örneğin Linux sistemlerinde 
    sıradan prosesler (yani root olmayan prosesler) mq_maxmsg değerini 10'un yukarısına çıkartamamaktadır. Ancak uygun önceliğe sahip prosesler 
    bu değeri 10'un yukarısında belirleyebilmektedir. Ancak POSIX standartları bu default limitler hakkında bir şey söylememiştir. Linux sistemlerinde
    sonraki paragraflarda açıklanacağı gibi bu limitler proc dosya sisteminden elde edilebilmektedir. 
  
    mq_open fonksiyonu başarı durumunda yaratılan mesaj kuyruğunu temsil eden betimleyici değeriyle, başarısızlık durumunda -1 değeriyle geri dönmektedir. 
    Fonksiyonun geri döndürdüğü "mesaj kuyruğu betimleyicisi (message queue desctiptor)" diğer fonksiyonlarda bir handle değeri gibi 
    kullanılmaktadır. Linux çekirdeği aslında mesaj kuyruklarını tamamen birer dosya gibi ele almaktadır. Yani mq_open fonksiyonu
    Linux sistemlerinde dosya betimleyici tablosunda bir betimleyici tahsis edip ona geri dönmektedir. Ancak POSIX standartları 
    fonksiyonun geri dönüş değerini mqd_t türüyle temsil etmiştir. Bu durum değişik çekirdeklerde mesaj kuyruklarının dosya sisteminin dışında
    başka biçimlerde de gerçekleştirilebileceği anlamına gelmektedir. POSIX standartlarına göre mqd_t herhangi bir tür olarak (yapı da dahil olmak üzere)
    <mqueue.h> dosyasında typedef edilebilir. 

    2) POSIX mesaj kuyruğuna mesaj yollamak için mq_send fonksiyonu kullanılmaktadır. Fonksiyonun prototipi şöyledir:

    #include <mqueue.h>

    int mq_send(mqd_t mqdes, const char *msg_ptr, size_t msg_len, unsigned msg_prio);

    Fonksiyonun birinci parametresi mesaj kuyruğunun betimleyicisini belirtir. Fonksiyonun ikinci parametresi mesajın bulunduğu 
    dizinin adresini almaktadır. Ancak bu parametrenin void bir adres olmadığına dikkat ediniz. Eğer mesaj başka türlere ilişkinse 
    tür dönüştürmesinin yapılması gerekmektedir. Üçüncü parametre gönderilecek mesajın uzunluğunu belirtir. Dördüncü parametre 
    mesajın öncelik derecesini belirtmektedir. Bu öncelik derecesi >= 0 bir bir değer olarak girilmelidir. POSIX mesaj kuyruklarında
    öncelik derecesi yüksek olan mesajlar FIFO sırasına göre önce alınmaktadır. Bu mesaj kuyruklarının klasik System 5 mesaj kuyruklarında 
    olduğu gibi belli bir öncelik derecesine sahip mesajları alabilme yeteneği yoktur. Buradaki öncelik derecesinin <limts.h> içerisindeki 
    MQ_PRIO_MAX değerinden küçük olması gerekmektedir. Bu değer ise işletim sistemlerini yazanlar tarafından belirlenmektedir. Ancak bu değer 
    _POSIX_MQ_PRIO_MAX (32) değerinden düşük olamaz. Yani başka bir deyişle buradaki desteklenen değer 32'den küçük olamamaktadır. 
    (Mevcut Linux sistemlerinde bu değer 32768 biçimindedir.)

    Fonksiyon başarı durumunda 0 değerine başarısızlık durumunda -1 değerine geri döner ve errno değişkeni uygun biçimde set edilir. 

    POSIX mesaj kuyruklarının da izleyen paragraflarda açıklanacağı üzere belli limitleri vardır. Eğer mesaj kuyruğu dolarsa mq_send 
    fonksiyonu bloke olmaktadır. Ancak açış sırasında O_NONBLOCK bayrağı belirtilmişse mq_send kuyruk doluysa bloke olmaz. Kuyruğa 
    hiçbir şey yazmadan başarısızlıkla (-1 değeriyle) geri döner ve errno EAGAIN değeri ile set edilir. 

    Örneğin:

    for (int i = 0; i < 100; ++i) {
        if (mq_send(mqdes, (const char *)&i, sizeof(int), 0) == -1)
            exit_sys("mq_send");
    }

    Burada 0'dan 100'e kadar 100 tane int değer mesaj kuyruğuna mesaj olarak yazılmıştır. 

    Mesaj kuyruklarının kendi içerisinde bir senkronizasyon da içerdiğine dikkat ediniz. Kuyruğa yazan taraf kuyruk dolarsa 
    (Linux'taki default değerin 10 olduğunu anımsayınız) blokede beklemektedir. Ta ki diğer taraf kuruktan mesajı alıp kuyrukta 
    açana kadar.

    3) POSIX mesaj kuyruklarından mesaj almak için mq_receive fonksiyonu kullanılmaktadır. Fonksiyonun prototipi şöyledir:

    #include <mqueue.h>

    ssize_t mq_receive(mqd_t mqdes, char *msg_ptr, size_t msg_len, unsigned *msg_prio);

    Fonksiyonun birinci parametresi mq_open fonksiyonundan elde edilen mesaj kuyruğu betimleyicisidir. İkinci parametre mesajın 
    yerleştirileceği adresi belirtmektedir. Yine bu parametrenin void bir gösterici olmadığına char türden bir gösterici olduğuna dikkat ediniz. 
    Yani char türünden farklı bir adres buraya geçilecekse tür dönüştürmesi uygulanmalıdır. Üçüncü parametre ikinci parametredeki 
    mesajın yerleştirileceği alanın uzunluğunu belirtir. Ancak dikkat edilmesi gereken nokta buradaki uzunluk değerinin mesaj kuyruğundaki 
    mq_msgsize değerinden küçük olmaması gerektiğidir. Eğer bu parametreye girilen değer mesaj kuyruğuna ilişkin mq_msgsize değerinden 
    küçük ise fonksiyon hemen başarısız olmaktadır. Bu durumda errno değişkeni EMSGSIZE değeri ile set edilmektedir. Pekiyi bu değeri 
    mq_receive fonksiyonunu uygulayacak programcı nasıl bilecektir? Eğer kuyruğu kendisi yaratmışsa ve yaratım sırasında mq_attr parametresiyle
    özellik belirtmişse programcı zaten bunu biliyor durumdadır. Ancak genellikle mq_receive fonksiyonunu kullanan programcılar bunu bilmezler. Çünkü 
    genellikle kuyruk mq_receive yapan programcı tarafından yaratılmamıştır ya da kuyruk default özelliklerle yaratılmıştır. Bu durumda mecburen 
    programcı mq_getattr fonksiyonu ile bu bilgiyi elde etmek zorunda kalır. Tabii bu işlem programın çalışma zamanında yapıldığına göre programcının 
    mesajın yerleştirileceği alanı da malloc fonksiyonu ile dinamik bir biçimde tahsis etmesi gerekmektedir. mq_receive fonksiyonun son parametresi 
    kuyruktan alınan mesajın öncelik derecesinin yerleştirileceği unsigned int türden nesnenin adresini almaktadır. Ancak bu parametre NULL 
    adres biçiminde geçilebilir. Bu durumda fonksiyon mesajın öncelik derecesini yerleştirmez. 

    Fonksiyon başarı durumunda kuyruktaki mesajın uzunluğu ile, başarısızlık durumunda -1 ile geri dönmektedir ve errno değişkeni 
    uygun biçimde set edilmektedir. 

    Örenğin:

    char buf[65536];
    ...
    if (mq_receive(mqdes, buf, 65536, NULL) == -1) 
            exit_sys("mq_receive");

    Burada biz mesajın önceliğini almak istemedik. Bu nedenle son parametreye NULL adres geçtik. Tampon uzunluğunu öylesine 
    büyük bir değer olarak uydurduk. Aslında yukarıda da belirttiğimiz gibi mq_receive uyguladığımız noktada bizim tampon uzunluğunu 
    biliyor durumda olmamız gerekir. 

    4) Pekiyi POSIX mesaj kuyruklarında mesaj haberleşmesi nasıl sonlandırılacaktır. Burada da karşı taraf betimleyiciyi kapattığında diğer taraf bunu 
    anlayamamaktadır. O halde heberleşmenin sonlanması için gönderen tarafın özel bir mesajı göndermesi ya da 0 uzunlukta bir mesajı
    göndermesi gerekir. Eğer 0 uzunluklu mesaj gönderilirse alan tarafta mq_receive fonksiyonu 0 ile geri dönecek ve alan taraf haberleşmenin 
    bittiğini anlayabilecektir. 

    5) POSIX mesaj kuyruğu ile işlemler bitince programcı mesaj kuyruğunu mq_close fonksiyonu ile kapatmalıdır. Fonksiyonun prototipi şöyledir:

    #include <mqueue.h>

    int mq_close(mqd_t mqdes); 

    Fonskiyon parametre olarak mesaj kuyruğu betimleycicisini alır. Başarı durumunda 0 değerine başarısızlık durumunda -1 değerine geri döner. 
    Programcı her şeyi doğru yaptığına inanıyorsa başarının kontrol edilmesine gerek yoktur. 

    Tabii eğer programcı mq_close fonksiyonunu hiç kullanmazsa proses bittiğinde otomatik olarak betimleyici kapatılmaktadır.

    6) POSIX mesaj kuyrukları mq_unlink fonksiyonu ile silinmektedir. Tabii yukarıda da belirtitğimiz gibi mesaj kuyruğu 
    açıkça silinmezse reboot edilene kadar (kernel persistant) yaşamaya ve içerisindeki mesajları tutmaya devam etmektedir. Bir POSIX mesaj 
    kuyruğu mq_unlink fonksiyonu ile silindiğinde halen mesaj kuyruğunu kullanan programlar varsa onlar kullanmaya devam ederler. 
    Mesaj kuyruğu gerçek anlamda son mesaj kuyruğu betimleyicisi kapatıldığında yok edilmektedir. mq_unlink fonksiyonunun prototipi şöyledir:

    #include <mqueue.h>

    int mq_unlink(const char *name);

    Fonksiyon mesaj kuyruğunun ismini alır. Başarı durumunda 0 değerine, başrısızlık durumnda -1 değerine geri döner. 

    Mesaj kuyruğunu kuyruğu yaratan tarafın silmesi en normal durumdur. Ancak kuyruğu kimin yarattığı bilinmiyorsa taraflardan biri 
    kuyruğu silebilir. 
---------------------------------------------------------------------------------------------------------------------------*/

/* prog1.c */

#include <stdio.h>
#include <stdlib.h>
#include <sys/stat.h>
#include <mqueue.h>

#define MSGQUEUE_NAME       "/test_queue"

void exit_sys(const char *msg);

int main(void)
{
    mqd_t mqdes;
    struct mq_attr attr;

    attr.mq_maxmsg = 10;
    attr.mq_msgsize = 32;
    
    if ((mqdes = mq_open(MSGQUEUE_NAME, O_WRONLY|O_CREAT, S_IRUSR|S_IWUSR|S_IRGRP|S_IROTH, &attr)) == -1)
        exit_sys("mq_open");

    for (int i = 0; i < 100; ++i) {
        if (mq_send(mqdes, (const char *)&i, sizeof(int), 0) == -1)
            exit_sys("mq_send");
    }

    mq_close(mqdes);

    if (mq_unlink(MSGQUEUE_NAME) == -1)
        exit_sys("mq_unlink");

    return 0;    
}

void exit_sys(const char *msg)
{
	perror(msg);

	exit(EXIT_FAILURE);
}

/* prog2.c */

#include <stdio.h>
#include <stdlib.h>
#include <sys/stat.h>
#include <mqueue.h>

#define MSGQUEUE_NAME       "/test_queue"

void exit_sys(const char *msg);

int main(void)
{
    mqd_t mqdes;
    char buf[32];       
    int val;

    if ((mqdes = mq_open(MSGQUEUE_NAME, O_RDONLY)) == -1)
        exit_sys("mq_open");

    for (;;) {
        if (mq_receive(mqdes, buf, 32, NULL) == -1) 
            exit_sys("mq_receive");
        val = *(const int *)buf;
        printf("%d ", val);
        fflush(stdout);
        if (val == 99)
            break;
    }
    printf("\n");

    mq_close(mqdes);

    return 0;    
}

void exit_sys(const char *msg)
{
	perror(msg);

	exit(EXIT_FAILURE);
}

/*--------------------------------------------------------------------------------------------------------------------------
                                                    44. Ders 08/04/2023 - Cumartesi
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Pekiyi mesajı alan taraf tutacağı tamponun büyüklüğünü nasıl anlayacaktır? Çünkü oluşturulması gereken tampon mesaj 
    kuyruğu yaratılırken kullanılan struct mq_attr yapısının içerisinde belirtilmektedir. Anımsanacağı gibi mesaj kuyruğu yaratılırken
    mq_open fonksiyonunda mq_attr parametresi NULL geçilirse mesaj kuyruğundaki mesaj uzunlukları için default değer alınmaktadır. 
    Her ne kadar Linux sistemlerinde şu anda bu default değer 8192 ise de başka sistemlerde ve Linux'ta ileride bunun böyle 
    olacağının bir garantisi yoktur. Yukarıdaki örnekte olduğu gibi mesaj kuyruğu yaratılırken bu değer programcı tarafından 
    belirleniyorsa zaten bu değer bilinmektedir. Ancak mq_open fonksiyonunda özellik parametresi NULL geçilebilir. Ya da 
    mesajı okuyacak taraf bunu bilmeyebilir. Bu durumda uygulanacak şey mq_gettattr fonksiyonu ile mesaj kuyruğunun özelliklerinin 
    alınması ve tamponun dinamik bir biçimde orada belirtilen mq_msgsize değeri kadar oluşturulmasıdır. 

    mq_getattr fonksiyonu mesaj kuyruğunun özellik bilgisini almak için kullanılır. Fonksiyonun prototipi şöyledir:

     #include <mqueue.h>

    int mq_getattr(mqd_t mqdes, struct mq_attr *attr);

    Fonksiyonun birinci parametresi mq_open fonksiyonu ile elde edilen mesaj kuyruğu betimleyicisidir. İkinci parametre ise 
    mesaj kuyruğu özelliklerinin yerleştirileceği mq_attr yapısının adresini almaktadır. Fonksiyon başarı durumunda 0, başarısızlık durumunda 
    -1 değerine geri dönmektedir. 

    Mesaj kuyruğu yaratıldıktan sonra mesaj kuyruğunun özellikleri mq_setattr fonksiyonu ile de değiştirilebilir. Fonksiyonun prototipi 
    şöyledir:

    #include <mqueue.h>

    int mq_setattr(mqd_t mqdes, struct mq_attr *newattr, struct mq_attr *oldattr);

    Fonksiyonun birinci parametresi mesaj kuyruğu betimleyicisini belirtir. İkinci parametre yeni özelliklerin bulunduğu struct mq_attr
    yapı nesnesinin adresini alır. Üçüncü parametre ise değiştirilmeden önceki mesaj kuyruğu özelliklerini elde etmek için kullanılan 
    yapı nesnesinin adresini belirtir. Bu parametre NULL adres olarak geçilebilir. Fonksiyon başarı durumunda 0 değerine başarısızlık durumunda 
    -1 değerine geri dönmektedir. mq_setattr fonksiyonu ile mq_attr yapısının yalnızca flags parametrtesi dikkate alınmaktadır. 
    Dolayısıyla değiştirilebilecek tek özellik aslında O_NONBLOCK bayrağıdır. Yapının diğer elemanları fonksiyon tarafından dikkate alınmamaktadır. 
    (Mesaj kuruğu yaratıldıktan sonra maksimum mesaj sayısının ya da mesaj uzunluklarının değiştirilmesi zaten genel olarka uygun değildir.)

    Aşağıdaki örnekte "prog1" programı stdin dosyasındna mesajı ve mesajın öncelik değerini alarak mesaj kuyruğuna yazmaktadır. 
    "prog2" programı da mesaj kuyruğundan bu bilgileri alarak stdout dosyasında bunları görüntülemektedir. Burada öncelikteki 
    yüksek değerin gerçek yüksek öncelik anlamına geldiğine dikkat ediniz. (Halbuki klasik System 5 mesaj kuyruklarında yüksek öncelik 
    düşük değerler temsil edilmektedir.) Bu programları çalıştırırken öncelik testini yapabilmek için önce "prog1" programını çalıştırıp 
    kuyruğua çeşitli önceliklerde mesajlar gönderiniz. Sonra "prog2" programını çalıştırıp durumu gözleyiniz. Örnekteki prog2 
    programı önce mq_gettatr fonksiyonu ile mesaj kuyruğundaki maksimum mesaj uzuluğunu elde etmiş ve o uzunlukta dinamik bir alan tahsis 
    etmiştir. 
---------------------------------------------------------------------------------------------------------------------------*/

/* prog1.c */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/stat.h>
#include <mqueue.h>

#define MSGQUEUE_NAME       "/my_message_queue"

void clear_stdin(void);
void exit_sys(const char *msg);

int main(void)
{
    mqd_t mqdes;
    char buf[8192];
    char *str;
    int prio;
    
    if ((mqdes = mq_open(MSGQUEUE_NAME, O_WRONLY|O_CREAT, S_IRUSR|S_IWUSR|S_IRGRP|S_IROTH, NULL)) == -1)
        exit_sys("mq_open");

	for (;;) {		
		printf("Message text:");
		fflush(stdout);
		
		if (fgets(buf, 8192, stdin) == NULL)
			continue;
		if ((str = strchr(buf, '\n')) != NULL)
			*str = '\0';

        printf("Priority:");
        fflush(stdout);
        scanf("%d", &prio);

        clear_stdin();

        if (mq_send(mqdes, buf, strlen(buf), prio) == -1)
            exit_sys("mq_send");

        if (!strcmp(buf, "quit"))
            break;
    }

    mq_close(mqdes);

    if (mq_unlink(MSGQUEUE_NAME) == -1)
        exit_sys("mq_unlink");

    return 0;    
}

void clear_stdin(void)
{
    int ch;
    while ((ch = getchar() != '\n') && ch != EOF)
        ;
}

void exit_sys(const char *msg)
{
	perror(msg);

	exit(EXIT_FAILURE);
}

/* prog2.c */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/stat.h>
#include <mqueue.h>

#define MSGQUEUE_NAME       "/my_message_queue"

void exit_sys(const char *msg);

int main(void)
{
    mqd_t mqdes;
    char *buf;     
    int val;
    struct mq_attr attr;
    int prio;
    ssize_t result;

    if ((mqdes = mq_open(MSGQUEUE_NAME, O_RDONLY)) == -1)
        exit_sys("mq_open");

    if (mq_getattr(mqdes, &attr) == -1)
        exit_sys("mq_getattr");

    if ((buf = malloc(attr.mq_msgsize + 1)) == NULL) {
        fprintf(stderr, "cannot allocate memry!..\n");
        exit(EXIT_FAILURE);
    }

    for (;;) {
        if ((result = mq_receive(mqdes, buf, attr.mq_msgsize, &prio)) == -1) 
            exit_sys("mq_receive");
        buf[result] = '\0';

        if (!strcmp(buf, "quit"))
            break;

        printf("Message: %s, Priority: %d\n", buf, prio);
    }
    printf("\n");

    free(buf);
    mq_close(mqdes);

    return 0;    
}

void exit_sys(const char *msg)
{
	perror(msg);

	exit(EXIT_FAILURE);
}

/*--------------------------------------------------------------------------------------------------------------------------
    Bazı UNIX türevi sistemlerde POSIX mesaj kuyrukları özel bir dosya sistemi biçiminde mount edilebilmektedir. Örneğin 
    Linux sistemlerinde mesaj kuyruklarına ilişkin dosya sistemi "/dev/mqueue" dizini üzerinde mount edilmiştir. 
    Yani biz "/dev/mqueue" dizinine geçtiğimizde ls komutuyla o anda yaşamakta olan tüm POSIX mesaj kuyruklarını görüntüleyebiliriz. 
    İstersek rm komutuyla onları silebiliriz. Örneğin:

    kaan@kaan-virtual-machine:/dev/mqueue$ ls -l
    toplam 0
    -rw-r--r-- 1 kaan kaan 80 Nis  8 11:25 my_message_queue

    Linux dağıtımları genellikle açılış sırasında bu dosya sistemini otomatik mount etmektedir. Ancak sistem yöneticisi isterse 
    /dev/mqueue dizinini unmount edebilir. Örneğin:

    sudo unmount /dev/mqueue

    Ya da sistem yöneticisi isterse bu dosya sistemini başka bir yere de mount komutuyla mount edebilir. Örneğin:

    sudo mount -t mqueue somename posix-mqueue

    Burada "somename" mount noktalarını görüntülerken kullanılacak bir isimdir. Mesaj kuyrukları bu biçimde mount edilirken 
    dizinin "sticky" biti set edilmektedir. Böylece bu dizinin birisi sahibi olsa da ancak oradaki dosyaları silebilmek için 
    kişinin dosyanın sahibi olması ya da uygun önceliğe sahip olması gerekmektedir. 
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Anımsanacağı gibi mesaj kuyrukları için iki önemli limit vardı: Bir mesaj kuyruğuna yazılabilecek maksimum mesajların sayısı 
    (Linux'ta default 10 demiştik) ve mesaj kuyruğundaki bir mesajın maksimum uzunluğu (Linux'ta default 8192 demiştik). Pekiyi 
    bunların default değerleri nereden gelmektedir? POSIX standartları bu konuda bir şey söylememektedir. Ancak Linux sistemlerinde 
    bu değerler "/proc/sys/fs/mqueue" dizini içerisinde çeşitli dosyalar tarafından temsil edilmiştir. Buradaki dosyaların ve içerisindeki
    değerlerin anlamları şöyledir:

    msg_default: Bu değer mq_open ile mesaj kuyruğu yaratılırken fonksiyonun özellik parametresi NULL geçildiğinde yaratılacak 
    kuyruğa en fazla yerleştirilecek mesaj sayısını belirtmektedir. Bu dosyanın içini cat komutu ile yazdırırsak mevcut sistemlerde 10 
    değerini görürüz. 

    msg_max: Bu dosya mq_open ile özellik girilerek mesaj kuyruğu yaratıldığında mq_attr yapısının mq_maxmsg elemanına yerleştirilecek
    maksimum değeri belirtmektedir. Linux sistemlerinde de şimdilik bu dosyanın içerisinde 10 yazmaktadır. Yani biz mesaj kuyruğunu yaratırken 
    10'dan daha fazla mesajı tutabilecek biçimde yaratamayız. 

    msgsize_default: mq_open ile mesaj kuyruğu yaratılırken özellik parametresine NULL geçildiğinde kuyruğa yazılabilecek maksimum mesaj 
    uzunluğunu belirtmektedir. Bu değerin zaten daha önce 8192 olduğunu belirtmiştik. O halde bu dosyanın içeriğini yazdırırsak 8192 
    değerini görürüz. 

    msgsize_max: Bu dosyada da mesaj kuyruğunu yaratırken özellik bilgisinde mq_attr yapısının mq_msgsize elemanına yerleştirilebilecek 
    maksimum değer bulunmaktadır. Bu dosya yazdırılırsa 8192 değeri görülmektedir. Yani biz kuyruktaki mesajların uzunluğunu bu değerin yukarısına 
    çekemeyiz. 

    queues_max: Bu değer sistem genelinde yaratılabilecek mesaj kuyruklarının toplam sayısını belirtmektedir. 

    Uygun önceliğe sahip prosesler yukarıdaki limitlerden etkilenmezler. Ayrıca buradaki değerler proc dosya sisteminden bu dosyalara yazma yapılarak 
    değiştirilebilmektedir. Örneğin:
    
    sudo sh -c "echo 20 > /proc/sys/fs/mqueue/msg_max"

    Buradaki değerlerin ayrı bir tavan limiti de vardır. Örneğin msg_max değerinin tavan limiti 3.5 ve sonrasındaki 
    çekirdeklerde 65536'dır. Yine örneğim msgsize_max değerinin de tavan limiti 3.5 ve sonrasındaki çekirdeklerde 16,777,216 biçimindedir. 
    Uygun önceliğe sahip prosesler /proc/sys/fs/mqueue içerisindeki limitlere takılmasalar da bu tavan limitlerine takılabilirler. Ayrıca belli 
    bir kullanıcının maxsimum kullanacağı mesaj kuyrukları için byte sayısı da bir limittir. Şu andaki çekirdeklerde bu 819200 byte'tır. Yani 
    belli bir kullanıcı toplam mesaj kuyruklarının sayısı * bir mesajdaki maksimum byte sayısını bu değerin yukarısında set edemez. 
    Bu konudaki detaylar için mq_overview(7) man sayfasına başvurabilirsiniz. 
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    mq_send ve mq_receive fonksiyonlarının "zaman aşımlı (timeout)" versiyonları da vardır. Bu zaman aşımlı versiyonları kuyruk 
    doluyken ya da boşken blokeyi belirlenen zaman çerçevesinde oluşturur. Eğer bloke daha uzun sürerse zaman aşımından dolayı
    bu fonksiyonlar başarısızlıkla geri dönerler ve errno değeri ETIMEDOUT ile set edilir. Fonksiyonların prototipleri şöyledir:

    #include <time.h>
    #include <mqueue.h>

    int mq_timedsend(mqd_t mqdes, const char *msg_ptr, size_t msg_len, 
            unsigned int msg_prio, const struct timespec *abs_timeout);

    ssize_t mq_timedreceive(mqd_t mqdes, char *restrict msg_ptr, size_t msg_len, 
                unsigned int *msg_prio, const struct timespec *abs_timeout);

    Bu fonksiyonların mq_send ve mq_receive fonksiyonlarından tek farkı zaman aşımına ilişkin bir parametreye sahip olmasıdır. 
    Zaman aşımı <time.h> içerisinde bildirilmiş olan timespec yapısıyla ifade edilmektedir:

    struct timespec {
        time_t tv_sec;          /* seconds */
        long tv_nsec;           /* nanoseconds */
    };

    Bu yapının amacı 01/01/1970'ten geçen saniye sayısını nano saniye mertebesinde detaylandırmaktır. Ancak fonksiyonlardaki 
    zaman aşımı değerleri "göreli" değil "mutlak"tır. Örneğin biz zaman aşımını 10 saniye tutacaksak buraya şimdiden 10 saniye sonraki
    timespec değerini girmeliyiz. Bunun için önce clock_gettime fonksiyonu ile şimdiki zamana ilişkin timespec değeri elde edilebilir. 
    Sonra o değere belli bir değer toplanıp zaman aşımı göreli biçimde oluşturulabilir. clock_gettime fonksiyonu aynı zamanda standart
    bir C fonksiyonudur. Bu fonksiyondaki saat türünün CLOCK_REALTIME alınması uygun olur. clock_gettime fonksiyonun prototipi şöyledir:

    int clock_gettime(clockid_t clock_id, struct timespec *tp);

    Fonksiyonun birrinci parametresi saatin türünü, ikinci parametresi zaman bilgisinin yerleştirileceği yapı nesnesinin adresini 
    almaktadır. Örneğin:

    if (clock_gettime(CLOCK_REALTIME, &ts) == -1)
        exit_sys("clock_gettime");

    ts.tv_sec += 10;

    if (mq_timedreceive(mqdes, buf, 8192, NULL, &ts) == -1)
        if (errno == ETIMEDOUT) {
            /* timeout oluştu başka şeyler yap */
        }

    Burada mq_timedreceive fonksiyonu ile 10 saniye kadar blokede beklenebilir. Ancak zaman aşımı dolduğunda bloke ortadan 
    kalkacaktır. Fonksiyon başarısızlıkla geri dönecek ve errnı ETIMEDOUT özel değeri ile set edilecektir. Böylece programcı 
    arka planda başka şeyler yapabilecektir. Bu zaman aşımlı işlemleri blokesiz işlemlerle karıştırmayınız. Blokesiz işlemlerde 
    bloke hiç oluşmamaktadır. Halbuki zaman aşımlı işlemlerde bloke oluşur ancak en fazla belirlenen zaman aşımı kadar bloke sürer. 
    Zaman aşımlı işlemlerde zaten zaman aşımı geçmişse ve kuruk dolu boşsa fonksiyon hemen başarısız olmaktadır. Fonksiyonlar zaman 
    aşımına kuyruk doluysa ya da boşa bakmaktadır. Eğer kuyruk blokesiz modda açılmışsa zaman aşımlı fonksiyonların zaman aşımlı 
    olmayanlardan davranış olarak bir farkı kalmaz. 

    Aşağıdaki örnekte bir mesaj kuyruğu okuma amaçlı yaratılmış sonra mq_timedreceive fonksiyonu ile şimdi zamandan 10 saniye 
    kadar blokeli beklenmiştir. Bu programı çalıştırdığınızda 10 saniye sonra "timeout" yazısının basıldığını göreceksiniz. 
  ---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <errno.h>
#include <sys/stat.h>
#include <time.h>
#include <mqueue.h>

#define MSGQUEUE_NAME       "/test_queue"

void exit_sys(const char *msg);

int main(void)
{
    mqd_t mqdes;
    struct mq_attr attr;
    struct timespec ts;
    char buf[8192];

    if ((mqdes = mq_open(MSGQUEUE_NAME, O_RDONLY|O_CREAT, S_IRUSR|S_IWUSR|S_IRGRP|S_IROTH, NULL)) == -1)
        exit_sys("mq_open");

    if (clock_gettime(CLOCK_REALTIME, &ts) == -1)
        exit_sys("clock_gettime");

    ts.tv_sec += 10;

    if (mq_timedreceive(mqdes, buf, 8192, NULL, &ts) == -1) 
        if (errno == ETIMEDOUT) 
            printf("timedout\n");
        else
            exit_sys("mq_timedreceive");

    mq_close(mqdes);

    if (mq_unlink(MSGQUEUE_NAME) == -1)
        exit_sys("mq_unlink");

    return 0;    
}

void exit_sys(const char *msg)
{
	perror(msg);

	exit(EXIT_FAILURE);
}

/*--------------------------------------------------------------------------------------------------------------------------
    Klasik Sistem 5 mesaj kuyrukları ile POSIX mesaj kuyruklarını avantaj/dezavantaj bakımından şöyle karşılaştırabiliriz:

    - POSIX mesaj kuyrukları isimlendirme bakımından daha güzel bir arayüz sunmaktadır.
    - Klasik Sistem 5 mesaj kuyrukları daha taşınabilirdir. Ancak POSIX mesaj kuyrukları da artık taşınabilir hale gelmiştir. 
    - POSIX mesaj kuyrukları dosyalar gibi kullanılmaktadır. Dolayısıyla "her şeyin dosya olduğu" tasarımı ile daha uyumludur. 
    - Klasik Sistem 5 mesaj kuyruklarında belli bir önceliğe ilişkin mesajlar alınabilmektedir. POSIX mesaj kuyruklarında bu yapılamamaktadır. 
    - POSIX mesaj kuyrukları silindiğinde onu kullanan prosesler kullanmaya devam ederler. Ancak klasik Sisyem 5 mesaj kuyruklarında
    mesaj kuyruğu silindiğinde onu kullanan prosesler artık mesaj kuyruğunu kullanamaz hale gelirler. 
    - POSIX mesaj kuyrukları dosya sistemi gibi mount edilebilmektedir. Dolayısıyla silme işlemi dosya siler gibi yapılabilmektedir. 
    - Her iki mesja kuyruğu da silinene kadar ya da sistem reboot edilene kadar yaşamaktadır. 
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Diğer önemli proseslerarası haberleşme yöntemleriden biri de "paylaşılan bellek alanları (shared memory)" denilen yöntemdir. 
    Paylaşılan bellek alanlarında işletim sistemi iki prosesin sayfa tablosundaki farklı sanal sayfa numaralarını aynı fiziksel sayfaya
    yönledirir. Böylece iki proses farklı saanal adreslerle aynı fiziksel sayfaya erişirler.Proseslerden biri oraya bir şey yazdığında 
    diğeri onu hemen görür. Ddolayısıyla yönem çok hızlıdır. Ancak bu yöntrm kendi içerisinde bir senkronizasyon içermemektedir. 
    Dolayısıyla senkronizasyonun sağlanması için semaphore gibi bir senkronizasyon nesnesine de gereksinim duyulur. Zaten bu nedenle
    IPC nesnelerine semaphore'lar eklenmiştir. 

    Paylaşılan bellek alanları da UNIX/Linux dünyasında tıpkı mesaj kuyruklarında olduğu gibi iki arayüzle kullanılabilmektedir:
    Klasik Sistem 5 paylaşılan bellek alanları ve POSIX paylaşılan bellek alanları. Biz de burada önce klasik Sistem 5 paylaşılan bellek 
    alanlarını sonra da POSIX paylaşılan bellek alanalarını göreceğiz. 
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
                                                        45. Ders 09/04/2023 - Pazar
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Klasik Sistem 5 paylaşılan bellek alanları aşağıdaki adımlardan geçilerek oluşturulmaktadır:

    1) Paylaşılan bellek alanı shmget fonksiyonu ile anahtar verilip id elde edilecek biçimde yaratılır ya da olan açılır. 
    Yine id değerleri sistem genelinde tektir. Yani bu id değeri diğer prosesler tarafından biliniyorsa yetki durumu da uygunsa
    shmget fonksiyonu çağrılmadan doğrudan kullanılabilir. shmget fonksiyonun prototipi şöyledir:

    #include <sys/shm.h>

    int shmget(key_t key, size_t size, int shmflg);

    Fonksiyonun birinci parametresi yine paylaşılan bellek alanının anahtar değerini belirtir. Aynı anahtar için aynı id değerleri 
    elde edilmektedir. Fonksiyonun ikinci parametresi yaratılacak paylaşılan bellek alanının büyüklüğünü belirtmektedir. 
    Bu büyüklük  normal olarak sayfa katlarına ilişkin bir değe olarak girilir. Ancak POSIX standartları bunu zorunlu hale getirmemiştir. 
    Örneğin biz bu büyüklüğü 5000 olarak girdiğimizde işletim sistemi 4096'lık iki sayfayı eşler. Dolayısıyla genellikle burada girilen değer
    sayfa katlarına bakılarak yukarıya doğru yuvarlanmaktadır. (Yani biz bu değeri örneğin Linux sistemlerinde 5000 girsek de sanki 
    sistem 2 * 4096 = 8192 girmişisz gibi durumu ele almaktadır.) Yukarıda da belirtitğimiz gibi buradaki büyüklüğün sayfa katlarına yukarıya 
    doğru yuvarlanması POSIX standartlarında belirtilmemiştir. Ancak Linux dokümanlarında (Linux man sayfalarında) belirtilmiştir. 
    Fonksiyonun son parametresi IPC nesnesinin erişim haklarını ve yaratım seçeneklerini belirtmektedir. Tabii bu parametre eğer IPC nesnesi 
    yaratılıyorsa (yani IPC_CREAT bayrağı kullanılmışsa) etkili olmaktadır. Eğer IPC nesnesi zaten yaratılmışsa bu parametre 0 geçilebilir. 
    Bu parametrenin msgget  get fonksiyonundaki ilgili parametreden bir farkı yoktur. Yine burada da erişim hakları S_IXXX sembolik sabitleriyle 
    oluşturulabilir    (ya da 2008 ve sonrasında doğrudan sayısal değerlerle oluşturulabilir). Erişim haklarına IPC_CREAT eklenebilir. Bu durum IPC nesnesi 
    yoksa onun yaratılacağı anlamına gelir. Yine IPC_CREAT|IPC_EXCL bayrakları birlikte kullanılırsa nesne zaten varsa fonksiyon başarısız
    olmaktadır. Yine tıpkı msgget fonksiyonunda olduğu gibi birinci parametreye IPC_PRIVATE değeri geçilebilir. Bu durumda nesne 
    çakışmayan bir anahtarla yaratılır ve IPC nesnesinin id değeri elde edilir. Bu id değeri diğer proseslere gönderilirse onlar 
    bu IPC nesnesini doğrudan kullanabilirler. Fonksiyonın geri dönüş değeri IPC nesnesinin id değerini vermektedir. Bu değer sistem genelinde 
    paylaşılan bellek alanları içerisinde tektir. Başka proseslere gönderilirse onlar tarafından da kullanılabilir. Fonksiyon başarısız olursa
    -1 değerine geri döner ve errno uygun biçimde set edilir. Linux'ta Linux'a özgü bir biçimde erişim haklarında birkaç standart olmayan bayrak da 
    kullanılabilmektedir. Bu bayrakları ilgili man sayfalarından inceleyebilirsiniz. 

    Yine sistemdeki o anda yaratılmış olan paylaşılan bellek alanları "ipcs" konutuyla ya da "ipcs -m" komutuyla görüntülenebilir. 
    Örneğin:

    kaan@kaan-virtual-machine:~/Study/UnixLinux-SysProg$ ipcs -m

    ----- Paylaşımlı Bellek Bölütleri -----
    anahtar    shmid      sahibi     izinler    bayt       ekSayısı durum       
    0x00000000 98305      kaan       600        4194304    2          hedef        
    0x00000000 98321      kaan       600        524288     2          hedef        
    0x00000000 19         kaan       600        67108864   2          hedef        
    0x00000000 65556      kaan       600        524288     2          hedef        
    0x00000000 131099     kaan       606        10437756   2          hedef        
    0x00000000 131100     kaan       606        10437756   2          hedef        
    0x00012345 131101     kaan       644        4096       0                       
    0x00000000 65570      kaan       600        4194304    2          hedef        
    0x00000000 51         kaan       600        4194304    2          hedef        
    0x00000000 59         kaan       600        524288     2          hedef     

    Aslında daha önceden de belirttiğimiz gibi "ipcs" komutu bu bilgileri "/proc/sysvipc" dizinindeki üç dosyadan elde etmektedir. 
    Klasik Sistem 5 paylaşılan bellek alanları için "/proc/sysvipc/shm" dosyası kullanılmaktadır. Örneğin:

    kaan@kaan-virtual-machine:~/Study/UnixLinux-SysProg$ cat /proc/sysvipc/shm

    bu biçimde benzer bilgileri elde edebiliriz.

    Örneğin:

  	int shmid;
    ...

	if ((shmid = shmget(SHM_KEY, 4096, 0)) == -1)
		exit_sys("shmget");

    2) Zaten yaratılmış bir klasik Sistem 5 paylaşılan bellek alanı nesnesini prosesin sanal bellek alanında oluşturmak gerekir. 
    Buna klasik Sistem 5 paylaşılan bellek alanları terminolojisinde "paylaşılan bellek alanının attach edilmesi" denilmektedir. 
    Bu işlem sırasında işletim sistemi ilgili prosesin sayfa tablosunda bu paylaşılan bellek alanına erişmede kullanılacak sanal adresi 
    oluşturmaktadır. Bu işlem shmat fonksiyonu ile yapılmaktadır. (İsimdeki "at" eki "attach" sözcüğünden kısaltmadır.) shmat 
    fonksiyonunun prototipi şöyledir:

    #include <sys/shm.h>

    void *shmat(int shmid, const void *shmaddr, int shmflg);

    Fonksiyonun birinci parametresi paylaşılan bellek alanının id'sini belirtmektedir. Fonksiyonun ikinci parametresi önerilen sanal 
    adresi belirtmektedir. Programcı işletim sistemine "şu sanal adres yoluyla paylaşılan bellek alanına erişmek istiyorum" diyebilmektedir. 
    Ancak programcının önerdiği adres kullanılıyor olabilir ya da işletim sistemi tarafından kulalnılamaz bir adres olabilir. 
    Bu durumda fonksiyon başarısız olur. Bu parametre NULL adres geçilebilir. Bu durumda işletim sistemi paylaşılan bellek aalanına erişmek 
    için kullanılacak sanal adresi kendisi tespit eder. Normal olarak bu adresin sayfa katlarında olması beklenmektedir. Ancak programcı 
    bu adresi sayfa katları olarak vermezsa ve fonksiyonun üçüncü parametresinde SHM_RND bayrağını kullanırsa bu durumda programcının 
    verdiği adres sayfa katlarına aşağıya doğru yuvarlanmaktadır. Örneğin programcı ikinci parametreye 0x4A6C324 biçiminde bir adres 
    girmiş olsun. Eğer fonksiyonun son parametresi SHM_RND Olarak girilirse bu adres 4096'nın katlarına aşağıya doğru yuvarlanmaktadır. 
    Yani bu durumda adres 0x4A6C000 biçimine dönüştürülecektir. Tabii programcının verdiği adres sayfa katlarında olsa bile işletim sistemi
    tarafından kabul edilmeyebilir. Çünkü sanal adres alanı içerisinde özel bölgeler, kullanılmayana alanlar bulunabilmektedir. 
    Eğer ikinci parametreye bir adres girilise ve bu adres sayfa katlarında değilse, üçüncü parametrede de SHM_RND girilmezse fonksiyon 
    büyük olasılıkla başarısız olacaktır. POSIX standartlarında "sayfa katlarına aşağıya yuvarlama" biçiminde bir ibare bulunmamaktadır. 
    Sayfa katları yerine standartlarda SHMLBA sembolik sabiti kullanılmıştır. Yani standartlar anlatımı "SHMLBA katlarına aşağıya yuvarlama"
    biçiminde oluşturmuştur. SHMLBA sembolik sabiti <sys/shm.h> içerisinde bildirilmiştir ve tipik olarak zaten sayfa uzunluğunu belirtir. 

    Fonksiyonun son parametresi 0 geçilebilir ya da bazı bayraklar burada kullanılabilir. Yukarıda da belirtitğimiz gibi eğer 
    ikinci parametrede bir adres girilmişse üçüncü parametrede SHM_RND bayrağı bu adresin sayfa katlarına aşağıya doğru yuvarlanacağını belirtmektedir. 
    Üçüncü parametredeki SHM_RDONLY ilgili paylaşılan bellek alanına "read-only" erişim için kullanılmaktadır. Bu durumda bu sayfaya 
    yazma yapıldığında "page fault" oluşacak ve işletim sistemi prosesi sonlandıracaktır. Bu bayrak belirtilmezse erişim "read-write" yapılır. 

    Proses aynı paylaşılan bellek alanı nesnesini birden fazla shmat fonksiyonu ile birden fazla kez "attach" yapabilir. Ancak genellikle
    böyle bir duruma gereksinim duyulmamaktadır. 

    Fonksiyon başarı durumunda paylaşılan bellek alanına erişmekte kullanılan sanal adrese başarısızlık durumunda (void *)-1 adresine
    geri dönmektedir. errno değişkeni uygun biçimde set edilmektedir. Fonksiyonun NULL adrese geri dönmemesinin nedeni bazı sistemlerde 
    0 adresinin geçerli bir biçimde kullanılabiliyor olmasındandır. Tabii fonksiyon bize safta katlarına ilişkin bir adres vermektedir. 
    (Yani 4096'lık sayfaların kullanıldığı sistemlerde verilen sanal adreslerin düşük anlamlı 3 hex digit'i 0 olacaktır.) Örneğin:

    int shmid;
	char *shmaddr;

	if ((shmid = shmget(SHM_KEY, 4096, 0)) == -1)
		exit_sys("shmget");

	if ((shmaddr = (char *)shmat(shmid, NULL, 0)) == (void *)-1)
		exit_sys("shmat");

    3) Artık iki proses de muhtemelen farklı sanal adresler yoluyla aynı fiziksel sayfaya erişmektedir. Proseslerden biri o bölgeye
    bir şeyler yazarsa diğeri onu görür ve elde edebilir. Tabii burada bir senkronizasyonun sağlanması gerekmektedir. Daha önce 
    görmüş olduğumuz borlular ve mesaj kuyruklarında zaten bu organizasyon bu nesneler tarafından sağlanmaktadır. Bir tarafın
    paylaşılan bellek alanına bir şeyleri yazdığı diğerinin okuduğu bu tür senkronizasyon problemlerine "üretici-tüketici problemi 
    (producer consumer problem)" denilmektedir. Bu problemin çözümü "thread'ler" konusunda ele alınacaktır. 

    4) Proses paylaşılan bellek alanının kullanımını bitirdikten sonra o alanı prosesin sanal bellek alanından çıkartmalıdır. 
    Terminolojide paylaşılan bellek alanının prosesin bellek alanına iliştirilmesine "attach" denirken bunun tersine "detach" denilmektedir. 
    (Yani shmat fonksiyonunu "malloc" gibi bir fonksiyona benzetirsek bunun bir de "free" gibi serbest bırakan bir karşılığının olması gerekir.)
    İşte shmat ile yapılan işlemi geri almak için shmdt fonksiyonu kullanılmaktadır (buradaki "dt" eki "detach" sözcüğünden kısaltılmıştır).
    Fonksiyonun prototipi şöyledir:

    #include <sys/shm.h>

    int shmdt(const void *shmaddr);

    Fonksiyon parametre olarak shmat fonksiyonundan elde edilen sanal adresi alır. Fonksiyon başarı durumunda 0 değerine, başarısızlık 
    durumunda -1 değerine geri dönmektedir. Her şey düzngün yapılmışsa fonksiyonun başarısının kontrol edilmesine de gerek yoktur. 
    Eğer programcı bu shmdt işlemini yapmazsa proses sonlanırken bu işlem zaten yapılmaktadır. Örneğin:

    int shmid;
	char *shmaddr;
    ...

	if ((shmid = shmget(SHM_KEY, 4096, 0)) == -1)
		exit_sys("shmget");

	if ((shmaddr = (char *)shmat(shmid, NULL, 0)) == (void *)-1)
		exit_sys("shmat");

    ...

    if (shmdt(shmaddr) == -1)
		exit_sys("shmdt");

    5) Paylaşılan bellek alanlarının "detach" edilmesi ilgili nesnenin yok edileceği anlamına gelmemektedir. Programcı "detach" işlemi 
    sonrasında yeniden attach işlemi yapabilir. Paylaşılan bellek alanları nesnesi diğer IPC nesnelerinde olduğu gibi açıkça silinene kadar 
    ya da reboot işlemine kadar yaşamaya devam etgmektedir. 

    6) Klasik Sistem 5 paylaşılan bellek alanları nesnesi için işletim sistemi shmid_ds isimli bir yapı oluşturmaktadır. Bu yapıda
    paylaşılan bellek  alanına ilişkin bazı önemli bilgiler tuttulmaktadır. Bu bilgileri elde  etmek için, set etmek için ya da
    IPC  nesnesini yok etmek için shmctl isimli fonksiyon kullanılmaktadır. Bu fonksiyonun  işlevi klasik Sistem 5 mesaj kuyruklarındaki
    msgctl fonksiyonuna benzetilebilir. shmctl fonksiyonunun parametrik yapısı şöyledir:

    include <sys/shm.h>

    int shmctl(int shmid, int cmd, struct shmid_ds *buf);

    Fonksiyonun birinci parametresi paylaşılan bellek alanının id değerini, ikinci parametresi ise uygulanacak işlemi belirtmektedir. 
    Fonksiyonun üçüncü parametresinde belirtilen yapı şöyledir:

    struct ipc_perm {
        uid_t          uid;      /* Effective UID of owner */
        gid_t          gid;      /* Effective GID of owner */
        uid_t          cuid;     /* Effective UID of creator */
        gid_t          cgid;     /* Effective GID of creator */
        unsigned short mode;     /* Permissions + SHM_DEST and
                                    SHM_LOCKED flags */
    };

     struct shmid_ds {
        struct ipc_perm shm_perm;    /* Ownership and permissions */
        size_t          shm_segsz;   /* Size of segment (bytes) */
        time_t          shm_atime;   /* Last attach time */
        time_t          shm_dtime;   /* Last detach time */
        time_t          shm_ctime;   /* Creation time/time of last
                                        modification via shmctl() */
        pid_t           shm_cpid;    /* PID of creator */
        pid_t           shm_lpid;    /* PID of last shmat(2)/shmdt(2) */
        shmatt_t        shm_nattch;  /* No. of current attaches */
    };
    
    Daha önceden de ipc_perm yapısını görmüştük. Bu yapı içerisinde IPC nesnesinin o anki kullanıcı ve grup id'leri, nesneyi 
    yaratan prosesin kullanıcı ve grup id'leri ve nesnenin erişim hakları bulunuyordu. shmid_ds yapısının diğer elemanları sırasıyla 
    şu bilgileri barındırmaktadır: Paylaşılan bellek alanın büyüklüğü, son attach zamanı, son detach zamanı, son shmid_ds yapısındaki 
    değişiklik zamanı, IPC nesnesini yaratan prosesin id'si, son attach ya da detach yapan prosesin id'si ve nihayet nesnenin kaç kere attach 
    yapıldığı bilgisi. 

    İkinci parametreye şunlardan biri girilebilir:

    IPC_STAT: Bu durumda paylaşılan bellek alanına ilişkin bilgiler fonksiyonun üçüncü parametresiyle belirtilen yapı nesnesine doldurulur. 

    IPC_SET: Bu durumda shmid_ds yapısının aşağıdaki elemanları set edilmektedir:

    shm_perm.uid
    shm_perm.gid
    shm_perm.mode    
    
    Tabii set işleminin yapılabilmesi için prosesin etkin kullanıcı id'sinin shm_perm.uid ya da sehm_perm.cuid değerine eşit olması 
    ya da prosesin uygun önceliğe sahip olması gerekmektedir. 

    IPC_RMID: Bu parametre değeri IPC nesnesini silmek için kullanılmaktadır. Benzer biçimde bu işlemin yapılabilmesi için de 
    IPC_SET koşulunda belirtilen koşulların sağlanması gerekmektedir. Paylaşılan bellek alanları nesnesini bunu yaratan prosesin silmesi uygun olur. 
    Klasik Sistem 5 mesaj kuyruklarında bir proses mesaj kuyruğunu silerse mesaj kuyruğu hemen siliniyordu. Dolayısıyla onu kullanan bir proses
    ilgili işlemlerde başarısızlıkla karşılaşıyordu. Ancak paylaşılan bellek alanlarında durum böyle değildir. Bir klasik Sistem 5
    paylaşılan bellek alanı shmctl fonksiyonu ile bir proses tarafından silinse bile gerçek silinme onu kullanan tüm proseslerin bellek alanını "detach" yapmasıyla
    gerçekleşmektedir. IPC nesnesi IPC_RMID parametresiyle silinecekse artık fonksiyonun son parametresi kulalnılmaz. NULL adres geçilebilir. 

    Paylaşılan bellek alanları komut satırında "ipcrm" komutuyla da silinebilmektedir. Komutta -M seçeneği anahtar ile silmek için -m 
    seçeneği id ile silmek için kullanılmaktadır. Örneğin:

    ipcrm -m 131135

    Burada 131135 id'sine sahip paylaşılan bellek alanı silinmektedir. Tabii bize ait olmayan paylaşılan bellek alanlarını silmek için 
    sudo uygulamak gerekir. 

    shmctl fonksiyonu başarı durumunda 0 değerine başarısızlık durumunda -1 değerine geri dönmektedir. 

    Aşağıdaki örnekte prog1 programı paylaşılan bellek alanına bir yazı yerleştirir prog2 programı da bu yazıyı oradan alıp ekrana (stdout dosyasına)
    yazdırmaktadır. 
---------------------------------------------------------------------------------------------------------------------------*/

/* prog1.c */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/stat.h>
#include <sys/shm.h>

#define SHM_KEY		0x12345

void exit_sys(const char *msg);

int main(void)
{
	int shmid;
	char *shmaddr;

	if ((shmid = shmget(SHM_KEY, 4096, IPC_CREAT|S_IRUSR|S_IWUSR|S_IRGRP|S_IROTH)) == -1)
		exit_sys("shmget");

	if ((shmaddr = (char *)shmat(shmid, NULL, 0)) == (void *)-1)
		exit_sys("shmat");

	printf("Shared memory virtual address: %p\n", shmaddr);

	strcpy(shmaddr, "this is a test");

	printf("press ENTER to continue...\n");

	getchar();

	if (shmdt(shmaddr) == -1)
		exit_sys("shmdt");

	if (shmctl(shmid, IPC_RMID, NULL) == -1)
		exit_sys("shmctl");

    return 0;    
}

void exit_sys(const char *msg)
{
	perror(msg);

	exit(EXIT_FAILURE);
}

/* prog2.c */

#include <stdio.h>
#include <stdlib.h>
#include <sys/stat.h>
#include <sys/shm.h>

#define SHM_KEY		0x12345

void exit_sys(const char *msg);

int main(void)
{
	int shmid;
	char *shmaddr;

	if ((shmid = shmget(SHM_KEY, 4096, 0)) == -1)
		exit_sys("shmget");

	if ((shmaddr = (char *)shmat(shmid, NULL, 0)) == (void *)-1)
		exit_sys("shmat");

    printf("Shared memory virtual address: %p\n", shmaddr);

    printf("press ENTER to continue...\n");
    getchar();

    puts(shmaddr);
    
    if (shmdt(shmaddr) == -1)
		exit_sys("shmdt");

    return 0;    
}

void exit_sys(const char *msg)
{
	perror(msg);

	exit(EXIT_FAILURE);
}

/*--------------------------------------------------------------------------------------------------------------------------
    Her ne kadar POSIX standartlarında belirtilmiş olmasa da işletim sistemleri paylaşılan bellek alanları için çeşitli sınır değerler
    oluşturmaktadır. Linux sistemlerinde paylaşılan bellek alanlarına ilişkin sınırlar şöyledir:

    SHMALL: Sistemdeki tüm paylaşılan bellek alanlarının kaplayabileceği toplam alanı sayfa sayısı cinsinden belirtmektedir. 
    Bu değer Linux sistemlerinde /proc/sys/kernel/shmall dosyasından elde edilebilir ve değiştirilebilir. Buradaki default değer
    çok büyüktür yani adeta bir sınır olmadığını belirtmektedir. 
  
    SHMMAX: Bu sınır belli bir prosesin shmget fonksiyonu ile oluşturabileceği maksimum paylaşılabilen bellek alanı büyüklüğüdür. 
    Yani shmget fonksiyonunda belirtilecek büyüklüğün üst sınırını belirtmektedir. Bu sınır da proc dosya sisteminde /proc/sys/kernel/shmmax
    dosyası ile elde edilebilir ve değiştirilebilir. Bu değer byte cinsindendir. Şu andaki Linux sistemlerindeki default değer çok 
    büyüktür. Adeta sınırsız gibi ele alınabilir. 

    SHMMIN: Bu sınır shmget ile oluşturulabilecek minimum uzunluğu belirtmektedir. Şimdiki Linux sistemlerinde bu değer 1'dir. 
    Ancak tabii biz shmget ile 1 byte alan oluşturmak istesek bile shmget bize en az bir sayfa tahsis etmektedir. Bunun için 
    proc dosya sisteminde bir giriş bulunmamaktadır. 

    SHMMNI: Bu sınır sistem genelinde yaratılabilecek makismum paylaşılan bellek alanlarının sayısını belirtmektedir. Bu değer
    proc dosya sisteminde /proc/sys/kernel/shmmni dosyası ile elde edilebilir ve değiştirilebilir. Mevcut Linux sistyemlerinde 
    bu dosyada default olarak 4096 değeri bulunmaktadır. 
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Paylaşılan bellek alanları da "POSIX paylaşılan bellek alanları" denilen alternatif bir arayüze sahiptir. POISX paylaşılan bellek alanları 
    daha önce görmüş olduğumuz POSIX mesaj kuyruklarına benzer bir kullanım sunmaktadır. Yani burada farklı prosesler anahtarlarla 
    değil yine kök dizindeki dosya isimleriyle anlaşma sağlarlar. POSIX arayüzü tıpkı mesaj kuyruklarında olduğu gibi daha modern 
    bir tasarıma sahiptir. Ayrıca POSIX arayüzü "bellek tabanlı dosyalar (memory mapped files)" denilen olguyla da birleştirilmiş durumdadır. 
    POSIX arayüzü yine sanki nesne bir dosyaymış gibi davranmaktadır. Ancak mesaj kuyruklarında da belirttiğimiz gibi bir taşınabilirlik 
    problemi burada da söz konusu olabilmektedir. Ancak pek çok UNIX türevi işletim sistemi artık bu arayüzü uzun süredir destekler duruma gelmiştir. 
    POSIX paylaşılan belek alanları librt kütüphanesi içerisinde bulunduğundan link işleminde -lrt seçeneğinin kullanılması gerekmektedir. 
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
                                                46.Ders 16/04/2023 - Cumartesi
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    POSIX paylaşılan bellek alanları tipik olarak şu adımlardan geçilerek kullanılmaktadır:

    1) POSIX paylaşılan bellek alanı nesnesi iki proses tarafından shm_open fonksiyonuyla yaratılabilir ya da zaten olan nesne shm_open 
    fonksiyonu ile açılabilir. Fonksiyonun prototipi şöyledir:

    #include <sys/mman.h>

    int shm_open(const char *name, int oflag, mode_t mode); 

    Fonksiyonun birinci parametresi paylaşılan bellek alanı nesnesinin ismini belirtmektedir. Tıpkı POSIX mesaj kuyruklarında 
    olduğu gibi bu ismin kök dizinde bir dosya ismi gibi verilmesi gerekmektedir. (Bazı sistemlerin buradaki dosya isminin 
    başka dizinlerde olmasına isin verebildiğini belirtmiştik.) Fonksiyonun ikinci parametresi paylaşılan bellek alanının açış 
    bayraklarını belirtmektedir. Bu bayraklar şunlardan birini içerebilir:

    O_RDONLY: Bu durumda paylaşılan bellek alanından yalnızca okuma yapılabilir.
    O_RDWR: Bu durumda paylaşılan bellek alanından hem okuma yapılabilir hem de oraya yazma yapılabilir,

    Aşağıdaki bayraklar da açış moduna eklenebilir:

    O_CREAT: Paylaşılan bellek alanı yoksa yaratılır, varsa olan açılır.
    O_EXCL: O_CREAT bayrağı ile birlikte kullanılabilir. Paylaşılan bellek alanı zaten varsa fonksiyon başarısız olur.
    O_TRUNC: Paylaşılan bellek alanı varsa sıfırlanarak açılır. Bu mod için O_RDWR bayrağının kullanılmış olması gerekmektedir. 

    Fonksiyonun üçüncü parametresi paylaşılan bellek alanının erişim haklarını belirtmektedir. Tabii ancak ikinci parametrede O_CREAT
    bayrağı kullanılmışsa bu parametreye gereksinim duyulmaktadır. İkinci parametrede O_CREAT bayrağı kullanılmamışsa üçüncü parametre
    hiç kullanılmamaktadır.

    shm_open bize tıpkı bir disk dosyasında olduğu gibi bir dosya betimleyicisi vermektedir. (Halbuki mq_open fonksiyonunda POSIX
    standartlarında bunun zorunlu olmadığını anımsayınız.) Fonksiyon başarısız olursa yine -1 değerine geri döner ve errno değişkeni 
    uygun biçimde set edilir. 

    Örneğin:

    int fdshm;

	if ((fdshm = shm_open(SHM_NAME, O_RDWR|O_CREAT, S_IRUSR|S_IWUSR|S_IRGRP|S_IROTH)) == -1)
		exit_sys("shm_open");

    2) Paylaşılan bellek alanı yaratıldıktan sonra ftruncate fonksiyonu ile ona bir büyüklük vermek gerekir. Örneğin:

    if (ftruncate(fdshm, SHM_SIZE) == -1)
		exit_sys("ftruncate");

    Tabii paylaşılan bellek alanı zaten yaratılmışsa ve biz onu açıyorsak ftruncate fonksiyonunu aynı uzunlukta çağırdığımızda aslında fonksiyon
    herhangi bir şey yapmayacaktır. Yani aslında ftruncate fonksiyonu paylaşılan bellek alanı ilk kez yaratılırken bir kez yapılır.
    Ancak yukarıda da belirttiğimiz gibi aynı uzunlukta ftruncate işleminin bir etkisi yoktur. 

    POSIX paylaşılan bellek alanı nesneleri Linux'ta dosya sisteminde /dev/shm dizini içerisinde görüntülenmektedir. Yani programcı isterse
    bu dizin içerisindeki nesneleri komut satırında rm komutuyla silebilir. 

    3) Artık paylaşılan bellek alanı nesnesinin belleğe "map" edilmesi gerekmektedir. (Klasik Sistem 5 paylaşılan bellek alanlarında 
    "map etmek" yerine "attach etmek" terimi kullanılmaktaydı. Bu arayüzde "attach" yerine "mapping" sözcüğü tercih edilmiştir.)
    Bunun içim mmap isimli bir POSIX fonksiyonu kullanılmaktadır. mmap fonksiyonu pek çok UNIX türevi sistemde bir sistem fonksiyonu 
    olarak gerçekleştirilmiştir. mmap paylaşılan bellek alanlarının dışında başka amaçlarla da kullanılabilen ayrıntılı bir sistem 
    fonksiyonudur. Bu nedenle biz burada önce fonksiyonun paylaşılan bellek alanlarında kullanımına kısaca değineceğiz. Sonra bu 
    fonksiyonu ayrıca daha ayrıntılı biçimde ele alacağız. mmap fonksiyonunun prototipi şöyledir:

    #include <sys/mman.h>

    void *mmap(void *addr, size_t len, int prot, int flags, int fd, off_t off);

    Fonksiyonun birinci parametresi "mapping için" önerilen sanal adresi belirtmektedir. Programcı belli bir sanal adresin 
    mapping için kullanılmasını isteyebilir. Ancak fonksiyon flags parametresinde MAP_FIXED geçilmemişse bu adresi tam (excact) olarak 
    yani verildiği gibi kullanmayabilir. Fonksiyon bu önerilen adresin yakınındaki bir sayfayı tahsis edebilir. Bu tahsiatın burada belirtilen 
    adresin neresesinde yapılacağı garanti edilmemiştir. Yani buradaki adres eğer fonksiyonun flags parametresinde MAP_FIXED kullanılmamışsa bir öneri 
    niteliğindedir. Eğer bu adres NULL olarak geçilirse bu durumda mapping işlemi işletim sisteminin kendi belirlediği bir adresten 
    itibaren yapılır. Tabii en normal durum bu parametrenin NULL adres olarak geçilmesidir. 

    Fonksiyonun ikinci parametresi paylaşılan bellek alanının ne kadarının map edileceğini belirtir. Örneğin paylaşılan bellek alanı 
    nesnesi 1 MB olabilir. Ancak biz onun 100K'lık bir kısmını map etmek isteyebiliriz. Ya da tüm paylaşılan bellek alanını da map etmek  isteyeebiliriz. 
    Bu uzunluk sayfa katlarında olmak zorunda değildir. Ancak pek çok sistem bu uzunluğu sayfa katlarına doğru yukarı yuvarlamaktadır. 
    Yani biz uzunluğu örneğin 100 byte verebiliriz. Ancak sistem 100 byte yerine sayfa uzunluğu olan 4096 byte'ı map edecektir. 

    Fonksiyonun üçüncü parametresi mapping işleminin koruma özelliklerini belirtmektedir. Başka bir deyişle bu parametre 
    paylaşılan bellek alanı için ayrılacak fiziksel sayfaların işlemci düzeyinde koruma özelliklerini belirtir. Bu özellikler şunlardan oluşturulabilir:

    PROT_READ
    PROT_WRITE
    PROT_EXEC
    PROT_NONE

    PROT_READ sayfanın "read only" olduğunu belirtir. Böyle sayfalara yazma yapılırsa işlemci exception oluşturur ve program SIGSEGV 
    sinyali ile sonlandırılır. PROT_WRITE sayfaya yazma yapılabileceğini belirtmektedir. Örneğin PROT_READ|PROT_WRITE hem okuma hem de 
    yazma anlamına gelmektedir. PROT_EXEC ilgili sayfada bir kod varsa (örneğin oraya bir fonksiyon yerleştirilmişse) o kodun 
    çalıştırılabilirliği üzerinde etkili olmaktadır. Örneğin Intel ve ARM işlemcilerinde fiziksel sayfa PROT_EXEC ile özelliklendirilmemişse 
    o sayfadaki bir kod çalıştırılamamaktadır. PROT_NONE o sayfaya herhangi bir erişimin mümkün olamayacağını belirtmektedir. Yani 
    PROT_NONE olan bir sayfa ne okunabilir ne de yazılabilir. Bu tür sayfa özellikleri "guard page" oluşturmak için kullanılabilmektedir. 
    Tabii bir sayfanın koruma özelliği daha sonra da değiştirilebilir. Aslında bütün işlemciler buradaki koruma özelliklerinin hepsini desteklemeyebilirler. 
    Örneğin Intel işlemcilerinde PROT_WRITE zaten okuma özelliğini de kapsamaktadır. Bazı işlemciler sayfalarda PROT_EXEC özelliğini 
    hiç bulundurmamaktadır. Ancak ne olursa olsun programcı sanki bu özelliklerin hepsi varmış gibi bu parametreyi oluşturmalıdır. 

    Fonksiyonun dördüncü parametresi olan flags aşağıdaki değerlerden yalnızca birini alabilir:

    MAP_PRIVATE
    MAP_SHARED

    MAP_PRIVATE ile oluşturulan mapping'e "private mapping", MAP_SHARED ile oluşturulan mapping'e ise "shared mapping" denilmektedir. 
    MAP_PRIVATE "copy on write" denilen semantik için kullanılmaktadır. Copy on write işlemi "yazma yapılana kadar sanal sayfaların
    aynı fiziksel sayfalara yönlendirilmesi ancak yazmayla birlikte o sayfaların bir kopyalarının çıkartılıp yazmanın o prosese 
    özel olarak yapılması ve yapılan yazmaların paylaşılan bellek alanına yansıtılmaması" anlamına gelmektedir. Başka bir deyişle
    MAP_PRIVATE şunlara yol açmaktadır:

    - Okuma yapılınca paylaşılan bellek alanından okuma yapılmış olur. 
    - Ancak yazma yapıldığında bu yazma paylaşılan bellek alanına yansıtılmaz. O anda yazılan sayfanın bir kopyası çıkartılarak
    yazma o kopya üzerine yapılır. Dolayısıyla başka bir proses bu yazma işlemini göremez. 

    Bir proses ilgili paylaşılan bellek alanı nesnesini MAP_PRIVATE ile map ettiğinde diğer proses o alana yazma yaptığında onun yazdığını MAP_PRIVATE
    yapan prosesin görüp görmeyeceği POSIX standartlarında belirsiz (unspecified) bırakılmıştır. Linux sistemlerinin man sayfasında da 
    aynı "unspecified" durum belirtilmiş olsa da mevcut Linux çekirdeklerinde başka bir proses private mapping yapılmış yere yazma yaptığında
    bu yazma private mapping'ing yapıldığı proseste görülmektedir. Ancak sayafaya yazma yapıldığında artık o sayfanın kopyasından 
    çıkartılacağı için bu yazma işleminden sonraki diğer prosesin yaptığı yazma işlemleri görülmemektedir.

    MAP_SHARED ise yazma işleminin paylaşılan bellek alanına yapılacağını yani "copy on write" yapılmayacağını belirtmektedir. 
    Dolayısıyla MAP_SHARED bir mapping'te paylaşılan alana yazılanlar diğer prosesler tarafından görülür. Normal olarak programcılar
    amaç doğrultusunda shared mapping kullanırlar.  Private mapping (yani "copy on write") bazı özel durumlarda tercih edilmektedir. 
    Örneğin işletim sistemi (exec fonksiyonları) çalıştırılabilir dosyanın ".data" bölümünü private mapping yaparak belleğe mmap 
    ile yüklemektedirler.

    Fonksiyonun flags parametresinde MAP_PRIVATE ve MAP_SHARED değerlerinin yalnızca biri kullanılabilir. Ancak bu değerlerden biri ile 
    MAP_FIXED değeri bit düzeyinde OR işlemine sokulabilemktedir. MAP_FIXED bayrağı fonksiyonun birinci parametresindeki adres NULL geçilmemişse
    bu adresin kendisinin aynen (hiç değiştirilmeden) kullanılacağını belirtmektedir. Yani bu adresin yakınındaki herhangi bir sayfa değil kendisi tahsis edilecek 
    ve fonksiyon bu adresin aynısıyla geri dönecektir. Eğer MAP_FIXED bayrağı belirtilmişse Linux sistemlerinde birinci parametredeki 
    adresin sayfa katlarında olma zorunlululuğu vardır. Ancak POSIX standartlarının son versiyonları "may require" ifadesiyle bunun zorunlu olmayabileceğini 
    belirtmektedir. 

    Fonksiyonun son iki parametresi dosya betimleyicisi ve bir de offset içermektedir. Paylaşılan bellek alanının belli bir offset'ten 
    sonraki kısmı map edilebilmektedir. Örneğin paylaşılan bellek alanı nesnemiz 4 MB olsun. Biz bu nesnenin 1 MB'sinden itibaren 64K'lık 
    kısmını map edebiliriz. O halde mmap fonksiyonunu örneğin şöyle çağırabiliriz:

    shmaddr = mmap(NULL, SHM_SIZE, PROT_WRITE, MAP_SHARED, fdshm, 0);

    Burada paylaşılan bellek alanı nesnesinin SHM_SIZE kadar alanı map edilmek istenmiştir. İlgili sayfalar 
    PROT_WRITE özelliğine sahip olacaktır. Yani bu sayfalara yazma yapılabilecektir. Bu sayfalara yazma 
    yapıldığında paylaşılan bellek alanı nesnesi bundan etkilenecek yani aynı nesneyi kullanan diğer proseslerde de 
    eğer shared mapping yapılmışsa bu durum gözükecektir. Burada paylaşılan bellek alanı nesnesinin 0'ıncı offset'inden 
    itibaren SHM_SIZE kadar alanın map edildiğine dikkat ediniz. 

    mmap fonskiyonun son parametresindeki offset değeri MAP_FIXED belirtilmişse birinci parametre ile son parametrenin sayfa katlarına bölümünden elde edilen 
    kalan aynı olmak zorundadır. (Yani örneğin POSIX standartlarında işletim sistemi eğer 5000 adresini kabul ediyorsa 5000 % 4096 = 4'tür. Bu durumda 
    son parametrenin de 4096'ya bölümünden elde edilen kalan 4 olmaldır.) Ancak MAP_FIXED belirtilmemişse POSIX standartları bu offset değerinin 
    sayfa katlarında olup olmayacağını işletim sistemini yazanların isteğine bırakmıştır. Linux çekirdeklerinde MAP_FIXED belirtilsein ya da belirtilmesin 
    bu offset değeri her zaman sayfa katlarında olmak zorundadır. 
        
    mmap fonksiyonu başarı durumunda mapping yapılan sanal bellek adresine geri dönmektedir. Fonskiyon başarısızlık durumunda 
    MAP_FAILED özel değerine geri döner. Pek çok sistemde MAP_FAILED bellekteki son adres olarak aşağıdaki biçimde define edilmiştir:

    #define MAP_FAILED  ((void *) -1)

    Kontrol şöyle yapılabilir:

    shmaddr = mmap(NULL, SHM_SIZE, PROT_WRITE, MAP_SHARED, fdshm, 0);
	if (shmaddr == MAP_FAILED) 
		exit_sys("mmap");

    Paylaşılan bellek alanı betimleyicisi mapping işleminden sonra close fonksiyonuyla kapatılabilir. Bu durum mapping'i etkilememektedir. 

    4) Programcı paylaşılan bellek alanı ile işini bitirdikten sonra artık map ettiği alanı boşaltabilir. Bu işlem munmap POSIX 
    fonksiyonu ile yapılmaktadır. (mmap fonksiyonunu malloc gibi düşünürsek munmap fonksiyonunu da free gibi düşünebiliriz.)
    munmap fonksiyonunun prototipi şöyledir:

    #include <sys/mman.h>

    int munmap(void *addr, size_t len);

    Fonksiyonun birinci parametresi daha önce map edilen alanın başlangıç adresini belirtir. İkinci parametre unmap edilecek alanın uzunluğunu 
    belirtmektedir. Fonksiyon birinci parametresinde belirtilen adresten itibaren ikinci parametresinde belirtilen miktardaki 
    byte'ı kapsayan sayfaları unmap etmektedir. (Örneğin buradaki adres bir sayfanın ortalarında ise ve uzunluk da başka bir sayfanın ortalarına kadar 
    geliyorsa bu iki sayfa da tümden unmap edilmektedir.) POSIX standartları işletim sistemlerinin birinci parametrede belirtilen 
    adresin sayfa katlarında olmasını zorlayabileceğini (may require) belirtmektedir. Linux'ta birinci parametrede belirtilen adres sayfa katlarında olmak zorundadır. 
    Fonksiyon başarı durumunda 0 değerine, başarısızlık durumunda -1 değerine geri döner ve errno değişkeni uygun biçimde set edilir. 
    munmap ile zaten map edilmemiş bir alan unmap edilmeye çalışılırsa fonksiyon bir şey yapmaz. Bu durumda fonksiyon başarıszlıkla geri dönmemektedir. 

    Paylaşılan bellek alanına ilişkin dosya betimleyicisi close fonksiyonu ile kapatılabilir. Paylaşılan bellek alanı betimleyicisi close ile kapatıldığında 
    munmap işlemi yapılmamaktadır. Zaten paylaşılan bellek alanı nesnesi map edildikten sonra hemen close ile kapatılabilir. Bunun mapping işlemine bir etkisi olmaz. 

    Unmap işlemi mevcut mapping'in bir kısmına yapılabilmektedir. Bu durumda işletim sistemi mapping işlemini ardışıl olmayan 
    parçalara kendisi ayırmaktadır. Örneğin:

    xxxxmmmmmmmmmxxxx

    Burada m map edilmiş sayfaları x ise diğer sayfaları belirtiyor olsun. Biz de mapping'in içerisinde iki sayfayı unmap edelim:

    xxxxmmmmxxmmmxxxx

    Görüldüğü gibi artık sanki iki ayrı mapping varmış gibi bir durum oluşmaktadır. 

    Proses bittiğinde map edilmiş bütün alanlar zaten işletim sistemi tarafından unmap edilmektedir. 

    5) Paylaşılan bellek alanı nesnesine ilişkin betimleyici close fonksiyonu ile sanki bir dosyaymış gibi kapatılır. Yukarıda da 
    belirttiğimiz gibi bu kapatma işlemi aslında mapping işlemindne hemen sonra da yapılabilir. 

    6) Artık paylaşılan bellek alanı nesnesi shm_unlink fonksiyonu ile silinebilir. Anımsanacağı gibi bu silme yapılmazsa 
    sistem reboot edilene kadar nesne hayatta kalmaya devam edecektir (kernel persistant). Fonksiyonun prototipi şöyledir:

    #include <sys/mman.h>

    int shm_unlink(const char *name);

    Fonksiyon paylaşılan bellek alanı nesnesinin ismini alır onu yok eder. Başarı durumunda 0 değerine, başarısızlık durumunda -1 
    değerine geri dönmektedir. Örneğin:

    Tıpkı POSIX mesaj kuyruklarında olduğu gibi bir proses paylaşılan bellek alanını shm_unlink fonksiyonu ile silse bile paylaşılan bellek 
    alanını kullanan diğer prosesler unmap işlemi yapana kadar nesne gerçek anlamda silinmemektedir. 

    Aşağıdaki örnekte prog1 programı paylaşılan bellek alanına bir yazı yazmakta prog2 programı da bu yazıyı alarak stdout dosyasına 
    yazdırmaktadır. Tabii prog1 programı sürekli paylaşılan bellek alanının başına eskisini ezecek biçimde yazıları yazar. 
    Programı test ederken prog1'de paylaşılan bellek alanına bir şeyler yazdıktan sonra prog2'de ENTER tuşuna basarak o yazılanların 
    alınmasını sağlamalısınız. Paylaşılan bellek alanları kendi içerisinde bir senkronizasyon içermemektedir. Örneğimizde prog1 en sonunda
    paylaşılan bellek alanına "quit" yazdığında her iki program da sonlanmaktadır. 

---------------------------------------------------------------------------------------------------------------------------*/

/* prog1.c */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <fcntl.h>
#include <sys/stat.h>
#include <unistd.h>
#include <sys/mman.h>

#define SHM_NAME		"/sample_posix_shared_memory"
#define SHM_SIZE		4096

void exit_sys(const char *msg);

int main(void)
{
	int fdshm;
	char *shmaddr;
	char buf[4096];
	char *str;
	
	if ((fdshm = shm_open(SHM_NAME, O_RDWR|O_CREAT, S_IRUSR|S_IWUSR|S_IRGRP|S_IROTH)) == -1)
		exit_sys("shm_open");

	if (ftruncate(fdshm, SHM_SIZE) == -1)
		exit_sys("ftruncate");

	shmaddr = (char *)mmap(NULL, SHM_SIZE, PROT_WRITE, MAP_SHARED, fdshm, 0);
	if (shmaddr == MAP_FAILED) 
		exit_sys("mmap");

	for (;;) {
		printf("Text:");

		/* okuma doğrudan paylaşılan bellek alanına da yapılarbilir */

		if (fgets(buf, 4096, stdin) == NULL)
			continue;
		if ((str = strchr(buf, '\n')) != NULL)
			*str = '\0';
		strcpy(shmaddr, buf);
		if (!strcmp(buf, "quit"))
			break;
	}

	if (munmap(shmaddr, SHM_SIZE) == -1)
		exit_sys("munmap");

	close(fdshm);

	if (shm_unlink(SHM_NAME) == -1)
		exit_sys("shm_unlink");

    return 0;    
}

void exit_sys(const char *msg)
{
	perror(msg);

	exit(EXIT_FAILURE);
}

/* prog2.c */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <fcntl.h>
#include <unistd.h>
#include <sys/stat.h>
#include <sys/mman.h>

#define SHM_NAME		"/sample_posix_shared_memory"
#define SHM_SIZE		4096

void exit_sys(const char *msg);

int main(void)
{
	int fdshm;
    char *shmaddr;

	if ((fdshm = shm_open(SHM_NAME, O_RDWR, 0)) == -1)
		exit_sys("shm_open");

	shmaddr = (char *)mmap(NULL, SHM_SIZE, PROT_WRITE, MAP_SHARED, fdshm, 0);
	if (shmaddr == MAP_FAILED) 
		exit_sys("mmap");

    for (;;) {
        printf("Press ENTER to read...");
        getchar();
        puts(shmaddr);
        if (!strcmp(shmaddr, "quit"))
            break;
    }

	if (munmap(shmaddr, SHM_SIZE) == -1)
		exit_sys("munmap");

    close(fdshm);

    return 0;    
}

void exit_sys(const char *msg)
{
	perror(msg);

	exit(EXIT_FAILURE);
}

/*--------------------------------------------------------------------------------------------------------------------------
    Konu ile ilgili tipik sorular ve yanıtları şunlardır:

    SORU: POSIX paylaşılan bellek alanı nesnesi demekle ne kastedilmektedir? 
    
    YANIT: shm_open fonksiyonu sanki bir dosya yaratıyor gibi paylaşılan bellek alanı nesnesini yaratmaktadır. Aslında ortada bir dosya 
    yoktur. Ancak gerçek dosyalar da map edilebildiğinden (ileride ele alınacak) tasarım sanki "paylaşılan bellek alanı nesnesi 
    bir dosyaymı da o nesneye bir şeyler yazdığımızda o dosyaya bir şeyler yazıyormuşuz" gibi yapılmıştır. 

    SORU: POSIX paylaşılan bellek alanı shm_open fonksiyonu ile yaratıldığında gerçekte diskte bir dosya yaratılmakta mıdır?

    YANIT: Hayır yapılmamaktadır. Yalnızca bize sanki paylaşılan bellek alanı nesneleri bir dosya gibi gösterilmektedir. İşletim sistemi
    arka planda paylaşılan bellek alanı nesneleri için swap dosyalarında yer ayırabilmektedir.

    SORU: POSIX paylaşılan bellek alanları arka planda nasıl işlem görmektedir?

    YANIT: Arka plan çalışma klasik Sistem 5 paylaşılan bellek alanlarında olduğu gibidir. Yani yine proseslerin sayfa tablolarında 
    değişik sanal sayfa numaraları aynı fiziksel sayfalarla eşleştirilmektedir. 

    SORU: ftruncate fonksiyonuna neden egreksinim duyulmaktadır? 

    YANIT: Paylaşılan bellek alanı shm_open ile ilk kez yaratıldığında henüz alanın içi boştur. Ona bir uzunluk vermek gerekmektedir. 
    ftruncate ona bir uzunluk vermek için kullanılmaktadır. Tabii ftruncate fonksiyonu nesne yaratıldığı zaman bir kez çağrılır. Ancak 
    aynı uzunlukla ftruncate işleminde nesne üzerinde bir dğeişiklik olmayacaktır. 

    SORU: Private mapping yapılmasının ne anlamı olabilir? Çünkü private mapping'te nesneye yapılan yazma işlemleri 
    nesneye yansıtılmamaktadır. 

    YANIT: Private mapping'te nesneye yazma yapıldığında "copy on write" mekanizması devreye girer ve yazma yapılan sayfa
    paylaştırılan sayfadan ayrıştırılır. Copy on write mekanizması işletim sisteminin pek çok yerinde kullanılmaktadır. 
    Yani private mapping programcılardan ziyade çekirdek tarafından kullanılır. 

    SORU: Private mapping yapıldığında başka bir proses paylaşılan bellek alanına yazma yaptığında (tabii o proses de 
    paylaşılan bellek alanını shared mapping ile açmış olsun) bu yazma işlemini private mapping yapan taraf görür mü? 

    YANIT: Bu durum POSIX standartlarında "unspecified" bırakılmıştır. Linux çekirdeğinde bu yazma "private mapping yapan tarafta 
    eğer sayfada "copy on write" yapılmadıysa" görülmektedir. 

    SORU: mmap fonksiyonun birinci paremtresi ve sonuncu parametresi sayfa katlarında olmak sorunda mıdır? 

    YANIT: Eğer fonksiyonun flags parametresinde MAP_FIXED belirtilmemişse birinci parametre sayfa katlarında olmak zorunda değildir. 
    Ancak MAP_FIXED belirtilmişse POSIX'in seski versiyonu sayfa katlarını zorunlu tutmaktaydı. Ancak güncel versiyonda bu zorunluluk 
    gevşetilmiştir ve işletim sisteminin isteğine bağlı hale getirilmiştir. Linux çekirdeği MAP_FIXED durumunda birinci parametredeki adresin
    sayfa katlarında olmasını zorunlu tutmaktadır. Fonksiyonun son parametresindeki offset değeri eğer MAP_FIXED belirtilmisşe 
    POSIX standartlarına göre birinci parametrede belirtilen adresin sayfa katlarına bölümüne elde edilen kalanla aynı kalanı vermek zorundadır. 
    Ancak POSIX standartları MAP_FIXED belirtilsin ya da belirtilmesin offset değerinin işletim sistemi tarafından sayfa katlarında olmasının 
    zorunlu tutulabileceğini (may require) de belirtmiştir. Linux sistemlerinde MAP_FIXED belirtilse de belirtrilmese de offset değeri sayfa katlarında 
    olmak zorundadır. 

    SORU: Paylaşılan bellek alanları shmget ya da shm_open fonksiyonuyla oluşturulduktan sonra neden onların attach edilmesi ya da 
    map edilmesi gerekmektedir?

    YANIT: Klasik Sistem 5'teki shmget ve POSIX'teki shm_open fonksiyonları nesnenin kendisini oluşturur. Bu nesnenin proseste kullanılabilmesi 
    için prosesin adres alanı içerisine attach ya da map edilmesi gerekmektedir. Yani nesnenin var olması ayrı bir durumdur
    onun proses tarafından kullanılır duruma getirilmesi ayrı bir durumdur. Kaldı ki aynı nesne aynı prosesin adres alanı içerisinde birden 
    fazla kez de attach ya da map de edilebilir. Örneğin tipik olarak işletim sistemi shm_open fonksiyonu ile bir paylaşılan bellek alanı 
    oluşturulduğunda o alanı bir swap dosası içerisinde diskte oluşturmaktadır. Sonra bu paylaşılan bellek alanı prosesin sanal 
    bellek alanına map edildiğinde işletim sistemi prosesin sayfa tablosunda ilgili girişleri ayırır ve paylaşılan bellek alanı kullanılmaya başlandığında 
    onu RAM'e çeker. Başka bir proses de onu kullanmak isterse o prosesin sayfa tablosunda o girişleri aynı fiziksel sayfaya yönlendirir. 

    SORU: Paylaşılan bellek alanı shm_open ile açıldıktan sonra bu betimleyiciyi ne zaman kapatmalıyız? 
    
    YANIT: Aslında mapping işlemi yapıldıktan sonra bu betimleyiciyi hemen kapatabiliriz. Ancak bazen bu betimleyici ile 
    başka işlemlerin yapılması da gerekebilmektedir. Örneğin fstat fonksiyonu ile bu betimleyiciyi kullanarak paylaşılan bellek 
    alanının büyüklüğünü elde edebiliriz. 
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
                                             47.Ders 16/04/2023 - Pazar
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Bellek tabanlı dosyalar (memory mapped files) 90'lı yıllarla birlikte işletim sistemlerine sokulmuştur. Microsoft ilk kez 
    32 bit Windows sistemlerinde (Windows NT ve sonra da Windows 95) bellek tabanlı dosyaları işletim sisteminin çekirdeğine dahil etmiştir. 
    90'ların ortalarında bellek tabanlı dosyalar POSIX IPC nesneleriyle birlikte UNIX türevi sistemlere de resmi olarak sokulmuştur. 
    macOS sistemleri de bellek tabnlı dosyaları (memory mapped files) desteklemektedir. 

    Bellek tabanlı dosyalar (memory mapped files) adeta diskte bulunan bir dosyanın prosesin sanal bellek alanına çekilmesi 
    anlamına gelmektedir. Biz bir disk dosyasını bellek tabanlı biçimde açıp kullandığımızda dosya sanki bellekteymiş gibi bir 
    durum oluşturulur. Biz bellekte göstericilerle dosyanın byte'larına erişiriz. Bellekte birtakım değişikler yapıldığında 
    bu değişiklikler dosyaya yansıtılmaktadır. Böylece dosya üzerinde işlemler yapılırken read ve write sistem fonksiyonları yerine
    doğrudan göstericilerle bellek üzerinde işlem yapılmış olur. 

    read fonksiyonu ile dosyanın bir kısmını okumak isteyelim:

    result = read(fd, buf, size);

    Burada genellikle işletim sistemlerinde arka planda iki işlem yapılmaktadır: Önce dosyanın ilgili bölümü işletim sisteminin
    çekirdeği içerisindeki bir alana (bu alana buffer cache ya da page cache denilmektedir) çekilir. Sonra bu alandan bizim belirttiğimiz 
    alana aktarım yapılır. Halbuki bellek tabanlı dosyalarda genel olarak bu iki aktarım yerine dosya doğrudan prosesin bellek 
    alanına map edilmektedir. Yani bu anlamda bellek tabanlı dosyalar hız ve bellek kazancı sağlamaktadır. Ayrıca her read ve write 
    işleminin kontrol edilme zorunluluğu da bellek tabanlı dosyalarda ortadan kalkmaktadır. Bir dosya üzerinde dosyanın farklı yerlerinden 
    okuma ve yazma işlemlerinin sürekli yapıldığı durumlarda bellek tabanlı dosyalar klasik read/write sistemine göre oldukça avantaj sağlamaktadır. 

    Bu noktada kişilerin akıllarına şu soru gelmektedir? Biz bir dosyayı open ile açsak dosyanın tamamını read ile belleğe okusak 
    sonra işlemleri bellek üzerinde yapsak sonra da write fonksiyonu ile tek hamlede yine onları diske yazsak bu yöntemin 
    bellek tabanlı dosyalardan bir farkı kalır mı? Bu soruda önerilen yöntem bellek tabanlı dosya çalışmasına benzemekle birlikte 
    bellek tabanlı dosyalar bu sorudaki çalışma biçiminden farklıdır. Birincisi dosyanın taamamın belleğe okunması yine iki tamponun 
    devreye girmesine yol açmaktadır. İkincisi bellek tabanlı dosyaların bir mapping oluşturması ve dolayısıyla prosesler arasında 
    etkin bir kullanıma yol açmasıdır. Yani örneğin iki proses aynı dosyayı bellek tabanlı olarak açtığında işletim sistemi her proses için 
    ayrı bir alan oluşturmamakta dosyanın parçalarını fiziksel bellekte bir yere yerleştirip o proseslerin aynı yerden çalışmasını 
    sağlamaktadır. 
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Bir dosyayı bellek tabanlı (memory mapped) biçimde kullanmak için sırasıyla şu adımlardan geçilmektedir:

    1) Dosya open fonksiyonuyla açılır ve bir dosya betimleyicisi elde edilir. Örneğin:

    int fd;
    ...

    if ((fd = open("test.txt", O_RDWR)) == -1)
        exit_sys("open");

    İleride de belirtileceği gibi dosyalar bellek tabanlı olarak yaratılamamakta ve dosyalara bellek tabanlı biçimde eklemeler yapılamamaktadır.
    Yani zaten var olan dosyalar bellek tabanlı biçimde kullanılabilirler.

    2) Açılmış olan dosya mmap fonksiyonu ile prosesin sanal bellek alanına map edilir. Yani işlemler adeta önceki konuda gördüğümüz
    POSIX paylaşılan bellek alanlarına benzer bir biçimde yürütülmektedir. (Burada shm_open yerine open fonksiyonunun kullanıldğını 
    varsayabilirsiniz.) Mapping işleminde genellikle shared mapping (MAP_SHARED) tercih edilir. Eğer private mapping (MAP_PRIVATE)
    yapılırsa mapping yapılan alana yazma yapıldığında bu dosyaya yansıtılmaz, copy on writye mekanizması devreye girer. mmap fonksiyonun son 
    iki parametresi dosya betimleyicisi ve dosyada bir offset belirtmektedir. İşte dosya betimleyicisi olarak açmış olduğumuz dosyanın 
    betimleyicisini verebiliriz. offset olarak da dosyanın neresi map edeceksek oranın başlangıç offsetini verebilriz. mapping sırasında 
    dosya göstericisinin konumunun bir önemi yoktur. Örneğin:

    char *maddr;
    struct stat finfo;
    ...

    if (fstat(fd, &finfo) == -1)
        exit_sys("fstat");
        
    if ((maddr = (char *)mmap(NULL, finfo.st_size, PROT_READ|PROT_WRITE, MAP_SHARED, fd, 0)) == MAP_FAILED) 
        exit_sys("mmap");

    Burada biz önce dosyanın uzunluğunu fstat fonksiyonu ile elde ettik sonra da mmap fonksiyonu ile dosyanın hepsini 
    shared mapping yaparak map ettik. Artık dosya bellektedir ve biz dosya işlemleri yerine gösterici işlemleri ile bellekteki 
    dosyayı kullanabiliriz. Örneğin:

    for (off_t i = 0; i < finfo.st_size; ++i)
        putchar(maddr[i]);

    mapping işleminden sonra artık dosya betimleyicisi close fonksiyonuyla kapatılabilir. Yani kapatım için unmap işleminin 
    beklenmesine gerek yoktur. 

    3) Tıpkı POSIX paylaşılan bellek alanlarında olduğu gibi işimiz bittikten sonra yapılan mapping işlemini munmap fonksiyonu ile 
    serbest bırakabiliriz. Eğer bu işlemi yapmazsak proses sonlandığında zaten map edilmiş alanlar otomatik olarak unmap edilecektir. Örneğin:

    if (munmap(maddr, finfo.st_size) == -1)
        exit_sys("munmap");

    4) Nihayet dosya betimleyicisi close fonksiyonuyla kapatılabilir. Yukarıda da belirttiğimiz gibi aslında map işlemi yapıldıktan 
    sonra hemen de close fonksiyonu ile dosya betimleyicisini kapatabilirdik. Örneğin:

    close(fd);

    Aşağıdaki örnekte komut satırından alınan dosya bellek tabanlı biçimde açılmış ve dosyanın içindekiler ekrana (stdout dosyasına)
    yazdırılmıştır. Aynı zamanda dosyanın başındaki ilk 6 karakter değiştirilmiştir. Programı çalıştırırken dosyanın başındaki 
    ilk 6 karakterin bozulacağına dikkat ediniz. 
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <fcntl.h>
#include <sys/stat.h>
#include <unistd.h>
#include <sys/mman.h>

void exit_sys(const char *msg);

int main(int argc, char *argv[])
{
    int fd;
    char *maddr;
    struct stat finfo;

    if (argc != 2) {
        fprintf(stderr, "wrong number of arguments!..\n");
        exit(EXIT_FAILURE);
    }

    if ((fd = open(argv[1], O_RDWR)) == -1)
        exit_sys("open");

    if (fstat(fd, &finfo) == -1)
        exit_sys("fstat");
        
    if ((maddr = (char *)mmap(NULL, finfo.st_size, PROT_READ|PROT_WRITE, MAP_SHARED, fd, 0)) == MAP_FAILED) 
        exit_sys("mmap");

    for (off_t i = 0; i < finfo.st_size; ++i)
        putchar(maddr[i]);

    memcpy(maddr, "xxxxx", 6);      /* dosya güncelleniyor */

    if (munmap(maddr, finfo.st_size) == -1)
        exit_sys("munmap");

    close(fd);

    return 0;    
}

void exit_sys(const char *msg)
{
	perror(msg);

	exit(EXIT_FAILURE);
}

/*--------------------------------------------------------------------------------------------------------------------------
    Bellek tabanlı dosyaları (memory mapped files) açarken ve kullanırken bazı ayrıntılara dikkat edilmesi gerekir. Burada 
    bu ayrıntılar üzerinde duracağız. 

   - Dosyayı bizim mmap fonksiyonundaki sayfa koruma özelliklerine uygun açmamız gerekmektedir. Örneğin biz dosyayı O_RDONLY modunda 
    açıp buna ilişkin sayfaları mmap fonksiyonunda PROT_READ|PROT_WRITE olarak belirlersek mmap başarısız olacak ve errno EACCESS
    değeri ile set edilecektir. Eğer biz dosyayı O_RDWR modunda açtığımız halde mmap fonksiyonunda yalnızca PROT_READ kullanırsak 
    bu durumda dosyaya yazma hakkımız olsa da sayfa özellikleri "read only" olduğu için o bellek bölgesine yazma yapılırken 
    program SIGSEGV sinyali ile çökecektir. 

    - Bellek tabanlı dosyaların O_WRONLY modunda açılması probleme yol açabilmektedir. Çünkü böyle açılmış olan bir dosyanın mmap 
    fonksiyonunda PROT_WRITE olarak map edilmesi gerekir. Halbuki Intel gibi bazı işlemcilerde PROT_WRITE zaten aynı zamanda okuma
    izni anlamına da gelmeketdir. Yani örneğin Intel'de PROT_READ diye bir sayfa özelliği yoktur. PROT_WRITE aslında PROT_READ|PROT_WRITE
    anlamına gelmektedir. Dolayısıyla biz dosyayı O_WRONLY modunda açıp mmap fonksiyonunda PROT_WRITE özelliğini belirtirsek 
    bu PROT_WRITE aynı zamanda okuma izni anlamına da geldiği için mmap başarısız olacak ve errno EACCESS değeri ile set edilecektir. 
    POSIX standartlarında da bellek tabanlı dosyaların (aynı durum shm_open için de geçerli) açılırken "read" özelliğinin olması gerektiği 
    belirtilmiştir. Yani POSIX standartları da bellek tabanlı dosyaların O_WRONLY modda açılamayacağını açılırsa mmap fonksiyonun 
    başarısız olacağını ve errno değerinin EACCESS olarak set edileceğini belirtmektedir. 

    - Bir dosyanın uzunluğu 0 ise biz mmap fonksiyonunda length parametresini 0 yapamayız. Fonksiyon doğrudan başarısızllıkla 
    sonlanıp errno değeri EINVAL olarak set edilmektedir. 

    - Anımsanacağı gibi mmap fonksiyonunun offset parametresi Linux sistemlerinde sayfa uzunluğunun katlarında olması gerekiyordu
    (POSIX bunu "may require" biçimde belirtmiştir). Yani Linux'ta biz dosyayı zaten sayfa katlarından itibaren map edebilmekteyiz. 
    Bu durumda Linux'ta zaten map edilen adres sayfanın başında olmaktadır. 

    - Biz normal bir dosyayı büyütmek için dosya göstericisini EOF durumuna çekip yazma yapıyorduk. Ya da benzer işlemi truncate, ftruncate
    fonksiyonlarıyla da yapabiliyorduk. Halbuki bellek tabanlı olarak açılmış olan dosyalar bellek üzerinde hiçbir biçimde büyütülememektedir. 
    Biz bir dosyayı mmap fonksiyonu ile dosya uzunluğundan daha fazla uzunlukta map edebiliriz. Örneğin dosya 10000 byte uzunlukta olduğu 
    halde biz dosyayı 20000 byte olarak map edebiliriz. Bu durumda dosyanın sonundan o sayfanın sonuna kadarki alana biz istediğimiz gibi 
    erişiriz. Dosyanın uzunluğu 10000 byte ise dosyanın son sayfasında dosyaya dahil olmayan 2288 byte bulunacaktır (3 * 4096 - 10000). 
    İşte bizim bu son sayfadaki 2288 byte'a erişmemizde hiçbir sakınca yoktur. Ancak bu sayfanın ötesinde erişim yapamayız. yani
    bizim artık 3 * 4096 = 12288'den 20000'e kadarki alana erişmeye çalışmamamız gerekir. Eğer bu alana erişmeye çalışırsak 
    SIGBUS sinyali oluşur ve prosesimiz sonlandırılır. Pekiyi bir dosyanın uzunluğundan fazla yerin map edilmesinin bir anlamı olabilir mi?
    Daha önceden de belirttiğimiz gibi bellek tabanlı dosyalar bellek üzerinde büyütülemezler. Yani biz dosyayı uzunluğunun ötesinde 
    map ederek oraya yazma yapmak suretiyle büyütemeyiz. Ancak dosyalar dışarıdan büyütülebilmektedir. 
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
                                                    48. Ders 29/04/2023 - Cumartesi
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Bellek tabanlı dosyaların çalışma mekanizmasının iyi anlaşılması için öncelikle dosya işlemlerinde read ve write işlemlerinin
    nasıl yapıldığı hakkında bilgi sahibi olunması gerekmektedir. 
    
    Biz write POSIX fonksiyonuyla dosyaya bir yazma yaptığımızda write fonksiyonu genellikle doğrudan bu işlemi yapan bir sistem 
    fonksiyonunu çağırmaktadır. Örneğin Linux sistemlerinde write fonksiyonu prosesi kernel moda geçirerek doğrudan sys_write isimli 
    sistem fonksiyonunu çağırır. Pekiyi bu sys_write sistem fonksiyonu ne yapmaktadır? Genellikle işletim sistemlerinde 
    dosyaya yazma yapan sistem fonksiyonları hemen yazma işlemini diske yapmazlar. Önce kernel içerisindeki bir tampona yazma yaparlar. 
    Bu tampona Linux sistemlerinde eskinden "buffer cache" denirdi. Sonradan sistem biraz değiştirildi "page cache" denilmeye başlandı. 
    İşte bu tampon sistemi işletim sisteminin bir "kernel thread'i tarafından belli periyotlarla diske flush edilmektedir. 
    Yani biz diske write fonksiyonu ile yazma yaptığımızda aslında bu yazılanlar önce kernel içerisindeki bir tampona (Linux'ta page cache)
    yazılmakta işletim sisteminin bağımsız çalışan başka bir akışı tarafından çok bekletilmeden bu tamponlar diske flush edilmektedir. 
    Pekiyi neden write fonksiyonu doğrudan diske yazmak yerine önce bir tampona (page cache) yazmaktadır? İşte bunun amacı 
    performansın artırılmasıdır. Bu konuya genel olarak "IO çizelgelemesi (IO scheduling)" denilmektedir. IO çizelgemesi 
    diske yazılacak ya da diskten okunacak bilgilerin bazılarının bir araya getirilerek belli bir sırada işleme sokulması anlamına 
    gelmektedir. (Örneğin biz dosyaya peşi sıra birkaç write işlemi yapmış olalım. Bu birkaç write işlemi aslında kernel içerisindeki 
    page cache'e yapılacak ve bu page cache'teki sayfa tek hamlede işletim sistemi tarafından diske flush edilecektir.) Tabii işletim 
    sisteminin arka planda bu tamponları flush eden kernel thread'i çok fazla beklemeden bu işi yapmaya çalışmaktadır. Aksi takdirde 
    elektrik kesilmesi gibi durumlarda bilgi kayıpları daha yüksek düzeyde olabilmektedir. Pekiyi biz write fonksiyonu ile yazma yaptığımızda 
    mademki yazılanlar hemen diskteki dosyaya aktarılmıyor o halde başka bir proses tam bu işlemden hemen sonra open fonksiyonu ile dosyayı 
    açıp ilgili yerden okuma yapsa bizim en son yazdıklarımızı okuyabilecek midir? POSIX standartlarına göre write fonksiyonu geri 
    döndüğünde artık aynı dosyadan bir sonraki read işlemi ne olursa olsun write yapılan bilgiyi okumalıdır. İşte işletim sistemleri 
    zaten bir dosya açıldığında read işleminde de write işleminin kullandığı aynı tamponu kullanmaktadır. u tasarıma "unified file system" 
    de denilmektedir. Bu tasarımdan dolayı zaten ilgili dosya üzerinde işlem yapan herkes aynı işletim sistemi içerisindeki 
    tamponları kullanmaktadır. Dolayısıyla bu tamponların o anda flush edilip edilmediğinin bir önemi kalmamaktadır. (Tabii bir proses 
    işletim sistemini bypass edip doğrudan disk sektörlerine erişirse bu durumda gerçekten henüz write fonksiyonu ile yazılanların 
    dosyaya yazılmamış olduğunu görebilir.)

    Pekiyi biz bir dosyayı bellek tabanlı olarak açarak o bellek alanını güncellediğimizde oradaki güncellemeler başka prosesler
    tarafından read işlemi sırasında görülecek midir? Ya da tam tersi olarak başka prosesler write yaptığında bizim map ettiğimiz 
    bellek otomatik bu yazılanları görecek midir? İşte POSIX standartları bunun garantisini vermemiştir. POSIX standartlarında 
    bellek tabanlı dosyanın bellek içeriğinde değişiklik yapıldığında bu değişikliğin diğer prosesler tarafından görülebilmesi için ya da 
    diğer proseslerin yaptığı write işleminin bellek tabanlı dosyanın bellek alanına yansıtılabilmesi için msync isimli bir POSIX 
    fonksiyonunun çağrılması gerekmektedir. Her ne kadar POSIX standartları bu msync fonksiyonunun çağrılması gerektiğini belirtiyorsa 
    da Linux gibi pek çok UNIX türevi sistem "unifed file system" tasarımı nedeniyle aslında msync çağrısına gereksinim 
    duymamaktadır. Örneğin Linux'ta biz bir bellek tabanlı dosyayı map ettiğimizde aslında sayfa tablosunda bizim map ettiğimiz kısım
    doğrudan zaten işletim sisteminin tamponunu (page cache) göstermektedir. Sistem dosyanın o parçası için her zaman o tamponu kullandığından dolayı
    aslında bellek tabanlı dosyanın bellek alanına yazma yapıldığında Linux'ta o yazma adeta o anda dosyaya yapılmış gibi bir 
    durum olulmaktadır. Benzer biçimde başka bir proses dosyaya yazma yaptığında aslında o da aynı tampona (page cache) yazma yapmış 
    olmaktadır. Ancak ne olursa olsun taşınabilir programların bu msync fonksiyonunu aşağıda belirteceğimiz biçimde çağırması gerekmektedir. 

    Aşağıdaki örnekte "sample.c" programı bir dosyayı bellek tabanlı olarak açıp beklemiştir. "mample.c" isimli program ise 
    aynı dosyayı open fonksiyonu ile açıp dosyanın başına write işlemi yapıp beklemiştir. Linux sistemlerinde hiç msync fonksiyonu
    çağrılmadan "mample.c" programının yazdığı şeyler "sample.c" programı tarafından görülecektir. Bu testi yaparken önce içi dolu 
    olan bir dosya yaratınız. Bu dosyanın "test.txt" olduğunuy varsayalım. Farklı terminallerden programları aşağıdaki gibi çalıştırınız:

    ./sample test.txt
    ./mample test.txt
---------------------------------------------------------------------------------------------------------------------------*/

/* sample.c */

#include <stdio.h>
#include <stdlib.h>
#include <fcntl.h>
#include <sys/stat.h>
#include <unistd.h>
#include <sys/mman.h>

void exit_sys(const char *msg);

int main(int argc, char *argv[])
{
    int fd;
    char *maddr;
    struct stat finfo;

    if (argc != 2) {
        fprintf(stderr, "wrong number of arguments!..\n");
        exit(EXIT_FAILURE);
    }

    if ((fd = open(argv[1], O_RDWR)) == -1)
        exit_sys("open");

    if (fstat(fd, &finfo) == -1)
        exit_sys("fstat");
        
    if ((maddr = (char *)mmap(NULL, finfo.st_size, PROT_READ|PROT_WRITE, MAP_SHARED, fd, 0)) == MAP_FAILED) 
        exit_sys("mmap");

    printf("Press ENTER to continue..\n");

    getchar();

    printf("---------\n");

    for (off_t i = 0; i < finfo.st_size; ++i)
        putchar(maddr[i]);

    printf("press ENTER to exit...\n");
    getchar();

    if (munmap(maddr, finfo.st_size) == -1)
        exit_sys("munmap");
  
    close(fd);

    return 0;    
}

void exit_sys(const char *msg)
{
	perror(msg);

	exit(EXIT_FAILURE);
}

/* mample.c */

#include <stdio.h>
#include <stdlib.h>
#include <fcntl.h>
#include <unistd.h>

void exit_sys(const char *msg);

int main(int argc, char *argv[])
{
    int fd;

    if (argc != 2) {
        fprintf(stderr, "wrong number of arguments!..\n");
        exit(EXIT_FAILURE);
    }

    if ((fd = open(argv[1], O_WRONLY)) == -1)
        exit_sys("open");

    if (write(fd, "zzzzz", 5) == -1 )
        exit_sys("write");

    printf("Press ENTER to exit...\n");

    getchar();

    close(fd);

    return 0;    
}

void exit_sys(const char *msg)
{
	perror(msg);

	exit(EXIT_FAILURE);
}

/*--------------------------------------------------------------------------------------------------------------------------
    Yukarıda da belirttiğimiz gibi her ne kadar Linux gibi "unified file system" tasarımını kullanan işletim sistemlerinde msync
    fonksiyonu gerekmiyorsa da bellek tabanlı dosyada yapılan değişikliklerin diskteki dosyaya yansıtılması, diskteki dosyada 
    yapılan değişikliklerin bellek tabanlı dosyanın bellek alanına yansıtılması için msync isimli POSIX fonksiyonun çağrılması 
    gerekmektedir. msync fonksiyonunun prototipi şöyledir:

     #include <sys/mman.h>

    int msync(void *addr, size_t len, int flags);

    Fonksiyonun birinci parametresi flush edilecek bellek tabanlı dosyanın bellek adresini, ikinci parametresi bunun uzunluğunu belirtmektedir. 
    POSIX standartlarına göre birinci parametrede belirtilen adresin "sayfa katlarında olması zorunlu değildir, ancak işletim sistemi 
    bunu zorunlu yapabilir (may require)". Linux sistemlerinde bu adresin sayfa katlarında olması zorunlu tutulmuştur. Fonksiyonun ikinci parametresi 
    flush edilecek byte miktarını belirtmektedir. Burada belirtilen byte miktarı ve girilen adresi kapsayan tüm sayfalar işleme sokulmaktadır. (Örneğin
    birinci parametrede belirtilen adres sayfa katlarında olsun. Biz ikinci parametre için 7000 girsek sayfa uzunluğu 4K ise sanki 
    8192 girmiş gibi etki oluşacaktır.) Fonksiyonun son parametresi flush işleminin yönünü belirtmektedir. Bu parametre aşağıdaki bayraklardan 
    yalnızca birini alabilir:

    MS_SYNC: Burada yön bellekten diske doğrudur. Yani biz bellek tabanlı dosyanın bellek alanında değişiklik yaptığımızda bunun
    diskteki dosyaya yansıtılabilmesi için MS_SYNC kullanabiliriz. Bu bayrak aynı zamanda msync fonksiyonu geri döndüğünde flush işleminin
    bittiğinin garanti edilmesini sağlamaktadır. Yani bu bayrağı kullandığımızda msync flush işlemi bitince geri dönmektedir.  

    MS_ASYNC: MS_SYNC bayrağı gibidir. Ancak bu bayrakta flush işlemi başlatılıp msync fonksiyonu hemen geri dönmektedir. Yani
    bu bayrakta msync geri döndüğünde flush işlemi başlatılmıştır ancak bitmiş olmak zorunda değildir. 

    MS_INVALIDATE: Buradaki yön diskten belleğe doğrudur. Yani başka bir proses diskteki dosyayı güncellendiğinde bu güncellemenin
    bellek tabanlı dosyanın bellek alanına yansıtılması sağlanmaktadır. 
    
    munmap işlemi ile bellek tabanlı dosyanın bellek alanı unmap edilirken zaten msync işlemi yapılmaktadır. Benzer biçimde proses
    munmap yapmadan sonlanmış olsa bile sonlanma sırasında munmap işlemi işletim sistemi tarafından yapılmakta ve bu flush işlemi de
    gerçekleştirilmektedir. 

    Fonksiyon başarı durumunda 0 değerine başarısızlık durumunda -1 değerine geri dönmektedir. 

    Bu durumda biz POSIX standartlarına uygunluk bakımından örneğin bir bellek tabanlı dosyanın bellek alanına bir şeyler yazdığımızda
    o alanın flush edilmesi için MS_SYNC ya da MS_ASYNC bayraklarıyla msync çağrısını yapmamız gerekir:

    if ((maddr = (char *)mmap(NULL, finfo.st_size, PROT_READ|PROT_WRITE, MAP_SHARED, fd, 0)) == MAP_FAILED) 
        exit_sys("mmap");

    memcpy(maddr, "ankara", 6);

    if (msync(maddr, finfo.st_size, MS_SYNC) == -1)     /* bellekteki değişiklikler diske yazsıtılıyor */
        exit_sys("msync");

    Yine POSIX standartlarına uygunluk bakımından dışarıdan bir prosesin bellek tabanlı dosyada değişiklik yapması durumunda
    onun bellek tabanlı dosyanın bellek alanına yansıtılabilmesi için MS_INVALIDATE bayrağı ile msync fonskyionunun çağrılması gerekmektedir. 
    Örneğin:

     if ((maddr = (char *)mmap(NULL, finfo.st_size, PROT_READ|PROT_WRITE, MAP_SHARED, fd, 0)) == MAP_FAILED) 
        exit_sys("mmap");

    /* başka bir proses dosya üzerinde değişiklik yapmış olsun */

    if (msync(maddr, finfo.st_size, MS_INVALIDATE) == -1)     /* diskteki değişiklikler belleğe yansıtılıyor */
        exit_sys("msync");

    msync fonksiyonunda yalnızca tek bir bayrak kullanılabilmektedir. Bu nedenle iki işlemi MS_SYNC|MS_INVALIDATE biçiminde
    birlikte yapmaya çalışmayınız. 

    Aşağıda msync fonksiyonunun kullanımına ilişkin bir örnek verilmiştir. 
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <fcntl.h>
#include <sys/stat.h>
#include <unistd.h>
#include <sys/mman.h>

void exit_sys(const char *msg);

int main(int argc, char *argv[])
{
    int fd;
    char *maddr;
    struct stat finfo;

    if (argc != 2) {
        fprintf(stderr, "wrong number of arguments!..\n");
        exit(EXIT_FAILURE);
    }

    if ((fd = open(argv[1], O_RDWR)) == -1)
        exit_sys("open");

    if (fstat(fd, &finfo) == -1)
        exit_sys("fstat");
        
    if ((maddr = (char *)mmap(NULL, finfo.st_size, PROT_READ|PROT_WRITE, MAP_SHARED, fd, 0)) == MAP_FAILED) 
        exit_sys("mmap");

    memcpy(maddr, "ankara", 6);

    if (msync(maddr, finfo.st_size, MS_SYNC) == -1)
        exit_sys("msync");

    printf("Press ENTER to continue..\n");

    if (munmap(maddr, finfo.st_size) == -1)
        exit_sys("munmap");

    close(fd);

    return 0;    
}

void exit_sys(const char *msg)
{
	perror(msg);

	exit(EXIT_FAILURE);
}

/*--------------------------------------------------------------------------------------------------------------------------
    Pekiyi bellek tabanlı dosyanın MAP_PRIVATE ile private olarak map edilemsinin nasıl bir amacı olabilir? İşte daha önceden de belirtildiği 
    gibi "private mapping" "copy on write" mekanizması için kullanılmaktadır. Örneğin iki porses aynı dosyayı private mapping yaptığında
    işletimn sistemi bu iki prosesin dosyasını fiziksel bellekte aynı tamponu (page cache) belirtecek biçimde ayarlamaktadır. 
    Ancak proseslerden biri dosyaya yazma yaptığında bu yazma dosyaya değil, tamponun o anda çıkartılan başka bir kopyasına yapılmaktadır. 
    Yani "copy on write" şu anlama gelmektedir: "Okuma yapıldığı sürece aynı tamponu payla, yazma yapıldığında o sayfayı ayır". 

    Bellek tabanlı dosyalarda private mapping özellikle işletim sistemi tarafından "çalıştırılabilir (executable)" dosyaların ve "dinamik kütüphanelerin"
    yüklenmesi sırasında kullanılmaktadır. Örneğin "sample" isimli çalıştırılabilir bir ELF dosyasının içeriği "kabaca" şöyledir:

    .text
    .data
    .bsdd
    diğer bölümler (sections)

    ELF formatı "bölümlerden (sections)" oluşmaktadır. exec fonksiyonları ELF formatını yüklerken her bölümü "sections" private 
    mapping yaparak belleğe yüklemektedir. Dolayısıyla bir programı ikinci kez çalıştırdığımızda aslında mümkün olduğunca aynı fiziksel 
    bellek kullanılmakta bir proses yazma yaptığında ilgi sayfa "copy on write" mekanizması yoluyla farklılaştırılmaktadır.
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Linux sistemlerinde mmap fonksiyonun MAP_SHARED, MAP_PRIVATE ve MAP_FIXED bayraklarının dışında POSIX'te olmayan başka 
    bayrakları da vardır. Bu bayraklardan en önemlisi MAP_ANONYMOUS bayrağıdır. Bu bayrakla mapping yapıldığında bu duruma
    Linux sistemlerinde "anonymous mapping" denilmektedir. Anonymous mapping dosya üzerinde (yani bellek tabanlı dosya biçiminde)
    yapılamamaktadır. Dolayısıyla anonymous mapping yapılırken mmap fonksiyonunun fd ve offset parametreleri dikkate alınmamaktadır. 

    Anonymous mapping işleminde kalıcı yer olarak (backing store) doğrudan işletim sisteminin "swap dosyaları" kullanılmaktadır. 
    Böylece aslında anonymous mapping adeta bellek tahssisatı anlamına gelmektedir. Zaten glibc kütüphanesindeki malloc, calloc ve realloc
    fonksiyonları arka planda "anoymous mapping" işlemini yapmaktadır. Tipik olarak glibc kütüphanesinde "malloc" fonksiyonu önce 
    geniş bir alanı mmap fonksiyonu ile anonymous mapping yaparak yaratmakta sonra bu alanı tahsisat için organize etmektedir. 
    Yani malloc fonksiyonu güncel kütüphanede aslında önce geniş bir alanı anonymous mapping yöntemiyle tahsis etmekte sonra orayı 
    organize etmektedir. Pekiyi biz anonymous mapping işlemini malloz işlemi yerine kullanabilir miyiz? Aslında kullanabiliriz. 
    Ancak anonymous mapping sayfa katlarında tahsisat yapmaktadır. Oysa malloc fonksiyonu byte temelinde tahsisat yapmaktadır. 
    Bu durumda anoymous mapping yerine malloc işlemi genel olarak çok daha uygundur. Fakat yine de büyük blokların tahsis edilmesi 
    gibi durumlarda anonymous mapping daha doğrudan ve daha hızlı bir tahsisata olanak verebilmektedir. 

    mmap fonksiyonunda MAP_ANONYMOUS kullanıldığında fonksiyonun fd parametresi dikkate alınmamaktadır. Ancak MAP_ANONYMOUS bayrağını destekleyen 
    diğer bazı işletim sistemlerinde bu parametrenin -1 girilmesi gerekmektedir. Bu nedenle bu parametrenin -1 olması uygundur. 
    Fonksiyonun offset parametresi de dikkate alınmamaktadır. Bu parametre 0 olarak girilebilir.

    MAP_ANONYMOUS bayrağı MAP_PRIVATE ya da MAP_SHAED ile birlikte kullanılmaktadır. En normal durum MAP_ANOYMOUS bayrağı ile MAP_PRIVATE
    bayrağının birlikte kullanılmasıdır. Pekiyi MAP_ANONYMOUS|MAP_PRIVATE ile MAP_ANONUMOUS|MAP_SHARED arasında ne farklılık vardır?
    İşte normal olarak anonymous mapping için ayrılan swap alanı başka prosesler tarafından kullanılamamaktadır. Ancak fork işlemi 
    üst proses bir proses yarattığında tüm mapping alanları alt prosese aktarılmaktadır. O halde biz MAP_ANONYMOUS|MAP_SHARED 
    uyguladığımızda fork yapmakdıktan sonra bunun MAP_ANONYMOUS|MAP_SHARED işleminden hiçbir farkı olmayacaktır. Ancak fork yapıldığında 
    MAP_ANONYMOUS|MAP_SHARED uygulamasında üst ve alt prosesler aynı anonymous alanı paylaşacaktır. Yani örneğin üst proses buraya 
    bir şey yazdığında alt proses onu görecektir. Ancak MAP_ANOBYNOUS|MAP_PRIVATE uygulamasında üst proseslerden biri alan bir 
    şey yazdığında "copy on write" mekanizması devreye girecek ve yazılanı diğer proses görmeyecektir. malloc fonksiyonu da
    arka planda büyük alanı mmap ile tahsis ederken MAP_ANOYMOUS|MAP_PRIVATE uygulamaktadır. 

    Aşağıdaki örnekte mmap ile anonymous mapping örneği verilmiştir. 
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/mman.h>

void exit_sys(const char *msg);

int main(int argc, char *argv[])
{
    char *maddr;
         
    if ((maddr = (char *)mmap(NULL, 4096, PROT_READ|PROT_WRITE, MAP_ANONYMOUS|MAP_PRIVATE, -1, 0)) == MAP_FAILED) 
        exit_sys("mmap");

    strcpy(maddr, "ankara");
    puts(maddr);   

    if (munmap(maddr, 4096) == -1)
        exit_sys("munmap");

    return 0;    
}

void exit_sys(const char *msg)
{
	perror(msg);

	exit(EXIT_FAILURE);
}

/*--------------------------------------------------------------------------------------------------------------------------
    POSIX standartlarına göre mmap fonksiyonunda bir tahsisat yapıldığında dosyaya ilişkin olmayan tüm alanlar otomatik olarak 
    sıfırlanmaktadır. Linux sistemlerinde de durum böyledir. Default olarak anonymous mapping yapıldığında da tahsis edilen alan sıfırlanmaktadır. 
    Ancak Linux'ta POSIX'te olmayan MAP_UNINITIALIZED isimli bir bayrak da vardır. Eğer bu bayrak kullanılırsa tahsis edilen alanlar 
    sıfırlanmaz. Bazen programcılar tahsisatı hızlandırmak için MAP_ANONYMOUS|MAP_PRIVATE|MAP_UNINITIALIZED biçiminde bayrak kullanabilmektedir. 

    Daha önceden de "çalıştırıabilir dosyaların exec fonkisyonları tarafından bölüm bölüm (section section) belleğe mmap 
    mekanizmasıyla map edildiğini belirtmiştik. İşte ilkdeğer verilmemiş global değişkenlerin bulunduğu ".bss" alanı da 
    zaten mapping işlemi yapılırken sıfırlanmaktadır. 
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
                                                49. Ders 30/04/2023 - Pazar
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Sanal bellek kullanan işletim sistemlerinde bazı sayfaların lock edilmesine olanak verilebilmektedir. Bir sayfa lock edildiğinde 
    artık o sayfa fiziksel RAM'de yer açmak için işletim sistemi tarafından "swap out" yapılmamaktadır. Bir sayfanın belleğe lock
    edilmesinin iki avantajı olabilmektedir:

    1) Bu sayede swap out yapılmayacağı için göreli bir hız kazancı sağlanır. Özellikle gerçek zamanlı uygulamalarda bu tür hız kazançları
    önemli olabilmektedir. 
    2) Bu sayede swap dosyalarından bilgi çalmaya çalışan kişiler engellenmiş olur. Tabii swap dosyalarından bilgi çalmak da 
    aslında kolay bir şey değildir. 

    Pekiyi bir proses istediği kadar sanal sayfayı lock edebilir mi? Şüphesiz eğer prosesler istedikleri kadar sanal sayfayılock edebilselerdi
    swap işlemleri konusunda dolayısıyla sanal bellek kullanımı konusunda bir baskı olulurdu. Bu nedenle işletim sistemlerinde 
    uygun önceliğe sahip olmayan proseslerin lock edebilecğei sayfa sayısında bir sınırlama yapılmaktadır. Linux'ta uygun önceliğe 
    sahip olmayan proseslerin kilitleyebileceği sayfa sayısı RLIMIT_MEMLOCK isimli kaynak limitiyle belirlenmiştir. Bu kaynak 
    limitinin hem hard hem de soft değeri mevcut Linux çekirdeklerinde 509853696 byte (124476 sayfa) adardır. Ancak Linux sistemlerinde 
    "uygun önceliğe sahip olan (appropriate privileges)" prosesler istedikleri kadar sayfayı kilitleyebilmektedir. Yani bu prosesler prosesin 
    RLIMIT_MEMLOCK limitlerinden etkilenmemektedir. 

    Sanal sayfaların belleğe lock edilmesi için birkaç fonksiyon kullanılabilmeketedir. Bu amaçla kullanılan mlock isimli POSIX 
    fonksiyonunun prototipi şöyledir:

    int mlock(const void *addr, size_t len);

    Fonksiyon birinci parametresiyle belirtilen adresten itibaren ikinci parametresiyle belirtilen uzunluktaki bellek alanını lock 
    etmektedir. Buradaki adres + uzunluk içerisinde kalan tüm sayfalar lock edilmektedir. (Yani adres bir sayfanın başına hizalanmamışsa 
    uzunluk da başka bir sayfanın ortalarına kadar gidiyorsa her baştaki ve sonraki her iki sayfa lock işlemine dahil edilmeketedir.)
    POSIX standartlarında birinci parametresiyle belirtilen adresin ilgili sistem tarafından sayfa katlarında olmasının zounlu 
    tutulabileceği (may require) belirtilmiştir. Linux sistemlerinde birinci parametrede belirtilen adresin sayfa katlarında olması 
    zorunluluğu yoktur. Uzunluk parametresi herhangi bir değerde olabilir. Fonksiyon başarı durumunda 0 değerine başarısızlık durumunda -1 değerine
    geri dönmektedir. errno uygun biçimde set edilmektedir. 

    mlovk fonksiyonu ile kilitlenmeye çalışılan sayfalar o anda RAM'de değilse mlock önce onları RAM'e alıp kilitlemektedir. 
    Yani fonksiyon başarılı bir biçimde geri döndüğünde kesinlikle sayfalar o anda RAM'de bulunmaktadır. 

    mlock ile kilitlenen sayfaların kilidni açmak için munlock POSIX fonksiyonu bulundurulmuştur. Fonksiyonun prototipi şöyledir:

    int munlock(const void *addr, size_t len);

    Fonksiyonun birinci parametresi unlock edilecek sayfalara ilişkin adresi, ikinci parametresi de uzunluğu belirtmektedir. 
    Yine bu adres + uzunluk değerini içeren tüm sayfalar unlock edilmektedir. Fonksiyon başarı durumunda 0 değerine başarısızlık durumunda 
    -1 değerine geri döner ve erro uygun biçimde set edilir. Tabii en kötü olasılıkla proses sonlandığında sayfalar zaten unlock 
    edilip boşaltılmaktadır. 
    
    mlock ve mlock fonksiyonlarında bir sayaç mekanizması yoktur. Yani bir alan birden fazla kez lock yapılsa bile tek bir unlock işlemi 
    ile unlock yapılabilmektedir. 

    Aşağıdaki örnekte mlock fonksiyonu ile bir global dizinin bulunduğu sanal sayfa kilitlenmiştir. Tabii bu örnekte aslında 
    dizi 4096 byte olmasına karşın iki sayfa da kilitlenmiş olabilir. 
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <sys/mman.h>

void exit_sys(const char *msg);

char buf[4096];

int main(void)
{
    if (mlock(buf, 4096) == -1)
        exit_sys("mlock");
    
    printf("Ok\n");

    if (munlock(buf, 4096) == -1)
        exit_sys("munlock");

    return 0;    
}

void exit_sys(const char *msg)
{
	perror(msg);

	exit(EXIT_FAILURE);
}

/*--------------------------------------------------------------------------------------------------------------------------
    Bir prosesin bütün sayfalarını lock etmek için mlockall POSIX fonksiyonu kullanılabilmektedir:

    int mlockall(int flags);

    Buradaki flags parametresi aşağıdaki sembolik sabitlerin bit OR işlemine sokulmasıyla oluşturulur:

    MCL_CURRENT: Şu anda RAM'de olan tüm sayfaların kilitleneceği anlamına gelir. 
    MCL_FUTURE: Bundan sonra RAM'e alınacak tüm sayfaların kilitleneceği anlamına gelir. 

    munlockall fonksiyonu ise ters işlemi yapmaktadır:

    int munlockall(void);

    mlockall fonksiyonu yine prosesin RLIMIT_MEMLOCK kaynak limitinden etkilenmektedir. Bunun soft değeri mevcut çekirdeklerde 
    oldukça yükseltilmiştir. 
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <sys/mman.h>

void exit_sys(const char *msg);

char buf[1000000];

int main(void)
{
    if (mlockall(MCL_CURRENT|MCL_FUTURE) == -1)
        exit_sys("mlock");
    
    printf("Ok\n");
    
    return 0;    
}

void exit_sys(const char *msg)
{
	perror(msg);

	exit(EXIT_FAILURE);
}

/*--------------------------------------------------------------------------------------------------------------------------
    Sayfa kilitleme işlemi Linux sistemlerinde mmap fonksiyonu ile mapping yapılırken mapping alanı için de MAP_LOCKED flags
    parametresi ile sağlanabilmektedir. (Bu bayrak POSIX standartlarında yoktur.) Yani biz bu sayede mapping yaptığımız alanları 
    aynı zamanda lock edebilmekteyiz. Tabii burada da prosesin RLIMIT_MEMLOCK kaynak limiti bir kısıt oluşturabilmektedir. 
    Ancak Linux sistemlerinde mmap fonksiyonundaki MAP_LOCKED bayrağı tüm map edilen sayfaları o anda RAM'e çekemeyebilmektedir. 
    Bu durumda fonksiyon başarısız olmamaktadır. Yani başka bir deyişle bu davranış mlock kadar kesin değildir. Aynı davranış 
    aslında Linux'a özgü biçimde klasik Sistem 5 paylaşılan bellek alanlarında da chmctl fonksiyonunda bazı küçük farklılıklarla bulunmaktadır. 
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Thread'ler 90'lı yıllarda işletim sistemlerine sokulmuştur. Microsoft'un thread'li ilk işletim sistemi Windows NT (1993) ve 
    sonra da Windows 95 (1995) sistemleridir. Benzer biçimde UNIX/Linux dünyasına da thread'ler ilk kez 90'lı yıllarla sokulmuştur. 
    Yani thread'ler daha önce denemeler yapılmış olsa da 90'lı yılların başlarında işletim sistemlerine sokulmuş durumdadır. 
    Bugün pek çok programalama dili ve framework kendi içerisinde thread'leri barındıran kütüphanelere sahiptir. Hatta yeni dillerin
    bazıları artık thread'leri anahtar sözcüklerle dilin sentaksına dahil etmektedir. Örneğin C++ Programlama Diline 2011 versiyonuyla (C++11)
    bir thread kütüphanesi eklenmiştir. Bnezer biçimde .NET ve C#'ın ilk sürümlerinde (2002) bile framework bir thread kütüphanesine sahipti.
    Benzer biçimde Java Dilininde kütüphanesi içerisinde thread'lerle işlem yapan sınıflar bulunuyordu. Microsoft'un MFC framework'ü gibi,
    yaygın kullanılan Qt framework'ü gibi pek çok framework kendi içerisinde bir thread kütüphanesi barındırmaktadır. Tabii thread işlemleri 
    bir dilin ya da bir framework'ün kontrolü altında olan işlemler değildir. Doğrudan işletim sistemiin kontrolü altında olan işlemlerdir. 
    Dolayısıyla programalama dilleri ya da framework'ler işletim sistemlerinin sunduğu mekanizmayı kullanmaktadır. Tabii bu diller 
    ve framework'ler thread kullanımını "platform bağımsız" hale de getirmektedir. Yani örneğin Windows'un ve Linux'un sağladığı thread 
    mekanizması farklı olmasına karşın C++'ın standart thread kütüphanesi "platform bağımsız" bir kütüphanedir. Başka bir deyişle C++'ın
    standart thread kütüphanesi Windows sistemlerinde "Windows API Fonksiyonları" kullanılarak UNIX/Linux sistemlerinde "POSIX fonksiyonları"
    kullanılarak gerçekleştirilmiştir. C programlama Diline de 2011 sürümüyle (C11) birlikte "isteğe bağlı (optional)" mini 
    bir thread kütüphanesi eklenmiştir. Ancak bu mini thread kütüphanesi Microsoft C derleycicisi tarafından ve gcc derleyicileri tarafından 
    desteklenmiyordu. Ancak gcc derleyicilerinin son versyionları bu thread kütüphanesini desteklemektedir. 

    Biz kursumuzda (kursumuz bir sistem programala kursu olduğu için) UNIX/Linux sistemlerindeki işletim sistemi çekirdeği ile ilgili 
    olan aşağı seviyeli thread mekanizması üzerinde duracağız. Yukarıda da belirttiğimiz gibi programala dili ya da framework ne olursa olsun
    UNIX/Linux sistemlerinde eninde sonunda işlemler burada anlatacak olduğumuz thread mekanizması yoluyla yapılmaktadır.
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    İşletim sistemlerinde bir prosesin bağımsız olarak çizelgelenen akışlarına "thread" denilmektedir. Thread sözcüğü İngilizce 
    "iplik" anlamına gelmektedir. Akışlar ipliklere benzetilerek bu sözcük türetilmiştir. Proses kavramı çalışmakta olan programın tüm bilgisini
    içermektedir. Oysa thread'ler yalnızca akış belirtmektedir. Bir proses tek bir akışa sahip olmak zorunda değildir. Prosesler
    birden fazla akışa sahip olabilmektedir. İşte prosesin bu bağımsız akışlarına "thread" denilmektedir. İşletim sistemlerinin 
    "çizelgeleyici (scheduler)" alt sistemleri prosesleri değil thread'leri çizelgelemektedir. Yani çizelgeleyici alt sistem bir 
    thread'i çalıştırıp belli bir quanta süresi dolduğunda ona ara vermekte ve diğer bir thread'i CPU'ya atamaktadır. Ara verilen 
    thread ile akışın CPU'ya verildiği thread aynı prosesin thread'leri olabileceği gibi farklı proseslerin thread'leri de olabilmektedir. 

    Prosesler çalışmasına tek bir thread'le başlamaktadır. Yani fork işlemi ile aslında tek bir thread yaratılmaktadır. Bir proses
    birden fazla thread'e sahipken fork işlemi yapılsa bile yeni yaratılan alt proses tek bir thread ile yaratılmaktadır. O da 
    fork işleminin yapıldığı thread'tir. Diğer thread'ler proses yaratıldıktan sonra programcı tarafından yaratılmaktadır. 
    exec işlemi yapıldığında yine prosesin tüm thread'leri yok edilir. exec yapılan program tek bir thread'le çalışmaya başlar. 
    Program çalışmaya başladığında var olan bu thread'e programın "ana thread'i (main thread)" denilmektedir. Örneğin biz 
    "sample" programını çalıştırdığımza çalışma tek bir thread ile başlatılmaktadır. Bu "sample" programının ana thread'idir. 
    Thread'lerin olmadığı zamanlarda zaten proseslerin tek bir akışı vardı. Dolayısıyla o zamanlar yalnızca ana thread bulunmaktaydı.
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Pekiyi thread'lere neden gereksinim duyulmaktadır? Bunun birkaç bariz nedenini aşağıda maddeler halinde veriyoruz:

    1) Thread'ler arka plan işlemlerin yapılması için iyi bir araç oluşturmaktadır. Bir işi yaparken aynı zamanda arka planda
    periyodik bir işlem yapmak istediğimizi düşünelim. Bu durumda biz bloke olursak artık o periyodik işlemi yapamayız. Örneğin:

    for (;;) {
        ch = getchar();
        proc(ch);
        <saati bas>
    }

    Buradaki temsili kodda klavyeden bir karakter okunmuş ve o karakter işlenmiştir. Ancak arka planda ekrana bir saat de 
    basılmaktadır. Oysa getchar gibi bir işlemde bloke oluşacağı için ekrandaki saat duracaktır. İşte eskiden bu tür işlemler 
    oldukça zor biçimde ancak  dolaylı olarak gerçekleştiriliyordu. Ancak thread'ler kullanılmaya başlandığında bu tür işlemleri gerçekleştirmek
    çok kolaylaştı. Thread'ler bağımsız çizelgelendiği için bir thread bloke olduğunda prosesin diğer thread'leri çalışmaya
    devam etmektedir. Örneğin:

    Ana thread:

    for (;;) {
        ch = getchar();
        proc(ch);
    }

    Diğer thred:

    for (;;) {
        <ssati bas>
    }

    2) Thread'ler bir işi hızlandırmak için sıkça kullanılmaktadır. Bir işin tek bir akışa yaptırılmasıyla birden fazla akışa 
    yaptırılması arasında önemli bir hız farkı olabilmektedir. Örneğin bir satranç programında thread'lerden biri mümkün hamleleri 
    tespit ederken diğer bir thread bu hamleleri analiz ediyor olabilir. Tek bir CPU'nun bulunduğu durumda da thread'ler prosesin 
    toplam CPU zamanının artırılmasını sağlayabilmektedir. (Örneğin tek bir işlemci bukunuyor olsun. Bizim dışımızda sistemde 10 thread 
    çalışıyor olsun. Biz prosesimizde tek thread oluşturursak (default durum) 1 / 11 CPU zamanı elde ederiz. İki thread oluştursak 
    2 / 12 CPU zamanı elde ederiz. Üç thread oluştursak 3 / 13 CPU zamanı elde ederiz. Bir kesrin pay ve paydasına aynı sayı eklendiğinde 
    kesrin büyüdüğüne dikkat ediniz.) 

    3) Bir programın çeşitli parçalarının çok işlemcili ya da çok çekirdekli makinelerde eş zamanlı biçimde çalıştırılmasına
    "paralel programlama" denilmektedir. Paralel programlama yapabilmek için programcının thread'leri kullanması ve thread'leri farklı 
    işlemcilere ya da çekirdeklere ataması gerekmektedir. 

    4) Thread'ler bazı durumlarda mutlak zorunlu olmasa da tasarımı kolaylaştırmak için ve sistemi ölçeklenebilir (scalable) 
    hale getirmek için kullanılabilmektedir.

    5) Thread'ler bazı durumlarda zorunlu olarak da kullanılabilmektedir. Örneğin GUI programlama modelinde bir mesajın işlenmesi 
    uzun süre aldığında bu durumda mecburen thread'ler kullanılmaktadır. 
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Programın akışına ilişkin birkaç terim bazen birbirleriyle karıştırılmaktadır. (Yine de bilgisayar bilimlerindeki terimlerin çoğu 
    farklı konularda farklı anlamlarda kullanılabilmektedir.)

    Concurrent Computing: Bu terim genel bir şemsiye terimdir. Birden fazla akışın söz konusu olabildiği tüm durumlar için kullanılabilmektedir. 
    
    Multithreading (ya da Mulitthreaded) Programming: Bir işin birden fazla thread ile gerçekleştirilmesine yönelik uygulamalar için 
    bu terim kullanılmaktadır. 

    Reentrancy: Bu terim de genellikle fonksiyon akışının içi içe geçebilmesini belirtmektedir. Örneğin bir fonksiyonun "reenterant"
    olması demek fonksiyon çalışırken yeniden aynı fonksiyonun çalıştırılması demektir. Reentrancy "özyineleme (recursion)" demek değildir. 
    Özyinelemede tek bir akış vardır. Fakat örneğin iki thread'in aynı fonksiyona girmesi durumunda bir "reentrancy" durumu oluşur. 
    Ya da örneğin bir mikro denetleyici sistemde akış bir fonksiyon üzerinde ilerlerken bir kesme oluştuğunda kesme kodu 
    yeniden aynı fonksiyonu çağrırısa burada da bir "reentrancy" durumu söz konusu olur. UNIX/Linux sistemlerinde de hiç thread 
    kullanmamış olsak da "sinyal (signal)" mekanizması bir "reentrancy" durumu oluşturabilmektedir. 

    Parallel Programming: Aynı makinede bir prosesin çeşitli thread'lerinin farklı CPU ya da çekirdeklerde eşzamanlı çalıştırılma gayretine
    paralel programlama denilmektedir. 

    Distributed Computing: Bir işin farklı bilgisayarlarda eş zamanlı bir biçimde ele alınmasına ilişkin bir terimdir. Paralel 
    programlamaya benzemektedir. Ancak paralel programlama "aynı makinede" yürütülen bir faaliyetken "distributed computing" 
    işlerin farklı makinelerde koordineli bir biçimde gerçekleştirilmesi anlamına gelmektedir. 
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
                                                    50. Ders 06/05/2023 - Cumartesi
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Thread işlemleri işletim sistemlerinde aslında birtakım sistem fonksiyonlarıyla gerçekleştirilmektedir. Örneğin Linux sistemlerinde
    thread yaratan sys_clone isimli bir sistem fonksiyonu bulunmaktadır. Ancak daha önce de ifade ettiğimiz gibi sistem fonksiyonları 
    taşınabilir değildir ve sistem fonksiyonları genellikle düşük seviyeli fonksiyonlardır. Yani bunların kullanılmaları zordur. Eskiden 
    thread'ler UNIX/Linux sistemlerine ilk sokulduğunda farklı thread kütüphaneleri oluşturulmuştu. Programcılar bu kütüphanelerden birini 
    kullanıyorlardı. Ancak 90'lı yılların ortalarında thread kütüphanesi "Realtime Extensions" başlığı altında POSIX standartlarına 
    sokulmuştur. POSIX tarafından desteklenen bu thread kütüphanesine "POSIX Thread kütüphanesi" ya da kısaca "pthread" kütüphanesi 
    denilmektedir. POSIX thread kütüphanesinin içeirsindeki bütün fonksiyonlar pthread_xxxx biçiminde "pthread_" öneki ile başlatılmış durumdadır. 
    POSIX thread kütüphanesi "libpthread" isimli bir kütüphane biçiminde oluşturulmuştur. Bu kütüphaneyi kullanırken derleme sırasında 
    "-lpthread" seçeneğinin bulundurulması gerekmektedir. Bu seçenek link aşamasında POSIX thread kütüphanesinin linker tarafından 
    işleme sokulacağını belirtmektedir. Diğer programlama dillerindeki thread kütüphaneleri de UNIX/Linux sistemlerinde pthread 
    kütüphanesi kullanılarak gerçekleştirilmiştir. Yani bu anlamda pthread kütüphanesi "taban (base)" bir kütüphanedir. 
    (Örneğin C++11 ile birlikte C++'a bir thread kütüphanesi eklenmiştir. Bu kütüphanenin UNIX/Linux sistemlerindeki gerçekleştirimi 
    pthread kütüphanesi kullanılarak yapılmıştır. Tabii C++'ın thread kütüphanesi C++'ın standart kütüphanesinin bir parçasıdır. 
    Dolayısıyla "cross platform" özelliği vardır. Yani örneğin aynı kütüphane Windows sistemlerinde Windows API fonksiyonları kullanılarak
    gerçekleştirilmiş durumdadır.)
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Thread'ler aynı prosesin bağımsız çizelgelenen farklı akışlarıdır. Bir işi ikiş thread'e yaptırmakla iki prosese yaptırmak arasında 
    şu önemli farklılıklar vardır:

    - Prosesin thread'leri aynı bellek alanını kullanmaktadır. Yani örneğin bir thread bir global değişkene bir şey yazsa 
    diğer thread bunu görmektedir. Oysa proseslerin bellek alanları tamamen izole edilmiştir. Porsesler arasındaki haberleşme maliyetli  
    yüksetir ve proseslerarası haberleşme kodu daha karmaşık hale getirmektedir. Halbuki thread'ler global eğişkenler yoluyla 
    ya da heap yoluyla daha az maliyetle haberleşebilmektedir.

    - Thread'lerin yaratılması ve yok edilmesi proseslere göre daha hızlıdır. Çünkü bir proses yaratılırken arka planda prosese özgü 
    pek çok yaratım işlemleri de yapılmaktadır.

    - Thread'ler proseslere göre daha az sistem kaynağı harcama eğilimindedir. Yani bir prosesin yaratılması sırasında harcanan sistem 
    kaynağı bir thread'in yaratılması sırasında harcanan sistem kaynağından daha yüksektir.

    Proses kavramı çalışmakta olan programın tüm bilgilerini belirtmektedir. Thread ise yalnızca bir akış belirtmektedir. Örneğin:

    - Thread'lerin gerçek ve etkin kullanıcı id'leri ve grup id'leri yoktur. Proseslerin vardır. Yani bir prosesin tüm thread'leri aynı
    kullancı ve grup id'sine sahiptir. 

    - Thread'lerin çalışma dizinleri, çevre değişkenleri yoktur. Proseslerin vardır. Örneğin biz bir proseste chdir POSIX fonksiyonu ile 
    çalışma dizininini (current working directory) değiştirdiğimizde tüm thread'ler için bu durum geçerlidir. 

    - Dosya betimleyici tablosu prosese özgüdür. Dolatısıyla tüm thread'ler aynı dosya betimleyici tablosunu kullanmaktadır. 

    - Prosesin thread'lerinin proses id'leri aynıdır. 
    
    Ancak UNIX/Linux dünyasında threadler arasında bir altlık-üstlük (parent-child) ilişkisi yoktur. Yani bir thread'in hangi 
    thread tarafından yaratıldığının (istisna bazı durumlar dışında) bir önemi yoktur. Dolayısıyla UNIX/Linux dünyasında "üst hread (parent thread)"
    ve "alt thread (child thread)" biçiminde kavramlar yoktur.
   ---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Proses çalışmaya tek bir thread ile başlamaktadır. Diğer thread'ler programcı tarafından yaratılmaktadır. Bir thread yaratılırken 
    thread akışının başlatılacağı bir fonksiyon da belirtilmektedir. Nasıl programın ana thread'i yani ana akışı akışı main fonksiyonundan başlıyorsa 
    bizim yarattığımız thread'in akışı da bizim belirttiğimiz bir fonksiyondan başlatılmaktadır. Örneğin biz bir thread yaratmış olalım 
    ve thread'imizin akışı da foo fonksiyonundan başlatılmış olsun:

    int main(void)
    {
        ...
    }
    ...
    void *foo(void *param)
    {
        ...
    }
    ...

    Burada bir akış main fonksiyonundan ilerlerken diğer akış bağımız olarak foo fonksiyonundan itibaren ilerleyecektir. 
    Bu iki akış aynı programın içerisindedir. Dolayısıyla bu akışlardan biri bir global değişkeni değiştirse diğeri de onu 
    değişmiş görecektir. Şimdi bu durumu aşağıdaki durum ile kıyaslayınız:

    int main(void)
    {
        ...
        if ((pid = fork()) == -1)
            exit_sys("fork");
        if (pid == 0)
            foo();
        ...
    }

    void foo(void)
    {
        ....
    }

    Biz burada benzer işlemi fork ile yapmaya çalıştık. Ancak fork yaptığımızda biz maliyetli bir biçimde yeni bir proses yarattık. 
    Bu prosesin bilgileri üst prosesten alınmaktadır. Ayrıca yarattığımız alt proses ayrı bir bellek alanına sahiptir. Dolayısıyla
    örneğin aynı global değişkenleri kendi aralarında paylaşmamaktadır. Örneğin biz alt proseste dosya açsak üst proses bunbu görmeyecektir. 
    Halbuki thread'ler aynı prosesin akışlarıdır. Prosesin bir thread'i bir dosya açsa diğer thread'i onu açık olarak görmektedir. 
    Proseslerle thread'ler akış bakımından benzemektedir. Her iki durumda da farklı akış oluşturulmaktadır. Thread'lere ilk zamanlar 
    bu benzerlikten hareketle "ligghtweight (hafif siklet)" proses de denilmektedir. 
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Her ne kadar prosesin thread'leri aynı bellek alanını kullanıyorsa da "stack" konusunda bu durum geçerli değildir. Thread'lerin 
    stack'leri biribirinden ayrılmıştır. Başka bir deyişle bir thread yaratıldığında o thread için ayrı bir stack yaratılmaktadır. 
    Yerel değişkenlerin ve parametre değişkenlerinin stack'te yaratıldığını anımsayınız. Thread'lerin stack'leri biribirinden ayrıldığı için 
    farklı thread akışları aynı fonksiyon üzerinde ilerlese bile aynı yerel değişkenleri görmemektedir. Yerel değişkenlerin her thread 
    için ayrı bir kopyası oluşturulmaktadır. Örneğin:

    int g_x;

    void *thread_proc1(void *param)
    {
        ...
        foo();
        ...
    }

    void *thread_proc2(void *param)
    {
        ...
        foo();
        ...
    }

    void foo(void)
    {
        int a = 10;
        static int b = 10;
        ...
        ++a;
        ...
        ++a;
        ...
        ++b;
        ...
        ++g_x;
        ...
    }

    Burada iki thread foo üzerinde ilerlerken aslında yerel değişken olan a'nın kendi kopyaları üzerinde işlem yapmaktadır. Yani bir thread 
    buradaki yerel a değişkenini değiştirdiğinde diğer thread bu değişikliği görmez. Başka bir deyişle her thread'in kendine 
    özgü farklı bir a değişkeni vardır. Bu durumun teknik açıklaması şöyledir: Yerel değişkenler stack'te yaratılmaktadır. Thread'lerin de 
    stack'leri birbirinden ayrıldığı için bu a değişkeni hangi thread akışı o fonksiyonu çağırmışsa onun stack'inde yaratılmaktadır. 

    Ancak prosesin bütün thread'leri aynı ".data" ve ".bss" ve "heap" alanını ortak kullanmaktadır. Bu nedenle thread'lerden biri yukarıdaki 
    örnekte ++g_x global değişkenini artırdığında diğeri onu artırılmış olarak görecektir. Fonksiyonların static yerel değişkenleri stack'te
    yaratılmamaktadır. Eğer ilkdeğer verilmişse bunlar ".data" alanında, ilkdeğer verilmemişse ".bss" alanında yaratılmaktadır. Dolayısıyla 
    örneğin bir thread static bir yerel değişkeni değiştirirse diğer thread onu değişmiş olarak görmektedir. 

    İşletim sistemlerinde yaratılan bir thread'in default stack büyüklüğü sistemden sisteme değişebilmektedir. Linux sistemlerinde thread 'ler default olarak 
    8MB stack ile yaratılmaktadır. Ancak thread'ler yaratılırken programcı isterse stack büyüklüğünü kendisi de belirleyebilmektedir. 
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Thread'lerin errno değişkenleri biribirinden farklıdır. Yani her thread'in ayrı bir errno değişkeni vardır. Örneğin biz bir thread'te 
    bir POSIX fonksiyonu çağırsak o POSIX fonksiyonu başarısız olsa o thread'in errno değişkeni set edilir. Diğer thread'lerin errno değişkenleri 
    bundan etkilenmez. perror fonksiyonu da kendi thread'inin errno değişkenini kullanmaktadır. Yani biz perror fonksiyonu ile 
    hata mesajını stderr dosyasına yazdırmak istersek perror o thread'in errno değişkeninin değerine başvurarak yazıyı oluşturacaktır.
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    POSIX thread kütüphanesini incelemeden önce kütüphanedeki bazı ortak özellikleri belirtelim:

    - Kütüphandeki bütün fonksiyonların isimleri "pthread_" ile başlatılmıştır. 
    
    - Kütüphanedeki fonksiyonların büyük bölümünün geri dönüş değeri int türdendir. Bu fonksiyonlar başarı durumunda 0 değerine
    başarısızlık durumunda bizzat errno değerinin kendisine geri dönmektedir. Bu fonksiyonlar errno değişkenini set etmemektedir. 
    Başarısızlık durumunda errno değerinin kendisine geri dönmektedir. Bu durumda başarı kontrolünün yapılması ve hata mesajlarının 
    yazdırılşması şöyle yapılabilir:

    int result;
    ...
    if ((result = pthread_xxxx(...)) != 0) {
        fprintf(stderr, "phread_xxx: %s\n", strerror(result));
        exit(EXIT_FAILURE);
    }

    Görüldüğü gibi burada perror fonksiyonu kullanılmamıştır. Çünkü perror fonksiyonu errno değerinin yazısını yazdırmaktadır. Halbuki
    pthread fonksiyonları errno değerini set etmemekte bizzat errno değerinin kendisiyle geri dönmektedir. strerror fonksiyonunun bir errno
    numarası için hata yazısını verdiğini anımsayınız. Tabii biz yine bir sarma fonksiyon kullanabiliriz:

    void exit_sys_errno(const char *msg, int eno)
    {
        fprintf(stderr, "%s: %s\n", msg, strerror(eno));

        exit(EXIT_FAILURE);
    }

    Bu durumda biz therad fonksiyonlarını bu sarma fonksiyon yoluyla şöyle çağırabiliriz:

    int result;
    ...
    if ((result = pthread_xxxx(...)) != 0) 
        exit_sys_errno("pthread_xxx", result);

    errno ismi bazı sistemlerde bir değişken değil makro olduğu için errno isminde bir değişken tanımlamayınız. 

    - Bütün POSIX thread fonksiyonlarının prototipleri <pthread.h> dosyası içerisindedir. Dolayısıyla thread işlemleri yapacaksak 
    bizim bu dosyayı include etmemiz gerekmektedir:

    #include <pthread.h>

---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Thread'ler pthread_create isimli POSIX fonksiyonu ile yaratılmaktadır. Fonksiyonun prototipi şöyledir:

    #include <pthread.h>

    int pthread_create(pthread_t *thread, const pthread_attr_t *attr, 
            void *(*start_routine)(void *), void *arg);

    Fonksiyonun birinci parametresi thread'in id değerinin yerleştirileceği nesnensin adresini almaktadır. Nasıl proseslerin 
    id değerleri varsa thread'lerin de id değerleri vardır. Proseslerin id değerleri o anda sistem genelinde tektir (unique). 
    Ancak thread'lerin id değerleri sistem genelinde tek olmak zorunda değildir. Fakat proses içerisinde tektir. Yani farklı proseslerin 
    yarattığı thread'lerin id değerleri aynı olabilir ancak aynı prosesin thread'lerinin id değerleri farklı olmak zorundadır. 
    (Linux sistemlerinde thread'lerin id değerleri onlar için ayrılan task_struct yapısına ilişkin bir değer olduğu için sistem genelinde
    tektir. Ancak POSIX standartlarında bunun bir garantisi yoktur.)   
    
    pthread_t türü <thread.h> ve <sys/types.h> dosyaları içerisinde typedef edilmiştir. POSIX standarlarına göre pthread_t türü 
    "aritmetik bir tür (yani tamsayı türü ya da gerçek sayı türü)" olmak zorunda değildir. Yani bir yapı türünden de olabilir. 
    Dolayısıyla pthread_t türünden iki nesneyi kendi aralarında karşılaştırmaya çalışmayınız. Linux'ta pthread_t türü "unsigned long int" olarak 
    typedef edilmiştir. 

    Fonksiyonun ikinci parametresi yaratılacak thread'in bazı özelleklerini belirten pthread_attr_t türünden bir nesnenin adresini 
    almaktadır. Thread özellikleri konusu ileride ele alınacaktır. Ancak bu parametre NULL adres geçilirse bu durumda thread default
    özelliklerle yaratılmaktadır. Fonksiyonun üçüncü parametresi thread akışının başlatılacağı fonksiyonun adresini belirtmektedir. 
    Thread fonksiyonlarının geri dönüş değerleri ve parametresi void * olmak zorundadır. Fonksiyonun son parametresi thread fonksiyonuna 
    geçirilecek parametreyi belirtmektedir. Böylece aynı thread fonksiyonu farklı bilgilerle başlatılabilmektedir. Thread'e geçirilecek parametrenin 
    void * türünden olduğuna dikkat ediniz. Çünkü adres bilgisi en genel parametrik bilgi durumundadır. Tabii programcı bu parametreye
    bir adres geçirmeyip bir değer de geçirmek isteyebilir. Bu durumda değeri void * türüne dönüştürmelidir. Fonksiyonun üçüncü parametresiyle
    belirtilen thread fonksiyonunun geri dönüş değerinin de void * türünden olduğuna dikkat ediniz. Thread'ler de sonlandığında tıpkı prosesler gibi
    bir exit kodu oluşturmaktadır. Ancak bu exit kodu int türden değil void * türündendir. Bu exit kodunun nasıl elde edileceği izleyen 
    paragraflarda ele alınmaktadır. 
   
    pthread_create fonksiyonu başarı durumunda 0 değerine, başarısızlık durumunda errno değerine geri dönmektedir. 

    Bir thread yaratıldığında hemen çalışmaya başlamaktadır. (Örneğin bazı thread kütüphanelerinde önce thread yaratılmakta sonra 
    "start" gibi bir fonksiyonla thread çalıştırılmaktadır. Halbuki POSIX kütüphanesinde thread'ler zaten yaratıldığında çalıştırılırlar.)
    Tabii pthread_create fonksiyonu ile thread yaratıldığında yaratan thread'in mi yoksa yeni yaratılan thread'in mi ilk olarak CPU'ya atanacağı
    işletim sisteminin çizelgeleme algoritmasına bağlı olarak değişebilmektedir. POSIX bu konuda herhangi bir garanti vermemektedir. 

    Aşağıda thread yaratımına bir örnek verilmiştir. Bir thread'te sleep fonksiyonu kullanıldığında sleep fonksiyonu kendisini çağıran 
    thread'i belirtilen saniye kadar bloke etmektedir. 
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <pthread.h>

void *thread_proc(void *param);
void exit_sys_errno(const char *msg, int eno);

int main(void)
{
    pthread_t tid;
    int result;

    if ((result = pthread_create(&tid, NULL, thread_proc, NULL)) != 0)
        exit_sys_errno("pthread_create", result);

    for (int i = 0; i < 10; ++i) {
        printf("main thread: %d\n", i);
        sleep(1);
    }

    return 0;    
}

void *thread_proc(void *param)
{
    for (int i = 0; i < 10; ++i) {
        printf("other thread: %d\n", i);
        sleep(1);
    }

    return NULL;
}

void exit_sys_errno(const char *msg, int eno)
{
    fprintf(stderr, "%s: %s\n", msg, strerror(eno));

    exit(EXIT_FAILURE);
}

/*--------------------------------------------------------------------------------------------------------------------------
   Thread fonksiyonuna parametre geçebiliriz. Bunun için genellikle programcılar heap'te tahsisat yaparlar. Tahsis edilen bu alanlar
   thread fonksiyonunun sonunda free hale getirilebilmektedir.  
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <pthread.h>

void *thread_proc(void *param);
void exit_sys_errno(const char *msg, int eno);

#define NTHREADS        10

int main(void)
{
    pthread_t tid[NTHREADS];
    int result;
    char *buf;

    for (int i = 0; i < NTHREADS; ++i) {
        if ((buf = (char *)malloc(1024)) == NULL) {
            fprintf(stderr, "cannnot allocate memory!..\n");
            exit(EXIT_FAILURE);
        }
        snprintf(buf, 1024, "Thread-%d", i);

        if ((result = pthread_create(&tid[i], NULL, thread_proc, buf)) != 0)
            exit_sys_errno("pthread_create", result);
    }

    for (int i = 0; i < 10; ++i) {
        printf("main thread: %d\n", i);
        sleep(1);
    }

    return 0;    
}

void *thread_proc(void *param)
{
    char *str = (char *)param;

    for (int i = 0; i < 10; ++i) {
        printf("%s: %d\n", str, i);
        sleep(1);
    }

    free(str);

    return NULL;
}

void exit_sys_errno(const char *msg, int eno)
{
    fprintf(stderr, "%s: %s\n", msg, strerror(eno));

    exit(EXIT_FAILURE);
}

/*--------------------------------------------------------------------------------------------------------------------------
    Thread fonksiyonuna geirilecek parametre birden fazla ise tipik olarak programcı bu parametreleri bir yapı biçiminde oluşturur. .
    İlgili yapı türünden bir ndinammik bir nensne tahsis eder ve o  nesnenin adresini thread fonksiyonuna geçirir. Aşağıda buna ilişkin 
    bir örnek verilmiştir. 
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <pthread.h>
#include <unistd.h>

void *thread_proc(void *param);
void exit_sys_errno(const char *msg, int eno);

struct PARAM_INFO {
    char *name;
    int count;
};

int main(void)
{
    pthread_t tid;
    int result;
    struct PARAM_INFO *pi;

    if ((pi = (struct PARAM_INFO *)malloc(sizeof(struct PARAM_INFO))) == NULL) {
        fprintf(stderr, "cannot alocate memory!..\n");
        exit(EXIT_FAILURE);
    }

    pi->name = "other thread";
    pi->count = 10;

    if ((result = pthread_create(&tid, NULL, thread_proc, pi)) != 0)
        exit_sys_errno("pthread_create", result);

    for (int i = 0; i < 10; ++i) {
        printf("main thread: %d\n", i);
        sleep(1);
    }

    return 0;
}

void *thread_proc(void *param)
{
    struct PARAM_INFO *pi = (struct PARAM_INFO *)param;

    for (int i = 0; i < pi->count; ++i) {
        printf("%s: %d\n", pi->name, i);
        sleep(1);
    }

    free(param);

    return NULL;
}

void exit_sys_errno(const char *msg, int eno)
{
    fprintf(stderr, "%s:%s\n", msg, strerror(eno));

    exit(EXIT_FAILURE);
}

/*--------------------------------------------------------------------------------------------------------------------------
    Bir thread çeşitli biçimlerde sonlanabilmektedir:

    1) Thread fonksiyonu bittiğinde thread'ler otomatik olarak sonlanırlar. Bu en çok karşılaşılan doğal sonlanama biçimidir. 

    2) Thread'ler pthread_exit fonksiyonuyla thread fonksiyonunun sonuna gelinmeden sonlandırılabilmektedir. pthread_exit 
    fonksiyonu "kendi thread'ini" sonlandırmaktadır. Başka bir thread'i sonlandırmamaktadır. Yani hangi thread akışı pthread_exit 
    fonksiyonunu görürse o thread sonlandırılmaktadır. pthread_exit fonksiyonunun prototipi şöyşedir:

    #include <pthread.h>

    void pthread_exit(void *value_ptr);

    Nasıl exit fonksiyonu prosesi sonlandırırken bir exit kodunu alıyorsa pthread_exit fonksiyonu da thread'i sonlandırırken 
    void * türünden bir exit kodu almaktadır. (main fonksiyonun geri dönüş değeri int türdendir. exit fonksiyonun parametresi de 
    int türdendir. İşte thread fonksiyonunun geri dönüş değeri void * türünden olduğu için pthread_exit fonksiyonunun parametresi de 
    void * türündendir.)

    3) Bir programda exit standart C fonksiyonu ya da _exit POSIX fonksiyonu çağrılırsa proses sonlandırılır. Thread kavramı proses kavramının 
    içerisindedir. Dolayısıyla proses sonlandığında prosesin tüm thread'leri de otomatik olarak sonlandırılmaktadır. Tabii exit ya da _exit
    fonksiyonu herhangi bir thread tarafından çağrılabilmektedir. Burada önemli bir nokta main fonksiyonu bittiğinde exit işleminin yapılmasıdır. 
    Dolayısıyla main fonksiyonu biterse proses sonlanır; proses sonlanırsa da tüm thread'ler sonlanacaktır. Örneğin aşağıdaki gibi 
    hataları POSIX thread kütüphanesini yeni kullananlar sıkça yapmaktadır:

    int main(void)
    {
        pthread_t tid;
        int result;

        if ((result = pthread_create(&tid, NULL, thread_proc, NULL)) != 0)
            exit_sys_errno("pthread_create", result);

        /* Dikkat! main bittiğinde proses sonlanacak ve bütün thread'ler de yok edilecektir */

        return 0;    
    }

    Burada thread yaratılmıştır ancak proses sonlandığı için yaratılan thread de hemen sonlanacaktır. 

    Aslında prosesin ana thread'inin diğer thread'lerden bir farkı yoktur. Yani prosesin ana thread'i diğer thread'lerden önce sonlanabilir. 
    Pekiyi o zaman proses nasıl sonlanacaktır? Çünkü akış main fonksiyonunu bitirmeyecektir. İşte bir prosesin son thread'i sonlandığında 
    programın akışı exit ya da _exit fonksiyonunu görmese bile proses işletim sistemi tarafından sonlandırılmaktadır. 

    4) Prosesler sinyal yoluyla sonlandırılabilmektedir. Bu durumda prosese bir sinyal gönderilirse ve proses de bu sinyali 
    ele almamışsa (handle etmemişse) bazı sinyaller prosesin sonlanmasına yol açabilmektedir. Dolayısıyla bu tür durumlarda da prosesin 
    tüm thread'leri sinyal yüzünden sonlandırılacaktır.

    5) Bir thread başka bir thread'i pthread_cancel fonksiyonu ile sonlandırabilmektedir. Fonksiyonun prototipi şöyledir:

    #include <pthread.h>

    int pthread_cancel(pthread_t thread);

    Fonksiyon parametre olarak sonlandırılacak thread'in id değerini alır. Başarı durumunda 0 değerine, başarısızlık durumunda errno 
    değerine geri döner. pthread_cancel fonksiyonu geri döndüğünde thread'in sonlanmış olması gerekmemektedir. Yani sonlanma işlemi asenkron
    biçimde yapılmaktadır. pthread_cancel fonksiyonu ile thread'leri sonlandırmanın bazı ayrıntıları vardır. Bu ayrıntılar izleyen paragraflarda
    ele alınmaktadır. 
---------------------------------------------------------------------------------------------------------------------------*/
 
/*--------------------------------------------------------------------------------------------------------------------------
    Aşağıdaki örnekte bir hread yaratılmış ve thread erken bir biçimde pthread_exit fonksiyonu ile sonlandırılmıştır. 
    pthread_exit fonksiyonu hangi thread akışı tarafından çağrılırsa o thread sonlanmaktadır. 
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <pthread.h>

void *thread_proc(void *param);
void foo(void);
void exit_sys_errno(const char *msg, int eno);

int main(void)
{
    pthread_t tid;
    int result;

    if ((result = pthread_create(&tid, NULL, thread_proc, NULL)) != 0)
        exit_sys_errno("pthread_create", result);

    for (int i = 0; i < 10; ++i) {
        printf("main thread: %d\n", i);
        sleep(1);
    }

    return 0;    
}

void *thread_proc(void *param)
{
    foo();

    return NULL;
}

void foo(void)
{
    for (int i = 0; i < 10; ++i) {
        if (i == 5)
            pthread_exit(NULL);
        printf("other thread: %d\n", i);
        sleep(1);
    }
}

void exit_sys_errno(const char *msg, int eno)
{
    fprintf(stderr, "%s: %s\n", msg, strerror(eno));

    exit(EXIT_FAILURE);
}

/*--------------------------------------------------------------------------------------------------------------------------
    Aşağıdaki örnekte proses exit fonksiyonuyla sonlandırılmıştır. Dolayısıyla prosesin tüm thread'leri de exit işlemiyle sonlandırılmış
    olmaktadır.
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <pthread.h>

void *thread_proc(void *param);
void exit_sys_errno(const char *msg, int eno);

int main(void)
{
    pthread_t tid;
    int result;

    if ((result = pthread_create(&tid, NULL, thread_proc, NULL)) != 0)
        exit_sys_errno("pthread_create", result);

    for (int i = 0; i < 10; ++i) {
        if (i == 5)
            exit(EXIT_SUCCESS);
        printf("main thread: %d\n", i);
        sleep(1);
    }

    return 0;    
}

void *thread_proc(void *param)
{
    for (int i = 0; i < 10; ++i) {
        printf("other thread: %d\n", i);
        sleep(1);
    }

    return NULL;
}

void exit_sys_errno(const char *msg, int eno)
{
    fprintf(stderr, "%s: %s\n", msg, strerror(eno));

    exit(EXIT_FAILURE);
}

/*--------------------------------------------------------------------------------------------------------------------------
    Aşağıdaki örnekte main fonksiyonunda thrad yaratılmış ancak hemen main fonksiyonu sonlanmıştır. main fonksiyonu sonlandığında 
    exit fonksiyonu çağrılarak proses sonlandırılacağı için yaratılmış olan thread'ler de sonlandırılmış olacaktır. 
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <pthread.h>

void *thread_proc(void *param);
void exit_sys_errno(const char *msg, int eno);

int main(void)
{
    pthread_t tid;
    int result;

    if ((result = pthread_create(&tid, NULL, thread_proc, NULL)) != 0)
        exit_sys_errno("pthread_create", result);

    
    /* Dikkat! main bittiğinde proses sonlanacak ve dolayısıyla prosesin tüm thread'leri de sonlandırılacaktır */

    return 0;    
}

void *thread_proc(void *param)
{
    for (int i = 0; i < 10; ++i) {
        printf("other thread: %d\n", i);
        sleep(1);
    }

    return NULL;
}

void exit_sys_errno(const char *msg, int eno)
{
    fprintf(stderr, "%s: %s\n", msg, strerror(eno));

    exit(EXIT_FAILURE);
}

/*--------------------------------------------------------------------------------------------------------------------------
    Aşağıdaki örnekte programın ana thread'i sonlandırılmıştır. Bu durumda prosesin son thread'i sonlandığında hiç exit ya da
    _exit fonksiyonu çağrılmasa bile proses otomatik olarak sonlandırılacaktır.
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <pthread.h>

void *thread_proc(void *param);
void exit_sys_errno(const char *msg, int eno);

int main(void)
{
    pthread_t tid;
    int result;

    if ((result = pthread_create(&tid, NULL, thread_proc, NULL)) != 0)
        exit_sys_errno("pthread_create", result);

    for (int i = 0; i < 10; ++i) {
        if (i == 5)
            pthread_exit(NULL);
        printf("main thread: %d\n", i);
        sleep(1);
    }

    return 0;    
}

void *thread_proc(void *param)
{
    for (int i = 0; i < 10; ++i) {
        printf("other thread: %d\n", i);
        sleep(1);
    }

    return NULL;
}

void exit_sys_errno(const char *msg, int eno)
{
    fprintf(stderr, "%s: %s\n", msg, strerror(eno));

    exit(EXIT_FAILURE);
}

/*--------------------------------------------------------------------------------------------------------------------------
                                            51. Ders 07/05/2023 - Pazar                                
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    UNIX/Linux sistemlerinde (aslında Windows sistemlerinde de böyle) thread'ler arasında altlık-üstlük (parent-child)" ilişkisi 
    yoktur. Örneğin bir thread'in hangi thread tarafından yaratıldığının bir önemi yoktur. Bir thread'in ana thread tarafından 
    yaratılması zorunlu değildir. Bir thread herhangi bir thread akışı tarafından yaratılabilir. Benzer biçimde örneğin thread'lerin 
    exit kodları herhangi bir thread tarafından elde edilebilmektedir. 
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Bir thread'in exit kodu pthread_join fonksiyonu ile elde edilmektedir. pthread_join fonksiyonunun davranışı alt prosesin exit kodunu elde 
    eden wait fonksiyonlarına benzemektedir. Ancak pthread_join fonksiyonu herhangi bir thread akışı tarafından çağrılabilmektedir. 
    pthread_join fonksiyonu exit kodu alınacak thread henüz sonlanmamışsa onun sonlanmasını bekler. Eğer söz konusu thread 
    sonlanmışsa herhangi bir bloke oluşmaz. Fonksiyonun prototipi şöyledir:

    #include <pthread.h>

    int pthread_join(pthread_t thread, void **value_ptr);

    Fonksiyonun birinci parametresi exit kodu alınacak thread'in id değerini, ikinci parametresi exit kodunun yerleştirileceği 
    void * türünden göstericinin adresini almaktadır. Bu parametres NULL adres geçilebilir. Bu durumda thread'in exit kodu 
    programcıya verilmez. Fonksiyon başarı durumunda 0 değerine başarısızlık durumunda errno değerine geri dönmektedir. 

    Aşağıdaki örnekte bir thread yaratılmış thread bir exit kodla geri döndürülmüştür. Sonra da bu thread'in sonlanması 
    beklenmiş ve exit kod alınmıştır. Thread'lerin exit kodları birer adres biçiminde olsa da biz aşağıdaki örnekte olduğu gibi
    tamsayı değerleri sanki birer adresmiş gibi exit kod olarak oluşturabiliriz. 
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <pthread.h>

void *thread_proc(void *param);
void exit_sys_errno(const char *msg, int eno);

int main(void)
{
    pthread_t tid;
    int result;
    void *valptr;

    if ((result = pthread_create(&tid, NULL, thread_proc, NULL)) != 0)
        exit_sys_errno("pthread_create", result);

    printf("waiting for the thread to finish...\n");

    if ((result = pthread_join(tid, &valptr)) != 0)
        exit_sys_errno("pthread_join", result);

    printf("%d\n", (int)valptr);

    return 0;    
}

void *thread_proc(void *param)
{
    for (int i = 0; i < 10; ++i) {
        printf("other thread: %d\n", i);
        sleep(1);
    }

    return (void *)100;
}

void exit_sys_errno(const char *msg, int eno)
{
    fprintf(stderr, "%s: %s\n", msg, strerror(eno));

    exit(EXIT_FAILURE);
}

/*--------------------------------------------------------------------------------------------------------------------------
    Pekiyi bir thread'i yaratıp onu pthread_join fonksiyonu ile beklemezsek "zombie proses" benzeri bir durum oluşur mu? 
    Gerçekten de tıpkı zombie proseslerde olduğu gibi işletim sistemleri sonlanan thread'e ilişkin bazı kaynakları "onların exit 
    kodları her an programcı tarafından alınabilir" diye bekletmektedir. Bu durum da zombie proses gibi olumsuzluklara yol açabilmektedir. 
    Gerçi zombie thread'ler zombie prosesler kadar sorunlara yol açmıyorsa de programcıların yarattıkları thread'i 
    pthread_join fonksiyonu ile beklemesi gerekir. Ancak bazen programcılar çok sayıda thread yaratıp bunları bekleyecekleri noktaları 
    oluşturamayabilirler. Bu durumda threadler'in "detached" modda yaratılmaları ya da yaratıldıktan sonra "detached" moda sokulmaları gerekir. 
    "Detached" thread'ler sonlandığında kaynaklarını otomatik boşaltan dolaysıyla join yapılamayan thread'lerdir. Thread'lerin nasıl 
    detached moda sokulacağı izleyen paragraflarda ele alınmaktadır. 
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Linux çekirdeğinde (diğer sistemlerde böyle olmak zorunda değil) thread'ler için yine bir task_struct nesnesi tahsis edilmektedir. 
    Yani Linux çekirdeği prosesin thread'lerini adeta sanki aynı bellek alanını kullanan porosesler gibi oluşturmaktadır. 
    Tabii prosesin kendisi için de prosesin thread'leri için de aynı task_struct veri yapısının oluşturulması biraz verimsiz bir
    bellek kullanımına yol açmaktadır. Çünkü aslında thread'ler bu task_struct yapısının önemli bir kısmını zaten kullanmamaktadır. 
    Ancak bu biçimdeki yaklaşım çekirdeğin kodlanmasını oldukça kolaylaştırmıştır. Bir task_struct yapısında onun bir thread'e 
    ilişkin mi yoksa prosese ilişkin mi olduğu bilgisi tutulmaktadır. Benzer biçimde prosese ilişkin task_struct yapısının içerisinde
    o prosesin thread'lerine ilişkin task_struct nesneleri de bir biçimde tutulmaktadır. Zaten Linux çekirdeğinde aslında proses yaratmak 
    için de thread yaratmak için de sys_clone isimli aynı sistem fonksiyonu kullanılabilmektedir. Proses yaratmakta kullanılan sys_fork 
    isimli sistem fonksiyonu ve sys_clone sistem fonksiyonu fonksiyonu aslında  çekirdek içerisindeki do_fork isimli ortalk bir 
    fonksiyonu çağırmaktadır. Başka bir deyişle Linux çekirdeğinde aslında sys_fork sistem fonksiyonu sys_clone 
    sistem fonksiyonunun özel bir biçimidir. 
    
    Özetle Linux çekirdeği aslında thread'leri "aynı bellek alanını kullanan prosesler" gibi organize etmektedir. Zaten Linux'ta 
    thread'ler için kullanılan "lightweight process" terimi bu tasarımdan dolayı uydurulmuştur. 
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Yukarıda da belirttiğimiz gibi bir thread prosesin herhangi bir thread'i tarafından sonlandırılmak istenebilir. Buna POSIX terminolojisinde 
    "thread'in cancel edilmesi" denilmektedir. Bu işlem yukaruıda da açıkladığımız üzere pthread_cancel POSIX fonksiyonuyla yapılmaktadır. 

    #include <pthread.h>

    int pthread_cancel(pthread_t thread);

    Tabii biz başka bir prosesin thread'ini pthread_cancel ile sonlandıramayız. Çünkü UNIX/Linux sistemlerinde therad'lerin id değerleri
    proses özgüdür. Yani o proses için anlamlıdır. Bir thread pthread_cancel fonksiyonu ile sonlandırıldığında pthread_join fonksiyonundan 
    thread'in exit kodu olarak PTHREAD_CANCELED özel değeri elde edilmektedir. Bu değer pek çok sistemde aşağıdaki gibi define edilmiştir:

    #define PTHREAD_CANCELED        ((void *)-1)

    Aşağıdaki örnekte ana thread pthread_cancel fonksiyonu ile diğer thread'i sonlandırmaktadır. 
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <pthread.h>

void *thread_proc(void *param);
void exit_sys_errno(const char *msg, int eno);

int main(void)
{
    pthread_t tid;
    int result;
    
    if ((result = pthread_create(&tid, NULL, thread_proc, NULL)) != 0)
        exit_sys_errno("pthread_create", result);  

    for (int i = 0; i < 10; ++i) {
        printf("main thread: %d\n", i);
        sleep(1);

        if (i == 5)
            if ((result = pthread_cancel(tid)) != 0)
                exit_sys_errno("pthread_cancel", result);
    }

    if ((result = pthread_join(tid, NULL)) != 0)
        exit_sys_errno("pthread_join", result);

    return 0;    
}

void *thread_proc(void *param)
{
    for (int i = 0; i < 10; ++i) {
        printf("other thread: %d\n", i);
        sleep(1);
    }

    return NULL;
}

void exit_sys_errno(const char *msg, int eno)
{
    fprintf(stderr, "%s: %s\n", msg, strerror(eno));

    exit(EXIT_FAILURE);
}

/*--------------------------------------------------------------------------------------------------------------------------
    Bir thread'in başka bir thread tarafından pthread_cancel POSIX fonksiyonu ile sonlandırılmasının bazı detayları vardır. 
    Örneğin aslında default durumda sonlandırma ani bir biçimde yapılmamaktadır. Sonlandırma isteği thread'e gönderilmekte 
    thread bazı POSIX fonksiyonlarının içerisine girerse sonlandırma o POSIX fonksiyonlarının içerisinde yapılmaktadır. Bu POSIX
    fonksiyonlarına "cancellation points" denilmektedir. Cancalletion point belirten POSIX fonksiyonları standartlarda aşağıdaki 
    bağlantıda listelenmiştir:

    https://pubs.opengroup.org/onlinepubs/000095399/functions/xsh_chap02_09.html#tag_02_09_05_02

    Burada bizim gördüğümüz pek çok fonksiyonun zaten bir cancellation point belirttiğine dikkat ediniz. Örneğin open, read, write, 
    close, sleep birer cancellation point belirtmektedir. 

    Bir thread yukarıda belirtilen POSIX fonksiyonlarına girmezse pthread_cancel ile sonlandırma isteği thread'e gönderilse bile
    bu istek "askıda (pending durumda)" kalmaktadır. Dolayısıyla thread sonlandırılamayacaktır. Örneğin aşağıdaki gibi bir thread 

    pthread_cancel ile sonlandırılamaz:

    
    void *thread_proc(void *param)
    {
        for (;;) {
            /* bir cancellation point yok */
        }

        return NULL;
    }

    Aşağıdaki örnekte pthread_cancel kullanıldığı halde thread bir cancellation point içerisine girmediği için sonlanmayacaktır.
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <pthread.h>

void *thread_proc(void *param);
void exit_sys_errno(const char *msg, int eno);

int main(void)
{
    pthread_t tid;
    int result;
    
    if ((result = pthread_create(&tid, NULL, thread_proc, NULL)) != 0)
        exit_sys_errno("pthread_create", result);  

    for (int i = 0; i < 10; ++i) {
        printf("main thread: %d\n", i);
        sleep(1);

        if (i == 5)
            if ((result = pthread_cancel(tid)) != 0)
                exit_sys_errno("pthread_cancel", result);
    }

    printf("waiting for the thread to finish...\n");
    
    if ((result = pthread_join(tid, NULL)) != 0)
        exit_sys_errno("pthread_join", result);

    return 0;    
}

void *thread_proc(void *param)
{
    for (;;) {
        /* bir cancellation point yok */
    }

    return NULL;
}

void exit_sys_errno(const char *msg, int eno)
{
    fprintf(stderr, "%s: %s\n", msg, strerror(eno));

    exit(EXIT_FAILURE);
}

/*--------------------------------------------------------------------------------------------------------------------------
    Pekiyi bir thread bu "cancellation" point fonksiyonlarına ihtiyaç duymadan bir döngü içerisinde işlemini yapıyorsa onu nasıl 
    cancel edebiliriz? İşte bunun için yalnızca bu işlevi yerine getirecek pthread_testcancel isimli bir fonksiyon bulunudurulmuştur:

    void pthread_testcancel(void); 

    Fonksiyonun parametresi yoktur. Fonksiyon bir şey yapmamakta yalnızca cancellation point oluşturmaktadır. 

    Aşağıda pthread_testcancel fonksiyonuna ilişkin bir örnek verilmiştir. 
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <pthread.h>

void *thread_proc(void *param);
void exit_sys_errno(const char *msg, int eno);

int main(void)
{
    pthread_t tid;
    int result;
    
    if ((result = pthread_create(&tid, NULL, thread_proc, NULL)) != 0)
        exit_sys_errno("pthread_create", result);  

    for (int i = 0; i < 10; ++i) {
        printf("main thread: %d\n", i);
        sleep(1);

        if (i == 5)
            if ((result = pthread_cancel(tid)) != 0)
                exit_sys_errno("pthread_cancel", result);
    }

    printf("waiting for the thread to finish...\n");
    
    if ((result = pthread_join(tid, NULL)) != 0)
        exit_sys_errno("pthread_join", result);

    return 0;    
}

void *thread_proc(void *param)
{
    for (;;) {
        pthread_testcancel();
    }

    return NULL;
}

void exit_sys_errno(const char *msg, int eno)
{
    fprintf(stderr, "%s: %s\n", msg, strerror(eno));

    exit(EXIT_FAILURE);
}

/*--------------------------------------------------------------------------------------------------------------------------
    Aslında bir thread'in pthread_cancel fonksiyonu karşısındaki davranışı değiştirilebilmektedir.Bunun için iki POSIX fonksiyonu 
    kullanılmaktadır. 

    pthread_setcanceltype isimli fonksiyon thread'in sonlandırma biçimini belirtir. Fonksiyonun prototipi şöyledir:

    #include <thread.h>

    int pthread_setcanceltype(int type, int *oldtype);

    Fonksiyonun birinci parametresi sonlandırma biçimini belirten aşağıdaki iki değerden biri olabilir:

    PTHREAD_CANCEL_DEFERRED 
    PTHREAD_CANCEL_ASYNCHRONOUS

    Burada PTHREAD_CANCEL_DEFERRED yukarıda açıkladığımız "cancellation point fonksiyonlarına girildiğinde sonlandırma" 
    anlamına gelmektedir. Thread yaratıldığında thread'in default sonlandırma biçimi böyledir. PTHREAD_CANCEL_ASYNCHRONOUS değeri 
    ise thread'in o anda cancellation point olmadan doğrudan sonlandırılacağı anlamına gelmektedir. 

    Fonksiyonun ikinci parametresi önceki sonlandırma biçiminin yerleştirileceği int nesnenin adresini almaktadır. Linux sistemlerinde 
    bu parametre NULL adres geçilebilmektedir. Ancak POSIX standartlarında böyle bir durum belirtilmemiştir. Fonksiyon başarı durumunda 
    0 değerine başarısızlık durumunda errno değerine geri dönmektedir. 

    Fonksiyonda bir thread id belirtilmediğine dikkat ediniz. Yani biz başka bir thread'in sonlanma biçimini değiştiremeyiz. 
    Bu fonksiyonu hangi thread akışı çaprırsa o thread'in sonlanma biçimi değiştirilmektedir.

    Aşağıdaki örnekte thread'in sonlandırma biçimi PTHREAD_CANCEL_ASYNCHRONOUS biçiminde değitirilmişir. Dolayısıyla artık 
    thread'e pthread_cancel uygulandığında thread cancellation poin'te girmedne o anda ani bir biçimde sonlandırılacaktır. 
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <pthread.h>

void *thread_proc(void *param);
void exit_sys_errno(const char *msg, int eno);

int main(void)
{
    pthread_t tid;
    int result;
    
    if ((result = pthread_create(&tid, NULL, thread_proc, NULL)) != 0)
        exit_sys_errno("pthread_create", result);  

    for (int i = 0; i < 10; ++i) {
        printf("main thread: %d\n", i);
        sleep(1);

        if (i == 5)
            if ((result = pthread_cancel(tid)) != 0)
                exit_sys_errno("pthread_cancel", result);
    }

    printf("waiting for the thread to finish...\n");
    
    if ((result = pthread_join(tid, NULL)) != 0)
        exit_sys_errno("pthread_join", result);

    return 0;    
}

void *thread_proc(void *param)
{
    int oldtype;

    pthread_setcanceltype(PTHREAD_CANCEL_ASYNCHRONOUS, &oldtype);

    for (;;) {
        
    }

    return NULL;
}

void exit_sys_errno(const char *msg, int eno)
{
    fprintf(stderr, "%s: %s\n", msg, strerror(eno));

    exit(EXIT_FAILURE);
}

/*--------------------------------------------------------------------------------------------------------------------------
    Thread'işn pthread_cancel fonksiyonu bağlamındaki Sonlandırma durumunun değiştirilmesi için ise ptherad_setcancelstate 
    fonksiyonu kullanılmaktadır. Fonksiyonun prototipi şöyledir:

    #include <pthread.h>

    int pthread_setcancelstate(int state, int *oldstate);

    Fonksiyonun birinci parametresi aşağıdaki iki değerden biri olabilir:

    PTHREAD_CANCEL_ENABLE
    PTHREAD_CANCEL_DISABLE

    PTHREAD_CANCEL_ENABLE değeri thread'in pthread_cancel fonksiyonu ile sonlandırılabileceğini belirtmektedir. PTHREAD_CANCEL_DISABLE
    değeri ise thread'in pthread_cancel fonksiyonu ile sonlandırılamayacağını belirtmektedir. Thread'ler yaratıldığında default olarak 
    sonlandırılabilir yani PTHREAD_CANCEL_ENABLE durumdadır. Thread eğer PTHREAD_CANCEL_DISABLE duruma sokulursa bu durumda pthread_cancel 
    uygulandığında thread sonlandırılmaz. Ancak istek "askıda (pending)" durumda kalır. Thread'in durumu eğer PTHREAD_CANCEL_ENABLE
    hale getirilirse askıda olan sonlandırma eylemi sonlandırma biçiminine göre işleme alınır. Fonksiyonun ikinci parametresi 
    eski sonlandırma durumunun yerleştirileceği int nesnenin adresini almaktadır. Linux'ta bu değer NULL geçilebilirse de POSIX
    standartlarında böyle bir davranış tanımlanmamıştır. 

    Aşağıdaki örnekte thread'in durumu PTHREAD_CANCEL_DISABLE yapılmıştır. Ana thread pthread_cancel uyguladığı halde 
    thread sonlandırılmayacaktır. 
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <pthread.h>

void *thread_proc(void *param);
void exit_sys_errno(const char *msg, int eno);

int main(void)
{
    pthread_t tid;
    int result;
    
    if ((result = pthread_create(&tid, NULL, thread_proc, NULL)) != 0)
        exit_sys_errno("pthread_create", result);  

    for (int i = 0; i < 10; ++i) {
        printf("main thread: %d\n", i);
        sleep(1);

        if (i == 5)
            if ((result = pthread_cancel(tid)) != 0)
                exit_sys_errno("pthread_cancel", result);
    }

    printf("waiting for the thread to finish...\n");
    
    if ((result = pthread_join(tid, NULL)) != 0)
        exit_sys_errno("pthread_join", result);

    return 0;    
}

void *thread_proc(void *param)
{
    int oldstat;

    pthread_setcancelstate(PTHREAD_CANCEL_DISABLE, &oldstat);

    for (int i = 0; i < 10; ++i) {
        printf("other thread: %d\n", i);
        sleep(1);
    }

    return NULL;
}

void exit_sys_errno(const char *msg, int eno)
{
    fprintf(stderr, "%s: %s\n", msg, strerror(eno));

    exit(EXIT_FAILURE);
}

/*--------------------------------------------------------------------------------------------------------------------------
    Biz o anda hangi thread akışının ilerlemekte olduğunu anlamak isteyebiliriz. Bunun için pthread_self isimli POSIX fonksiyonu 
    kullanılmaktadır. pthread_self fonksiyonu, bu fonksiyonu çağıran thread'in id değerini vermektedir. Fonksiyonun prototipi şöyledir:

    #include <pthread.h>

    pthread_t pthread_self(void);

    Fonksiyon başarısız olamamaktadır. 

    Programcı kendi thread'i ile ilgili birtakım işlemler yapmak istediğinde de bu fonksiyonu kullanabilmektedir. 
    Fonksiyon başarısız olamamaktadır.
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
                                            52. Ders 13/05/2023 - Cumartesi
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Biz şimdiye kadar thread'lere özellik (attribute) bilgisi geçmedik. pthread_create fonksiyonunda bu özellik parametresine 
    NULL adres verdik. Bu NULL adres thread'in default özelliklerle yarataılacağını belirtmekteydi. Şimdi thread özellikleri 
    üzerinde duracağız. 
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Thread özellikleri pthread_attr_t türü ile temsil edilmektedir. pthread_attr_t türü <pthread.h> ve <sys/types.h> dosyalarında
    typedef edilmiştir. Tipik olarak bu pthread_attr_t türü bir yapı biçiminde typedef edilmektedir. Ancak POSIX standartları 
    bu yapının elemanlarını açıklamamıştır. Yani bu yapının elemanları sistemden sisteme o sistemin özelliklerine göre değişebilmektedir. 
    Thread'in özellik bilgileri bu yapının içerisine pthread_attr_setxxx fonksiyonlarıyla set edilmekte ve pthread_attr_getxxx 
    fonksiyonlarıyla da get edilebilmektedir. (Bu durumu nesne yönelimli programlamadaki sınıflara benzetebilirsiniz. Nasıl sınıfın veri elemanları 
    sınıfın "private" bölümünde tutulup onlara getter/setter fonksiyonlarla erişiliyorsa burada da aynı mantık izlenmiştir.)

    Bir thread yaratılırken ona özellik girmek için şu adımlardan geçilmelidir:

    1) Önce pthread_attr_t türünden bir nesne yaratılır. 
    
    2) Yaratılan bu nesneye pthread_attr_init fonksiyonuyla ilkdeğer verilir. Fonksiyonun prototipi şöyledir:

    #include <pthread.h>

    int pthread_attr_init(pthread_attr_t *attr);

    Fonksiyon pthread_attr_t türünden nesnenin adresini alarak nesneye ilkdeğer vermektedir. Fonksiyon başarı durumunda 0, 
    başarısızlık durumunda errno değeri ile geri dönmektedir. Fonksiyon Linux'ta her zaman başarılı olmaktadır. Ancak bazı sistemlerde 
    bu pthread_attr_t yapısı içerisinde bazı göstericiler için alan tahsis ediliyor olabilir ve bu tahsisat başarsızlıkla sonuçlanabilir. 
    Bu durumda pthread_attr_init fonksiyonu ENOMEM değeri ile geri döner. ENOMEM errno değeri malloc, calloc, realloc gibi fonksiyonlarda da
    kullanılan "not enough memory" durumunu anlatmaktadır. 

    3) pthread_attr_t nesnesine ilk değer verildikten sonra artık thread özellikleri pthread_attr_setxxx fonksiyonlarıyla set edilebilir, 
    pthread_attr_getxxx fonksiyonlarıyla da get edilebilir. Bazı thread özellikleri bazı özel konulara ilişkindir. Dolayısıyla biz 
    o özellikleri o konunun anlatıldığı yerde ele alacağız. Örneğin pthread_attr_setstacksize fonksiyonu ile biz özellik nesnesine
    yaratılacak thread'in stack uzunlupğunu set edebiliriz. 

    4) Artık set işlemleri de yapıldıktan sonra pthread_create fonksiyonu ile thread bu pthread_attr_t türünden nesnenin adresi 
    verilerek yaratılabilir. 

    5) Thread yaratıldıktan sonra phread_attr_init fonksiyonuyla yapılan işlemler pthread_attr_destroy fonksiyonu ile geri alınabilir. Bu fonksiyon
    thread yaratıldıktan sonra hemen çağrılabilir. Yani pthread_create fonksiyonu bizim verdiğimiz pthread_attr_t nesnesinin 
    adresini saklayıp kullanmak yerine onun içerisindekileri ilgili yere kopyalamaktadır.  pthread_attr_destroy fonksiyonun 
    prototipi şöyledir:

    #include <pthread.h>

    int pthread_attr_destroy(pthread_attr_t *attr);

    Her ne kadar fonksiyonun geri dönüş değeri benzer biçimde başarı-başarısızlık belirtiyorsa da fonksiyonun başarısız olması için 
    bir neden yoktur. Linux sistemlerinde fonksiyon her zaman başarılı olmaktadır. 

    O halde thread özelliklerini oluşturup thread'in bu özelliklerle yaratılması aşağıdaki gibi yapılabilmektedir:

    pthread_attr_t tattr;
    ...
        
    if ((result = pthread_attr_init(&tattr)) != 0)
        exit_sys_errno("pthread_attr_init", result);
    
    if ((result = pthread_attr_setxxx(&tattr, ...)) != 0)
        exit_sys_errno("pthread_attr_setxxx", result);  

    if ((result = pthread_create(&tid, &tattr, thread_proc, NULL)) != 0)
        exit_sys_errno("pthread_create", result);  

    if ((result = pthread_attr_destroy(&tattr)) != 0)
        exit_sys_errno("pthread_attr_destroy", result);  
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Bir thread'in kullanacağı stack büyüklüğü thread yaratılırken thread'in özellik bilgileriyle set edilebilmektedir. Bunun 
    için pthread_attr_setstacksize fonksiyonu kullanılmaktadır. Fonksiyonun prototipi şöyledir:

    #include <pthread.h>

    int pthread_attr_setstacksize(pthread_attr_t *attr, size_t stacksize);

    Fonksiyonun birinci parametresi thread özelliklerine ilişkin pthread_attr_t türünden nesnenin adresini almaktadır. İkinci parametresi 
    ise stack uzunluğunu belirtmektedir. Eğer bu set işlemi yapılmazsa Linuz sistemlerinde glibc kütüphanesi default stack uzunluğunu X86 32 bit
    sistemlerinde 2MB, X86 64 bit sistemlerde 8MB almaktadır.

    pthread_attr_init fonksiyonundan sonra biz bu özellik nesnesinden default stack uzunluğunu pthread_attr_getstacksize fonksiyonu ile
    elde edebiliriz:

    #include <pthread.h>
    
    int pthread_attr_getstacksize(const pthread_attr_t *attr, size_t *stacksize);

    Fonksiyonun birinci parametresi özellik nesnesini, ikinci parametresi stack uzunluğunun yerleştirileceği size_t türünden nesnenin
    adresini belirtmektedir. Fonksiyon başarı durumunda 0 değerine başarısızlık durumunda errno değerine geri dönmektedir. 

    Aşağıdaki programda önce default stack uzunluğu yazdırılmış, sonra yeni yaratılan thread'in 64K stack kullanması sağlanmıştır. 
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <pthread.h>

void *thread_proc(void *param);
void exit_sys_errno(const char *msg, int eno);

int main(void)
{
    pthread_t tid;
    int result;
    pthread_attr_t tattr;
    size_t size;
    
    if ((result = pthread_attr_init(&tattr)) != 0)
        exit_sys_errno("pthread_attr_init", result);
    
    if ((result = pthread_attr_getstacksize(&tattr, &size)) != 0)
        exit_sys_errno("pthread_attr_getstacksize", result);

    printf("Default stack size: %zd\n", size);

    if ((result = pthread_attr_setstacksize(&tattr, 65536)) != 0)
        exit_sys_errno("pthread_attr_getstacksize", result);

    if ((result = pthread_create(&tid, &tattr, thread_proc, NULL)) != 0)
        exit_sys_errno("pthread_create", result);  

    if ((result = pthread_attr_destroy(&tattr)) != 0)
        exit_sys_errno("pthread_attr_destroy", result);  

    if ((result = pthread_join(tid, NULL)) != 0)
        exit_sys_errno("pthread_join", result);

    return 0;    
}

void *thread_proc(void *param)
{
    for (int i = 0; i < 10; ++i) {
        printf("other thread: %d\n", i);
        sleep(1);
    }

    return NULL;
}

void exit_sys_errno(const char *msg, int eno)
{
    fprintf(stderr, "%s: %s\n", msg, strerror(eno));

    exit(EXIT_FAILURE);
}

/*--------------------------------------------------------------------------------------------------------------------------
    Anımsanacağı gibi bir thread sonlandığında onun exit kodu pthread_join fonksiyonu ile elde edilip thread zombie olmaktan kurtarılıyordu.
    pthread_join fonksiyonu thread sonlanana kadar akışı bloke ediyordu. İşte biz bir thread'i "detached" moda sokarsak artık thread sonlandığında
    otomatik olarak thread nesnesinin tuttuğu kaynaklar boşaltılır. Dolayısıyla zombie thread durumu ortadan kaldırılmış olur. 
    Eğer biz çok sayıda thread yaratıp bunları pthread_join ile beklemek istemiyorsak thread'leri "detached" moda sokmalıyız.
    Thread'ler yaratıldığında default olarak detached durumda değildir. Bu default duruma "joinable" durum da denilmektedir. 

    Detached durumda bir thread pthread_join fonksiyonu ile beklenemez. POSIX standartları bu durumu "tanımsız davranış (undefined behavior)"
    olarak nitelendirmiştir. Linux sistemlerinde detached bir thread pthread_join ile beklenmeye çalışılırsa pthread_join fonksiyonu 
    EINVAL errno değeri ile başarısız olmaktadır. 

    Bir thread'i detached moda sokmanın iki yolur vardır. Birincisi thread yaratılırken thread özellikleri ile bu sağlanabilir. 
    Bunun için int pthread_attr_setdetachstate fonksiyonu kullanılmaktadır:

    #include <pthread.h>

    int pthread_attr_setdetachstate(pthread_attr_t *attr, int detachstate);

    Fonksiyonun birinci parametresi özellik nesnesini almaktadır. İkinci parametre şunlardan biri olabilir:

    PTHREAD_CREATE_DETACHED 
    PTHREAD_CREATE_JOINABLE

    pthread_attr_init fonksiyonu default olarak zaten bu detached durumunu PTHREAD_CREATE_JOINABLE olarak set etmektedir. 
    Thread özellik parametresi NULL geçilerek yaratıldığında da default olarak "joinable" durumda olur. Fonksiyon başarı durumunda
    0 değerine başarısızlık durumunda errno değerine geri dönmektedir. 

    Aşağıdaki örnekte thread özellik bilgisi ile detached moda sokulmuştur.
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <pthread.h>

void *thread_proc(void *param);
void exit_sys_errno(const char *msg, int eno);

int main(void)
{
    pthread_t tid;
    int result;
    pthread_attr_t tattr;
        
    if ((result = pthread_attr_init(&tattr)) != 0)
        exit_sys_errno("pthread_attr_init", result);
    
    if ((result = pthread_attr_setdetachstate(&tattr, PTHREAD_CREATE_DETACHED)) != 0)
        exit_sys_errno("pthread_attr_getstacksize", result);

    if ((result = pthread_create(&tid, &tattr, thread_proc, NULL)) != 0)
        exit_sys_errno("pthread_create", result);  

    if ((result = pthread_attr_destroy(&tattr)) != 0)
        exit_sys_errno("pthread_attr_destroy", result);  

    printf("press ENTER to exit...\n");
    getchar();

    return 0;    
}

void *thread_proc(void *param)
{
    for (int i = 0; i < 10; ++i) {
        printf("other thread: %d\n", i);
        sleep(1);
    }

    return NULL;
}

void exit_sys_errno(const char *msg, int eno)
{
    fprintf(stderr, "%s: %s\n", msg, strerror(eno));

    exit(EXIT_FAILURE);
}

/*--------------------------------------------------------------------------------------------------------------------------
    Thread'i "detached" moda sokmanın diğer bir yolu thread yaratıldıktan sonra pthread_detach fonksiyonunu çağırmaktır. 
    Fonksiyonun prototipi şöyledir:

     #include <pthread.h>

    int pthread_detach(pthread_t thread);

    Fonksiyon detached duruma sokulacak thread'in id değerini parametre olarak almaktadır. Başarı durumunda 0 değerine başarısızlık durumunda
    errno değerine geri dönmektedir. Zaten detched durumda olan bir thread için bu çağrının yapılması POSIX standartlarına göre "tanımsız davranışa"
    yol açmaktadır. Linux sistemlerinde "joinable" olmayan thread'lerde bu fonksiyon başarısız olmakta ve EINVAL errno değeri ile geri dönmektedir. 
    Thread fonksiyon çağrıldığında zaten sonlanmışsa thread'in kaynakları yine otomatik olarak yol edilmektedir. 

    Aşağıdaki örnekte thread pthread_detach donksiyonu ile detached duruma sokulmuştur. 
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <pthread.h>

void *thread_proc(void *param);
void exit_sys_errno(const char *msg, int eno);

int main(void)
{
    pthread_t tid;
    int result;
    pthread_attr_t tattr;
        
    if ((result = pthread_create(&tid, NULL, thread_proc, NULL)) != 0)
        exit_sys_errno("pthread_create", result);  

    if ((result = pthread_detach(tid)) != 0) 
        exit_sys_errno("pthread_detach", result);  
    
    printf("press ENTER to exit...\n");
    getchar();

    return 0;    
}

void *thread_proc(void *param)
{
    for (int i = 0; i < 10; ++i) {
        printf("other thread: %d\n", i);
        sleep(1);
    }

    return NULL;
}

void exit_sys_errno(const char *msg, int eno)
{
    fprintf(stderr, "%s: %s\n", msg, strerror(eno));

    exit(EXIT_FAILURE);
}

/*--------------------------------------------------------------------------------------------------------------------------
    Therad'ler konusunun önemli bir bölümünü "thread senkronizasyonu" oluşturmaktadır. Thread'lerin birlikte belli bir amacı 
    ortak bir biçimde gerçekleştirirken uyum içinde çalışması gerekebilmektedir. Özellikle ortak kaynaklara erişen thread'lerin
    bu kaynakları bozmadan işleme sokması kritik önemdedir. Thread senkronizasyonunun önemini anlatmak için basit bir örnek 
    verebiliriz. İki thread aynı global değişkeni aşağıdaki gibi artırıyor olsun:

    int g_count = 0;
    ...

    void *thread_proc1(void *param)
    {
        for (int i = 0; i < 1000000; ++i)
            ++g_count;
        
        return NULL;
    }

    void *thread_proc2(void *param)
    {
        for (int i = 0; i < 1000000; ++i)
            ++g_count;    

        return NULL;
    }

    Bu thread'lerin çalışması bittikten sonra bu global değişkenin 2000000 değerinde olması beklenir. Ancak gerçekte bu durum sağlanamayacaktır. 
    Çünkü artırım tek bir C deyimi ile yapılmış olsa bile bunun için birkaç makine komutu gerekebilmektedir. Örneğin:

    MOV reg, g_count
    INC reg
    MOV g_count, reg

    Burada thread'lerden birinin aşağıdaki noktada quanta süresini bitirdiğini düşünelim. Bu durumda işletim sistemi tam o noktada thread'in
    çalışmasına ara verip CPU'ya başka bir thread'i atayacaktır:

    MOV reg, g_count
    ---> Bu noktada prememtive olarak çalışmaya ara verilmiş olsun
    INC reg
    MOV g_count, reg

    Burada görüldüğü gibi global değişkenin değeri CPU içerisinde bir yazmaca çekilmiştir. Ancak tam o sırada thread'lerarası 
    geçiş (context switch) oluşmuştur. Bu sırada diğer bir thread CPU'ya atanıp çalıştırılmış olabilir. Böylece diğer thread global değişkeni 
    artırmış olacaktır. Sonra yeniden çalışma bu thread'de döndüğünde thread kalınan yerden çalışmaya devam edecekir:

    INC reg
    MOV g_count, reg

    Görüldüğü gibi çalışma devam ettiğinde global değişkenin o anki değeri kaybedilmiş olmaktadır. Threadlerarası geçiş oluştuğunda işletim sistemi
    o andaki thread'e ilişkin CPU yazmaçlarının değerlerini de saklayıp geri yüklemektedir. Buradaki problem ise bir işlemin arada kesilmesi ile 
    ilgilidir. Bu tür işlemlerde volatile anahtar sözcüğü bize bir fayda sağlamaz. Örneğin:

    volatile int g_count;

    volatile anahtar sözcüğü işlemin atomik yapılmasını garanti etmemektedir. volatile anahtar sözcüğü yalnızca "ilgili nesne kullanıldığında o nesnenin 
    güncel değeri için" belleğe başvurunun yapılacağı" anlamına gelmektedir. Yani burada nesne volatile yapılsa bile üretilen
    makine kodlarında bir farklılık oluşmayacaktır. 

    Pekiyi yukarıdaki problemin kaynağı nedir? Problemin asıl kaynağı "thread'lerin ansızın belli bir makine komutunda preemtive 
    biçimde quanta süresini doldurduklarında kesilebilmesi yani çalışmasına ara verilebilmesidir". Pekiyi bu problem nasıl çözülebilir? 
    İşte bu problem iki biçimde çözülebilir:

    1) Söz konusu işlemlerin atomik bir biçimde yapılmasıyla: İşlemlerin atomik yapılması demek o işlemler yapılırken hiç kesilme 
    olmaması yani tek hamlede yapılması demektir. Genellikle böyle bir durumu sağlamak mümkün olmaz. Tabii yukarıdaki örnekte 
    artırma işlemi tek bir makine komutu ile yapılıyor olsaydı işlem atomik olurdu. Dolayısıyla yukarıdaki örnekte bir sorun kalmazdı.
    Thread'lerarası geçiş makine komutları çalıştırılırken gerçekleşmemektedir. Bir makine komutunun çalışması bittikten sonra ancak diğeri
    henüz çalıştırılmadan gerçekleşebilmektedir. Yani makine komutları atomiktir.

    2) Söz konusu işlemler sırasında kesilme (thread'ler arası geçiş) olsa da başka bir akışın bu işlemler bitene kadar bekletilmesiyle:
    Bu yöntem genellikle kullanılan yöntemdir. Bu yöntemde işlemler sırasında ters bir noktada kesilme (thread'ler arası geçiş) olabilir. 
    Ancak geçilen eğer aynı ortak kaynağa erişiyorsa "thread kesilen thread bu işlemi bitirene kadar" bekletilir. 

    Yukarıdaki gibi threadler'le çalışmada çok sık karşımıza çıkmaktadır. Örneğin bir thread bir makineyi önce reset edip bir konuma soksun:

    - makine reset ediliyor
    - reset edilen makine belli bir konuma sokuluyor

    Bu konuma sokma işlemi mutlaka reset'ten sonra yapılmak zorunda olsun. Şimdi makineye birden thread'ten eriştiğimizi düşünelim.
    thread akış'larından biri aşağıdaki noktada kesilmiş olsun:

    - makine reset ediliyor
        ---> thread akışı bu noktada kesilmiş olsun
    - reset edilen makine belli bir konuma sokuluyor

    Bu thread kesilmişken başka bir thread bu makine üzerinde yukarıdaki iki işlemi kesilmeden yapmış olabilir. Bu durumda bu thread 
    çalışmasına devam ettiğinde sanki makineyi reset sonrasında konumlandıyor gibi bir durum oluşacaktır. Halbuki makinenin durumu 
    değişmiştir. 

    Thread senkronizasyonu genellikle "ortak kaynaklara" eşimde gerekmektedir. İki thread biribirinden bağımsız işlemler yapıyorsa
    yani bunlar hiçbir ortak kaynağa erişmiyorlarsa bunların senkronize edilmesi gerekliliği yoktur.
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Başından sonuna kadar tek bir akış tarafından çalıştırılması gereken kodlara "kritik kodlar (criticak sections)" denilmektedir. 
    Kritik kod bloklarına bir thread girdiğinde orada thread akışı kesilebilir. Yani thread'lerarası geçiş oluşabilir. Ancak başka 
    bir thread önceki thread o bloktan çıkana kadar o bloğa girmemelidir. Örneğin:

    MOV reg, g_count
    INC reg
    MOV g_count, reg

    Burası bir kritk kod bloğudur. Çünkü bu kod bloğu başından sonuna kadar tek bir thread tarafından çalıştırılmalıdır. 
    Bir thread bu kritik kod bloğunda kesilse bile başka bir thread bu önceki thread bu bloktan çıkana kadar bu bloğa girmemelidir. 
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Kritik kodlar manuel biçimde oluşturulamazlar. Örneğin aşağıdaki gibi bir çaba sonuçsuz kalacaktır:

    int g_flag = 0;
    ...

    while (g_flag == 1)
        ;
    g_flag = 1;
    .....
    .....   KRİTİK KOD BLOĞU
    .....  
    g_flag = 0;

    Burada programcı g_flag 1 olduğu SÜRECE "başka bir thread kritik kodda olduğu için" beklemiştir. g_flag 0'a çekildiğinde
    akış döngüden çıkmakta ve g_flag yeniden 1 yapılmaktadır. Bu kodun iki önemli problemi vardır. Birincisi kesilme döngüden çıkıldığında
    ancak henüz g_flag değişkenine 1 atanmadan gerçekleşmiş olabilir:

    while (g_flag == 1)
        ;
    ---> DİKKAT BU NOKTADA KESİLME OLABİLİR
    g_flag = 1;
    .....
    .....   KRİTİK KOD BLOĞU
    .....  
    g_flag = 0;

    Bu kodun ikinci problemi beklemenin "meşgul bir döngüde (busy loop)" yapılmasıdır. Yani burada bekleme bir döngü içerisinde 
    CPU zamanı harcanarak yapılmaktadır. Halbuki beklemenin CPU zamanı harcanmadan thread bloke edilerek yapılması arzu edilir.   
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Pekiyi kritik kod blokları nasıl oluşturulmaktadır? İşte kritik kodlar "işletim sisteminin de işe karıştığı" birtakım 
    "senkronizasyon nesneleriyle" oluşturulmaktadır. Bu senkronizasyon nesneleri genel olarak kernel moda geçiş yapabilmektedir.
    Kernel modda atomik işlemler yapmak işlemcilerin sağladığı bazı özel makine komutlarıyla mümkün olabilmektedir. Artık 
    pek çok modern masasütü ve mobil işlemci "user modda" bazı senkronizasyon problemleri için "atomik bir biçimde çalışan" 
    özel komutlar barındırmaktadır. Bazı senkronizasyon nesneleri daha az kernel moda geçerek bu makine komutlarının 
    yardımıyla daha etkin kilitleeme yapabilmektedir. 

    Linux sistemlerinde senkronizasyon nesneleri ismine "futex" denilen bir sistem fonksiyonu yoluyla gerçekleştirilmiştir. 
    Yani Linux senkronizasyon amacıyla kullanılacak bir futex nesnesini bir sistem fonksiyonu olarak bulundurmuştur. Burada ele 
    alacğımız senktronizasyon nesneleri Linux'ta bu "futex" denilen sistem fonksiyonu kullanılarak gerçekleştirilmiştir. 
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Kritik kod oluşturmak için yaygın kullanılan senkronizasyon nesnelerinden biri "mutex" denilen nesnedir. Mutex sözcüğü 
    "mutual exclusion" sözcüklerinden kısaltma yapılarak uydurulmuştur. Mutex nesneleri pek çok farklı işletim sisteminde benzer biçimlerde 
    bulunmaktadır. 
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
                                                    53. Ders 20/05/2023 - Cumartesi
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    UNIX/Linux sistemlerinde mutex nesneleri tipik olarak şu aşamalardan geçilerek kullanılmaktadır:

    1) Mutex nesneleri pthread_mutex_t türü ile temsil edilmiştir. Bu tür ismi <thread.h> ve <sys/types> dosyaları içerisinde typedef
    edilmiş durumdadır. POSIX standartlarına göre pthread_mutex_t türü herhangi bir tür olarak typedef edilmiş olabilir. Örneğin Linux'ta bu tür bir yapı 
    (birliğin içerisinde bir yapı) biçiminde typedef edilmiştir. Programcı phtread_mutex_t türünden global bir nesne tanımlamalıdır. Örneğin:

    pthread_mutex_t g_mutex;

    Bu nesneye ilkdeğer vermenin iki yolu vardır. İlkdeğer doğrudan PTHREAD_MUTEX_INITIALIZER isimli makro kullanılarak verilebilir. 
    Bu makro tipik olarak küme parantezleri içerisinde yapıya ilkdeğer verme biçiminde açılmaktadır. Örneğin:

    pthread_mutex_t g_mutex =  PTHREAD_MUTEX_INITIALIZER;

    Mutex nesnesine ilkdeğer vermenin ikinci yolu pthread_mutext_init fonksiyonunu kullanmaktır. Fonksiyonun prototipi şöyledir:

    #include <pthread.h>
    
    int pthread_mutex_init(pthread_mutex_t *mutex, const pthread_mutexattr_t *attr);

    Fonksiyonun birinci parametresi ilkdeğer verilecek mutex nesnesinin adresini almaktadır. İkinci parametresi mutex nesnesinin 
    bazı özelliklerini belirten "özellik nesnesinin" adresini almaktadır. Mutex özellikleri daha sonra ele alınacaktır. Bu ikinci 
    parametre NULL adres geçilirse mutex default özelliklerle yaratılır. Fonksiyon başarı durumunda 0 değerine başarısızlık durumunda errno 
    değerine geri dönmektedir. Örneğin:
     
    if ((result = pthread_mutex_init(&g_mutex, NULL)) != 0)
        exit_sys_errno("pthread_mutex_init", result);

    Mutex nenesi PTHREAD_MUTEX_INITIALIZER makrosuyla yaratıldığında mutex nesnesinin özellik bilgisi de default default değerlerle oluşturulmaktadır. 
    Yani aşağıdaki iki ilkdeğer verme biçimi eşdeğerdir:

    pthread_mutex_t g_mutex =  PTHREAD_MUTEX_INITIALIZER;
        pthread_mutex_init(&g_mutex, NULL);

    Tabii bir mutex nesnesine yalnızca bir kez ilkdeğer vermeliyiz. POSIX standartlarına göre nesneye birden fazla kez ilkdeğer vermek tanımsız
    davranışa yol açmaktadır. 

    Programcı mutex nesnesinin kullınımı bittikten sonra pthread_mutex_destroy fonksiyonu ile onu boşaltmalıdır. Aslında bazı sistemlerde bu pthread_mutex_destroy
    fonksiyonu boşaltım için bir şey yapmamaktadır. Yani bazı sistemlerde bu içi boş bir fonksiyondur. Ancak POSIX standartlarına göre mutex nesnesi
    yaratılırken birtakım tahsisatlar yapılmış olabilir ve bu tahsisatların geri alınması pthread_mutex_destroy fonksiyonuyla sağlanmaktadır. 
    Yine bazı sistemlerde mutex nesnesine PTHREAD_MUTEX_INITIALIZER makrosuyla ilkdeğer verilmişse onun boşaltımının yapılması gerekmeyebilmektedir. 
    Ancak POSIX standartlarına göre nesneye makro ile ilkdeğer verilmiş olsa bile nesnenin boşaltımı yine yapılmalıdır. 

    #include <pthread.h>
    
    int pthread_mutex_destroy(pthread_mutex_t *mutex);

    Fonksiyon mutex nesnesinin adresini parametre olarak alır. Başarı durumunda 0 değerine başarısızlık durumunda errno değerine 
    geri döner. Linux'ta bu fonksiyon bir şey yapmamaktadır. Ancak POSIX standarttlarına göre bu fonksiyonun çağrılması gerekir. 
    Çünkü yukarıda da belirttiğimiz gibi pthread_mutex_init fonksiyonu içerisinde dinamik tahsisatlar yapılmış olabilir ve 
    bu tahsisatların geri alınması gerekebilir. Tabii aslında bu fonksiyonun başarısız olması da genel olarak mümkün değildir. Örneğin:

    if ((result = pthread_mutex_destroy(&g_mutex)) != 0)
        exit_sys_errno("pthread_mutex_destory", result);

    Burada bir noktayı yeniden vurgulamak istiyoruz: Eğer mutex nesnesine PTHREAD_MUTEX_INITIALIZER makrosuyla ilkdeğer verilmişse
    mutex nesnesinin destroy edilmesi pek çok sistemde gerekmemektedir. Ancak POSIX standartlarında bu durum belirtilmemiştir, bu da mutex nesnesi 
    makroyla initialize edilse bile destroy işlemini yapılması gerektiği anlamına gelmektedir. Ancak pek çok programcı bu tür durumlarda
    destroy işlemini yapmamaktadır. 
    
    Pekiyi mademki PTHERAD_MUTEX_INITIALIZER makrosu daha pratik bir kullanım sunmaktadır o halde neden pthread_mutex_init fonksiyonuna 
    gereksinim duyulmuştur? İşte bazen mutex nesneleri dinamik bir biçimde de tahsis edilebilmektedir. Örneğin bir yapı nesnesini senkronize 
    etmek için bir mutex kullanılacaksa mutex o yapının içerisinde yapı elemanı olarak bildirilebilir. Bu durumda ona statik biçimde makroyla
    ilkdeğer vermek mümkün olmaz. Çünkü C'de bir yapı nesnesine küme parantezleri ile atama yapamayız. (C99 ile birlikte ismine "compound literals" 
    denilen bir sentaks ile bu durum mümkün hale getirilmiştir.)
    
    Örneğin (kontroller ihmal edilmiştir):

    struct INFO {
        int a;
        int b;
        int c;
        pthread_mutex_t mutex;
    };
    ...
    struct INFO *info;

    info = (struct INFO *)malloc(sizeof(struct INFO));

    pthread_mutex_init(&info->mutex, NULL);

    2) Mutex nesneleriyle kritik kod aşağıdaki gibi oluşturulmaktadır:

    if ((result = pthread_mutex_lock(&g_mutex)) != 0)
        exit_sys_errno("pthread_mutex_lock", result);

    ....
    ....         <KRİTİK KOD>
    ....

    if ((result = pthread_mutex_unlock(&g_mutex)) != 0)
        exit_sys_errno("pthread_mutex_unlock", result);
    
    Görüldüğü gibi kritik kodun başında pthread_mutex_lock fonksiyonu sonunda da pthread_mutex_unlock fonksiyonu çağrılmıştır. 
    Mutex nesneleri işletim sistemlerinde "thread temelinde sahipliği (ownership) alınan" nesnelerdir. Bir thread pthread_mutex_lock
    fonksiyonuna girdiğinde mutex nesnesinin sahipliğinin başka bir thread tarafından alınıp alınmadığı fonksiyonda kontrol edilmektedir. 
    Eğer mutext nesnesinin sahipliği başka bir thread tarafından alınmışsa yani mutex nesnesi zaten "kilitlenmişse (locked edilmişse)"
    bu durumda pthread_mutex_lock fonksiyonu thread'i bloke eder, ta ki mutex'in sahipiğini alan thread pthread_mutex_unlock ile 
    mutex'in sahipliğini bırakana kadar. Eğer mutex'in sahipliği herhangi bir thread tarafından alınmamışsa yani mutex kilitli değilse bu durumda 
    pthread_mutex_lock fonksiyonu mutex'in sahipliğini alır (yani onu kilitler) ve akış kritik koda girer. Mutex kilitliyken 
    diğer thread akışları pthread_mutex_lock fonksiyonunda bloke edilerek bekletilecektir. Mutex nesnesinin kilidi onu kilitleyen 
    thread tarafından açıldığında pthread_mutex_lock fonksiyonunda bloke olmuş olan thread'lerden biri mutex'in sahipliğini 
    alarak (yani onu kilitleyerek) kritik koda girecektir. Böylece kritik kod içerisinde başından sonuna kadar tek bir thread akışı bulunuyor 
    olacaktır. Ancak pthread_mutex_lock fonksiyonunda birden fazla thread'in bloke olması durumunda mutex'in kilidi açıldığı zaman 
    hangi thread'in mutex'in sahipliğini alacağı konusunda işletim sistemleri bir garanti vermemektedir. Yani burada bir FIFO sisteminin
    uygulanmasının bir garantisi yoktur. Ancak işletim sistemleri çeşitli koşullar sağlanıyorsa mümkün olduğunca adil bir 
    durum oluşturmaya çalışırlar. pthread_mutex_lock ve pthread_mutex_unlock fonksiyonlarının prototipleri şöyledir:

    #include <pthread.h>

    int pthread_mutex_lock(pthread_mutex_t *mutex);
    int pthread_mutex_unlock(pthread_mutex_t *mutex);

    Fonksiyonlar parametre olarak olarak mutex nesnesinin adresini alırlar. Başarı durumunda 0 değerine başarısızlık durumunda 
    errno değerine geri dönerler. 

    Tabii kritİk kodun tek bir yerde olması gerekmemektedir. Önemli olan aynı mutex nesnesinin kullanılıyor olmasıdır. Örneğin 
    thread'lerden biri aşağıdaki gibi bir kritk kodla bir fonksiyonda karşılaşmış olabilir:

    if ((result = pthread_mutex_lock(&g_mutex)) != 0)
        exit_sys_errno("pthread_mutex_lock", result);

    ....
    ....         <KRİTİK KOD>
    ....

    if ((result = pthread_mutex_unlock(&g_mutex)) != 0)
        exit_sys_errno("pthread_mutex_unlock", result);
    
    Başka bir thread de başka bir fonksiyonda aşağıdaki gibi bir kritik kodla karşılaşmış olabilir:

    if ((result = pthread_mutex_lock(&g_mutex)) != 0)
        exit_sys_errno("pthread_mutex_lock", result);

    ....
    ....         <KRİTİK KOD>
    ....

    if ((result = pthread_mutex_unlock(&g_mutex)) != 0)
        exit_sys_errno("pthread_mutex_unlock", result);

    Burada kullanılan mutex nesneleri aynı nesnedir. Dolayısıyla iki thread de aynı mutex nesnesini kilitlemeye çalışmaktadır. O halde
    threadler'lerden biri o fonksiyonda kritik koda girerse diğer bir thread başka bir fonksiyonda diğer kritik koda giremez. 

    Normal olarak programcının her paylaşılan kaynak için ayrı bir mutex nesnesini bulundurması gerekir. Örneğin global bir bağlı liste 
    söz konusu olsun. Bu bağlı liste üzerinde eleman ekleme, eleman silme ve arama işlemlerini yapan üç fonksiyon bulunuyor olsun:

    add_item(...)
    {
        ...
    }

    remove_item(...)
    {
        ...
    }

    search_item(...)
    {
        ...
    }

    Burada bir thread eleman eklerken diğer diğer'lerin bu iş bitene kadar eleman silmeye çalışmaması ya da bağlı listede 
    arama yapmaması gerekir. Ya da bir eleman silerken diğerlerinin bu diğer işleri yapmaması gerekir. O halde bu üç fonksiyonda 
    aynı mutex kullanılarak kritik kod oluşturulmalıdır. Örneğin (sembolik kodlar kullanıyoruz):

    pthread_mutex_t g_llmutex = PTHREAD_MUTEX_INITIALIZER;

    add_item(...)
    {
        pthread_mutex_lock(&g_llmutex);
        <eleman ekleniyor>
        pthread_mutex_unlock(&g_llmutex);
    }

    remove_item(...)
    {
        pthread_mutex_lock(&g_llmutex);
        <eleman siliniyor>
        pthread_mutex_unlock(&g_llmutex);
    }

    search_item(...)
    {
        pthread_mutex_lock(&g_llmutex);
        <eleman aranıyor>
        pthread_mutex_unlock(&g_llmutex);
    }

    Mutex nesnelerinin thread temelinde sahipliği söz konusudur. Yani mutex nesnesinin sahipliği pthread_mutex_lock fonksiyonu 
    ile alındığında ancak alan thread nesnenin sahipliğini pthread_mutex_unlock fonksiyonuyla bırakabilir. Özetle biz başka bir 
    thread'in kilitlediği mutex nesnesinin kilidini açamayız. POSIX standartlarına göre sahipliği alınmamış olan bir mutex 
    nesnesini unlock etmeye çalışmak mutex özelliklerine bağlı olarak "tanımsız davranışa" yol açabileceği gibi pthread_mutex_unlock 
    fonksiyonunun başarısız olmasına da yol açabilmektedir. Normal mutex'ler (yani default özellikle yaratılmış mutex'ler) için POSIX standartları 
    sahipliğini almayan thread'in mutex nesnesinin kilidini açmaya çalışmasının "tanımsız davranışa" yol açacağını belirtmektedir. 

    3) Mutex nesneleri için bazı yardımcı fonksiyonlar da bulunmaktadır. Örneğin biz bir mutex nesnesi kilitliyken bloke olmayı 
    istemeyip "madem nesne kilitli o zaman ben de başka şeyler yapayım" diyebiliriz. Bu işlem pthread_mutex_trylock fonksiyonuyla 
    sağlanabilmektedir. Fonksiyonun prototipi şöyledir:

    #include <pthread.h>

    int pthread_mutex_trylock(pthread_mutex_t *mutex);

    Fonksiyon parametre olarak mutex nesnesinin adresini almaktadır. Başarı durumunda 0 değerine başarısızlık durumunda 
    errno değerine geri dönmektedir. Eğer mutex nesnesi zaten başka bir thread tarafından kilitlenmişse fonksiyon bloke olmaz ve 
    EBUSY errno değeri ile geri döner. Örneğin:

    result = pthread_mutex_trylock(&g_mutex);
    
    if (result != 0)
        if (result == EBUSY) {
            <başka bir şeyler yap>
        }
        else 
            exit_sys_errno("pthread_mutex_trylock", result);

    Bu örnekte pthread_mutex_trylock fonksiyonu başarısız olduğunda erro değeri EBUSY ise başka birtakım işlemler yapılmaktadır.

    pthread_mutex_timedlock isimli fonksiyon pthread_mutex_lock fonksiyonunun "zaman aşımlı (timeout)" biçidimir. Fonksiyonun prototipi 
    şöyledir:

    #include <pthread.h>

    int pthread_mutex_timedlock(pthread_mutex_t *mutex, const struct timespec *abstime);

    Fonksiyonun birinci parametresi mutex nesnesinin adresini, ikinci parametresi de mutlak zamana ilişkin timespec yapı nesnesinin 
    adresini almaktadır. Burada zaman aşımı mutlak zamana ilişkindir. Yani biz örneğin 5 saniyelik bir zaman aşımı vereceksek önce
    01/01/1970'ten geçen saniye sayısını elde edip onun izerine 5 saniye katarak bu fonksiyona vermeliyiz. Örneğin:

    struct timespec ts;
    ...
    if (clock_gettime(CLOCK_REALTIME, &ts) == -1)
        exit_sys("clock_gettime");

    ts.tv_sec += 5;

    result = pthread_mutex_timedlock(&g_mutex, &ts);

    if (result != 0) {
        if (result == ETIMEDOUT) {
            <fonksiyon zaman aşımından dolayı sonlandı>
        }
        else 
            exit_sys_errno("pthread_timedlock, result);
    }
    ...

    Bazı algoritmalarda "kilitlenme (deadlock)" problemlerinin çözümü zor olabilmektedir. Bu tür durumlarda son çare olarak 
    bu fonksiyon kullanılabilmektedir. Bazen makul bir süre aşıldığında arka plan belirli işlemlerin yapılması da gerekebilmektedir. 
    Bu tür seyrek durumlarda da pthread_mutex_timedlock fonksiyonu kullanılabilmektedir. Ancak bu fonksiyona toplamda çok seyrek gereksinim 
    duyulmaktadır. 

---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Aşağıdaki örnekte iki thread kritik kod içerisinde aynı global değişkeni 1000000 kez artırmıştır. Bu durumda global değişken 
    olması gerektiği değerde (2000000) olacaktır. 
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <pthread.h>

void *thread_proc1(void *param);
void *thread_proc2(void *param);
void exit_sys_errno(const char *msg, int eno);

pthread_mutex_t g_mutex;

int g_count = 0;

int main(void)
{
    pthread_t tid1, tid2;
    int result;
 
    if ((result = pthread_mutex_init(&g_mutex, NULL)) != 0)
        exit_sys_errno("pthread_mutex_init", result);

    if ((result = pthread_create(&tid1, NULL, thread_proc1, NULL)) != 0)
        exit_sys_errno("pthread_create", result);

    if ((result = pthread_create(&tid2, NULL, thread_proc2, NULL)) != 0)
        exit_sys_errno("pthread_create", result);

    if ((result = pthread_join(tid1, NULL)) != 0)
        exit_sys_errno("pthread_join", result);

    if ((result = pthread_join(tid2, NULL)) != 0)
        exit_sys_errno("pthread_join", result);
        
    printf("%d\n", g_count);

    if ((result = pthread_mutex_destroy(&g_mutex)) != 0)
        exit_sys_errno("pthread_mutex_destroy", result);

    return 0;
}

void *thread_proc1(void *param)
{
    int result;

    for (int i = 0; i < 1000000; ++i) {
        if ((result = pthread_mutex_lock(&g_mutex)) != 0)
            exit_sys_errno("pthread_mutex_init", result);
    
        ++g_count;    

        if ((result = pthread_mutex_unlock(&g_mutex)) != 0)
            exit_sys_errno("pthread_mutex_init", result);
    }
        
    return NULL;
}

void *thread_proc2(void *param)
{
    int result;

    for (int i = 0; i < 1000000; ++i) {
        if ((result = pthread_mutex_lock(&g_mutex)) != 0)
                exit_sys_errno("pthread_mutex_init", result);
        
            ++g_count;    

            if ((result = pthread_mutex_unlock(&g_mutex)) != 0)
                exit_sys_errno("pthread_mutex_init", result);
     }

    return NULL;
}

void exit_sys_errno(const char *msg, int eno)
{
    fprintf(stderr, "%s:%s\n", msg, strerror(eno));

    exit(EXIT_FAILURE);
}

/*--------------------------------------------------------------------------------------------------------------------------
    Aşağıdaki örnekte iki thread de bir makineyi 1'den 5'e kadar konuma sokmaktadır. Ancak bu işlemlerin iç içe geçmesi istanmemektedir. 
    Örnekte ratgele beklemeler de uygulanmıştır. Burada thread'lerin sırasıyla kritik koda girmesinin zorunlu olmadığına dikkat ediniz. 
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <pthread.h>

void *thread_proc1(void *param);
void *thread_proc2(void *param);
void do_something(const char *name);
void exit_sys_errno(const char *msg, int eno);

pthread_mutex_t g_mutex = PTHREAD_MUTEX_INITIALIZER;

int main(void)
{
    pthread_t tid1, tid2;
    int result;

    if ((result = pthread_create(&tid1, NULL, thread_proc1, "thread1")) != 0)
        exit_sys_errno("pthread_create", result);

    if ((result = pthread_create(&tid2, NULL, thread_proc2, "thread2")) != 0)
        exit_sys_errno("pthread_create", result);

    if ((result = pthread_join(tid1, NULL)) != 0)
        exit_sys_errno("pthread_join", result);

    if ((result = pthread_join(tid2, NULL)) != 0)
        exit_sys_errno("pthread_join", result);
        
    if ((result = pthread_mutex_destroy(&g_mutex)) != 0)
        exit_sys_errno("pthread_mutex_destroy", result);

    return 0;
}

void *thread_proc1(void *param)
{
    const char *name = (const char *)param;

    for (int i = 0; i < 10; ++i)
        do_something(name);
        
    return NULL;
}

void *thread_proc2(void *param)
{
    const char *name = (const char *)param;

    for (int i = 0; i < 10; ++i)
        do_something(name);
    
    return NULL;
}

void do_something(const char *name)
{
    int result;

    if ((result = pthread_mutex_lock(&g_mutex)) != 0)
        exit_sys_errno("pthread_mutex_lock", result);

    printf("%s: 1. Step\n", name);
    usleep(rand() % 300000);
    printf("%s: 2. Step\n", name);
    usleep(rand() % 300000);
    printf("%s: 3. Step\n", name);
    usleep(rand() % 300000);
    printf("%s: 4. Step\n", name);
    usleep(rand() % 300000);
    printf("%s: 5. Step\n", name);
    usleep(rand() % 300000);
    printf("-----------------------\n");

    if ((result = pthread_mutex_unlock(&g_mutex)) != 0)
        exit_sys_errno("pthread_mutex_unlock", result);
}

void exit_sys_errno(const char *msg, int eno)
{
    fprintf(stderr, "%s:%s\n", msg, strerror(eno));

    exit(EXIT_FAILURE);
}

/*--------------------------------------------------------------------------------------------------------------------------
                                                    54. Ders 21/05/2023 - Pazar
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Bir veri yapısı thread'ler arasında ortak bir biçimde kullnılıyorsa ve bu thread'ler veri yapısı üzerinde değişikler 
    yapabiliyorsa veri yapısının bozulmaması için senkronize edilmesi gerekir. Her veri yapısı için tipik olarak o veri 
    yapısını senkronize etmekte kullanılan bir mutex nesnesinin veri yapısı içerisinde bulundurulması yoluna gidilmektedir. 
    Örneğin thread'ler arasında ortak kullanılabilecek bir "bağlı liste (linked list)" oluşturmak isteyelim. Bu bağlı listeye
    iki thread de eleman eklemeye çalışırsa bağlı liste bozulabilecektir. Bu nedenle bağlı listeyi senkronize etmek için bir mutex
    bulundurulmalı ve bu mutex nesnesi ile senkronizasyon işlemi yapılmalıdır. Aşağıda böyle bir örnek verilmiştir. Bu örnekte 
    create_llist fonksiyonu "tek bağlı (single linked)" bağlı liste yaratmaktadır. Fonksiyon bağlı liste bilgilerinin bulunduğu 
    yapı nesnesinin adresine geri dönmektedir:

    typedef struct tagNODE {
        int val;
        struct tagNODE *next;
    } NODE;

    typedef struct tagLLIST {
        NODE *head;
        NODE *tail;
        size_t count;
        pthread_mutex_t mutex;
    } LLIST;
    
    LLIST *create_llist(void);

    add_item_tail ve add_item_head fonksiyonları bağlı listenin sonuna ve başına mutex kontrolü ile eleman eklemektedir. 

    NODE *add_item_tail(LLIST *llist, int val);
    NODE *add_item_head(LLIST *llist, int val);

    Fonksiyonlar başarı durumunda eklenen düğümün adresine başarısızlık durumunda NULL adrese geri dönmektedir. Fonksiyonlar başarısızlık 
    durumunda errno değerine de set etmektedir. Bağlı listeyi dolaşan bir walk__llist fonksiyonu da bulunmaktadır:

    int walk_llist(LLIST *llist);

    Fonksiyon başarı durumunda 0, başarısızlık durumunda -1 değerine geri dönmekte ve errno uygun biçimde set edilmektedir. 
    Nihayet bağlı liste destroy_llist fonksiyonu ile silinmektedir:

    void destroy_llist(LLIST *llist);

---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <errno.h>
#include <pthread.h>

typedef struct tagNODE {
    int val;
    struct tagNODE *next;
} NODE;

typedef struct tagLLIST {
    NODE *head;
    NODE *tail;
    size_t count;
    pthread_mutex_t mutex;
} LLIST;

LLIST *create_llist(void);
void destroy_llist(LLIST *llist);
NODE *add_item_tail(LLIST *llist, int val);
NODE *add_item_head(LLIST *llist, int val);
int walk_llist(LLIST *llist);

void *thread_proc1(void *param);
void *thread_proc2(void *param);
void *thread_proc3(void *param);

void exit_sys(const char *msg);
void exit_sys_errno(const char *msg, int eno);

static inline size_t get_count(LLIST *llist)
{
    return llist->count;
}

LLIST *create_llist(void)
{
    LLIST *llist;
    int result;

    if ((llist = (LLIST *)malloc(sizeof(LLIST))) == NULL)
        return NULL;
    
    llist->head = NULL;
    llist->tail = NULL;
    llist->count = 0;

    if ((result = pthread_mutex_init(&llist->mutex, NULL)) != 0) {
        errno = result;
        free(llist);
        return NULL;
    }

    return llist;
}

NODE *add_item_tail(LLIST *llist, int val)
{
    NODE *new_node;
    int result;

    if ((new_node = (NODE *)malloc(sizeof(NODE))) == NULL)
        return NULL;

    new_node->val = val;

    if ((result = pthread_mutex_lock(&llist->mutex)) != 0) {  
        free(new_node);
        goto FAILED;
    }

    if (llist->head == NULL)
        llist->head = new_node;
    else
        llist->tail->next = new_node;

    llist->tail = new_node;
    ++llist->count;

    if ((result = pthread_mutex_unlock(&llist->mutex)) != 0) 
        goto FAILED;

    return new_node;

FAILED:
      errno = result;
      
      return NULL;
}

NODE *add_item_head(LLIST *llist, int val)
{
    NODE *new_node;
    int result;

    if ((new_node = (NODE *)malloc(sizeof(NODE))) == NULL)
        return NULL;

    new_node->val = val;

    if ((result = pthread_mutex_lock(&llist->mutex)) != 0) {  
        free(new_node);
        goto FAILED;
    }
    
    if (llist->head == NULL)
        llist->tail = new_node;

    new_node->next = llist->head;
    llist->head = new_node;

    ++llist->count;

    if ((result = pthread_mutex_unlock(&llist->mutex)) != 0) 
        goto FAILED;

    return new_node;

FAILED:
      errno = result;
      
      return NULL;
}

int walk_llist(LLIST *llist)
{
    NODE *node;
    int result;

    if ((result = pthread_mutex_lock(&llist->mutex)) != 0) {
        errno = result;
        return -1;
    }

    node = llist->head;

    while (node != NULL) {
        printf("%d ", node->val);
        fflush(stdout);
        node = node->next;
    }

    if ((result = pthread_mutex_unlock(&llist->mutex)) != 0) {
        errno = result;
        return -1;
    }

    printf("\n");

    return 0;
}

void destroy_llist(LLIST *llist)
{
    NODE *node, *temp_node;
    
    node = llist->head;

    while (node != NULL) {
        temp_node = node->next;
        free(node);
        node = temp_node;
    }

    free(llist);
}

int main(void)
{
    pthread_t tid1, tid2, tid3;
    int result;
    LLIST *llist;

    if ((llist = create_llist()) == NULL) 
        exit_sys("create_list");

    if ((result = pthread_create(&tid1, NULL, thread_proc1, llist)) != 0)
        exit_sys_errno("pthread_create", result);

    if ((result = pthread_create(&tid2, NULL, thread_proc2, llist)) != 0)
        exit_sys_errno("pthread_create", result);

    if ((result = pthread_create(&tid3, NULL, thread_proc3, llist)) != 0)
        exit_sys_errno("pthread_create", result);

    if ((result = pthread_join(tid1, NULL)) != 0)
        exit_sys_errno("pthread_join", result);

    if ((result = pthread_join(tid2, NULL)) != 0)
        exit_sys_errno("pthread_join", result);

    if ((result = pthread_join(tid3, NULL)) != 0)
        exit_sys_errno("pthread_join", result);

    walk_llist(llist);
    
    printf("%zd\n", get_count(llist));
    
    destroy_llist(llist);
    
    return 0;
}

void *thread_proc1(void *param)
{
    LLIST *llist = (LLIST *)param;

    for (int i = 0; i < 1000000; ++i)
        if (add_item_tail(llist, i) == NULL) 
            exit_sys("add_item_tail");
            
    return NULL;
}

void *thread_proc2(void *param)
{
    LLIST *llist = (LLIST *)param;
    
    for (int i = 0; i < 1000000; ++i)
        if (add_item_tail(llist, i) == NULL) 
            exit_sys("add_item_tail");

    return NULL;
}

void *thread_proc3(void *param)
{
    LLIST *llist = (LLIST *)param;
    
    for (int i = 0; i < 1000000; ++i)
        if (add_item_head(llist, i) == NULL) 
            exit_sys("add_item_head");

    return NULL;
}

void exit_sys(const char *msg)
{
	perror(msg);

	exit(EXIT_FAILURE);
}

void exit_sys_errno(const char *msg, int eno)
{
    fprintf(stderr, "%s:%s\n", msg, strerror(eno));

    exit(EXIT_FAILURE);
}

/*--------------------------------------------------------------------------------------------------------------------------
    Mutex nesnesine pthread_mutex_init fonksiyonu ile ilkdeğer verilirken mutex özellikleri de bu fonksiyonun ikinci parametresinde
    belirtilebilir. Eğer mutex nesnesine PTHREAD_MUTEX_INITIALIZER makrosuyla ilkdeğer verilmişse bu durumda mutex default özelliklerle
    yaratılmaktadır. Daha önceden de belirttiğimiz gibi aşağıdaki iki ilkdeğer verme tamamen eşdeğerdir:

    pthread_mutex_t g_mutex = PTHREAD_MUTEX_INITIALIZER;
    pthread_mutex_init(&g_mutex, NULL);

    Mutex özelliklerinin set edilmesi tamamen thread özelliklerinin set edilmesinde olduğu gibi yapılmaktadır. Yani işlemler şu adımlardan 
    geçilerek gerçekleştirilir:

    1) Önce pthread_mutexattr_t türünden bir özellik nesnesi tanımlanır. 

    2) Bu özellik nesnesine pthread_mutexattr_init fonksiyonu ile ilkdeğerleri verilir. Bu nesneye ilkdeğer vermek için bir makro yoktur:
    Fonksiyonun prototipi şöyledir:

    #include <pthread.h>

    int pthread_mutexattr_init(pthread_mutexattr_t *attr);

    Fonksiyon parametre olarak mutex özellik nesnesinin adresini almaktadır. Başarı durumunda 0 değerine başarısızlık durumunda errno 
    değerine geri döner. 

    3) Bundan sonra artık pthread_mutexattr_setxxx fonksiyonlarıyla mutex özellikleri özellik nesnesinin içerisine yerleştirilir. 

    4) Artık özellik nesnesi oluşturulmuştur. Mutex nesnesi bu özellik nesnesi verilerek pthread_mutex_init fonksiyonu ile 
    oluşturulabilir. 

    5) Mutex nesnesi yaratıldıktan sonra artık özellik nesnesine gerek kalmamaktadır. Özellik nesnesi pthread_mutexattr_destroy 
    fonksiyonu ile yok edilebilir. Fonksiyonun prototipi şöyledir:

    #include <pthread.h>

    int pthread_mutexattr_destroy(pthread_mutexattr_t *attr);

    Fonksiyon yine parametre olarak mutex özellik nesnesini alır. Başarı durumunda 0 değerine başarısızlık durumunda errno değerine geri 
    döner. Özetle işlemler aşağıdaki kod parçasında belirtilen sırada yapılmaktadır:

    pthread_mutexattr_t mattr;
    ...
 
    if ((result = pthread_mutexattr_init(&mattr)) != 0)
        exit_sys_errno("pthread_mutexattr_init", result);

    /* pthread_mutexattr_setxxx fonksiyonlarıyla set işlemi */

    if ((result = pthread_mutex_init(&g_mutex, &mattr)) != 0)
        exit_sys_errno("pthread_mutex_init", result);

    if ((result = pthread_mutexattr_destroy(&mattr)) != 0)
        exit_sys_errno("pthread_mutexattr_destroy", result);

---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Bir thread bir mutex nesnesinin sahipliğini pthread_mutex_lock fonksiyonu ile aldıktan sonra yeniden aynı fonksiyonu çağırarak
    aynı mutex nesnesinin sahipliğini almaya çalışırsa ne olur? Muhtemel üç durum söz konusudur:

    1) Thread kendi kendini kilitler ve "deadlock" oluşur.
    
    2) Thread mutex'in sahipliğini ikinci kez alır ve bir sorun oluşmaz. Böyle mutex'lere "recursive mutex" denilmektedir. 

    3) Sahipliği alınmış mutex nesnesine yeniden pthread_mutex_lock uygulandığında fonksiyon başarısız olur.

    İşte bu muhtemel senaryoların her biri mutex nesnesinin türü denilen özelliği değiştirilerek sağlanabilmektedir. Mutex nesnesinin 
    türünü değiştirmek için pthread_mutexattr_settype fonksiyonu kullanılmaktadır. Fonksiyonun prototipi şöyledir:

    #include <pthread.h>
    
    int pthread_mutexattr_settype(pthread_mutexattr_t *attr, int type);

    Fonksiyonun birinci parametresi mutex özellik nesnesini ikinci parametresi mutex'in türünü almaktadır. Tür şunlardan biri olabilir:

    PTHREAD_MUTEX_NORMAL: Mutex'in sahipliği ikinci kez alınmak istenirse kilitlenme "deadlock" oluşur.

    PTHREAD_MUTEX_ERRORCHECK: Şu durumlarda fonksiyonlar başarısız olmaktadır:

        - Mutex nesnesnin sahipliği ikinci kez alınmaya çalışıldığında
        - Mutex nesnesinin sahipliğini almadan pthread_mutex_unlock işlemi uygulandığında

    PTHREAD_MUTEX_RECURSIVE: Mutex'in sahipliğini alan thread yeniden pthread_mutex_lock fonksiyonu ile sahipliği alabilir. 
    Ancak bu durumda fonksiyon sahipliğini aldığı miktarda onu pthread_mutex_unlock uygulamalıdır. Recursive mutex'ler için mutex 
    nesnesinin içerisinde bir sayaç bulundurulmaktadır. (Yani her pthread_mutex_lock fonksiyonundan geçildiğinde mutex'in sayacı 1
    artırılır, her pthread_mutex_unlock fonksiyonundan geçildiğinde sayaç 1 eksiltilir. Sayaç 0'a düşünce mutex'in kilidi açılır.)

    PTHREAD_MUTEX_DEFAULT: Bu default durumdur. POSIX standartlarına göre bu default durum yukarıdaki üç durumdan biri olabilir. 
    Linux sistemlerinde default durum PTHREAD_MUTEX_NORMAL ile aynıdır. 

    Eğer mutex nesnesinin türü set edilmediyse mutex nesnesi default olarak PTHREAD_MUTEX_DEFAULT durumda olur. Yukarıda da belirtildiği gibi 
    Linux sistemlerinde bu değer zaten PTHREAD_MUTEX_NORMAL ile aynıdır. Yani default durumda Linux sistemlerinde thread yeniden mutex nesnesinin 
    sahipliğini almaya çalışırsa "deadlock" oluşmaktadır. 

    Mutex nesnesinin türü de benzer biçimde pthread_mutexattr_gettype fonksiyonu ile alınabilmektedir:

    #include <pthread.h>

    int pthread_mutexattr_gettype(const pthread_mutexattr_t *attr, int *type);

    Fonksiyon mutex'in tür bilgisini ikinci parametresiyle belirtilen nesneye yerleştirir. Başarı durumunda 0 değerine, başarısızlık 
    durumunda errno değerine geri döner. 

/*--------------------------------------------------------------------------------------------------------------------------
    Aşağıdaki örnekte iki thread bir mutex'in sahipliğini almaya çalışmaktadır. Mutex'in sahipliğini alan thread foo fonksiyonunu 
    çağırdığında mutex'in sahipliğini ikinci kez almaya çalışmaktadır. Mutex nesneleri Linux'ta default durumda PTHREAD_MUTEX_NORMAL
    türünde olduğu için "deadlock" oluşacaktır. 
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <pthread.h>

void foo(const char *name);
void *thread_proc1(void *param);
void *thread_proc2(void *param);
void exit_sys_errno(const char *msg, int eno);

pthread_mutex_t g_mutex;

int main(void)
{
    pthread_t tid1, tid2;
    int result;
 
    if ((result = pthread_mutex_init(&g_mutex, NULL)) != 0)
        exit_sys_errno("pthread_mutex_init", result);

    if ((result = pthread_create(&tid1, NULL, thread_proc1, "thread1")) != 0)
        exit_sys_errno("pthread_create", result);

    if ((result = pthread_create(&tid2, NULL, thread_proc2, "thread2")) != 0)
        exit_sys_errno("pthread_create", result);

    if ((result = pthread_join(tid1, NULL)) != 0)
        exit_sys_errno("pthread_join", result);
    
    if ((result = pthread_join(tid2, NULL)) != 0)
        exit_sys_errno("pthread_join", result);

    if ((result = pthread_mutex_destroy(&g_mutex)) != 0)
        exit_sys_errno("pthread_mutex_destroy", result);

    return 0;
}

void foo(const char *name)
{
    int result;

    printf("%s: entering pthread_mutex_lock\n", name);

    if ((result = pthread_mutex_lock(&g_mutex)) != 0)
        exit_sys_errno("pthread_mutex_init", result);

    printf("%s mutex locked...\n", name);
 
    printf("%s: entering pthread_mutex_unlock\n", name);

    if ((result = pthread_mutex_unlock(&g_mutex)) != 0)
        exit_sys_errno("pthread_mutex_init", result);
    
    printf("%s: mutex unlocked...\n", name);
}

void *thread_proc1(void *param)
{
    char *name = (char *)param;
    int result;
    
    printf("%s: entering pthread_mutex_lock\n", name);

    if ((result = pthread_mutex_lock(&g_mutex)) != 0)
        exit_sys_errno("pthread_mutex_init", result);

    printf("%s mutex locked...\n", name);

    foo(name);
 
    printf("%s: entering pthread_mutex_unlock\n", name);

    if ((result = pthread_mutex_unlock(&g_mutex)) != 0)
        exit_sys_errno("pthread_mutex_init", result);
    
    printf("%s: mutex unlocked...\n", name);
   
    return NULL;
}

void *thread_proc2(void *param)
{
    char *name = (char *)param;
    int result;

    printf("%s: entering pthread_mutex_lock\n", name);

    if ((result = pthread_mutex_lock(&g_mutex)) != 0)
        exit_sys_errno("pthread_mutex_init", result);

    printf("%s mutex locked...\n", name);

    foo(name);
 
    printf("%s: entering pthread_mutex_unlock\n", name);

    if ((result = pthread_mutex_unlock(&g_mutex)) != 0)
        exit_sys_errno("pthread_mutex_init", result);
    
    printf("%s: mutex unlocked...\n", name);
    
    return NULL;
}

void exit_sys_errno(const char *msg, int eno)
{
    fprintf(stderr, "%s:%s\n", msg, strerror(eno));

    exit(EXIT_FAILURE);
}

/*--------------------------------------------------------------------------------------------------------------------------
    Şimdi de yukarıdaki örneği mutex türünü PTHREAD_MUTEX_RECURSIVE yaparak yeniden düzenleyelim. Burada artık mutex nesnesi "recursive"
    duruma sokulduğu için aynı thread mutex nesnesinin sahipliğini almaya çalıştığında bloke oluşmayacaktır. Ekrana çıkan yazıları dikkatlice
    inceleyiniz. 
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <pthread.h>

void foo(const char *name);
void *thread_proc1(void *param);
void *thread_proc2(void *param);
void exit_sys_errno(const char *msg, int eno);

pthread_mutex_t g_mutex;

int main(void)
{
    pthread_t tid1, tid2;
    int result;
    pthread_mutexattr_t mattr;
 
    if ((result = pthread_mutexattr_init(&mattr)) != 0)
        exit_sys_errno("pthread_mutexattr_init", result);

    if ((result = pthread_mutexattr_settype(&mattr, PTHREAD_MUTEX_RECURSIVE)) != 0)
        exit_sys_errno("pthread_mutexattr_settype", result);

    if ((result = pthread_mutex_init(&g_mutex, &mattr)) != 0)
        exit_sys_errno("pthread_mutex_init", result);

    if ((result = pthread_mutexattr_destroy(&mattr)) != 0)
        exit_sys_errno("pthread_mutexattr_destroy", result);

    if ((result = pthread_create(&tid1, NULL, thread_proc1, "thread1")) != 0)
        exit_sys_errno("pthread_create", result);

    if ((result = pthread_create(&tid2, NULL, thread_proc2, "thread2")) != 0)
        exit_sys_errno("pthread_create", result);

    if ((result = pthread_join(tid1, NULL)) != 0)
        exit_sys_errno("pthread_join", result);
    
    if ((result = pthread_join(tid2, NULL)) != 0)
        exit_sys_errno("pthread_join", result);

    if ((result = pthread_mutex_destroy(&g_mutex)) != 0)
        exit_sys_errno("pthread_mutex_destroy", result);

    return 0;
}

void foo(const char *name)
{
    int result;

    printf("%s: entering pthread_mutex_lock\n", name);

    if ((result = pthread_mutex_lock(&g_mutex)) != 0)
        exit_sys_errno("pthread_mutex_init", result);

    printf("%s mutex locked...\n", name);
 
    printf("%s: entering pthread_mutex_unlock\n", name);

    if ((result = pthread_mutex_unlock(&g_mutex)) != 0)
        exit_sys_errno("pthread_mutex_init", result);
    
    printf("%s: mutex unlocked...\n", name);
}

void *thread_proc1(void *param)
{
    char *name = (char *)param;
    int result;
    
      printf("%s: entering pthread_mutex_lock\n", name);

    if ((result = pthread_mutex_lock(&g_mutex)) != 0)
        exit_sys_errno("pthread_mutex_init", result);

    printf("%s mutex locked...\n", name);

    foo(name);
 
    printf("%s: entering pthread_mutex_unlock\n", name);

    if ((result = pthread_mutex_unlock(&g_mutex)) != 0)
        exit_sys_errno("pthread_mutex_init", result);
    
    printf("%s: mutex unlocked...\n", name);
   
    return NULL;
}

void *thread_proc2(void *param)
{
    char *name = (char *)param;
    int result;

    printf("%s: entering pthread_mutex_lock\n", name);

    if ((result = pthread_mutex_lock(&g_mutex)) != 0)
        exit_sys_errno("pthread_mutex_init", result);

    printf("%s mutex locked...\n", name);

    foo(name);
 
    printf("%s: entering pthread_mutex_unlock\n", name);

    if ((result = pthread_mutex_unlock(&g_mutex)) != 0)
        exit_sys_errno("pthread_mutex_init", result);
    
    printf("%s: mutex unlocked...\n", name);
    
    return NULL;
}

void exit_sys_errno(const char *msg, int eno)
{
    fprintf(stderr, "%s:%s\n", msg, strerror(eno));

    exit(EXIT_FAILURE);
}

/*--------------------------------------------------------------------------------------------------------------------------
    Pekiyi bir thread bir mutex nesnesinin sahipliğini aldıktan sonra sonlanırsa ne olur? (Sahipliği bir thread tarafından alınmış
    ancak o thread'in sonlanmış olması durumunda bu tür mutex'lere "abondoned" mutex'ler de denilmektedir.) Bu tür durumlarda iki olası 
    durum söz konusudur:

    1) Thread sonlanmış olsa da mutex'in sahipliği sonlanan thread'te kalır. Dolayısıyla başka bir thread mutex'i kilitlemek 
    isterse ya da zaten pthread_mutex_lock ile bloke bekliyorsa "deadlock" oluşur. 

    2) Sahipsiz kalmış mutex bir daha kilitlenemez. Eğer bir thread bu mutex'i kilitlemeye çalışırsa ya da daha önce kilitlemeye çalışıp 
    bloke olmuşsa pthread_mutex_lock başarısız olur. 

    İşte bu iki durumun hangisinin uygulanacağı mutex özellikleri ile belirlenebilmektedir. Bunun için pthread_mutexattr_setrobust
    fonksiyonu kullanılmaktadır:

    int pthread_mutexattr_setrobust(pthread_mutexattr_t *attr, int robust);

    Fonksiyonun birinci parametresi yine mutex özellik nesnesinin adresini almaktadır. İkinci parametre şu değerlerden biri olabilir:

    PTHREAD_MUTEX_STALLED: Bu durumda mutex kilitli kalır ve başka bir thread mutex'i kilitlemeye çalışırsa "deadlock" oluşur.

    PTHREAD_MUTEX_ROBUST: Bu durumda başka bir thread "abondened" mutex'i kilitlemeye çalışırsa pthread_mutex_lock başarısız olur
    ve fonksiyon EOWNERDEAD errno değeri ile geri döner. Ancak POSIX standartlarına göre bu kilitlemeyi ilk yapmaya çalışan thread'de
    bu hata elde edilir. Diğer thread'lerin yeniden bu mutex'i kilitlemeye çalışması durumunda yeniden EOWNERDEAD hatasının elde edilip
    edilmeyeceği işletim sistemini yazanların isteğine bırakılmıştır. Sahibi sonlanmış bir mutex kilitlenmeye çalışılırken EOWNERDEAD 
    errno değeri ile fonksiyon geri döndüğünde thread'in yeniden kullanılabilir hale getirilebilmesi için pthread_mutex_consistent 
    fonksiyonun çağrılması gerekmektedir. Fonksiyonun prototipi şöyledir:

    #include <pthread.h>

    int pthread_mutex_consistent(pthread_mutex_t *mutex);

    Fonksiyon parametre olarak mutex nesnesinin adresini alır. Başarı durumunda 0 değerine başarısızlık durumunda errno değerine geri döner. 
    Mutex "consistent" duruma sokulduğunda aynı zamanda kilitlenmiş de olur. Örneğin:

    result = pthread_mutex_lock(&g_mutex);

    if (result == EOWNERDEAD) {
        if ((result = pthread_mutex_consistent(&g_mutex)) != 0)
            exit_sys_errno("pthread_mutex_consistent", result);

        /* mutex locked durumda *
    }
    else 
        exit_sys_errno("pthread_mutex_lock", result);

    Mutex nesneleri default özellikle yaratıldığında robust durumu default olarak PTHREAD_MUTEX_STALLED biçimdedir. 
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Aşağıdaki örnekte mutex nesnesi default özelliklerle yaratılmıştır. Burada thread_proc1 mutex nesnesinin sahipliğini alarak 
    sonlandırılmıştır. thread_proc2 fonksiyonun pthread_mutex_lock işleminde "deadlock" oluşacaktır.
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <pthread.h>
#include <unistd.h>

void *thread_proc1(void *param);
void *thread_proc2(void *param);
void exit_sys_errno(const char *msg, int eno);

pthread_mutex_t g_mutex;

int main(void)
{
    pthread_t tid1, tid2;
    int result;
   
    if ((result = pthread_mutex_init(&g_mutex, NULL)) != 0)
        exit_sys_errno("pthread_mutex_init", result);

    if ((result = pthread_create(&tid1, NULL, thread_proc1, "thread1")) != 0)
        exit_sys_errno("pthread_create", result);

    if ((result = pthread_create(&tid2, NULL, thread_proc2, "thread2")) != 0)
        exit_sys_errno("pthread_create", result);

    if ((result = pthread_join(tid1, NULL)) != 0)
        exit_sys_errno("pthread_join", result);
    
    if ((result = pthread_join(tid2, NULL)) != 0)
        exit_sys_errno("pthread_join", result);

    if ((result = pthread_mutex_destroy(&g_mutex)) != 0)
        exit_sys_errno("pthread_mutex_destroy", result);

    return 0;
}

void *thread_proc1(void *param)
{
    char *name = (char *)param;
    int result;

    printf("%s: entering pthread_mutex_lock\n", name);

    if ((result = pthread_mutex_lock(&g_mutex)) != 0)
        exit_sys_errno("pthread_mutex_lock", result);

    printf("%s: thread terminates\n", name);
   
    return NULL;
}

void *thread_proc2(void *param)
{
    char *name = (char *)param;
    int result;

    sleep(1);
    printf("%s: entering pthread_mutex_lock\n", name);

    if ((result = pthread_mutex_lock(&g_mutex)) != 0)
        exit_sys_errno("pthread_mutex_lock", result);

    printf("%s mutex locked...\n", name);
    
    if ((result = pthread_mutex_unlock(&g_mutex)) != 0)
        exit_sys_errno("pthread_mutex_unlock", result);

    printf("%s mutex unlocked...\n", name);
    
    return NULL;
}

void exit_sys_errno(const char *msg, int eno)
{
    fprintf(stderr, "%s:%s\n", msg, strerror(eno));

    exit(EXIT_FAILURE);
}

/*--------------------------------------------------------------------------------------------------------------------------
    Aşağıdaki örnekte mutex "robust" duruma sokularak aynı işlemler yapılmıştır. Bu duurmda thread_proc2 artık mutex nesnesini 
    kilitlemeye çalıştığında fonksiyon EOWNERDEAD errno değeri ile başarısız olacaktır. 
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <pthread.h>
#include <unistd.h>

void *thread_proc1(void *param);
void *thread_proc2(void *param);
void exit_sys_errno(const char *msg, int eno);

pthread_mutex_t g_mutex;

int main(void)
{
    pthread_t tid1, tid2;
    int result;
    
    pthread_mutexattr_t mattr;
 
    if ((result = pthread_mutexattr_init(&mattr)) != 0)
        exit_sys_errno("pthread_mutexattr_init", result);

    if ((result = pthread_mutexattr_setrobust(&mattr, PTHREAD_MUTEX_ROBUST)) != 0)
        exit_sys_errno("pthread_mutexattr_settype", result);
    
    if ((result = pthread_mutex_init(&g_mutex, &mattr)) != 0)
        exit_sys_errno("pthread_mutex_init", result);

    if ((result = pthread_mutexattr_destroy(&mattr)) != 0)
        exit_sys_errno("pthread_mutexattr_destroy", result);

    if ((result = pthread_create(&tid1, NULL, thread_proc1, "thread1")) != 0)
        exit_sys_errno("pthread_create", result);

    if ((result = pthread_create(&tid2, NULL, thread_proc2, "thread2")) != 0)
        exit_sys_errno("pthread_create", result);

    if ((result = pthread_join(tid1, NULL)) != 0)
        exit_sys_errno("pthread_join", result);
    
    if ((result = pthread_join(tid2, NULL)) != 0)
        exit_sys_errno("pthread_join", result);

    if ((result = pthread_mutex_destroy(&g_mutex)) != 0)
        exit_sys_errno("pthread_mutex_destroy", result);

    return 0;
}

void *thread_proc1(void *param)
{
    char *name = (char *)param;
    int result;

    printf("%s: entering pthread_mutex_lock\n", name);

    if ((result = pthread_mutex_lock(&g_mutex)) != 0)
        exit_sys_errno("pthread_mutex_lock", result);

    printf("%s: thread terminates\n", name);
   
    return NULL;
}

void *thread_proc2(void *param)
{
    char *name = (char *)param;
    int result;

    sleep(1);
    printf("%s: entering pthread_mutex_lock\n", name);

    if ((result = pthread_mutex_lock(&g_mutex)) != 0) 
        exit_sys_errno("pthread_mutex_lock", result);

    printf("%s mutex locked...\n", name);
    
    if ((result = pthread_mutex_unlock(&g_mutex)) != 0)
        exit_sys_errno("pthread_mutex_unlock", result);

    printf("%s mutex unlocked...\n", name);
    
    return NULL;
}

void exit_sys_errno(const char *msg, int eno)
{
    fprintf(stderr, "%s:%s\n", msg, strerror(eno));

    exit(EXIT_FAILURE);
}

/*--------------------------------------------------------------------------------------------------------------------------
    Mutex nesneleri bazı programlama dilelrinde bir deyim olarak bile bulundurulmuştur. Örneğin C#'ta lock deyimi ve Java'da 
    syncronize deyimi mutex kontrolü altında işlem yapmak için dile eklenmiştir. Örneğin C#'taki lock deyiminin genel 
    biçimi şöyledir:

    lock (obj) 
        <deyim>

    Burada farklı thread'ler aynı nesneyi kullanırlarsa aynı kilit üzerinde işlem yapıyor olurlar. Aslında .NET dokümanlarında
    lock deyiminin Monitor nesnesi kullandığı belirtilmiştir. Monitor nesnesi de bir çeşit mutex nesnesi gibidir. 

    Aynı deyim Java'da synchronized ismiyle bulunmaktadır. Oradaki deyimin genel biçimi de C#'taki gibidir:

    synchronized (obj) 
        <deyim>

    Aşağıda C#'ta lock deyiminin kullanılmasına bir örnek verilmiştir:
---------------------------------------------------------------------------------------------------------------------------*/

using System;
using System.Threading;

namespace CSD
{
    class App
    {
        private static int m_count;
        private static object m_obj = new object();

        public static void Main(string[] args)
        {
            Thread thread1 = new Thread(new ParameterizedThreadStart(ThreadProc1));
            Thread thread2 = new Thread(new ParameterizedThreadStart(ThreadProc2));

            thread1.Start(null);
            thread2.Start(null);

            thread1.Join();
            thread2.Join();

            Console.WriteLine(m_count);
        }

        public static void ThreadProc1(object o)
        {
            for (int i = 0; i < 1000000; i++)
                lock (m_obj) 
                {
                    ++m_count;
                }
        }

        public static void ThreadProc2(object o)
        {
            for (int i = 0; i < 1000000; i++)
                lock (m_obj)
                {
                    ++m_count;
                }
        }
    }
}

/*--------------------------------------------------------------------------------------------------------------------------
                                                55. Ders 27/05/2023 - Cumartesi
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Biz şimdiye kadar mutex nesnelerini aynı prosesin thread'lerini senkronize etmek amacıyla kullandık. Mutex nesneleri 
    farklı proeslerin thread'lerini senkronize etmek için de kulanılabilmektedir. Aynı prosesin thread'leri mutex nesnesi ile 
    senkronize edilirken mutex nesnesi global bir değişken olarak tanımlanıyordu. Her iki thread de aynı mutex nesnesini kullanabiliyordu.
    Pekiyi mutex nesneleri farklı prosesin thread'leri arasında senkronizasyon amacıyla kullanılmak istendiğinde iki proses de 
    aynı mutex nesnesini nasıl görecektir? Eğer Windows sistemlerinde olduğu gibi mutex nesnelerinin UNIX/Linux sistemlerinde isimleri olsaydı
    bu kullanım kolaylıkla sağlanabilirdi. Ancak UNIX/Linux sistemlerinde mutex nesnelerinin isimleri yoktur. O halde tek yol 
    mutex nesnesini paylaşılan bir bellek alanında yaratmaktır. Ancak POSIX standartlarına göre mutex nesnelerinin paylaşılan bellek alanlarında 
    yaratılması proseslerarası kullanım için yeterli değildir. Aynı zamanda mutex nesnesinin proseslerarası paylaşılabilirliğini 
    set etmek gerekir. Bu da mutex özellikleriyle yapılmaktadır. pthread_mutexattr_setpshared fonksiyonu ile mutex paylaşımlı moda 
    sokulabilmektedir:

    #include <pthread.h>

    int pthread_mutexattr_setpshared(pthread_mutexattr_t *attr, int pshared); 

    Fonksiyonun birinci parametresi mutex özellik nesnesinin adresini almaktadır. İkinci parametresi ise nesnenin proseslerarası paylaşımını 
    belirtmektedir. Bu patametre PTHREAD_PROCESS_SHARED geçilirse nesne proseslerarasında paylaşılmakta, PTHREAD_PROCESS_PRIVATE geçilirse
    nesne proseslerarasında paylaşılmamaktadır. Fonksiyon başarı durumunda 0 değerine başarısızlık durumunda errno değerine geri 
    dönmektedir. Mutex özellik nesnesinin paylaşılabilirlik özelliği pthread_mutexattr_getpshared fonksiyonu ile elde edilebilir:

    #include <pthread.h>

    int pthread_mutexattr_getpshared(const pthread_mutexattr_t *attr, int *pshared);

    Fonksiyonun birinci parametresi mutex özellik nesnesinin adresini, ikinci parametresi paylaşılabilirlik durum bilgisinin yerleştirileceği 
    int türden nesnesinin adresini almaktadır. Tabii fonksiyon bu nesneye PTHREAD_PROCESS_SHARED ya da PTHREAD_PROCESS_PRIVATE değerlerindne birini 
    yerleştirmektedir. Fonksiyon başarı durumunda 0 değerine başarısızlık durumunda errno değerine geri dönmektedir. 

    Mutex özellikleri belirtilmezse ya da pthread_mutexattr_setpshared fonksiyonu ile set edilmezse default durumda nesnenin paylaşım 
    özelliği PTHREAD_PROCESS_PRIVATE biçimindedir. 

    Görüldüğü gibi mutex nesnelerinin proseslararasındaki paylaşımı biraz zahmetlidir. Bu nednele proseslerarasındaki senkronizasyonlar 
    için daha çok semaphore nesneleri tercih edilmektedir. 
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Aşağıdaki örnekte iki proses ortak bir paylaşılan bellek alanını kullanmaktadır. Paylaşılan bellek alanının başında aşağıdaki 
    gibi bir yapı nesnesi bulunmaktadır:

    typedef struct tagSHARED_INFO {
        int count;
        /* other members... */
        pthread_mutex_t mutex;   
    } SHARED_INFO;

    Örneğimizde iki proses de count değerini asenkron biçimde mutex koruması eşliğinde birer milyar kez artırmaktadır. 
    Bu örnekte paylaşılan bellek alanı "prog1.c" programı tarafından yaratılmış ve oradaki mutex nesnesine bu program tarafından 
    ilkdeğer verilmiştir. Dolayısıyla bizim önce "prog1" programını çalıştırmamız gerekmektedir. Mutex nesnesinin ve count nesnesinin
    paylaşılan bellek alanında bulunduğuna dikkat ediniz. Bu paylaşılan bellek alanı "prog1.c" programı tarafından shm_unlik fonksiyonu 
    ile yok edilmiştir. Tabii anımsanacağı gibi shm_unlink fonksiyonu başka bir proses paylaşılan bellek alanını kullanıyorsa o proses 
    paylaşılan bellek alanı nesnesini bırakana kadar zaten gerçek bir silme yapılmamaktadır. Pekiyi buradaki mutex nesnesi ne zaman 
    destroy edilmelidir? Normal olarak bir nesneyi hangi proses yaratmışsa onun yok etmesi uygun olur. Örneğimizde de mutex 
    nesnesini "prog1.c" programı yarattığına göre onun destroy edilmesi de aynı program tarafından yapılmalıdır. Ancak mutex nesnesini 
    destroy ederken diğer proseslerin artık bunu kullanmadığına emin olmak gerekir. Programların tasarımına göre buna emin olabildiğimiz
    noktalar söz konusu olabilir. Bu durumda biz de mutex nesnesimizi o noktalarda destroy edebiliriz. Ya da destroy işlemi için paylaşılan bellek 
    alanında ayrı bir sayaç da tutulabilir. Mutex'i destroy edecek program da bu sayaca bakabilir. Tabii bu sayacın kontrol edilmesi de blokeli 
    bir biçimde yapılabilir. Bunun için "durum değişkenleri (condition variable)" kullanılabilir. Biz aşağıdaki programda
    her prosesin de işini bitirdikten sonra beklemesini sağladık. Böylece mutex'i yine iki program da bittikten sonra "prog1.c" 
    programı destroy etmektedir. 

    Programları aşağıdaki gibi derleyip farklı terminallerden çalıştırabilirsiniz:

    gcc -o prog1 prog1.c -lrt -lpthread
    gcc -o prog2 prog2.c -lrt -lpthread

---------------------------------------------------------------------------------------------------------------------------*/

/* sharing.h */

#ifndef SHARING_H_
#define SHARING_H_

#include <sys/types.h>

#define SHM_NAME		"/shared_memory_for_mutex"

typedef struct tagSHARED_INFO {
    int count;
    /* other members... */
    pthread_mutex_t mutex;   
} SHARED_INFO;

#endif

/* prog1.c */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <fcntl.h>
#include <sys/stat.h>
#include <sys/mman.h>
#include <unistd.h>
#include <pthread.h>
#include "sharing.h"

void exit_sys(const char *msg);
void exit_sys_errno(const char *msg, int eno);

int main(void)
{
	int fdshm;
	SHARED_INFO *shminfo;
    pthread_mutexattr_t mattr;
    int result;
		
	if ((fdshm = shm_open(SHM_NAME, O_RDWR|O_CREAT, S_IRUSR|S_IWUSR|S_IRGRP|S_IROTH)) == -1)
		exit_sys("shm_open");   

	if (ftruncate(fdshm, sizeof(SHARED_INFO)) == -1)
		exit_sys("ftruncate");

	shminfo = (SHARED_INFO *)mmap(NULL, sizeof(SHARED_INFO), PROT_WRITE, MAP_SHARED, fdshm, 0);
	if (shminfo == MAP_FAILED) 
		exit_sys("mmap");

    if ((result = pthread_mutexattr_init(&mattr)) != 0)
        exit_sys_errno("pthread_mutexattr_init", result);

    if ((result = pthread_mutexattr_setpshared(&mattr, PTHREAD_PROCESS_SHARED)) != 0)
        exit_sys_errno("pthread_mutexattr_setpshared", result);

    if ((result = pthread_mutex_init(&shminfo->mutex, &mattr)) != 0)
        exit_sys_errno("pthread_mutex_init", result);
    
    if ((result = pthread_mutexattr_destroy(&mattr)) != 0)
        exit_sys_errno("pthread_mutexattr_destroy", result);

    shminfo->count = 0;

    for (int i = 0; i < 1000000000; ++i) {
        if ((result = pthread_mutex_lock(&shminfo->mutex)) != 0) 
            exit_sys_errno("pthread_mutex_lock", result);

        ++shminfo->count;

         if ((result = pthread_mutex_unlock(&shminfo->mutex)) != 0) 
            exit_sys_errno("pthread_mutex_unlock", result);
    }

    printf("Press ENTER to exit...\n");
    getchar();

    printf("%d\n", shminfo->count);
    
	if (munmap(shminfo, sizeof(SHARED_INFO)) == -1)
		exit_sys("munmap");

	close(fdshm);

	if (shm_unlink(SHM_NAME) == -1)
        exit_sys("shm_unlink");

    return 0;    
}

void exit_sys(const char *msg)
{
	perror(msg);

	exit(EXIT_FAILURE);
}

void exit_sys_errno(const char *msg, int eno)
{
    fprintf(stderr, "%s:%s\n", msg, strerror(eno));

    exit(EXIT_FAILURE);
}

/* prog1.c */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <fcntl.h>
#include <sys/stat.h>
#include <sys/mman.h>
#include <unistd.h>
#include <pthread.h>
#include "sharing.h"

void exit_sys(const char *msg);
void exit_sys_errno(const char *msg, int eno);

int main(void)
{
	int fdshm;
	SHARED_INFO *shminfo;
    pthread_mutexattr_t mattr;
    int result;
		
	if ((fdshm = shm_open(SHM_NAME, O_RDWR, 0)) == -1)
		exit_sys("shm_open");   

	shminfo = (SHARED_INFO *)mmap(NULL, sizeof(SHARED_INFO), PROT_WRITE, MAP_SHARED, fdshm, 0);
	if (shminfo == MAP_FAILED) 
		exit_sys("mmap");

    for (int i = 0; i < 1000000000; ++i) {
        if ((result = pthread_mutex_lock(&shminfo->mutex)) != 0) 
            exit_sys_errno("pthread_mutex_lock", result);

        ++shminfo->count;

         if ((result = pthread_mutex_unlock(&shminfo->mutex)) != 0) 
            exit_sys_errno("pthread_mutex_unlock", result);
    }

    printf("Press ENTER to exit...\n");
    getchar();

    printf("%d\n", shminfo->count);

	if (munmap(shminfo, sizeof(SHARED_INFO)) == -1)
		exit_sys("munmap");

	close(fdshm);

    return 0;    
}

void exit_sys(const char *msg)
{
	perror(msg);

	exit(EXIT_FAILURE);
}

void exit_sys_errno(const char *msg, int eno)
{
    fprintf(stderr, "%s:%s\n", msg, strerror(eno));

    exit(EXIT_FAILURE);
}

/*--------------------------------------------------------------------------------------------------------------------------
    Mutex nesneleri UNIX/Linux sistemlerinde nispeten hızlı senkronizasyon nesneleridir. Linux sistemlerinde senkronizasyon nesnelerinin
    hepsi zaten "futex (fast user space mutex)" denilen sistem fonksiyonu çağrılarak gerçeklştirilmektedir. mutex fonksiyonları 
    duruma göre hiç kernel moda geçmeden işlemini user modda yapabilmektedir. Şöyle ki: Biz mutext nesnesini pthread_mutex_lock 
    fonksiyonu ile kilitlemek isteyelim. Mutex nesnesi kendi içerisinde bayrak değişkenleri tutarak kilitleme işlemini atomik bir biçimde 
    yapmak isteyecektir. Atomikliği sağlamanın bir yolu "kernel moda geçerek CLI gibi makine komutuyla kesme mekanizmasını kapatıp bayrak
    değişkenlerin set etmek" olabilir. Ancak kernel moda geçmenin maliyeti yüksektir. İşte daha önceden de belirtitğimiz gibi yeni 
    modern işlemcilere "compare and set" gibi atomik makine komutları eklenmiştir. Bu makine komutları sayesinde bu tür flag değişkenleri 
    hiç kernel moda geçmeden user modda atomik bir biçimde set edilebilmektedir. 

    Ancak pthread_mutex_lock gibi bir fonksiyonun hiç kernel moda geçmeden işlem yapma olanağı da yoktur. Eğer mutex nesnesi kilitli 
    değilse onun kilitlenmesi user modda "compare and set" komutlarıyla yapılabilmektedir. Ancak ya mutex nesnesi zaten kilitliyse? 
    İşte bu durumda mecburen fonksiyon kernel moda geçerek thread'i bloke edecektir. Tabii aslında mutex kilitliyekn bu fonksiyonlar
    hemen kernel moda geçip bloke oluşturmazlar. Çünkü pek çok senkronizasyon nesnesi çok kısa bir süre için kilitleyip açılmaktadır. 
    Bu nedenle pthread_mutex_lock mutex'in kilitli olduğunu gördüğünde birden fazla işlemci ya da çekirdek varsa başka bir işlemci ya da 
    çekirdekteki mutex'i kilitleyen thread'in kısa süre içerisinde kilidi bırakacağını umarak meşgul bir döngüde sürekli bayrak değişkenine bakıp 
    bir süre beklemektedir. Bu tür meşgul döngülere senkronizasyon dünyasında "spin lock" denilmektedir. 
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Yaygın seknronizasyon nesnelerinden bir diğeri de "koşul değişkeleri (condition variables)" denilen nesnelerdir. 
    Bu nesneler UNIX/linux sistemlerinde uzunca bir süredir bulunmaktadır. Windows sistemlerine de belli bir süreden sonra sokulmuştur. 
    Koşul değişken nesneleri tek başlarına kullanılmaz mutex nesneleriyle beraber kullanılmaktadır. Koşul değişkenleriin temel kullanım amacı 
    "belli bir koşul sağlanana kadar" thread'in blokede bekletilmesidir. Bu koşul programcı tarafından oluşturulur. Örneğin 
    programcı global bir g_count değişkeni 0'dan büyük olana kadar thread'i bloke edip bekletmek isteyebilir. Ya da örneğin programcı
    bir g_flag değişkeni 1 olana kadar thread'ini blokede bekletmek isteyebilir. 

    Maalesef koşul değişkenleri anlaşılması en zor senkronizasyon nesnelerinden biridir. Bu nesnelerin düzgün kullanılabilmesi için belli bir 
    yöntemin izlenmesi gerekmektedir. Programcılar koşul değişkenlerinin kullanımına ilişkin kalıpları anlamakta zorluk çekebilmektedir. 
    Aynı zamanda programcıların kafası bu senkronizasyon nesnelerinin nedne gerektiği konusunda da karışabilmektedir. Biz önce 
    koşul değişkenlerinin tipik olarak nasıl kullanılması gerektiği üzerinde duracağız. Sonra konunun ayrıntılarına gireceğiz. 
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Koşul değişkenleri tipik olarak şu adımlardan geçilerek kullanılmaktadır:

    1) Koşul değişkenleri pthread_cond_t türü ile temsil edilmiştir. Bu tür <pthread.h> ve <sys/types.h> içerisinde typedef edilmiştir. 
    pthread_cont_t türü Sistemlerde tipik olarak bir yapı biçiminde typedef edilmektedir. Örneğin:

    pthread_cond_t g_cond;

    Programcı yine koşul değişkenlerini farklı thread'ler erişebilsin diye tipik olarak global bir değişken biçiminde tanımlar.

    2) Koşul değişkenlerine tıpkı mutex nesnelerinde olduğu gibi statik ya da dinamik olarak ilkdeğer verilebilmektedir. Biz koşul değişkenlerine
    statik düzeyde PTHREAD_COND_INITIALIZER makrosuyla ilkdeğer verebiliriz. Örneğin:

    pthread_cond_t g_cond = PTHREAD_COND_INITIALIZER;

    İlkdeğer verme işlemi dinamik olarak pthread_cond_init fonksiyonuyla da yapılabilmektedir:

    #include <pthread.h>

    int pthread_cond_init(pthread_cond_t *cond, const pthread_condattr_t *attr);

    Fonksiyonun birinci parametresi koşul değişken nesnesinin adresini ikinci parametresi onun özellik bilgilerinin bulunduğu özellik nesnesinin 
    adresini almaktadır. Koşul değişkenlerinin de özellik bilgisi vardır. Koşul değişkenlerinin özellikleri üzerinde daha ileride duracağız. 
    İkinci parametre NULL geçilirse koşul değişkenleri default özelliklerle yaratılmış olur. Aşağıdaki iki yaratım işlevsel olarak 
    eşdeğer etkiyi sağlamaktadır:

    pthread_cond_t g_cond = PTHREAD_COND_INITIALIZER;
    pthread_cond_init_(&g_cond, NULL);

    3) Koşul değişkenleri denilen senkronizasyon nesneleri tek başlarına kullanılmaz. Bir mutex eşliğinde kullanılmaktadır. Dolayısıyla
    bizim koşul değişkeninin yanı sıra onunla birlikte kullanacağımız bir mutex nesnesine de gereksinimiz vardır. Örneğin:

    pthread_mutex_t g_mutex = PTHREAD_MUTEX_INITIALIZER;
    pthread_cond_t g_cond = PTHREAD_COND_INITIALIZER;

    4) Programcının bazı değişkenlerle ilişkili bir koşul oluşturması gerekmektedir. Örneğin koşul "g_flag değişkeninin 1 olması"
    biçiminde olabilir. Koşul "thread'in bloke olmaması için gerekli olan durumu" belirtmektedir. Bizim koşulumuz g_flag değişkeninin 1 
    olması ise bu durum "eğer g_flag değişkeni 1 değilse blokede beklemek istediğimiz" anlamına gelmektedir. Yani programcının oluşturduğu koşul 
    sağlanmadığı sürece programcı thread'ini blokede bekletmek istemektedir. 

    5) Koşul sağlanmadığı sürece blokede beklemek için koşul sağlanıyorsa bloke oluşturmdan akışın devam etmesi için tipik kalıp 
    aşağıdaki gibidir (kontroller yapılmamıştır):

    pthread_mutex_lock(&g_mutex);

    while (<koşul sağlanmadığı sürece>)
        pthread_cond_wait(&cond, &g_mutex);

    /* kritik kod işlemleri */

    pthread_mutex_unlock(&g_mutex);

    Bu kalıpta koşul değişkenini bekleyen asıl fonksiyon pthread_cond_wait isimli fonksiyondur. Fonksiyonun prototipi şöyledir:

    #include <pthread.h>

    int pthread_cond_wait(pthread_cond_t *cond, pthread_mutex_t *mutex);

    Fonksiyonun birinci parametresi koşul değişken nesnesinin adresini, ikinci parametresi mutex nesnesinin adresini almaktadır. Fonksiyon 
    başarı durumunda 0 değerine başarısızlık durumunda errno değerine geri dönmektedir. 

    6) Durum değişkenlerinde blokede bekleme işlemi pthread_cond_wait tarafından sağlanmaktadır. Bu fonksiyon doğrudan thread'i bloke
    etmektedir. Koşul değişkenini bekleyen bir thread'in uyandırılması iki fonksiyonla yapılabilir: pthread_cond_signal ve 
    pthread_cond_broadcast. Fonksiyonların prototipleri şöyledir:

    #include <pthread.h>

    int pthread_cond_broadcast(pthread_cond_t *cond);
    int pthread_cond_signal(pthread_cond_t *cond);

    Her iki fonksiyon da koşul değişkeni nesnesinin adresini almaktadır. Fonksiyonlar yine başarı durumunda 0 değerine başarısızlık durumunda 
    errno değeerine geri dönmektedir. Bir thread pthread_cond_wait fonksiyonunda blokede beklerken o thread'in blokesini kaldırmak için 
    başka bir thread'in pthread_cond_signal ya da pthread_cond_broadcast fonksiyonlarını çağırması gerekmektedir. pthread_cond_signal 
    fonksiyonunun asıl amacı koşul değişkeninde blokede bekleyen herhangi tek bir thread'i uyandırmaktır. Ancak işletim sistemlerinde 
    kernel tasarımından dolayı bu mümkün olamayabilmektedir. Her ne kadar pthread_cond_signal aslında tek bir thread'i uyandırmak 
    için düşünülmüşse de işletim sisteminin tasarımından dolayı birden fazla thread'i de uyandırabilmektedir. Bu nedenle POSIX standartlarında
    pthread_cond_signal fonksiyonunun "koşul değişkeninde bekleyen en az bir thread'i uyandıracağı" söylenmiştir. Ancak pthread_cond_broadcast 
    fonksiyonu kesinlikle o koşul değişkeni ile blokede bekleyen tüm therad'leri uyandırmaktadır. Genellikle algoritmalarda "koşul değişkenini bekleyen 
    tek bir therad'in uyandırılması" istenir. Bu nedenle pthread_cond_broadcast yerine çoğu kez ptherad_cond_signal fonksiyonu kullanılır. 

    pthread_cond_wait fonksiyonu koşul değişkeni nesneesinin yanı sıra bir de mutex nesnesini de bizden istemektedir. Fonksiyon atomik 
    bir biçimde (yani tek bir işlem gibi) uykuya dalaken (yani bloke olurken) aynı zamanda bu mutex nesnesinin sahipliğini bırakmaktadır.
    Yani mutex nesnesinin sahipliği yukarıdaki kalıpta aslında pthread_cond_wait tarafından bırakılmaktadır. Örneğin:

    pthread_mutex_lock(&g_mutex);               /* mutex'in sahipliği alındı */

    while (<koşul sağlanmadığı sürece>)
        pthread_cond_wait(&cond, &g_mutex);     /* mutex'in sahipliği bırakılıyor */

    /* kritik kod işlemleri */

    pthread_mutex_unlock(&g_mutex);             /* mutex'in sahipliği bırakılıyor */


    Burada mutex nesnesnin sahipliği alınmış daha sonra koşul sağlanmıyorsa pthread_cond_wait fonksiyonuna girilmiştir. 
    İşte bu fonksiyon thread'i uykuya yatırırken aynı zamanda mutex'in sahipliğini de bırakmaktadır. Pekiyi koşul değişkeni pthread_cond_signal 
    ya da pthread_cond_broadcast fonksiyonuyla uyandırıldığında ne olacaktır? İşte pthread_cond_wait fonksiyonu ile koşul değişkeninin 
    blokesi çözüldüğünde fonksiyon buradaki mutex'in sahipliğini de yeniden alarak fonksiyondan çıkmaya çalışır. Koşul değişkeni nesnesi 
    ile mutex nesnesi farklı nesnelerdir. Diğer bir thread pthread_cond_signal ya da pthread_cond_broadcast uygulandığında koşul 
    değişkeninin blokesinden uyanılmaktadır. Ancak pthread_cond_wait fonksiyonu geri dönmeden önce mutex nesnesinin de sahipliğini 
    almaya çalışır. pthread_cond_wait fonksiyonunun "sözde kodu (pseudo code)" şöyle düşünülebilir:

    int ptherad_mutex_wait(pthread_cond_t *cond, pthread_mutex_t *mutex)
    {
        1) Atomik biçimde mutex'in sahipliğini bırak (yani kilidini aç) ve uykuya dal
        2) Şimdi uyandın, çünkü başka bir thread pthread_vond_signal ya da pthread_cond_broadcast fonksiyonlarını çağırdı
        3) Şimdi mutex sahipliğini almaya çalış:

        pthread_mutex_lock(mutex);

        return <başarı durumu>
    }

    Burada önemli bir nokta şudur: pthread_cond_wait fonksiyonu koşul değişkeninden uyandığında mutex nesnesinin sahipliğini de
    almaya çalışmaktadır. İşte bu noktada mutex nesnesi kilitliyse pthread_cond_wait geri dönmeyecektir. Ta ki mutex nesnesinin 
    sahipliği bırakılana kadar. Tabii bu durumda her ne kadar pthread_cond_wait geri dönmüyorsa da onun geri dönmesi için artık 
    pthread_cond_signal ya da pthread_cond_broadcast çağrılarına gerek yoktur. Yalnızca mutex kilidinin açılması gerekmektedir. 

    Böylece yukarıdaki kalıpta mutex'in kilidi iki kez açılmamaktadır. Zaten ptherad_cond_wait fonksiyonundan çıkıldığında mutex yeniden 
    kilitlendiği için kilitli olan mutex'in kilidi kritik kodun sonunda açılmaktadır. 

    Pekiyi biz yukarıdaki kalıpta mutex'in sahipliğini almadan pthread_mutex_unlock fonksiyonunu çağırabilir miyiz? pthread_mutex_wait 
    fonksiyonu mutex'in sahipliğini bırakacağına göre sahipliğin alınmış olması gerekmektedir. Anımsanacağı gibi sahipliği alınmayan 
    mutex'lerin unlock edilmesi duruma göre "undefined behavior" ya da işlemin başarısız olmasına yol açmaktadır. 

    Yukarıdaki kalıpta diğer önemli bir nokta pthread_cond_wait fonksiyonundan çıkıldığında koşul değişkenin bir döngü 
    içerisinde kontrol edilmesidir. Örneğin biz g_flag değişkenin 1 olması koşulunu uygulaayalım. Bu durumda buradaki döngü 
    şöyle olamalıdır:

    pthread_mutex_lock(&g_mutex);               /* mutex'in sahipliği alındı */

    while (g_flag != 1)
        pthread_cond_wait(&cond, &g_mutex);     /* mutex'in sahipliği bırakılıyor */

    /* kritik kod işlemleri */

    pthread_mutex_unlock(&g_mutex);             /* mutex'in sahipliği bırakılıyor */

    En normal durum ptherad_cond_signal ya da pthread_cond_broadcast işlemini yapan ve bizi koşul değişkenindeki uykudan uyandıran 
    thread'in bu işlemi uygulamadan önce koşulu olumlu hale getirmesidir (yani koşulu sağlanır hale getirmesidir). Örneğin:

    pthread_mutex_lock(&g_mutex);
    g_flag = 1;
    pthread_mutex_unlock(&g_mutex);

    pthread_cond_signal(&g_cond);

    En normal durum koşul değişkeninin koşulun sağlanması biçiminde ayarlanması işleminin de aynı mutex'i kullanarak kritik kod 
    içerisinde yapılmasıdır. Çünkü programda başka bir thread bu değişkene aynı anda erişirse yine sorun ortaya çıkabilir. Tabii 
    böyle bir durum yoksa koşul kritik kod içerisinde set edilmeye de bilir. Özetle diğer bir thread koşul değişkenindeki blokeyi 
    pthread_cond_signal ya da pthread_cond_broadcast ile kaldırmadan önce koşul değişkenini koşul sağlanacak biçimde set etmesi 
    gerekir. Aksi takdirde koşul sağlanmadığı için pthread_cond_wait fonksiyonundan uyanan thread döngü içerisinde yendien uykuya dalacaktır.

    7) Kullanım bittikten sonra koşul değişkeni pthread_cond_destroy fonksiyonu ile boşaltılmalıdır. Fonksiyonun prototipi şöyledir:

    #include <pthread.h>

    int pthread_cond_destroy(pthread_cond_t *cond);

    Fonksiyon koşul değişken nesnesinin adresini alır. Başarı durumunda 0 değerine başarısızlık durumunda errno değerine geri döner. 
    
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
                                                56.Ders 03/06/2023 - Cumartesi
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Yukarıdaki kalıbı uygulayan bir örnek aşağıda verilmiştir. Bu örnekte Thread2 g_flag == 1 koşulu sağlanana kadar koşul 
    değişkeninde blokede beklemektedir. Thread1 ise g_flag == 1 koşulunu sağlayıp pthread_cond_signal fonksiyonu ile Thread2'yi 
    koşul değişkenindeki blokeden kurtarmaktadır. Programın çıktısı aşağıdaki gibi olacaktır:

    Thread2 locked mutex
    Thread2 is waiting at the condition variable...
    Press ENTER to continue...

    Thread1 continues...
    Thread2 unlocked mutex
    Thread2 continues...

---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <pthread.h>
#include <unistd.h>

void *thread_proc1(void *param);
void *thread_proc2(void *param);
void exit_sys_errno(const char *msg, int eno);

pthread_mutex_t g_mutex = PTHREAD_MUTEX_INITIALIZER;
pthread_cond_t g_cond = PTHREAD_COND_INITIALIZER;

int g_flag = 0;

int main(void)
{
    pthread_t tid1, tid2;
    int result;
 
    if ((result = pthread_create(&tid1, NULL, thread_proc1, NULL)) != 0)
        exit_sys_errno("pthread_create", result);

    if ((result = pthread_create(&tid2, NULL, thread_proc2, NULL)) != 0)
        exit_sys_errno("pthread_create", result);

    if ((result = pthread_join(tid1, NULL)) != 0)
        exit_sys_errno("pthread_join", result);

    if ((result = pthread_join(tid2, NULL)) != 0)
        exit_sys_errno("pthread_join", result);

    if ((result = pthread_mutex_destroy(&g_mutex)) != 0)
        exit_sys_errno("pthread_mutex_destroy", result);

    if ((result = pthread_cond_destroy(&g_cond)) != 0)
        exit_sys_errno("pthread_cond_destroy", result);
  
    return 0;
}

void *thread_proc1(void *param)
{
    int result;

    printf("Press ENTER to continue...\n");
    getchar();

    if ((result = pthread_mutex_lock(&g_mutex)) != 0)
        exit_sys_errno("pthread_mutex_lock", result);

    g_flag = 1;

    if ((result = pthread_mutex_unlock(&g_mutex)) != 0)
        exit_sys_errno("pthread_mutex_unlock", result);

    if ((result = pthread_cond_signal(&g_cond)) != 0)
        exit_sys_errno("pthread_cond_signal", result);
    
    printf("Thread1 continues...\n");

    return NULL;
}

void *thread_proc2(void *param)
{
    int result;
  
    if ((result = pthread_mutex_lock(&g_mutex)) != 0)
        exit_sys_errno("pthread_mutex_lock", result);

    printf("Thread2 locked mutex\n");

    while (g_flag != 1) {
        printf("Thread2 is waiting at the condition variable...\n");
        if ((result = pthread_cond_wait(&g_cond, &g_mutex)) != 0)
            exit_sys_errno("pthread_cond_wait", result);
    }

    if ((result = pthread_mutex_unlock(&g_mutex)) != 0)
        exit_sys_errno("pthread_mutex_unlock", result);

    printf("Thread2 unlocked mutex\n");

    printf("Thread2 continues...\n");

    return NULL;
}

void exit_sys_errno(const char *msg, int eno)
{
    fprintf(stderr, "%s:%s\n", msg, strerror(eno));

    exit(EXIT_FAILURE);
}

/*--------------------------------------------------------------------------------------------------------------------------
    Koşul değişkenlerinin kullanımına ilişkin bazı ayrıntılar vardır. Şimdi o ayrıntılar üzerinde duralım:

    Yukarıda verdiğimiz kalıpta koşul değişkenini pthread_cond_wait ile beklerken bir döngü kullandık. Bu döngünün amacı nedir?

    while (<koşul sağlanmadığı sürece>)
        pthread_cond_wait(&g_cond);

    Yukarıda da belirttiğimiz gibi bir koşul değişkeni için pthread_cond_signal işlemi yapıldığında o koşul değişkeninde bekleyen 
    tek bir thrad değil birden fazla thread uyandırılabilmektedir. Her ne kadar pthread_cond_signal tek bir thread'i koşul 
    değişkenindne uyandırmak istese de bu işletim sistemi tasarımından kaynaklanan nedenlerle mümkün olmayabilmektedir. 
    pthread_cond_signal istemeden birden fazla thread'i uyandırdığında bu thread'ler mutex'in sahipliğini almaya çalışırlar. 
    Bunlardan yalnızca biri mutex'in sahipliğini almayı başarır. Diğer thread'ler koşul değişkeninden uyanmıştır. Ancak bunlardan 
    biri mutex neesnesinin sahipliğini aldığı için mutex'te blokede beklerler. Aşağıdaki sözde kodu inceleyeniz:

    int ptherad_mutex_wait(pthread_cond_t *cond, pthread_mutex_t *mutex)
    {
        1) Atomik biçimde mutex'in sahipliğini bırak (yani kilidini aç) ve uykuya dal
        2) Şimdi uyandın, çünkü başka bir thread pthread_vond_signal ya da pthread_cond_broadcast fonksiyonlarını çağırdı
        3) Şimdi mutex sahipliğini almaya çalış:

        <Thread'lerden biri mutex'in sahipliğini alacak, yanlışlıkla uyanan diğerleri bu noktada bekleyecek>

        pthread_mutex_lock(mutex);  

        return <başarı durumu>
    }

    İşte bu durumda pthread_cond_signal fonksiyonunu uygulayan taraf koşul değişkeninden tek bir thread'in uyandırılıp kritik koda 
    girmesini isterken yanlışlıkla birden fazla threda uyandırılmış olacaktır. O halde eğer programcı bunu istiyorsa uyanan thread yeniden 
    koşul değişkenini koşul sağlanmaz hale getirebilir ve bu döngü sayesinde diğer thread'ler yeniden uykuya dalabilir. Örneğin:
    
    pthread_mutex_lock(&g_mutex);               /* mutex'in sahipliği alındı */

    while (g_flag != 1)
        pthread_cond_wait(&cond, &g_mutex);     /* mutex'in sahipliği bırakılıyor */

    /* kritik kod işlemleri */

    g_flag = 0;                                 /* Dikkat! koşul yeniden sağlanmaz hale getiriliyor */

    pthread_mutex_unlock(&g_mutex);             /* mutex'in sahipliği bırakılıyor */

    <Artık bu noktada koşul dğeişkeninden yanlışlıkla uyanmış olan thread'ler koşul sağlanmadığı için yeniden uykuya dalacaklar>

    Tabii burada "koşul yeniden sağlanmaz hale getirildiğinde göre diğer uykuya dakan thread'lerin akibeti" merak edilebilmektedir. 
    İşte thread'ler yeniden koşul sağlandığında teker teker uyandırılacaktır. Yani koşul değişkeninde bekleyen thread'ler de 
    aslında aynı amacı gerçekleştirmek için beklemektedir. Amaç onları teker teker kritik kod içerisinde oradan çıkarmaktır.

    Döngü oluşturulmasının ikinci nedeni "spurious wakeup" denilen durumdur. Bazı sistemlerde hiç pthred_cond_signal ya da 
    pthread_cond_broadcast yapılmasa bile thread'ler işletim sisteminin tasarımından kaynaklanan nedenlerle koşul değişkeninden 
    uyandırılabilmektedir. Bu durumda koşul sağlanmadığına göre yanlışlıkla uyanan ("spurious" Türkçe "yapay, sahte, yanlış"
    anlamlarına gelmektedir) thread'lerin bu döngü sayesinde yeniden uyutulması gerekmektedir. 

    pthread_cond_signal işlemi kaydedilen bir işlem değildir. Yani biz pthread_cond_signal yaptığımızda eğer koşul değişkeninde bekleyen 
    hiçbir thread yoksa bu işlem boşa çıkmış olur. Başka bir deyişle biz pthread_cond_signal ya da pthread_cond_broadcast yaptıktan sonra 
    bir thread pthread_cond_wait fonksiyonuna girerse bloke olur. pthread_cond_signal ya da pthread_cond_broadcast işlemi sadece 
    o anda koşul değişkeninde bekleyen thread'ler için bir uyandırma yapmaktadır. 

    Pekiyi biz pthread_cond_signal ya da pthread_cond_broadcast işlemlerini mutex kilitliyken yapasak ne olur? Örneğin:

    pthread_mutex_lock(&g_mutex);
    g_flag = 1;

    pthread_cond_signal(&g_cond);
    ....
    pthread_mutex_unlock(&g_mutex);

    Bu durumda biz pthread_cond_signal işleminde koşul değişkeninde bekleyen thread'i uyandırmış olmaktayız. Ancak pthread_cond_wait 
    koşul değişkeninden uyanmakla birlikte mutex'in sahipliğini almak için bloke olur. Tabii biz mutex'in sahipliğini bırakınca 
    o thread mutex'in sahipliğini alıp pthread_cond_wait fonksiyonundançıkacaktır. Tabii pthread_cond_signal ya da pthread_cond_broadcast 
    fonksiyonlarını mutex'in sahipliğini bıraktıktan sonra uygulamak normal olan durumdur. Örneğin:

    pthread_mutex_lock(&g_mutex);
    g_flag = 1;
    pthread_mutex_unlock(&g_mutex);
    pthread_cond_signal(&g_cond);
    
    Döngünün oluşturulmasının bir nedeni de şudur: Birden fazl thread koşulu sağlayıp pthread_cond_signal uygulamış olsun. 
    
    Örneğin:

    <Threadlerden biri>

    pthread_mutex_lock(&g_mutex);
    <koşulun sağlanması yapılıyor>
    pthread_mutex_unlock(&g_mutex);

    pthread_cond_signal(&g_cond);

    <Diğer bir thread>

    pthread_mutex_lock(&g_mutex);
    <koşulun sağlanması yapılıyor>
    pthread_mutex_unlock(&g_mutex);

    pthread_cond_signal(&g_cond);

    Burada iki ayrı thread bir üretici-tüketici probleminde değer üretip tüketiciyi uyandırmak istesin. Burada koşul değişkeninde bekleyen 
    birden fazla tüketici thread koşul değişkeninden uyandırılacak ancak bunların bir tanesi muetex'in sahipliğini alacaktır. İşte mutex 
    sahipliğini alan thread tüm tüketimi yapıp kritik koddan çıktığında eğer bir döngü olmazsa artık diğer thread kritik koda girecektir. 
    Üretici-tüketici problemini izleyen paragraflarda ele alacağız.
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Üretici-Tüketici Problemi (Producer-Consumer Problem) gerçek hayatta en fazla karşılaşın senkronizasyon problemlerinden biridir. 
    Problemin çeşitli varyasyonları vardır. Üretici-Tükettici problemi aynı prosesin thread'leri arasında uygulanabilecğei gibi 
    farklı proseslerin thread'leri arasında da uygulanabilmektedir. Üretici-Tüketici probleminde en az bir üretici thread ve en az bir 
    tüketici thread vardır. Biz bir üretici bir de tüketici thread'in olduğunu varsayalım. Üreitici thread belli bir işlemden sonra bir 
    değer üretir. Ancak o değerin işlenmesini tüketici thread'e havale eder. Bunun ortak bir paylaşılan alan oluşturulur. Üretici 
    thread elde ettiği değeri paylaşılan alana yerleştirir. Tüketici thread de onu oradan alarak kullanır. Yan, üretici thread'in görevi
    değeir elde edip onu bir paylaşılan bellek alanına yazmaktır. Tüketici thread'in görevi de onu paylaşılan bellek alanından alıp işlemektir. 
    Tabii eğer problem aynı prosesin thread'leri arasında uygulanacaksa bu durumda paylaşılan alan global bir nesne olabilir. 
    Ancak problem farklı proseslerin thread'leri arasında uygulanacaksa bu durumda paylaşılan alan gerçekten "paylaşılan bellek alanı 
    (shared memory)" olarak oluşturulmalıdır. Problemdeki ana unsur üretici thread'in ve tüketici thread'in asenkron çalışması nedeniyle 
    koordine edilmesi gerekliliğidir. Eğer üretici thread tüketici thread'ten daha hızlı davranırsa daha tüketici thread önceki değeri 
    paylaşılan bellek alanından almadan üretici thread yeni bir değeir oraya yerleştirerek önceki değeri ezebilir. Benzer biçimde 
    eğer tüketici thread üretici thread'ten daha hızlı davraırsa bu durumda önceki değeri yenidne alıp işlemeye çalışabilir. O halde
    bu problemde "tüketici thread'in önceki değeri almadan üretici thread'in yeni bir değeri paylaşılan alana yerleştirmemesi" gerekir. 
    Benzer biçimde tüketici thread de "üretici thread yeni bir değeri paylaşılan alana yerleştirmeden aynı değeri ikinci kez" almamlıdır.
    Yani iki thread'in birbirlerini beklemesi gerekmektedir. 

    Bu problemde nesnen tek bir thread'in hem değeri elde edip hem de onu işlemek yerine iki ayrı thread'in bu işi yapmaya çalıştığını 
    merak edebilirsiniz. Bunun amacı hız kazancı sağlamaktır. Bu sayede üretici thread üretim yaparken tüketici thread tüketim de yapabilmektedir. 
    Halbuki bu işlemler seri bir biçimde yapılırsa üretim ve tüketim faaliyetlerinin eş zamanlı yapılması mümkün olmaz. Tabii 
    birden fazla thread de seri olarak üretim ve tüketim faaliyetlerinde bulunabilir. Ancak çoüu kez üretim faaliyetinin de koordineli 
    bir biçimde yapılması gerekmektedir. Yani bu çözüm de gerkeli hızlanmayı sağlamayabilmektedir. 

    Tek bir işlemcinin ya da çekirdğein olduğu durumda üretici-tüketici problemi bir hızlanma sağlayabilir mi? Burada da yine 
    prosesin toplam CPU zamanı birden fazla thread'le fazlalaştırılabilmektedir. Yani üretici thread üretim işlemi bittiğinde kesildiğinde 
    hemen tüketici thread daha hızlı devreye girebilmektedir. Ancak şüphesiz çok işlemcili ya da çekirdekli sistemlerde performansın daha 
    fazla artması beklenir. 

    Üretici-tüketici probleminin değişik biçimleri vardır. Örneğin ortadaki paylaşılan bellek alanı tek bir nesneyi tutacak biçimde 
    değil birden fazla nesneyi tutacak biçimde bir "FIFO kuruk sistemi olarak" oluşturulabilir. Paylaşılan bir kuyurk sistemi olursa 
    üretici ve tüketicinin birbirlerini bekleme olasılığı azaltılmış olur. Artık üretici thread kuyruk tam dolmuşken, tüketici thread'te 
    kuyruk tam boşken bloke olacaktır. 

    Üretici-tüketivi probleminde üretici ve tüketici  thread'ler birden fazla da olabilmektedir. Yani çok üretici ve çok tüketici 
    paralel biçimde çalıştırılabilmektedir. Böylece tek işlemcili ya da çekirdekli sistemlerde bile performans artırılabilmektedir. 
    
    Üretici tüketici probleminin gerçek hayat uygulamalarına çok yerde kaşılaşılmaktadır. Örneğin client-server sistemlerde 
    client'lar üretici durumdadır, server'lar da tüketici durumdadır. Burada birden fazla client thread üretim yapmakta ve birden fazla
    server thread de tüketim yapmaktadır. Örneğin bir satranç prgramında üretici thread "geçerli hamleleri" elde ederken tüketici thread 
    bu geçerli hamleleri analiz ediyor olabilir. 
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Aşağıdaki örnekte üretici-tüketici problemi simüle edilmeye çalışılmıştır. Üretici thread 0'dan 99'a kaadar sayıları rastgele
    beklemelerle bir global değişkene yerleştirmekte tüketici thread'de rastgele beklemelerle o değeri bu global değişkenden alıp
    ekrana yazdırmaktadır. Buradaki usllep fonksiyonu "mikrosaniye" mertebesinde bekleme yapmaktadır. srand ve rand yerine rand_r 
    isimli onların "thread-safe" versiyonu kullanılmıştır. Buradaki örnek bir çalıştırmadan  elde edilen çıktı şöyledir:

    0 1 1 3 3 5 7 9 11 13 14 14 16 18 20 20 22 22 23 24 27 28 29 31 32 33 34 34 36 37 37 38 38 39 41 43 43 43 44 45 45 48 
    49 49 51 51 51 52 54 54 54 55 57 60 60 60 61 61 61 61 62 62 64 66 66 68 69 70 72 73 75 76 76 79 81 81 81 82 83 84 85 
    85 87 87 90 92 93 94 95 98 98 98 99 

    Görüldüğü gibi tüketici thread bazı değerleri kaçıtmış bazı değerleri de birden fazla kez almıştır. 

---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>
#include <pthread.h>
#include <unistd.h>

void *thread_producer(void *param);
void *thread_consumer(void *param);
void exit_sys_errno(const char *msg, int eno);

int g_shared;

int main(void)
{
    pthread_t tid1, tid2;
    int result;
 
    if ((result = pthread_create(&tid1, NULL, thread_producer, NULL)) != 0)
        exit_sys_errno("pthread_create", result);

    if ((result = pthread_create(&tid2, NULL, thread_consumer, NULL)) != 0)
        exit_sys_errno("pthread_create", result);

    if ((result = pthread_join(tid1, NULL)) != 0)
        exit_sys_errno("pthread_join", result);

    if ((result = pthread_join(tid2, NULL)) != 0)
        exit_sys_errno("pthread_join", result);
  
    return 0;
}

void *thread_producer(void *param)
{
    int val;
    unsigned seed;

    seed = time(NULL) + 123;

    val = 0;
    for (;;) {
        usleep(rand_r(&seed) % 300000);
        g_shared = val;
        if (val == 99)
            break;
        ++val;
    }

    return NULL;
}

void *thread_consumer(void *param)
{
    int val;
    unsigned seed;

    seed = time(NULL) + 456;

    for (;;) {
        val = g_shared;
        usleep(rand_r(&seed) % 300000);
        printf("%d ", val);
        fflush(stdout);
        if (val == 99)
            break;
    }
    printf("\n");

    return NULL;
}

void exit_sys_errno(const char *msg, int eno)
{
    fprintf(stderr, "%s:%s\n", msg, strerror(eno));

    exit(EXIT_FAILURE);
}

/*--------------------------------------------------------------------------------------------------------------------------
    Üretici-tüketici problemi tipik olarak semaphore'lar ve koşul değişkenleri kullanılarak çözülmektedir. Semaphore'lar 
    daha basit bir kullanıma sahiptir. Biz burada üretici-tüketici probleminin koşul değişkenleriyle çözümü üzerinde duracağız. 
    Semaphore'lar izleyen paragraflarda ele alınacaktır. 
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Üretici-tüketici probleminin koşul değişkenleriyle çzümünde üretici ve tüketici içim iki ayrı koşul değişkeni oluşturulur. 
    Koşul bir flag değişkeni ile ifade edilebilir. Çözümdeki temel fikir üreticinin-tüketiciyi beklemekten kurtarması, tüketicinin de 
    üreticiyi beklemekten kurtarması biçimindedir . Adeta bir tahteravalli gibi işlemler yürütülmektedir. Problemin çözümünde kullanılan 
    ortak değişkenler şöyledir:

    pthread mutex_t g_mutex = PTHREAD_MUTEX_INITIALIZER;
    pthread_cond_t g_cond_producer = PTHREAD_COND_INITIALIZER;
    pthread_cond_t g_cond_consumer = PTHREAD_COND_INITIALIZER;

    int g_flag = 0;

    Üretici thread'in sembolik kodu şöyledir:

    for (;;) {
        <değeri elde et>
        
        pthread_mutex_lock(&g_mutex);

        while (g_flag == 1)
            pthread_cond_wait(&g_producer, &g_mutex);

        <değeri paylaşılan alana yerleştir>

        g_flag = 1;

        pthread_mutex_unlock(&g_mutex);

        pthread_cond_signal(&g_cond_consumer);
    }

     Üretici thread'in sembolik kodu şöyledir:

      for (;;) {       
        pthread_mutex_lock(&g_mutex);

        while (g_flag == 0)
            pthread_cond_wait(&g_consumer, &g_mutex);

        <paylaşılan bellek alanından bilgiyi alacak>

        g_flag = 0;

        pthread_mutex_unlock(&g_mutex);

        pthread_cond_signal(&g_cond_producer);
    }

    Burada kodu dikkatlice inceleyiniz. g_flag değişkeninin başlangıçtaki değeri 0'dır. Bu durumda başlangıçta tüketici thread 
    bekleyecek ancak üretici thread beklemeden değeir üretip paylaşılan alana yerleştirecektir. Tüketici çok yavaş çalışsa bile üretici 
    thread değeri paylaşılan bellek alanına yerleştirdikten sonra artık g_flag değişkenini 1 yaptığı için pthread_cond_wait 
    fonksiyonunda bekleyeektir. Bu surada tüketici thread paylaşılan alandan bilgiyi alıp g_flag değişkenini 0 yaptıktam sonra üreticiyi
    blokeden kurtaracaktır. Görüldüğü gibi üretici-tüketiciyi, tüketici de üreticiyi beklemektedir. 
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
                                                57.Ders 04/06/2023 - Pazar
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Aşağıda üretici-tüketici probleminin koşul değişkenleriyle çözümüne bir örnek verilmiştir. Burada ortadaki paylaşılan
    alan yine tek bir int nesneden oluşmaktadır. Bu tür durumlarda kritik kodun mümkün olduğu kadar kısa tutulması iyi bir 
    tekniktir. Yani biz kodda yalnızca gerekli kısımları kritik kod içerisine almalıyız. 
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>
#include <pthread.h>
#include <unistd.h>

void *thread_producer(void *param);
void *thread_consumer(void *param);
void exit_sys_errno(const char *msg, int eno);

pthread_mutex_t g_mutex;
pthread_cond_t g_cond_producer;
pthread_cond_t g_cond_consumer;
int g_flag = 0;

int g_shared;

int main(void)
{
    pthread_t tid1, tid2;
    int result;

    if ((result = pthread_mutex_init(&g_mutex, NULL)) != 0)
        exit_sys_errno("pthread_mutex_init", result);

    if ((result = pthread_cond_init(&g_cond_producer, NULL)) != 0)
        exit_sys_errno("pthread_cond_init", result);

    if ((result = pthread_cond_init(&g_cond_consumer, NULL)) != 0)
        exit_sys_errno("pthread_cond_init", result);

    if ((result = pthread_create(&tid1, NULL, thread_producer, NULL)) != 0)
        exit_sys_errno("pthread_create", result);

    if ((result = pthread_create(&tid2, NULL, thread_consumer, NULL)) != 0)
        exit_sys_errno("pthread_create", result);

    if ((result = pthread_join(tid1, NULL)) != 0)
        exit_sys_errno("pthread_join", result);

    if ((result = pthread_join(tid2, NULL)) != 0)
        exit_sys_errno("pthread_join", result);

    if ((result = pthread_cond_destroy(&g_cond_consumer)) != 0)
        exit_sys_errno("pthread_cond_destroy", result);

    if ((result = pthread_cond_destroy(&g_cond_producer)) != 0)
        exit_sys_errno("pthread_cond_destroy", result);   

    if ((result = pthread_mutex_destroy(&g_mutex)) != 0)
        exit_sys_errno("pthread_mutex_destroy", result);
  
    return 0;
}

void *thread_producer(void *param)
{
    int val;
    unsigned seed;
    int result;

    seed = time(NULL) + 123;

    val = 0;
    for (;;) {
        usleep(rand_r(&seed) % 300000);

        if ((result = pthread_mutex_lock(&g_mutex)) != 0)
            exit_sys_errno("pthread_mutex_lock", result); 

        while (g_flag == 1)
            if ((result = pthread_cond_wait(&g_cond_producer, &g_mutex)) != 0)
                exit_sys_errno("pthread_cond_wait", result); 
        
        g_shared = val;
        g_flag = 1;

        if ((result = pthread_mutex_unlock(&g_mutex)) != 0)
            exit_sys_errno("pthread_mutex_unlock", result); 

        if ((result = pthread_cond_signal(&g_cond_consumer)) != 0)
            exit_sys_errno("pthread_cond_signal", result); 

        if (val == 99)
            break;
        ++val;
    }

    return NULL;
}

void *thread_consumer(void *param)
{
    int val;
    unsigned seed;
    int result;

    seed = time(NULL) + 456;

    for (;;) {
        if ((result = pthread_mutex_lock(&g_mutex)) != 0)
            exit_sys_errno("pthread_mutex_lock", result); 

        while (g_flag == 0)
            if ((result = pthread_cond_wait(&g_cond_consumer, &g_mutex)) != 0)
                exit_sys_errno("pthread_cond_wait", result); 

        val = g_shared;
        g_flag = 0;

        if ((result = pthread_mutex_unlock(&g_mutex)) != 0)
            exit_sys_errno("pthread_mutex_unlock", result); 

        if ((result = pthread_cond_signal(&g_cond_producer)) != 0)
            exit_sys_errno("pthread_cond_signal", result); 
        
        usleep(rand_r(&seed) % 300000);
        printf("%d ", val);
        fflush(stdout);
        if (val == 99)
            break;
    }
    printf("\n");

    return NULL;
}

void exit_sys_errno(const char *msg, int eno)
{
    fprintf(stderr, "%s:%s\n", msg, strerror(eno));

    exit(EXIT_FAILURE);
}

/*--------------------------------------------------------------------------------------------------------------------------
    Üretici-tüketici probleminde paylaşılan alan bir kuyruk sistemi olursa üreticinin tüketiciyi tüketicinin de üreticiyi
    bekleme olasılığı düşürülmüş olur. Çünkü bu durumda üretici yalnızca kuyruk tam doluyken tüketici de kuyruk tam boşken 
    bekleyecektir. Böyle bir kuruk gerçekleştirimi çeşitli biçimlerde yapılabilir. 
    
    En çok kullanılan kuyruk gerçekleştirimlerinden biri "döngüsel kuyruk sistemi (circular queue)" de denilen gerçekleştirimdir. 
    Bu gerçekleştirimde bir dizi oluşturulur. head ve tail olmak üzere iki indeks ya da gösterici kuyruğun başını ve sonunu tutar. 
    Kuyruğa bilgi yerleştiririlirken tail göstericisinin gösterdiği yere yerleştirme yapılır ve tail göstericisi bir artırılır. 
    Kuyruktan eleman alınırken eleman head göstericisinin gösterdiği yerdne alınır ve head göstericisi bir artırılır. Tabii head 
    ve tail göstericileri dizinin sonuna geldiğinde yeninden dizinin başına çekilir (zaten "döngüsel" terimi bu nedenle kullanılmaktadır). 
    Kuyrukta o anda kaç elemanının bulunduğu ayrı bir sayaçla tutulabilir. Burada önemli noktalardan biri head ve tail göstericilerinin 
    aynı yeri göstermesi durumunda kuyruğun tam boş ya da tam dolu olabileceğidir. Bunun tespiti sayaç değişkenine bakılarak 
    yapılabilir. 

    Üretici-tüketici probleminin kuyruklu çözümünde üreticinin bekleme koşulu şöyle oluşturulabilir (kontroller yapılmamıştır):

    while (g_count == QUEUE_SIZE)
        pthread_cond_wait(&g_cond_producer, &g_mutex);

    Bu koşul üreticinin yalnızca kuyruk eleman sayısı kuyruk uzunluğuna eşit olduğunda bloke olacağı anlamına gelmektedir. Yani kuyruk
    tam doluysa üretici bloke olacaktır. Tüketicinin bekeleme koşulu da şöyle oluşturulabilir:

    while (g_count == 0)
        pthread_cond_wait(&g_cond_consumer, &g_mutex);
        
    Burada da tüketici yalnızca kuyruk tam boş ise bloke olacaktır. 

    Aşağıda üretici-tüketici probleminin kuyruklu versiyonuna bir örnek verilmiştir.
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>
#include <pthread.h>
#include <unistd.h>

#define QUEUE_SIZE      10

void *thread_producer(void *param);
void *thread_consumer(void *param);
void exit_sys_errno(const char *msg, int eno);

pthread_mutex_t g_mutex;
pthread_cond_t g_cond_producer;
pthread_cond_t g_cond_consumer;

int g_queue[QUEUE_SIZE];
int g_head = 0;
int g_tail = 0;
int g_count = 0;

int main(void)
{
    pthread_t tid1, tid2;
    int result;

    if ((result = pthread_mutex_init(&g_mutex, NULL)) != 0)
        exit_sys_errno("pthread_mutex_init", result);

    if ((result = pthread_cond_init(&g_cond_producer, NULL)) != 0)
        exit_sys_errno("pthread_cond_init", result);

    if ((result = pthread_cond_init(&g_cond_consumer, NULL)) != 0)
        exit_sys_errno("pthread_cond_init", result);

    if ((result = pthread_create(&tid1, NULL, thread_producer, NULL)) != 0)
        exit_sys_errno("pthread_create", result);

    if ((result = pthread_create(&tid2, NULL, thread_consumer, NULL)) != 0)
        exit_sys_errno("pthread_create", result);

    if ((result = pthread_join(tid1, NULL)) != 0)
        exit_sys_errno("pthread_join", result);

    if ((result = pthread_join(tid2, NULL)) != 0)
        exit_sys_errno("pthread_join", result);

    if ((result = pthread_cond_destroy(&g_cond_consumer)) != 0)
        exit_sys_errno("pthread_cond_destroy", result);

    if ((result = pthread_cond_destroy(&g_cond_producer)) != 0)
        exit_sys_errno("pthread_cond_destroy", result);   

    if ((result = pthread_mutex_destroy(&g_mutex)) != 0)
        exit_sys_errno("pthread_mutex_destroy", result);
  
    return 0;
}

void *thread_producer(void *param)
{
    int val;
    unsigned seed;
    int result;

    seed = time(NULL) + 123;

    val = 0;
    for (;;) {
        usleep(rand_r(&seed) % 300000);

        if ((result = pthread_mutex_lock(&g_mutex)) != 0)
            exit_sys_errno("pthread_mutex_lock", result); 

        while (g_count == QUEUE_SIZE)
            if ((result = pthread_cond_wait(&g_cond_producer, &g_mutex)) != 0)
                exit_sys_errno("pthread_cond_wait", result); 
        
        g_queue[g_tail++] = val;
        g_tail %= QUEUE_SIZE;
        ++g_count;
 
        if ((result = pthread_mutex_unlock(&g_mutex)) != 0)
            exit_sys_errno("pthread_mutex_unlock", result); 

        if ((result = pthread_cond_signal(&g_cond_consumer)) != 0)
            exit_sys_errno("pthread_cond_signal", result); 

        if (val == 99)
            break;
        ++val;
    }

    return NULL;
}

void *thread_consumer(void *param)
{
    int val;
    unsigned seed;
    int result;

    seed = time(NULL) + 456;

    for (;;) {
        if ((result = pthread_mutex_lock(&g_mutex)) != 0)
            exit_sys_errno("pthread_mutex_lock", result); 

        while (g_count == 0)
            if ((result = pthread_cond_wait(&g_cond_consumer, &g_mutex)) != 0)
                exit_sys_errno("pthread_cond_wait", result); 

        val = g_queue[g_head++];
        g_head %= QUEUE_SIZE;
        --g_count;

        if ((result = pthread_mutex_unlock(&g_mutex)) != 0)
            exit_sys_errno("pthread_mutex_unlock", result); 

        if ((result = pthread_cond_signal(&g_cond_producer)) != 0)
            exit_sys_errno("pthread_cond_signal", result); 
        
        usleep(rand_r(&seed) % 300000);
        printf("%d ", val);
        fflush(stdout);
        if (val == 99)
            break;
    }
    printf("\n");

    return NULL;
}

void exit_sys_errno(const char *msg, int eno)
{
    fprintf(stderr, "%s:%s\n", msg, strerror(eno));

    exit(EXIT_FAILURE);
}

/*--------------------------------------------------------------------------------------------------------------------------
    Koşul değişkenlerinin zaman aşımlı bekleme yapan pthread_cond_timedwait isimli bir biçimi de vardır. Bu fonksiyon belli bir 
    zaman aşımı dolduğunda koşul değişkenini otomatik olarak açmaktadır. Fonksiyonun prototipi şöyledir:

    #include <pthread.h>

    int pthread_cond_timedwait(pthread_cond_t *cond, pthread_mutex_t *mutex,  const struct timespec *abstime);

    Burada yine timespec yapısı ile belirtilen zaman aşımı değeri göreli değil mutlaktır. Fonksiyon yine atomik bir biçimde
    mutex'in sahipliğini bırakır ve çıkışta yine mutex'in sahipliğini almaya çalışır. Ancak koşul değişkeninde bekleme en kötü 
    olasılıkla zaman aşımı dolduğunda sonlanmaktadır. Fonksiyon başarı durumunda sıfır başarısızlık durumunda errno değerine geri döner. 
    Yine fonksiyon eğer zaman aşımı dolayısıyla sonlanmışsa ETIMEDOUT değeri ile geri dönemktedir. 
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Koşul değişkenleri de özellik (attribute) parametresine sahiptir. Ancak koşul değişkenlerinin set edilebilecek yalnızca 
    iki özelliği vardır. Koşul değişkenlerine özellik iliştirmek diğer nesnelerde olduğu gibi yapılmaktadır. Programcı önce
    pthread_condattr_t türünden bir nesne tanımlar. Sonra bu nesneye pthread_condattr_init fonksiyonuyla ilkdeğer verir. 
    Sonra pthread_condattr_setxxx fonksiyonlarıyla özellikleri nesne içerisine set eder. Oluşturduğu bu özellik nesnesini de
    pthread_cond_init fonksiyonunda kullanır. Yine özellik nesnesinin pthread_cond_init fonksiyonundan sonra korunmasına gerek yoktur. 
    Özellik nesnesi pthread_condattr_destroy fonksiyonu ile boşaltılabilir. Fonksiyonların prototipileri şöyledir:

    #include <pthread.h>

    int pthread_condattr_destroy(pthread_condattr_t *attr);
    int pthread_condattr_init(pthread_condattr_t *attr);

    Koşul değişkenlerine iki özellik set ed,p bunları aalabiliriz. Birincisi koşul değişkeninin proseslerarası kullanımını sağlayan
    özelliktir. Bu özellik pthread_condattr_setpshared fonksiyonu ile set edilmetedir.  Fonksiyonun prototipi şöyledir:

    #include <pthread.h>

    int pthread_condattr_setpshared(pthread_condattr_t *attr, int pshared); 
    int pthread_condattr_getpshared(const pthread_condattr_t *attr, int * pshared);

    Buradaki pshaed parametresi PTHREAD_PROCESS_SHARED ya da PTHREAD_PROCESS_PRIVATE değerinde olabilir. pthread_condattr_getpshared 
    fonksiyonu bu değeri özellik nesnesinden alıp parametresiyle belirtilen nesneye yerleştirmektedir. Böyle bir set işlemi 
    yapılmazsa default durum PTHREAD_PROCESS_PRIVATE biçimindedir. 

    Biz pthread_cond_timedwait fonksiyonunda zaman aşımında kullanılacak saatin cinsini de beelirleyebiliriz. Bu işlemler için 
    pthread_condattr_setclock ve pthread_condattr_getclock fonksiyonları kullanılmaktadır:

    #include <pthread.h>

    int pthread_condattr_getclock(const pthread_condattr_t *attr, clockid_t *clock_id);
    int pthread_condattr_setclock(pthread_condattr_t *attr, clockid_t clock_id);

    Fonksiyon kullanılacak clock nesnesinin id'sini parametre olarak almaktadır. Default olarak "system clock" kullanılmaktadır. 

    Tabii koşul değişkenlerinin proseslerarası kullanımı için yine onların paylaşılan bellek alanında oluşturulması gerekmektedir. 
    Tabii bu durumda mutex nesnesinin de paylaşılan bellek alanında oluşturulması gerekecektir.   
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Aşağıda üetici-tüketici probleminin proseslerarasında oluşturulmasına ilişkin bir örnek verilmiştir. Bu örnekte tüm koşul 
    değişkenleri, mutex nesnesi ve kuyruk bilgileri paylaşılan bellek alanında oluşturulmuştur. Programlardna önce "producer"
    çalıştırılmalıdır. Tüm bu nesneleri producer yaratıp kendisi silmektedir. Derleme işlemlerini şöyle yapanilirsiniz:

    gcc -Wall -o producer producer.c -lpthread -lrt
    gcc -Wall -o consumer consumer.c -lpthread -lrt
---------------------------------------------------------------------------------------------------------------------------*/
/* sharing.h"

#ifndef SHARING_H_
#define SHARING_H_

#include <sys/types.h>

#define SHM_NAME        "/producer-consumer"
#define QUEUE_SIZE      10

typedef struct tagSHARED_INFO {
    pthread_cond_t cond_producer;
    pthread_cond_t cond_consumer;
    pthread_mutex_t mutex;
    int head;
    int tail;
    int queue[QUEUE_SIZE];
    int count;
} SHARED_INFO;

#endif

/* producer.c */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>
#include <fcntl.h>
#include <sys/stat.h>
#include <sys/mman.h>
#include <unistd.h>
#include <pthread.h>
#include "sharing.h"

void exit_sys(const char *msg);
void exit_sys_errno(const char *msg, int eno);

int main(void)
{
	int fdshm;
	SHARED_INFO *shminfo;
    pthread_mutexattr_t mattr;
    pthread_condattr_t cattr;
    int result;
    int val;

    srand(time(NULL));

	if ((fdshm = shm_open(SHM_NAME, O_RDWR|O_CREAT, S_IRUSR|S_IWUSR|S_IRGRP|S_IROTH)) == -1)
		exit_sys("shm_open");   

	if (ftruncate(fdshm, sizeof(SHARED_INFO)) == -1)
		exit_sys("ftruncate");

	shminfo = (SHARED_INFO *)mmap(NULL, sizeof(SHARED_INFO), PROT_WRITE, MAP_SHARED, fdshm, 0);
	if (shminfo == MAP_FAILED) 
		exit_sys("mmap");

    if ((result = pthread_mutexattr_init(&mattr)) != 0)
        exit_sys_errno("pthread_mutexattr_init", result);

    if ((result = pthread_mutexattr_setpshared(&mattr, PTHREAD_PROCESS_SHARED)) != 0)
        exit_sys_errno("pthread_mutexattr_setpshared", result);

    if ((result = pthread_mutex_init(&shminfo->mutex, &mattr)) != 0)
        exit_sys_errno("pthread_mutex_init", result);
    
    if ((result = pthread_mutexattr_destroy(&mattr)) != 0)
        exit_sys_errno("pthread_mutexattr_destroy", result);

    if ((result = pthread_condattr_init(&cattr)) != 0)
        exit_sys_errno("pthread_condattr_init", result);

    if ((result = pthread_condattr_setpshared(&cattr, PTHREAD_PROCESS_SHARED)) != 0)
        exit_sys_errno("pthread_condattrattr_setpshared", result);

    if ((result = pthread_cond_init(&shminfo->cond_producer, &cattr)) != 0)
        exit_sys_errno("pthread_cond_init", result);

    if ((result = pthread_cond_init(&shminfo->cond_consumer, &cattr)) != 0)
        exit_sys_errno("pthread_cond_init", result);

    if ((result = pthread_condattr_destroy(&cattr)) != 0)
        exit_sys_errno("pthread_condattr_destroy", result);

    shminfo->count = 0;
    shminfo->head = 0;
    shminfo->tail = 0;

    val = 0;
    for (;;) {
        usleep(rand() % 300000);

        if ((result = pthread_mutex_lock(&shminfo->mutex)) != 0)
            exit_sys_errno("pthread_mutex_lock", result); 

        while (shminfo->count == QUEUE_SIZE)
            if ((result = pthread_cond_wait(&shminfo->cond_producer, &shminfo->mutex)) != 0)
                exit_sys_errno("pthread_cond_wait", result); 
        
        shminfo->queue[shminfo->tail++] = val;
        shminfo->tail %= QUEUE_SIZE;
        ++shminfo->count;
 
        if ((result = pthread_mutex_unlock(&shminfo->mutex)) != 0)
            exit_sys_errno("pthread_mutex_unlock", result); 

        if ((result = pthread_cond_signal(&shminfo->cond_consumer)) != 0)
            exit_sys_errno("pthread_cond_signal", result); 

        if (val == 99)
            break;
        ++val;
    }
    
     if ((result = pthread_mutex_lock(&shminfo->mutex)) != 0)
            exit_sys_errno("pthread_mutex_lock", result); 

    while (shminfo->count != 0 )
        if ((result = pthread_cond_wait(&shminfo->cond_producer, &shminfo->mutex)) != 0)
            exit_sys_errno("pthread_cond_wait", result); 
    
    if ((result = pthread_mutex_unlock(&shminfo->mutex)) != 0)
        exit_sys_errno("pthread_mutex_unlock", result); 


    if ((result = pthread_cond_destroy(&shminfo->cond_consumer)) != 0)
        exit_sys_errno("pthread_cond_destroy", result);   

    if ((result = pthread_cond_destroy(&shminfo->cond_producer)) != 0)
        exit_sys_errno("pthread_cond_destroy", result);   

    if ((result = pthread_mutex_destroy(&shminfo->mutex)) != 0)
        exit_sys_errno("pthread_mutex_destroy", result);

	if (munmap(shminfo, sizeof(SHARED_INFO)) == -1)
		exit_sys("munmap");

	close(fdshm);

	if (shm_unlink(SHM_NAME) == -1)
        exit_sys("shm_unlink");

    return 0;    
}

void exit_sys(const char *msg)
{
	perror(msg);

	exit(EXIT_FAILURE);
}

void exit_sys_errno(const char *msg, int eno)
{
    fprintf(stderr, "%s:%s\n", msg, strerror(eno));

    exit(EXIT_FAILURE);
}

/* consumer.c */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>
#include <fcntl.h>
#include <sys/stat.h>
#include <sys/mman.h>
#include <unistd.h>
#include <pthread.h>
#include "sharing.h"

void exit_sys(const char *msg);
void exit_sys_errno(const char *msg, int eno);

int main(void)
{
	int fdshm;
	SHARED_INFO *shminfo;
    int result;
    int val;

    srand(time(NULL));
		
	if ((fdshm = shm_open(SHM_NAME, O_RDWR, 0)) == -1)
		exit_sys("shm_open");   

	shminfo = (SHARED_INFO *)mmap(NULL, sizeof(SHARED_INFO), PROT_WRITE, MAP_SHARED, fdshm, 0);
	if (shminfo == MAP_FAILED) 
		exit_sys("mmap");

    for (;;) {
        if ((result = pthread_mutex_lock(&shminfo->mutex)) != 0)
            exit_sys_errno("pthread_mutex_lock", result); 

        while (shminfo->count == 0)
            if ((result = pthread_cond_wait(&shminfo->cond_consumer, &shminfo->mutex)) != 0)
                exit_sys_errno("pthread_cond_wait", result); 
        
        val = shminfo->queue[shminfo->head++];
        shminfo->head %= QUEUE_SIZE;
        --shminfo->count;

        printf("%d ", val);
        fflush(stdout);
 
        if ((result = pthread_mutex_unlock(&shminfo->mutex)) != 0)
            exit_sys_errno("pthread_mutex_unlock", result); 

        if ((result = pthread_cond_signal(&shminfo->cond_producer)) != 0)
            exit_sys_errno("pthread_cond_signal", result); 

        usleep(rand() % 300000);

        if (val == 99)
            break;
    }
    printf("\n");
    
    if ((result = pthread_cond_signal(&shminfo->cond_producer)) != 0)
            exit_sys_errno("pthread_cond_signal", result); 

	if (munmap(shminfo, sizeof(SHARED_INFO)) == -1)
		exit_sys("munmap");

	close(fdshm);
	
    return 0;    
}

void exit_sys(const char *msg)
{
	perror(msg);

	exit(EXIT_FAILURE);
}

void exit_sys_errno(const char *msg, int eno)
{
    fprintf(stderr, "%s:%s\n", msg, strerror(eno));

    exit(EXIT_FAILURE);
}

/*--------------------------------------------------------------------------------------------------------------------------
    Semaphore'lar (semaphores) en çok kullanılan senkronizasyon nesnelerindendir. Pek çok işletim sisteminde semaphore nesneleri 
    benzer işlevselliklerle bulunmaktadır. UNIX/Linux sismtemlerinde semapore'lar IPC konusuyla ilişkilendirilmiştir. Bu nedenle 
    tıpkı paylaşılan bellek alanlarında ve mesaj kuyruklarında olduğu gibi semaphore'lar için de iki ayrı arayüz fonksiyon grubu
    bulunmaktadır. Ancak System 5 semaphore'ları maalesef oldukça karışık ve körü bir arayüzle tasarlanmıştır. POSIX semaphore'larında
    bu tasarımn düzeltilmiştir. Biz kursumuzda IPC nesnelerini önce System 5 sonra POSIX olacak biçimde açıklamıştık. Ancak burada bunun tersini 
    yapacağız. Yani önce POSIX semaphore'larını açıklayıp sonra System 5 semaphore'ları üzerinde durcağız. Uygulamada özel bir 
    gerekçe yoksa POSIX semaphore'ları tercih edilmelidir. 

    Semaphore'lar "sayaçlı" senkronizasyon nesneleridir. Semaphore sözcüğü "trafikteki dur-geç lambalarından" gelmektedir. 
    (Bu sözcüğü "anafor" sözcüğü ile karıştırmayınız.) Samepore'lar bir kritik koda en fazla n tane akışın girmesini sağlamak 
    için düşünülmüştür. Örneğin biz bir kritik koda en fazla 3 thread'in girmesini ancak daha fazla thread'in girmemesini isteyebiliriz. 
    Bu durumda ğç thread kritik koda girdikten sonra diğer thread'ler kritik koda giremeyecek ve blokede bekleyecektir. Kritik 
    koda girmiş olan bir thread kritik koddan çıktığından bekleyen bir thread kritik koda girebilecektir. Bu örnekte önemli olan aynı anda 
    üçten daha fazla thread'in aynı anda kritik koda girmemesinin bloke yoluyla sağlanmasıdır. Kritik koda birden fazla thread'in
    girmesi kişilere anlamsız gelebilmektedir. Çünkü iki thread bile ortak kaynağı bozabilir. O halde kritik koda n tane thread'in 
    girmesinin ne anlamı olabilir? İşte bunun en önemli kullanım gerekçesi "kaynak paylaşımının" sağlanmsıdır. Örneğin elimizde 
    üç tane makine olsun. Ancak 10 tane thread bu makineleri kullanmak istesin. Bizim bu üç makineyi yalnızca üç thread'e 
    tahsis etmemiz gerekir. Makineyi kullanmak isteyen diğer thread'ler bu makinelerden biri boşaltılana kadar CPU zamanı harcamadan 
    blokede bekletilmelidir. İşte burada tipik bir semaphore kullanımı söz konusudur. Örneğin:

    <kritik kodun başı>
    ....
    ....
    ....            <KRİTİK KODDA MAKİNE ATAMASI YAPILIYOR>
    ....
    ....
    <kritik kodun sonu>

    Kritik koda en fazla kaç akışın girebileceği "semaphore sayacı" ile ilgilidir. Eğer semapore sayacı 1'de tutulursa kritik koda 
    en fazla bir akış girebilir. Bu tür semaphore'lara "binary semaphore" denilmektedir. Binary semaphore'lar adeta mutex nesneleri 
    gibi bir etkiye sahiptir. Yani bu anlamda binary semaphore'lar bir mutex alternatifi olarak da kullanılabilirler. Ancak mutex
    nesnelerinin thread temelinde shipliği vardır. Yani mutex'in sahipliğini hangi thread almışsa onun bırakması gerekir. Halbuki 
    semaphore nesnelerinde böyle bir zorunluluk yoktur. Bu nedendne dolayı bazı kesimler tarafından semaphore nesneleri hataya daha 
    açık bir nesneler olarak değerlendirilebimektedir. 
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
                                            58.Ders 10/06/2023 - Cumartesi
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    POSIX semaphore nesneleri isimli ve isimsiz olarak yaratılabilmektedir. İsimli semaphore nesneleri proseslerarası kullanım
    için daha uygundur. İsimsiz semaphore nesneleri -her ne kadar proseslerarasında da kullanılabiliyorsa da- özellikle prosesin thread'leri 
    arasındaki senkronizasyonda tercih edilmektedir. 
    
    İsimsiz POSIX semaphore nesnelerinin kullanımı şöyledir:

    1) Semapahore nesneleri sem_t türü ile temsil edilmiştir. POSIX standartlarına göre sem_t herhangi bir tür olarak typedef edilebilmektedir. 
    UNIX türevi sistemlerde tipik olarak sem_t bir yapı biçiminde typedef edilmektedir. Programcı bu türden global bir nesne tanımlar ve
    ona sem_init fonksiyonuyla ilkdeğer verir. sem_init fonksiyonunun prototipi şöyledir:

    #include <semaphore.h>

    int sem_init(sem_t *sem, int pshared, unsigned value);  

    Fonksiyonun birinci parametresi sem_t türünden nesnesinin adresini alır. İkinci parametre semaphore nesnesinin prosesler arasında paylaşılıp 
    paylaşılmayacağını belirtir. Burada 0 değeri nesnenin prosesler arasında paylaşılmayacağını, sıfır dışı değer ise nesnenin prosesler arasında
    paylaşılacağını belirtmektedir. Üçüncü parametre başlangıçtaki semaphore sayacının değerini belirtir. Yani bu değer kritik koda en fazlası
    kaç akışın girebileceğini belirtmektedir. Fonksiyon başarı durumunda 0 değerine, başarısızlık durumunda -1 değerine geri döner ve errno 
    değişkeni uygun biçimde set edilir. (Thread fonksiyonlarının bizzat başarısızlık durumunda errno değeriyle geri döndüğünü anımsayınız. 
    Halbuki POSIX semaphore fonksiyonları doğrudan errno değişkenini set etmektedir.)

    Örneğin:

    sem_t g_sem;
    ...

    if (sem_init(&g_sem, 0, 3) == -1)
        exit_sys("sem_init");

    2) Kritik kod aşağıdaki gibi oluşturulabilir (kontroller yapılmamıştır):

    sem_wait(&g_sem);
    ....
    ....        <KRİTİK KOD>
    ....
    sem_post(&g_sem);

    sem_wait fonksiyonu semaphore sayacına bakar. Semaphore sayacı o'dan büyükse bloke oluşturmaz. Böylece thread kritik koda girer. 
    Ancak sem_wait fonksiyonu semaphore sayacı 0'dan büyükse atomik bir biçimde semaphore sayacını 1 eksiltmektedir. Örneğin 
    başlangıçtaki semaphore sayacı 3 olsun. Bu durumda thread'lerdne biri sem_wait fonksiyonundan geçtiğinde semaphore sayacı 2 olur. 
    Diğer bir thread de geçtiğinde semaphore sayacı 1 olacaktır. Nihayet bir thread daha sem_wait fonksiyonundan geçtiğinde semaphore
    sayacı 0 olur. Artık krikik kodda 3 tane thread vardır. Başka thread'ler sem_wait fonksiyonuna geldiğinde semaphore sayacı 0 olduğu 
    için bloke olurlar ve kritik koda giremezler. İşte sem_post fonksiyonu da semaphore sayacını 1 artırmaktadır. Böylece kritik koddan 
    çıkıldığında semaphore sayacı 1 artırılmış olur. sem_wait fonksiyonunda bekleyen thread'lerden biri artık semapore sayacı 0'dan 
    büyük olduğu için kritik koda girer. Görüldüğü gibi kritik kodda bellei bir anda en fazla 3 thread bulunabilmektedir. Yukarıda da
    belirttiğimiz gibi aslında semaphore'lar belli sayıda kaynağın thread'lere paylaştırılması için kullanılmaktadır. Örneğin elimizde 
    3 tane makine olabilir. Biz bu üç makineyi 10 thread'in kullanmasını isteyebiliriz. Ancak makine atamadığımız thread'lerin CPU 
    zamanı harcamadan bloke durumda bekletilmesi gerekmektedir. O halde biz ktirik kod her giren thread'e bir makine atarız. 
    Tıpkı mutex nesnelerind eolduğu gibi sem_wait fonksiyonunda birden fazla thread'in beklemesi durumunda bu thread'lerin hangisinin 
    kritik koda gireceği konusunda bir garanti verilmemektedir. İşletim sistemleri belirli koşullarda adil bir sistem uygulamaya çalışsa da 
    bunun bir gaarantisini vermemektedir. 

    Böylece üç makineyi 10 thread'in etkin bir biçimde kullanmasını sağlarız. sem_wait ve sem_post fonksiyonlarının prototipleri şöyledir:

    #include <semaphore.h>

    int sem_wait(sem_t *sem);
    int sem_post(sem_t *sem);

    Fonksiyonlar semaphore nesnesinin adresini parametre olarak alırlar. Başarı durumunda 0 değerine başarısızlık durumunda -1 
    değerine geri dönerler ve errno değişkeni uygun biçimde set edilir. 

    sem_wait fonksiyonunun ayrıca bir de sem_timedwait isimli zaman aşımlı bir biçimi de vardır. Bu zaman aşımlı biçim eğer 
    semaphore'da bloke olunmuşsa zaman aşımı dolduğunda blokeyi çzömektedir. sem_timedwait fonksiyonunun prototipi şöyledir:

    #include <semaphore.h>

    int sem_timedwait(sem_t *sem, const struct timespec *abstime);

    Ancak buradaki zaman aşımı yine göreli değil mutlak zamanı belirtmektedir. Fonksiyon eğer zaman aşımından dolayı başarısız olursa 
    -1 değerine geri döner ve errno değişkeni ETIMEDOUT değeri ile set edilmektedir. 

    3) Semaphore kullanımı bittikten sonra semaphore nesnesi sem_destroy fonksiyonu ile boşaltılmalıdır. Fonksiyonun prototipi 
    şöyledir:

    #include <semaphore.h>

    int sem_destroy(sem_t *sem);

    Fonksiyon semaphore nesnesinin adresini parametre olarak alır. Başarısı durumunda 0, başarısızlık durumunda - 1 değerine 
    geri döner ve errno değişkeni uygun biçimde set edilir. 
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Aşağıda basit bir binary semaphore örneği verilmiştir. Bu örnekte yine iki thread tıpkı mutex örneğinde olduğu gibi bir 
    semaphore eşliğinde global bir değişkeni artırmaktadır. 
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <pthread.h>
#include <unistd.h>
#include <semaphore.h>

void *thread_proc1(void *param);
void *thread_proc2(void *param);
void exit_sys(const char *msg);
void exit_sys_errno(const char *msg, int eno);

sem_t g_sem;
int g_count = 0;

int main(void)
{
    pthread_t tid1, tid2;
    int result;

    if ((sem_init(&g_sem, 0, 1)) == -1)
        exit_sys("sem_init");

    if ((result = pthread_create(&tid1, NULL, thread_proc1, NULL)) != 0)
        exit_sys_errno("pthread_create", result);

    if ((result = pthread_create(&tid2, NULL, thread_proc2, NULL)) != 0)
        exit_sys_errno("pthread_create", result);

    if ((result = pthread_join(tid1, NULL)) != 0)
        exit_sys_errno("pthread_join", result);

    if ((result = pthread_join(tid2, NULL)) != 0)
        exit_sys_errno("pthread_join", result);

    if (sem_destroy(&g_sem) == -1)
        exit_sys("sem_destroy");

    printf("%d\n", g_count);
  
    return 0;
}

void *thread_proc1(void *param)
{
    for (int i = 0; i < 1000000; ++i) {
        if (sem_wait(&g_sem) == -1)
            exit_sys("sem_wait");

        ++g_count;

        if (sem_post(&g_sem) == -1)
            exit_sys("sem_wait");
    }
   
    return NULL;
}

void *thread_proc2(void *param)
{
    for (int i = 0; i < 1000000; ++i) {
        if (sem_wait(&g_sem) == -1)
            exit_sys("sem_wait");

        ++g_count;

        if (sem_post(&g_sem) == -1)
            exit_sys("sem_wait");
    }
   
    return NULL;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

void exit_sys_errno(const char *msg, int eno)
{
    fprintf(stderr, "%s:%s\n", msg, strerror(eno));

    exit(EXIT_FAILURE);
}
  
/*--------------------------------------------------------------------------------------------------------------------------
    Pakiyi mademki binary semaphore'lar mutex'e çok benzemektedir. Biz hangisini tercih etmeliyiz? İşte mutex'in sahipliği 
    thread temelinde alındığı için mutex genel olarak binary semaphore'larq göre daha güvenlidir. Ayrıca genel olarak işletim sistemlerinde 
    mutex işlemleri semaphore işlemlerine göre daha hızlı olma eğilimindedir. Yani eğer bir senkronizasyon işlemini mutex kullanarak 
    da binary semahore kullanarak da yapabiliyorsak mutex'i tercih etmeliyiz. 
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Aşağıdaki örnekte belli sayıda kaynak (örneğimizde 3) belli sayıda thread tarafından (örneğimizde 10) paylaşılmaktadır. 
    Örnekte semaphore kontrolü ile kritik kod oluşturulmuş ve kritik koda her giren thread'e bir kaynak atanmıştır. Bu örnekten 
    amaç böyle bir durumun  simülasyonunun yapılmasıdır. Bu örnekte kaynağı elde edemeyen thread'ler blokede bekletilmektedir. 
    Bir thread'in kaynak kullanımı bittiğinde artık kritik koda yeni bir thread girmekte ve o kaynak o thread'e atanmaktadır. 
    Örneğimizde bir semaphore nesnesinin yanı sıra bir de mutex nesnesi kullanılmtır. B mutex nesnesi kaynak ataması sırasında
    oluşabilecek senkronizasyon problemini (race condition) engellemektedir. 
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>
#include <pthread.h>
#include <unistd.h>
#include <semaphore.h>

#define NTHREADS        10
#define NRESOURCES      3

typedef struct tagRESOURCES {
    int useflags[NRESOURCES];
    sem_t sem;
    pthread_mutex_t mutex;
} RESOURCES;

typedef struct tagTHREAD_INFO {
    pthread_t tid;
    char name[32];
    unsigned seed;
} THREAD_INFO;

void assign_resource(THREAD_INFO *ti);
void do_with_resource(THREAD_INFO *ti, int nresource);
void *thread_proc(void *param);
void exit_sys(const char *msg);
void exit_sys_errno(const char *msg, int eno);

RESOURCES g_resources;

int main(void)
{
    int result;
    THREAD_INFO *threads_info[NTHREADS];

    srand(time(NULL));

    for (int i = 0; i < NRESOURCES; ++i) 
        g_resources.useflags[i] = 0;
        
    if ((sem_init(&g_resources.sem, 0, NRESOURCES)) == -1)
        exit_sys("sem_init");
    if ((result = pthread_mutex_init(&g_resources.mutex, NULL)) != 0)
        exit_sys_errno("pthread_mutex_init", result);

    for (int i = 0; i < NTHREADS; ++i) {
        if ((threads_info[i] = (THREAD_INFO *)malloc(sizeof(THREAD_INFO))) == NULL) {
            fprintf(stderr, "cannot allocate memory!..\n");
            exit(EXIT_FAILURE);
        }
        snprintf(threads_info[i]->name, 32, "Thread-%d", i + 1);
        threads_info[i]->seed = rand();
        if ((result = pthread_create(&threads_info[i]->tid, NULL, thread_proc, threads_info[i])) != 0)
            exit_sys_errno("pthread_create", result);
    }

    for (int i = 0; i < NTHREADS; ++i) {
        if ((result = pthread_join(threads_info[i]->tid, NULL)) != 0)
            exit_sys_errno("pthread_join", result);
        free(threads_info[i]);
    }

    if ((result = pthread_mutex_destroy(&g_resources.mutex)) != 0)
         exit_sys_errno("pthread_mutex_destroy", result);

    if (sem_destroy(&g_resources.sem) == -1)
        exit_sys("sem_destroy");
  
    return 0;
}

void assign_resource(THREAD_INFO *ti)
{
    int result;
    int i;  

    if (sem_wait(&g_resources.sem) == -1)
        exit_sys("sem_wait");

    if ((result = pthread_mutex_lock(&g_resources.mutex)) != 0)
        exit_sys_errno("pthread_mutex_lock", result);

    for (i = 0; i < NRESOURCES; ++i)
        if (!g_resources.useflags[i]) {
            g_resources.useflags[i] = 1;
            break;
        }

    if ((result = pthread_mutex_unlock(&g_resources.mutex)) != 0)
        exit_sys_errno("pthread_mutex_unlock", result);

    printf("%s thread acquired resource \"%d\"\n", ti->name, i + 1);
    
    do_with_resource(ti, i + 1);

    usleep(rand_r(&ti->seed) % 500000);

    if ((result = pthread_mutex_lock(&g_resources.mutex)) != 0)
        exit_sys_errno("pthread_mutex_lock", result);

    g_resources.useflags[i] = 0;

    if ((result = pthread_mutex_unlock(&g_resources.mutex)) != 0)
        exit_sys_errno("pthread_mutex_unlock", result);

    printf("%s thread released resource \"%d\"\n", ti->name, i + 1);

    if (sem_post(&g_resources.sem) == -1)
        exit_sys("sem_wait");

    usleep(rand_r(&ti->seed) % 10000);
}

void do_with_resource(THREAD_INFO *ti, int nresource)
{
    printf("%s doing something with resource \"%d\"\n", ti->name, nresource);
}

void *thread_proc(void *param)
{
    THREAD_INFO *ti = (THREAD_INFO *)param;

    for (int i = 0; i < 10; ++i)
        assign_resource(ti);
    
    return NULL;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

void exit_sys_errno(const char *msg, int eno)
{
    fprintf(stderr, "%s:%s\n", msg, strerror(eno));

    exit(EXIT_FAILURE);
}

/*--------------------------------------------------------------------------------------------------------------------------
    Biz daha önce üretici-tüketici problemini koşul değişkenleri ile çözmüştük. Aynı problemi semaphore nesneleriyle da daha 
    kolay bir biçimde çözebiliriz. Yine tahteravalli sistemi burada geçerlidir. Semaphore sayaçlarının başka bir thread tarafından
    sem_post fonksiyonu ile artırılabildiğini anımsayınız. Yani sem_post uygulayabilmek için sem_wait yapmış olmak gerekmemektedir. 
    Tipik çözüm şöyledir: Yine üretici ve tüketici için iki semaphore alınır. Semaphore sayaçları paylaşılan alanın uzunluğuna ayarlanır. 
    Biz ortadaki paylaşılan alanın 1 elemanlık olduğunu varsayalım (kontroller yapılmamıştır):

    sem_t g_sem_producer;
    sem_t g_sem_consumer;
    ...
    sem_init(&g_sem_producer, 0, 1);
    sem_init(&g_sem_consumer, 0, 0);

    Başlangıçta üretici semaphore'un sayacının 1 olduğuna tüketici semaphore'un sayacının 0 olduğuna dikkat ediniz. Böylelikle 
    işin başında tüketici bekleyecek ancak üretici beklemeyecektir.

    ÜRETİCİ THREAD

    for (;;) {
        <değer elde ediliyor>
        sem_wait(&g_sem_producer);
        <değer paylaşan alana yerleştiriliyor>
        sem_post(&g_sem_consumer);
    }

    TÜKETİCİ THREAD

    for (;;) {
        sem_wait(&g_sem_consumer);
        <paylaşılan bellek alanından bilgiyi alınyor>
        sem_post(&g_sem_producer);
        <alınan bilgi işleniyor>
    }

---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
                                            59.Ders 11/06/2023 - Pazar
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Aşağıda üretici-tüketici probleminin kuyruksuz versiyonu semaphore nesneleri ile çözülmüştür. Burada üretici semaphore'unun
    bşlangıçta 1'e tüketici semaphore'unun da 0'a kurulduğuna dikkat ediniz. Üretici tüketiciyi tüketici de üreticiyi tahteravalli
    misali blokeden kurtarmaktadır. 
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>
#include <pthread.h>
#include <unistd.h>
#include <semaphore.h>

void *thread_producer(void *param);
void *thread_consumer(void *param);

void exit_sys(const char *msg);
void exit_sys_errno(const char *msg, int eno);

sem_t g_sem_producer;
sem_t g_sem_consumer;

int g_shared;

int main(void)
{
    pthread_t tid1, tid2;
    int result;

    if (sem_init(&g_sem_producer, 0, 1) == -1)
        exit_sys("sem_init");
    
    if (sem_init(&g_sem_consumer, 0, 0) == -1)
        exit_sys("sem_init");
    
    if ((result = pthread_create(&tid1, NULL, thread_producer, NULL)) != 0)
        exit_sys_errno("pthread_create", result);

    if ((result = pthread_create(&tid2, NULL, thread_consumer, NULL)) != 0)
        exit_sys_errno("pthread_create", result);

    if ((result = pthread_join(tid1, NULL)) != 0)
        exit_sys_errno("pthread_join", result);

    if ((result = pthread_join(tid2, NULL)) != 0)
        exit_sys_errno("pthread_join", result);

    if (sem_destroy(&g_sem_consumer) == -1)
        exit_sys("sem_destroy");

    if (sem_destroy(&g_sem_producer) == -1)
        exit_sys("sem_destroy");
  
    return 0;
}

void *thread_producer(void *param)
{
    int val;
    unsigned seed;

    seed = time(NULL) + 123;

    val = 0;
    for (;;) {
        usleep(rand_r(&seed) % 300000);
        
        if (sem_wait(&g_sem_producer) == -1)
            exit_sys("sem_wait");

        g_shared = val;

        if (sem_post(&g_sem_consumer) == -1)
            exit_sys("sem_wait");

        if (val == 99)
            break;
        ++val;
    }

    return NULL;
}

void *thread_consumer(void *param)
{
    int val;
    unsigned seed;

    seed = time(NULL) + 456;

    for (;;) {
        if (sem_wait(&g_sem_consumer) == -1)
            exit_sys("sem_wait");
        
        val = g_shared;

        if (sem_post(&g_sem_producer) == -1)
            exit_sys("sem_wait");   

        usleep(rand_r(&seed) % 300000);
        printf("%d ", val);
        fflush(stdout);
        if (val == 99)
            break;
    }
    printf("\n");

    return NULL;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

void exit_sys_errno(const char *msg, int eno)
{
    fprintf(stderr, "%s:%s\n", msg, strerror(eno));

    exit(EXIT_FAILURE);
}

/*--------------------------------------------------------------------------------------------------------------------------
    Üretici tüketici probleminin kuyruklu versiyonu da tamamen benzer biçimde semaphore nesneleriyle çözülebilmektedir. 
    Ancak bu durumda üretici semaphore'unun başlangıçta kuyruk uzunlupğuna kurulması gerekmektedir. Böylece türketici hiç çalışmadığında
    üretici kuyruğu doldurur ve bekler. Benzer biçimde üretici çalışmadığı durumda tüketici kuyruktaki tüm elemanları alır ve bekler. 
    Örneğin:

    sem_t g_sem_producer;
    sem_t g_sem_consumer;
    ...

    sem_init(&g_sem_producer, 0, QUEUE_SIZE);
    sem_init(&g_sem_consumer, 0, 0);

---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Aşağıda üretici-tüketici probleminin kuyruklu biçimi için bir veri yapısı oluşturulmuştur. Bu veri yapısı önce init_squeue
    fonksiyonu ile yaratılır. Sonra put_squeue ve get_squeue fonksiyonları ile bu kuyrul veri yapısına eleman eklenip alınır. 
    Kullanım bittikten sonra kuyruk veri yapısı destroy_squeu fonksiyonu ile boşaltılmalıdır. 

    Programın testi için derlemeyi şöyle yapabilirsiniz:

    gcc -o sample sample.c syncqueue.c
---------------------------------------------------------------------------------------------------------------------------*/

/* syncquque.h */

#ifndef SYNCQUEUE_H_
#define SYNCQUEUE_H_

#include <stddef.h>
#include <semaphore.h>

/* Type Declarations */

typedef int DATATYPE;

typedef struct tagSYNC_QUEUE {
    DATATYPE *queue;
    size_t size; 
    size_t head;
    size_t tail;
    sem_t sem_producer;
    sem_t sem_consumer;
} SYNC_QUEUE;

/* Function Prototypes */

SYNC_QUEUE *init_squeue(size_t size);
int put_squeue(SYNC_QUEUE *sd, DATATYPE val);
int get_squeue(SYNC_QUEUE *sd, DATATYPE *val);
int destroy_squeue(SYNC_QUEUE *sq);

#endif

/* syncqueue.c */

#include <stdio.h>
#include <stdlib.h>
#include "syncqueue.h"

/* Function Definitions */

SYNC_QUEUE *init_squeue(size_t size)
{
    SYNC_QUEUE *sq;

    if ((sq = (SYNC_QUEUE *)malloc(sizeof(SYNC_QUEUE))) == NULL)
        goto FAILED1;

    if ((sq->queue = (DATATYPE *)malloc(sizeof(DATATYPE) * size)) == NULL) 
        goto FAILED2;
   
    sq->size = size;
    sq->head = sq->tail = 0;
    
    if (sem_init(&sq->sem_producer, 0, size) == -1)
        goto FAILED3;
    
    if (sem_init(&sq->sem_consumer, 0, 0) == -1)
        goto FAILED3;

    return sq;

FAILED3:
    free(sq->queue);
FAILED2:
    free(sq);
FAILED1:

    return NULL;   
}

int put_squeue(SYNC_QUEUE *sq, DATATYPE val)
{
    if (sem_wait(&sq->sem_producer) == -1)
        return -1;
    sq->queue[sq->tail++] = val;
    sq->tail %= sq->size;
    if (sem_post(&sq->sem_consumer) == -1)
        return -1;

    return 0;
}

int get_squeue(SYNC_QUEUE *sq, DATATYPE *val)
{
    if (sem_wait(&sq->sem_consumer) == -1)
        return -1;
    *val = sq->queue[sq->head++];
    sq->head %= sq->size;
    if (sem_post(&sq->sem_producer) == -1)
        return -1;

    return 0;
}

int destroy_squeue(SYNC_QUEUE *sq)
{
    if (sem_destroy(&sq->sem_producer) == -1)
        return -1;

    if (sem_destroy(&sq->sem_consumer) == -1)
        return -1;
    
    free(sq->queue);
    free(sq);

    return 0;
}

/* sample.c */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>
#include <pthread.h>
#include <unistd.h>
#include "syncqueue.h"

void *thread_producer(void *param);
void *thread_consumer(void *param);
void exit_sys(const char *msg);
void exit_sys_errno(const char *msg, int eno);

int main(void)
{
    pthread_t tid1, tid2;
    int result;
    SYNC_QUEUE *sd;

    if ((sd = init_squeue(10)) == NULL) 
        exit_sys("init_squeue");

    if ((result = pthread_create(&tid1, NULL, thread_producer, sd)) != 0)
        exit_sys_errno("pthread_create", result);

    if ((result = pthread_create(&tid2, NULL, thread_consumer, sd)) != 0)
        exit_sys_errno("pthread_create", result);

    if ((result = pthread_join(tid1, NULL)) != 0)
        exit_sys_errno("pthread_join", result);

    if ((result = pthread_join(tid2, NULL)) != 0)
        exit_sys_errno("pthread_join", result);

    if (destroy_squeue(sd) == -1)
        exit_sys("destroy_squeue");
  
    return 0;
}

void *thread_producer(void *param)
{
    SYNC_QUEUE *sd = (SYNC_QUEUE *)param;
    int val;
    unsigned seed;

    seed = time(NULL) + 123;

    val = 0;
    for (;;) {
        usleep(rand_r(&seed) % 300000);

        if (put_squeue(sd, val) == -1)
            exit_sys("put_squeue");
        
        if (val == 99)
            break;
        ++val;
    }

    return NULL;
}

void *thread_consumer(void *param)
{
    SYNC_QUEUE *sd = (SYNC_QUEUE *)param;
    int val;
    unsigned seed;

    seed = time(NULL) + 456;

    for (;;) {
        if (get_squeue(sd, &val) == -1)
            exit_sys("get_squeue");

        usleep(rand_r(&seed) % 300000);
        printf("%d ", val);
        fflush(stdout);
        if (val == 99)
            break;
    }
    printf("\n");

    return NULL;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

void exit_sys_errno(const char *msg, int eno)
{
    fprintf(stderr, "%s:%s\n", msg, strerror(eno));

    exit(EXIT_FAILURE);
}

/*--------------------------------------------------------------------------------------------------------------------------
    İsimsiz semaphore nesneleri de yine istenirse sem_init fonksiyonunda pshared parametresi sıfır dışı yapılarak ve paylaşılan 
    bellek alanında oluşturularak prosesler arasında kullanılabilir. Ancak prosesler arasında kullanım için isimli semapore nesneleri 
    genellikle daha uygundur. 

    Aşağıda iki proses arasında isimsiz semaphore nesneleri ile üretici tüketici problemi uygulanmıştır. Burada önce "producer"
    programını çalıştırınız. Derleme işlemlerini aşağıdaki gibi yapabilirsiniz:

    gcc -o producer producer.c
    gcc -o consumer consumer.c
---------------------------------------------------------------------------------------------------------------------------*/

/* sharing.h */

#ifndef SHARING_H_
#define SHARING_H_

#include <semaphore.h>
#include <sys/types.h>

#define SHM_NAME        "/producer-consumer"
#define QUEUE_SIZE      10

typedef struct tagSHARED_INFO {
    sem_t sem_producer;
    sem_t sem_consumer;
    int head;
    int tail;
    int queue[QUEUE_SIZE];
} SHARED_INFO;

#endif

/* producer.c */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>
#include <fcntl.h>
#include <sys/stat.h>
#include <sys/mman.h>
#include <unistd.h>
#include "sharing.h"

void exit_sys(const char *msg);
void exit_sys_errno(const char *msg, int eno);

int main(void)
{
	int fdshm;
	SHARED_INFO *shminfo;
    int val;

    srand(time(NULL));

	if ((fdshm = shm_open(SHM_NAME, O_RDWR|O_CREAT, S_IRUSR|S_IWUSR|S_IRGRP|S_IROTH)) == -1)
		exit_sys("shm_open");   

	if (ftruncate(fdshm, sizeof(SHARED_INFO)) == -1)
		exit_sys("ftruncate");

	shminfo = (SHARED_INFO *)mmap(NULL, sizeof(SHARED_INFO), PROT_WRITE, MAP_SHARED, fdshm, 0);
	if (shminfo == MAP_FAILED) 
		exit_sys("mmap");

    if ((sem_init(&shminfo->sem_producer, 1, QUEUE_SIZE)) == -1)
        exit_sys("sem_init");

    if ((sem_init(&shminfo->sem_consumer, 1, 0)) == -1)
        exit_sys("sem_init");

    shminfo->head = 0;
    shminfo->tail = 0;

    val = 0;
    for (;;) {
        usleep(rand() % 300000);

        if (sem_wait(&shminfo->sem_producer) == -1)
            exit_sys("sem_wait");

        shminfo->queue[shminfo->tail++] = val;
        shminfo->tail %= QUEUE_SIZE;

        if (sem_post(&shminfo->sem_consumer) == -1)
            exit_sys("sem_post");       
 
        
        if (val == 99)
            break;
        ++val;
    }

    if (sem_destroy(&shminfo->sem_consumer) == -1)
        exit_sys("sem_destroy");

    if (sem_destroy(&shminfo->sem_producer) == -1)
        exit_sys("sem_destroy");


	if (munmap(shminfo, sizeof(SHARED_INFO)) == -1)
		exit_sys("munmap");

	close(fdshm);

	if (shm_unlink(SHM_NAME) == -1)
        exit_sys("shm_unlink");

    return 0;    
}

void exit_sys(const char *msg)
{
	perror(msg);

	exit(EXIT_FAILURE);
}

void exit_sys_errno(const char *msg, int eno)
{
    fprintf(stderr, "%s:%s\n", msg, strerror(eno));

    exit(EXIT_FAILURE);
}

/* consumer.c*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>
#include <fcntl.h>
#include <sys/stat.h>
#include <sys/mman.h>
#include <unistd.h>
#include "sharing.h"

void exit_sys(const char *msg);
void exit_sys_errno(const char *msg, int eno);

int main(void)
{
	int fdshm;
	SHARED_INFO *shminfo;
    int val;

    srand(time(NULL));
		
	if ((fdshm = shm_open(SHM_NAME, O_RDWR, 0)) == -1)
		exit_sys("shm_open");   

	shminfo = (SHARED_INFO *)mmap(NULL, sizeof(SHARED_INFO), PROT_WRITE, MAP_SHARED, fdshm, 0);
	if (shminfo == MAP_FAILED) 
		exit_sys("mmap");

    for (;;) {
        if (sem_wait(&shminfo->sem_consumer) == -1)
            exit_sys("sem_wait");

        val = shminfo->queue[shminfo->head++];
        shminfo->head %= QUEUE_SIZE;

        if (sem_post(&shminfo->sem_producer) == -1)
            exit_sys("sem_post");


        printf("%d ", val);
        fflush(stdout);
 
        usleep(rand() % 300000);

        if (val == 99)
            break;
    }
    printf("\n");

	if (munmap(shminfo, sizeof(SHARED_INFO)) == -1)
		exit_sys("munmap");

	close(fdshm);
	
    return 0;    
}

void exit_sys(const char *msg)
{
	perror(msg);

	exit(EXIT_FAILURE);
}

void exit_sys_errno(const char *msg, int eno)
{
    fprintf(stderr, "%s:%s\n", msg, strerror(eno));

    exit(EXIT_FAILURE);
}

/*--------------------------------------------------------------------------------------------------------------------------
    İsimli POSIX semaphore nesneleri daha önce görmüş olduğumuz POSIX paylaşılan bellek alanı ve POSIX mesaj kuyruklarına benzer 
    biçimde kullanılmaktadır. Kullanım adımları şöyledir:

    1) İsimli POSIX semaphore nesneleri sem_open fonksiyonu ile yaratılır ya da zaten var olan nesne açılır. Fonksiyonun prototipi 
    şöyledir:

    #include <semaphore.h>

    sem_t *sem_open(const char *name, int oflag, ...);

    Fonksiyonun birinci parametresi prosesler arasınd akullanım için gereken ismi belirtmektedir. Bu isim yine diğer POSIX IPC nesnelerinde
    olduğu gibi kök dizinde bir isim olmalıdır. İkinci parametre açış modunu belirtir. Burada eğer O_CREAT kullanılırsa nesne yoksa yaratılır, 
    varsa olan açılır. O_CREAT ile O_EXCL birlikte kullanılabilir. Bu durumda nesne zaten varsa fonksiyon başarısız olmaktadır. 
    Burada açış modunda O_RDONLY, O_WRONLY ya da O_RDWR gibi bayrakla rkullanılmaz. Başka bir deyişle isimli semaphore nesnelerinfrn 
    okuma yapmak ya da onlara yazmak yapmak biçiminde işlemler tanımlı değildir. Eğer zaten var olan bir semaphore nesnesi açılacaksa 
    bu ikinci parametre 0 geçilebilir. Eğer semaphore nesnesinin yaratılması söz konusu ise sem_open fonksiyonuna iki argüman 
    daha girilmeldir. Bu durumda üçüncü parametre nesnenin erişim haklarını dördüncü parametre ise semaphore sayacının başlangıçtaki 
    değerini belirtmektedir. Yani bu durumda adreta fonksiyonun prototipi aşağıdkai gibi olmaktadır:

    sem_t *sem_open(const char *name, int oflag, mode_t mode, unsigned int value);

    Semaphore nesneleri için "okuma ve yazma" eylemlerinin tanımsız olduğunu belirtmiştik. Bu nedenle POSIX standartları da nesnenin 
    erişim haklarının hangi durumda eirşime izin vereceği yönünde bir açıklama yapmamıştır. Linux sistemlerinde isimli semaphore nesnesi 
    yaratılırken bir prosesin bu nesneye erişmesi isteniyorsa erişim haklarında hem read hem de write bulunyor olmalıdır. Yani erişim işlemi sanki 
    "read/write" düzeyde (O_RDWR) yapılan bir işlem gibi kontrole girmektedir. Ancak buradaki erişim hakkı diğer dosya yaratan fonksiyonlarda 
    olduğu gibi prosesin umask değerinden etkilenmektedir. 

    Fonksiyon başarı durumunda kendi yarttığı semaphore nesnesinin adresine balarısızlık durumunda SEM_FAILED özel değerine geri 
    dönmer. errno değişkeni uygun biçimde set edilmektedir. Örneğin:

    sem_t *sem;
    ...

    if ((sem = sem_open("/my-test-semaphore", O_CREAT, S_IRUSR|S_IWUSR, 1)) == SEM_FAILED)
       exit_sys("sem_open");

    2) Artık kritk kod yine isimsiz semaphore nesnelerinde olduğu gibi sem_wait ve sem_post fonksiyonlarıyla oluşturulabilir. 
    Örneğin (kontroller uygulanmamıştır):

    sem_wait(sem);
    ...
    ...         <KRTİK KOD>
    ...
    sem_post(sem);

    3) Semaphore nesnesinin kullanımı bittikten sonra nesne sem_close fonksiyonu ile (sem_destroy fonksiyonu ile değil) boşaltılmaldır
    Örneğin:

    sem_close(sem);

    Fonksiyonun prototipi şöyledir:

    #include <semaphore.h>

    int sem_close(sem_t *sem);

    Fonksiyon semaphore nesnesinin adresini alır ve nesneyi kapatır. Başarı durumunda 0 değerine başarısızlık durumunda -1 değerine 
    geri dönmektedir. errno değişkeni uygun biçimde set edilmektedir. 

    4) Nihayet isimli semaphore nesnesi sem_unlink fonksiyonu ile yok edilebilir. Eğer nesne yok edilmezse "kernel persistant" 
    bir biçimde sistem reboot edilene kadar kalmaya deva eder. sem_unlik fonksiyonun prototipi şöyledir:

    #include <semaphore.h>

    int sem_unlink(const char *name);

    Fonksiyon semapore nesnesinin isamini parametre olarak alır. Başarı durumunda 0 değerine başarısızlık durumunda -1 değerine 
    geri döner. errno değişkeni uygun biçimde set edilmektedir. 

    Linux'ta isimli POSIX semaphore nesneleri de tıpkı POSIX paylaşılan bellek alanı nesnelerind olduğu gibi /dev/shm dizininde 
    görüntülenmektedir. Ancak bu dizinde bu nesnelerinin isimlerinin başında "sem." öneki bulnmaktadır. Programcı isterse 
    bu nesneleri komut satırında rm komutuyla silebilir. 

---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Aşağıda prosesler arasında üretici-tüketici problemi isimli semaphore nesneleri ile çözülmüştür. Derleme işlemleri aşağıdaki 
    gibi yapılabilir:

    gcc -o producer producer.c
    gcc -o consumer consumer.c

    Test işleminde nce "producer" prograının çalıştırılması gerekmektedir. 
---------------------------------------------------------------------------------------------------------------------------*/

/* sharing.h */

#ifndef SHARING_H_
#define SHARING_H_

#include <semaphore.h>
#include <sys/types.h>

#define SHM_NAME                    "/producer-consumer-shared-memory"
#define SEM_PRODUCER_NAME           "/producer-semaphore"
#define SEM_CONSUMER_NAME           "/consumer-semaphore"

#define QUEUE_SIZE      10

typedef struct tagSHARED_INFO {
    int head;
    int tail;
    int queue[QUEUE_SIZE];
} SHARED_INFO;

#endif

/* producer.c */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>
#include <fcntl.h>
#include <sys/stat.h>
#include <sys/mman.h>
#include <unistd.h>
#include "sharing.h"

void exit_sys(const char *msg);
void exit_sys_errno(const char *msg, int eno);

int main(void)
{
	int fdshm;
	SHARED_INFO *shminfo;
    sem_t *sem_producer;
    sem_t *sem_consumer;
    int val;

    srand(time(NULL));

	if ((fdshm = shm_open(SHM_NAME, O_RDWR|O_CREAT, S_IRUSR|S_IWUSR|S_IRGRP|S_IROTH)) == -1)
		exit_sys("shm_open");   

	if (ftruncate(fdshm, sizeof(SHARED_INFO)) == -1)
		exit_sys("ftruncate");

    if ((sem_producer = sem_open(SEM_PRODUCER_NAME, O_CREAT, S_IRUSR|S_IWUSR, QUEUE_SIZE)) == SEM_FAILED)
        exit_sys("sem_open");

    if ((sem_consumer = sem_open(SEM_CONSUMER_NAME, O_CREAT, S_IRUSR|S_IWUSR, 0)) == SEM_FAILED)
        exit_sys("sem_open");


	shminfo = (SHARED_INFO *)mmap(NULL, sizeof(SHARED_INFO), PROT_WRITE, MAP_SHARED, fdshm, 0);
	if (shminfo == MAP_FAILED) 
		exit_sys("mmap");

    shminfo->head = 0;
    shminfo->tail = 0;

    val = 0;
    for (;;) {
        usleep(rand() % 300000);

        if (sem_wait(sem_producer) == -1)
            exit_sys("sem_wait");

        shminfo->queue[shminfo->tail++] = val;
        shminfo->tail %= QUEUE_SIZE;

        if (sem_post(sem_consumer) == -1)
            exit_sys("sem_post");       
 
        
        if (val == 99)
            break;
        ++val;
    }
  
    if (sem_close(sem_producer) == -1)
        exit_sys("sem_close");

    if (sem_close(sem_consumer) == -1)
        exit_sys("sem_close");

    if (sem_unlink(SEM_PRODUCER_NAME) == -1)
        exit_sys("sem_unlink");

    if (sem_unlink(SEM_CONSUMER_NAME) == -1)
        exit_sys("sem_unlink");

	if (munmap(shminfo, sizeof(SHARED_INFO)) == -1)
		exit_sys("munmap");

	close(fdshm);

	if (shm_unlink(SHM_NAME) == -1)
        exit_sys("shm_unlink");

    return 0;    
}

void exit_sys(const char *msg)
{
	perror(msg);

	exit(EXIT_FAILURE);
}

void exit_sys_errno(const char *msg, int eno)
{
    fprintf(stderr, "%s:%s\n", msg, strerror(eno));

    exit(EXIT_FAILURE);
}

/* consumer.c */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>
#include <fcntl.h>
#include <sys/stat.h>
#include <sys/mman.h>
#include <unistd.h>
#include "sharing.h"

void exit_sys(const char *msg);
void exit_sys_errno(const char *msg, int eno);

int main(void)
{
	int fdshm;
	SHARED_INFO *shminfo;
    sem_t *sem_producer;
    sem_t *sem_consumer;
    int val;

    srand(time(NULL));
		
	if ((fdshm = shm_open(SHM_NAME, O_RDWR, 0)) == -1)
		exit_sys("shm_open");   

	shminfo = (SHARED_INFO *)mmap(NULL, sizeof(SHARED_INFO), PROT_WRITE, MAP_SHARED, fdshm, 0);
	if (shminfo == MAP_FAILED) 
		exit_sys("mmap");
 
    if ((sem_producer = sem_open(SEM_PRODUCER_NAME, 0)) == SEM_FAILED)
        exit_sys("sem_open");

    if ((sem_consumer = sem_open(SEM_CONSUMER_NAME, 0)) == SEM_FAILED)
        exit_sys("sem_open");

    for (;;) {
        if (sem_wait(sem_consumer) == -1)
            exit_sys("sem_wait");

        val = shminfo->queue[shminfo->head++];
        shminfo->head %= QUEUE_SIZE;

        if (sem_post(sem_producer) == -1)
            exit_sys("sem_post");

        printf("%d ", val);
        fflush(stdout);
 
        usleep(rand() % 300000);

        if (val == 99)
            break;
    }
    printf("\n");

    if (sem_close(sem_producer) == -1)
        exit_sys("sem_close");

    if (sem_close(sem_consumer) == -1)
        exit_sys("sem_close");

	if (munmap(shminfo, sizeof(SHARED_INFO)) == -1)
		exit_sys("munmap");

	close(fdshm);
	
    return 0;    
}

void exit_sys(const char *msg)
{
	perror(msg);

	exit(EXIT_FAILURE);
}

void exit_sys_errno(const char *msg, int eno)
{
    fprintf(stderr, "%s:%s\n", msg, strerror(eno));

    exit(EXIT_FAILURE);
}

/*--------------------------------------------------------------------------------------------------------------------------
                                            60. Ders 17/06/2023 - Cumartesi
/*--------------------------------------------------------------------------------------------------------------------------

/*--------------------------------------------------------------------------------------------------------------------------
    Daha önceden de belirtitğimiz gibi POSIX IPC nesneleri 90'lı yılların ortalarında POSIX standratlarına sokuldu. Daha önceleri 
    klasik Sistem 5 IPC nesneleri kullanıyordu. İşte klasik IPC nesnelerinin içerisinde semaphore nesneleri de bulunmaktadır. 
    Ancak maalesef Sistem 5 semaphore arayüzü oldukça karışıktır. Bu nedenle artuk yeni programların eğer özel bir taşınabilirlik sorunu 
    yoksa POSIX semaphore nesnelerini kullanması uygun olur. Sistem 5 semaphore nesneleri ayno prosesin thread'leri arasında değil 
    farklı prosesler arasında kullanım için düşünülmüştür. (Zaten bunların tasarlandığı yıllarda henüz thread'ler uygulamaya girmemişti.)
    Halbuki isimsiz POSIZ semaphore nesnelerini aynı prosesin therad'leri arasında kullanabilmekteyiz. 

    System 5 semaphore nesnelerinin isimlendirme biçimleri temel parametrik yapıları diğer Sistem 5 IPC nesnelerine oldukça 
    benzemektedir. Sistem 5 semaphore arayüzünü karışık yapan unsurlardan biri tek hamlede birden fazla semaphore üzerinde (buna
    semaphore set de denilmektedir) işlem yapılmaısıdır. Ayrıca sayaç mekanizması da biraz karışık ve çok işlevli tasarlanmıştır. 

    Biz kurusumuzda Sistem 5 semaphore nesneleri için çok ayrıntıya girmeyeceğiz. Yukarıda da belirttiğimiz gibi karmaşık tasarımlarından
    dolayı bunlar gittikçe POSIX semaphore nesneleri lehine daha az kullanılır hale gelmiştir. 
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Sistem 5 semaphore nesnelerinin tipik kullanımı şöyledir:

    1) Semaphore nesnesi semget fonksiyonu ile (diğer fonksiyonların shmget ve msgget biçiminde isimlendirildiğini anımsayınız)
    yaratılır ya da zaten var olan açılır. Sistem 5 IPC nesnelerinde isim yerine numara (key) kullanıldığını anımsayınız. semget
    fonksiyonunun prototipi şöyledir:

    #include <sys/sem.h>

    int semget(key_t key, int nsems, int semflg);

    Fonksiyonun birinci parametresi prosesler arasında kullanım için gereken anahtar değerdir. Anımsanacağı gibi Sistem 5 IPC 
    nesneleri birer anahtar verilerek yaratılıp açılmakta ve bu işlemden bir id değeri elde edilmektedir. Bu id değerinin sistem 
    genelinde tek (unique) olduğunu anımsayınız. Yine anımsayazağınız gibi bu anahtarı isim gibi kullanabilmek için ftok fonksiyonundan 
    faydalanılabiliyordu. Tabii fonksiyonun birinci parametresi diğer System 5 IPC nesnelerinde olduğuğu gibi IPC_PRIVATE biçiminde
    girilebilir. Bu durumda sistem olmayan bir anahtar kullanarak bize bir id vermektedir. 

    Fonksiyonun ikinci parametresi semaphore kümesindeki semaphore sayısını belirtmektedir. Yani bu parametre toplam kaç tane 
    semaphore'un yaratılacağını belirtmektedir. Fonksiyonun üçüncü parametresi yaratılacak IPC nesnesinin erişim haklarını almaktadır.
    Bu parametreye ayrıca IPC_CREAT ve IPC_EXCL bayrakları da eklenebilir. Yine IPC_CREAT bayrağı nesne yoksa onu yaratmak için 
    kullanılmaktadır. IOC_EXCL tek başına kullanılamaz. Ancak IPC_CREAT|IPC_EXCL biçiminde kullanılabilir. Bu durumda nesne zaten 
    varsa semget fonksiyonu baaşarısız olmaktadır. 

    semget fonksiyonu başarı durumunda IPC nesnesinin id değerine başarısılık durumunda -1 değerine geri dönmektedir.  

    Örneğin:

    if ((key = ftok(KEY_NAME, KEY_ID)) == -1)
		exit_sys("ftok");

    if ((semid = semget(key, 2, IPC_CREAT|S_IRUSR|S_IWUSR|S_IRGRP|S_IROTH)) == -1)
        exit_sys("semget");

    Biz bu notlarda "System 5 semaphore nesnesi" demekle aslında bir semaphore kümesini kastetmiş olacağız. 

    2) System 5 semaphore nesnesi yaratıldıktan sonra artık bu semaphore nesnesi içerisindeki semaphore'ların ilkdeğerlerinin 
    verilmesi gerekir. Çünkü System 5 semaphore nesneleri aslında bir semaphore kümesi içermektedir. Yani biz semget ile 
    aslında bir semaphore kümesi yaratmış olmaktayız. Yaratılan semaphore kümesindeki her semaphore'un ilk semaphore 0 olmak üzere 
    bir indeks numarası vardır. Semaphore semaphore'lar üzerinde işlem yapmak için semctl isimli fonksiyon kullanılmaktadır. 
    Fonksiyonun prototipi şöyledir:

     #include <sys/sem.h>

    int semctl(int semid, int semnum, int cmd, ...);

    Fonksiyonun birinci parametresi semaphore nesnesinin id değerini belirtmektedir. İkinci parametresi semaphore kümesindeki üzerinde
    işlem yapılacak olan semaphore'un indeks numarasını belirtir. Fonksiyonun üçüncü parametresi semaphore kümesindeki semaphore'lara
    uygulanacak işlemleri belirtmektedir. Bu işlemlere göre fonksiyona bir dördüncü parametre gerekebilmektedir. Eğer fonksiyon 
    çağrılırken bir dördüncü argüman girilecekse bu argüman aşağıdaki gibi bir birlik türünden olmak zorundadır:

    union semun {
        int val;
        struct semid_ds *buf;
        unsigned short  *array;
    } arg;

    Birlik elemanlarının çakışık yerleştirildiğini anımsayınız. Yani aslında fonksiyonun bu dördüncü parametresi üçüncü parametredeki işleme 
    göre int, struct semid_ds türündne bir adres ya da unsigned short türden bir adres olabilmektedir. Ancak karışıklığı engellemek 
    için bu türlerin hepsi bir birlik (union) içerisinde toplanmıştır. Maalesef bu birlik bildirimi herhangi bir başlık dosyaısnda
    bulunmamaktadır. Dolayısıyla bu bildirimi programcının kendisinin yapması gerekmektedir. 

    semctl fonksiyonu başarısızlık durumunda -1 değerine geri dönmektedir ve errno uygun biçimde set edilmektedir. 

    semctl fonksiyonunun üçüncü parametresi semaphore kümesindeki semaphore üzerinde hangi işlemin yapılacağını belirtmektedir. 
    Bu işlem şunlardan biri olabilir (IPC_RMID komutu daha sonra açıklanacaktır):

    GETVAL: İkinci parametre ile belirtilen semaphore'un semaphore sayaç değerinin elde edilmesi için kullanılır. Bu durumda semctl fonksiyonu 
    semaphore kümesindeki ikinci parametrede belirtilen semaphore'un sayaç değerine geri döner. Bu işlemin yapılabilmesi için prosesin semaphore 
    nesnesine "read" hakkının bulunuyor olması gerekir. Örneğin (kontroller yapılmamıştır):

    result = semctl(semid, 1, GETVAL);

    Burada biz semaphore kümesi içerisindeki 1 numaralı semaphore'un sayaç değerini elde etmiş olduk. 

    SETVAL: Bu durumda ikinci parametreyle belirtilen semaphore'a ilişkin semaphore sayacı fonksiyona girilecek olan 
    dördüncü argümandaki birliğin val elemanı ile set edilmektedir. Bunun için prosesin  semaphore nesnesine "write" hakkına
    sahip olması gerekmektedir. Örneğin (kontroller yapılmamıştır):

    union semun {
        int val;
        struct semid_ds *buf;
        unsigned short *array;
    } arg;
    ...
    
    arg.val = 5;

    semctl(semid, 1, SETVAL, arg);

    Burada biz 1 numaralı semaphore'un semaphore sayacını 5 olarak set etmiş olduk. 

    GETALL: Bu komutla semaphore kğmesindeki belli bir semaphore'un değil tüm semaphore'ların semaphore sayaç değerleri 
    elde edilmektedir. Bu durumda fonksiyona girilecek dördüncü argüman olan birliğin array elemanı semaphore sayaçlarının 
    yerleştirileceği unsigned short türünden dizinin başlangıç adresini göstermelidir. Yani programcı önce unsigned short türden 
    semaphore kğmesindeki semaphore sayısı kadar bir dizi açmalı ve bu dizinin adresini birliğin array elemanına yerleştirmeli 
    ve bu birliği de semctl fonksiyonunun son elemanına girmelidir. Örneğin semaphore kümemizde iki semaphore bulunuyor 
    olsun (kontroller yapılmamıştır):

    union semun {
        int val;
        struct semid_ds *buf;
        unsigned short  *array;
    } arg;
    unsigned short semvals[2];
    ...
    
    arg.array = semvals;

    semctl(semid, 0, GETALL, arg);

    Bu arada artık semaphore kümesindeki tüm semaphore'ların semaphore sayaçları semvals dizisine yerleştirilecektir. 
    Tabii GETALL komutunda artık fonksiyonun ikinci parametresindeki semaphore numarası dikkate alınmamaktadır. Bu işlemin 
    yapılabilmesi için yine prosesin semaphore nesnesine "read" hakkının olması gerekmektedir. 

    SETALL: Bu komut semaphore kümesindeki tüm semaphore'ların semaphore sayaçlarını set etmek için kullanılmaktadır. 
    Yine bunun için fonksiyonun dördüncü parametresine yukarıdaki birlik türünden bir nesne geçirilir. Birliğin array 
    elemanı semaphore sayaçlarının değerinin bulunduğu unsigned short türünden dizinin başlangıç adresini göstermelidir. 
    Tabii bu dizinin yine semaphore kümesindeki semaphore sayısı kadar uzunlukta olması gerekir. Örneğin semaphore kümesinde 
    iki semaphore bulunyor olsun (kontrooler yapılmamıştır):

    union semun {
        int val;
        struct semid_ds *buf;
        unsigned short  *array;
    } arg;
    unsigned short semvals[2] = {0, 10};
    ...

    arg.array = semvals;
    semctl(semid, 0, SETALL, arg);

    Burada semaphore kümesindeki ilk semaphore'un sayacı 0 olarak ikinci semaphore'un sayacı 10 olarak set edilmiştir. 
    Tabii yine bu durumda semctl fonksiyonunun ikinci parametresi fonksiyon tarafından kullanılmamaktadır. Bu işlemin yapılabilmesi için
    yine prosesin semaphore nesnesine "write" hakkının olması gerekmektedir. 

    GETPID: Bu komutta fonksiyonun dördüncü parametresine gereksinim yoktur. semctl fonksiyonu bize ikinci parametreyle belirtilen 
    semaphore üzerinde en son hangi prosesin semop uyguladığı bilgisini verir. Bu komuta çok seyrek gereksinim duyulmaktadır.
    Bu komut için de prosesin semaphore nesnesine "read" hakkının olması gerekmektedir. 

    GETNCNT ve GETZCNT: Bu komutlar da sırasıyla semaphore sayacının artırılmasını bekleyen ve 0 olmasını bekleyen proseslerin 
    sayısını elde etmek için kullanılmaktadır. Bu komutlar için de prosesin semaphore nesnesine "read" hakkının olması gerekmektedir. 

    Semaphore nesneleri yine "kernel persistant biçimdedir". Yani sistem reboot edilene kadar ya da semaphore nesnesi silinene kadar 
    kalıcı olmaktadır 

    3) Kritik kod semop fonksiyonu ile oluşturulmaktadır. Maalesef semop fonksiyonunun kullanımı POSIX semophore nesnelerinden 
    biraz daha karmaşıktır. Fonksiyonun prototipi şöyledir:

    #include <sys/sem.h>

    int semop(int semid, struct sembuf *sops, size_t nsops);

    Fonksiyonun birinci parametresi semaphore nesnesinin id değerini belirtmektedir. İkinci parametre sembuf isimli bir yapı 
    nesnesinin adresini almaktadır. Bu yapı <sys/sem.h> içerisinde bildirilmiştir. Bu nesnenin içi doldurmak fonksiyonu çağıran 
    kişi tarafından doldurulur. sembuf yapısı şöyle bildirilmiştir:

    struct sembuf {
        unsigned short sem_num;  /* semaphore number */
        short          sem_op;   /* semaphore operation */
        short          sem_flg;  /* operation flags */
    };

    Yapının sem_num elemanı semaphore kümesindeki işlem yapılacak semaphore'u belirtmektedir. İkinxi parametre semahpre 
    sayacı üzerinde yapılacak işlemi belirtmektedir. Bu parametreye aşağıdaki üç durumdan birine ilişkin bir değer girilebilir:

    a) Eğer yapının sem_op elemanının değeri 0'dan büyük bir değerse bu değer semaphore sayacına toplanır. Örneğin o anda 
    semaphore'un sayacının 1 olduğunu düşünelim. Biz sem_op değerine 1 yerleştirirsek artık semaphore sayaç değeri 2 olacaktır. 

    b) Eğer yapının sem_op elemanında negatif bir değer varsa bu durumda semop fonksiyonu o andaki semaphore sayacının değerine 
    bakar. Eğer o anda semaphore sayacından burada belirtilen değer çıkartıldığında (yani negatif değerin mutlak değeri çıkartıldığnda)
    semaphore sayacı 0'ın altına düşecek gibi bir durum oluşursa thread'i bloke eder. Ancak bu durumda henüz çıkartma işlemini yapmaz. 
    Ancak semaphore sayacının değerinden bu negatif değerin mutlak değeri çıkartıldığında sonuç 0 ya da 0'dan büyük olacaksa 
    fonksiyon bu çıkartmayı yapar ve blokeye yol açmadan geri döner. Örneğin:
    
        - Semaphore sayacının değeri 5 olsun. Biz de sem_op değerine -4 girmiş olalım. Bu durumda 5 - 4 = 1 olduğu için bir bloke oluşmaz. 
        semop başarıyla geri döner ve artık semaphore sayacının değeri 1 olur. 

        - Semaphore sayacının değeri 5 olsun biz de sem_op değerine -5 girmiş olalım. Bu durumda 5 - 5 = 0 olduğu için bloke oluşmaz. 
        semop başarıyla geri döner ve artık semaphore sayacının değeri 0 olur. 

        - Semaphore sayacının değeri 5 olsun. Biz de sem_op değerine -10 girmiş olalım. Şimdi 5 - 10 = -5'tir. Yani semaphore 
        sayacı negatif bir değere düşecek gibi olmuştur. İşte fonksiyon bu durumda asla semaphore sayacını negatif bir değere 
        düşürmeyeceği için thread'i bloke olur. Artık bu blokeden kurtulmanın yolu semaphore sayacını 10 ya da 10'un üzerine çekmektir. 
        Şimdi başka bir prosesin sem_op değerine 5 girerek semapore sayacını 10'a çektiğini düşünelim. Artık bu proses 10 - 10 = 0
        olacağı için blokeden çıkabilecek ve semaphore sayacı 0 olarak set edilecektir. 

    Buradaki önemli nokta şudur: Aslında semop hiçbir zaman semaphore sayaıcını 0'ın altına düşürmemektedir. Eğer semaphore sayacı
    0'ın altına düşecek gibi bir durum oluşursa zaten thread'i blokede bekletmektedir. 

    c) Eğer yapının sem_op elemanında 0 değeri varsa bu özel ve başka bir durum anlamına gelmektedir. Bu durumda semaphore sayacı 
    0'a düşürülene kadar ilgili proses blokede bekletilir. Blokeden çıkmanın yolu semaphore sayacını 0'ın yukarısına çekmektedir. 
    Örneğin semahore'un semaphore sayacı 1 olsun. 10 tane proses sem_op değerini 0'a çekerek blokede bekleyebilir. Sonra semaphore 
    sayacı 1 eksiltildiğinde (yani 0'a çekildiğinde) bu 10 proses de blokeden kurtulacaktır. Bu haliyle System 5 semaphore'ları 
    birden fazla prosesi blokede bekletip uyandırmak için kullanılabilmektedir. Ancak bu kullanım çok seyrektir. Yani sem_op değeri 0
    ise bu durum "semaphore sayacı 0 olmadığı sürece blokede bekle" anlamına gelmektedir. 

    sembuf yapısının sem_flg elemanı IPC_NOWAIT, SEM_UNDO bayraklarının birini ya da her ikisini içerebilir. Tabii bu bayraklardan 
    herhangi birisi girilmeyecekse bu elemana 0 değeri girilmelidir. IPC_NOWAIT bloksesin işlem yapmak için kullanılmaktadır. 
    Eğer bu bayrak belirtilirse bloke oluşturabilecek durumlarda bloke oluşmaz ve semop fonksiyonu -1 değeri ile geri döner ve
    errno değişkeni EAGAIN değeri ile set edilir. SEM_UNDO bayrağı proses sonlandığında semaphore adjusment" değerini (semadj) 
    işleme sokarak ters işlem yapmaktadır. 

    semop fonksiyonun üçüncü parametresi ikinci parametredeki sembuf dizisinin eleman sayısını belirtmektedir. Yani aslında 
    ikinci paarametreye tek bir sembuf nesnesinin adresi deği bir sembuf dizisinin adresi geçirilebilmektedir. Bu durumda 
    semop fonksiyonu birden fazla semaphore üzerinde işlem yapar. Fakat böyle bir kullanım genellikle çok seyrektir. 
    Örneğin bizim semaphore nesnemizin (kümemizin) içerisinde iki semaphore olsun. Biz tek bir semop çağrısıyla bir semaphore'un
    sayacını 1 artırırken diğerini 1 eksiltmek isteyebiliriz. Tabii bu kullanım seyrektir. Dolayısıyla genellikle fonksiyonun 
    son parametresi 1 geçilir. Eğer semop fonksiyonunda birden fazl semaphore için işlem yapılacaksa bu işlemler atomik bir biçimde 
    yapılmaktadır. Yani örneğin biz semop fonksiyonu ile iki semahore'un sayacını 1 eksiltmek isteyelim. Semaphore'lardan birinin 
    sayacı 1 olsun diğerinin 0 olsun. Şimdi biz sayacı 1 olan semapore'un sayacını 1 eksiltebiliriz. Ancak sayacı 0 olan semaphore'un 
    sayacını 1 eksiltemeyiz. O halde biz bloke oluruz. Ancak bloke olurken sayacı 1 olan semaphore'un sayacı eksiltilmemektedir. 
    Tüm işlemler eğer yapılacaksa tek hamlede tek bir işlem gibi yapılmaktadır. 

    semop fonksiyonu başarı durumunda 0 değerine başarısızlık durumunda -1 değerine geri döner ve errno değişkeni uygun biçimde 
    set edilir. 

    Pekiyi System 5 semaphore'ları ile kritik kod oluşturulmaktadır? İşte bunun tipik senaryosu şöyledir: Başlangıçta semaphore 
    sayacı semctl fonksiyonu ile ayarlanır. Sonra kritik kod aşağıdaki gibi oluşturulur (kontroller yapılmamıştır):
    
	struct sembuf sbuf;
    ...

	sbuf.sem_num = 0;
	sbuf.sem_op = -1;
	sbuf.sem_flags = 0;

	semop(semid, &sbuf, 1);

	.........
    .........       <KRİTİK KOD>
    .........

    sbuf.sem_num = 0;
    sbuf.sem_op = 1;
    sbuf.sem_flags = 0;
    
    semop(semid, &sbuf, 1);
	
    4) System 5 semaphore nesneleri diğer System 5 IPC nesneleri gibi "kernel persistant" biçimdedir. Yani silinene kadar ya da 
    reboot işlemine kadar kalıcıdır. Semaphore nesnelerini silmek için yine semctl fonksiyonunda IPC_RMID kullanmak gerekir. 
    Bu durumda semctl fonksiyonunun ikinci semaphore numarasını alan ikinci parametresi dikkate alınmamaktadır. Örneğin:

    if (semctl(semid, 0, IPC_RMID) == -1)
        exit_sys("semctl");
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
                                                61. Ders 18/06/2023 - Pazar
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Tıpkı System 5 paylaşılan bellek alanı ve mesaj kuyruklarında olduğu gibi System 5 semaphore nesnelerinde de yine semctl 
    fonksiyonunda IPC_GET ve IPC_SET komut kodlarıyla semaphore nesnelerinin bazıu değerleri get ve set edilebilmektedir. 
    System 5 semaphore nesneleri için işletim sistemi semid_ds isimli bir yapı nesnesi oluşturmaktadır. Bu yapı nesnesi şöyle 
    bildirilmiştir:

    struct semid_ds {
        struct ipc_perm sem_perm;       /* Ownership and permissions */
        time_t          sem_otime;      /* Last semop time */
        time_t          sem_ctime;      /* Creation time/time of last modification via semctl() */
        unsigned long   sem_nsems;      /* No. of semaphores in set */
    };

    Bu yapının ilk elemanı yine IPC nesnesinin erişim haklarını belirtir. İkicni ve üçüncü elemanları semaphore nesnesi üzerinde
    yapılan son işlemlerin zamanları hakkında bilgi verir. Son elemanı ise semaphore kümesindeki semaphore sayısını belirtmektedir. 
    semctl ile ilkdeğer verilmemiş semaphore'lar için yapının sem_ctime ve sem_nsems elemanları çöp değerlerdedir. Standartlaar
    henüz semop fonksiyonu uygulanmadan yapının sem_otime elemanının 0 olacağını garanti etmektedir. Bu garanti sayesinde iki 
    proses aynı semaphore'a ilişkin initialize işlemi yapmak istediğinde oluşan sorun çözülebilmektedir. İzleyen paragraflarda 
    bu durum yeniden açıklanacaktır.
    
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    System 5 semaphore nesneleri proseslerarası kullanım için düşünülmüştür. Özellikle prosesler arasındaki üretici-tüketici 
    problemi gibi tipik senkronizasyon problemleri eskiden bu nesnelerle çözülüyordu. Tabii bu nesneler aslında ağırlıklı 
    olarak System 5 paylaşılan bellek alanlarıyla birlikte kullanılmaktadır. 
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    System 5 semaphore nesnelerinin kullanımı POSIX semaphore nesnelerine göre daha zahmetlidir. Ancak istersek sarma fonksiyonlar 
    yazarak sistem 5 semaphore nesnelerini POSIX semaphore nesneleri gibi de kullanabiliriz. Böylece bu karmaşıklığı ortadan 
    kaldırabiliriz. Aşağıda 6 tane sarma fonksiyon yazılmıştır:

    int sem_create(int key, int mode);
    int sem_open(int key);
    int sem_init(int semid, int val);
    int sem_wait(int semid);
    int sem_post(int semid);
    int sem_destroy(int semid);

    Bu fonksiyonlar semaphore nesnesindeki tek bir semaphore üzerinde çalışmaktadır. sem_create fonksiyonu anahtar ve erişim 
    haklarıbı alarak semaphore nesnesini yaratır. sem_open fonksiyonu yaratılmış olanı açar. sem_init fonksiyonu semaphore 
    sayacına değerini atar. sem_wait ve sem_post fonksiyonları kritik kod oluşturmakta kullanılır. Nihayet sem_destroy 
    fonksiyonu da semaphore nesnesini yok eder. 

---------------------------------------------------------------------------------------------------------------------------*/

int sem_create(int key, int mode)
{
	return semget(key, 1, IPC_CREAT|mode);
}

int sem_open(int key)
{
	return semget(key, 1, 0);
}

int sem_init(int semid, int val)
{
	union semun {
       int val;    
       struct semid_ds *buf;    
       unsigned short  *array;  
       struct seminfo  *__buf;  
	} su;

	su.val = val;
	
	return semctl(semid, 0, SETVAL, su);
}

int sem_wait(int semid)
{
	struct sembuf sb;
	
	sb.sem_num = 0;
	sb.sem_op = -1;
	sb.sem_flg = 0;
	
	return semop(semid, &sb, 1);
}

int sem_post(int semid)
{
	struct sembuf sb;
	
	sb.sem_num = 0;
	sb.sem_op = 1;
	sb.sem_flg = 0;
	
	return semop(semid, &sb, 1);
}

int sem_destroy(int semid)
{
	return semctl(semid, 0, IPC_RMID);
}

/*--------------------------------------------------------------------------------------------------------------------------
    Aşağıda System 5 paylaşılan bellek alanları ve System 5 semaphore nesneleri ile kuyruklu üretici-tüketici problemi örneği
    verilmiştir. Bu örnekte paylaşılan alan aşağıdaki yapıyle temsil edilmiştir:

    typedef struct tagSHARED_INFO {
        int head;
        int tail;
        int queue[QUEUE_SIZE];
        int semid;          /* two semaphore, 0 is producer, 1 iis consumer */
    } SHARED_INFO;

    Burada System 5 semaphore'unun id değeri de bu yapının içerisinde bulundurulmuştur. Örneğimizde paylaşılan bellek alanını ve 
    semaphore nesnesini üretici program (producer.c) yaratmaktadır. Tüketici program (consumer.c) yalnızca yaratılmış olan nesneleri 
    kullanmaktadır. Tabii bu nedenle önce üretici programın çalıştırılması gerekmektedir. IPC nesnelerini üretici program yarattığı
    için bunları yine üretici program silmektedir. Anımsanacağı gibi System 5 paylaşılan bellek alanı shmctl fonksiyonununda  
    IPC_RMID ile silinse bile onu kullanan prosesler shmdt ile alanı serbest bırakmadan silme işlemi gerçek anlamda yapılmıyordu. 
    Ancak örnekte şöyle bir problem vardır: Tüketici program üretici program bu nesneleri yarattıktan sonra çalıştırılmalıdır. 
    Benzer biçimde üretici program tüketici program işini bitirdikten sonra semaphore nesnesini silmelidir. Bunun için biz 
    programın bitişine henüz silme işlemi yapılmadan bir bekleme yerleştirdik. Eğer tüketici programın da önce çalıştırılabilmesi 
    isteniyorsa bu problemi durum başka bir senkronizasyon nesnesi ile (örneğimizde bir System 5 semaphore'u olabilir) çözülebilir.
    Programda semahpore nesnesinin IPC_PRIVATE ile yaratıldığına dikkat ediniz. Bu durumda programcının çakışmayan bir anahtar belirlemesine
    gerek kalmamaktadır. 
---------------------------------------------------------------------------------------------------------------------------*/

/* sharing.h */

#ifndef SHARED_H_
#define SHARED_H_

#define SHM_KEY             0x12345678
#define QUEUE_SIZE          10

typedef struct tagSHARED_INFO {
    int head;
    int tail;
    int queue[QUEUE_SIZE];
    int semid;          /* two semaphore, 0 is producer, 1 iis consumer */
} SHARED_INFO;

#endif

/* producer.c */

#include <stdio.h>
#include <stdlib.h>
#include <time.h>
#include <sys/stat.h>
#include <sys/ipc.h>
#include <sys/shm.h>
#include <sys/sem.h>
#include <unistd.h>
#include "sharing.h"

void exit_sys(const char *msg);

int main(void)
{
    int shmid;
    SHARED_INFO *shminfo;
    struct sembuf sbuf;
    unsigned short semvals[] = {QUEUE_SIZE, 0};
    int val;

    srand(time(NULL));

    if ((shmid = shmget(SHM_KEY, sizeof(SHARED_INFO), IPC_CREAT|S_IRUSR|S_IWUSR|S_IRGRP|S_IROTH)) == -1)
		exit_sys("shmget");

    if ((shminfo = (SHARED_INFO *)shmat(shmid, NULL, 0)) == (void *)-1)
		exit_sys("shmat");

    shminfo->head = 0;
    shminfo->tail = 0;

    if ((shminfo->semid = semget(IPC_PRIVATE, 2, IPC_CREAT|S_IRUSR|S_IWUSR|S_IRGRP|S_IROTH)) == -1)
        exit_sys("semget");

    if (semctl(shminfo->semid, 0, SETALL, semvals) == -1)
        exit_sys("semctl");

    val = 0;
    for (;;) {
        usleep(rand() % 300000);

        sbuf.sem_num = 0;
        sbuf.sem_op = -1;
        sbuf.sem_flg = 0;

        if (semop(shminfo->semid, &sbuf, 1) == -1)
            exit_sys("semop");

        shminfo->queue[shminfo->tail++] = val;
        shminfo->tail %= QUEUE_SIZE;

        sbuf.sem_num = 1;
        sbuf.sem_op = 1;
        sbuf.sem_flg = 0;

        if (semop(shminfo->semid, &sbuf, 1) == -1)
            exit_sys("semop");   
         
        if (val == 99)
            break;
        ++val;
    }

    printf("Press ENTR to exit...\n");
    getchar();

    if (semctl(shminfo->semid, 0, IPC_RMID) == -1)
        exit_sys("semctl");

    if (shmdt(shminfo) == -1)
		exit_sys("shmdt");

    if (shmctl(shmid, IPC_RMID, 0) == -1)
        exit_sys("shmctl");

	return 0;
}

void exit_sys(const char *msg)
{
	perror(msg);

	exit(EXIT_FAILURE);
}

/* consumer.c */

#include <stdio.h>
#include <stdlib.h>
#include <time.h>
#include <sys/stat.h>
#include <sys/ipc.h>
#include <sys/shm.h>
#include <sys/sem.h>
#include <unistd.h>
#include "sharing.h"

void exit_sys(const char *msg);

int main(void)
{
    int shmid;
    SHARED_INFO *shminfo;
    struct sembuf sbuf;
    unsigned short semvals[] = {QUEUE_SIZE, 0};
    int val;

    srand(time(NULL));

    if ((shmid = shmget(SHM_KEY, 0, 0)) == -1)
		exit_sys("shmget");

    if ((shminfo = (SHARED_INFO *)shmat(shmid, NULL, 0)) == (void *)-1)
		exit_sys("shmat");

    val = 0;
    for (;;) {
        sbuf.sem_num = 1;
        sbuf.sem_op = -1;
        sbuf.sem_flg = 0;

        if (semop(shminfo->semid, &sbuf, 1) == -1)
            exit_sys("semop");

        val = shminfo->queue[shminfo->head++];
        shminfo->head %= QUEUE_SIZE;

        sbuf.sem_num = 0;
        sbuf.sem_op = 1;
        sbuf.sem_flg = 0;

        if (semop(shminfo->semid, &sbuf, 1) == -1)
            exit_sys("semop");  

        printf("%d ", val);
        fflush(stdout);
  
        usleep(rand() % 300000);
         
        if (val == 99)
            break;
    }
    printf("\n");

    if (shmdt(shminfo) == -1)
		exit_sys("shmdt");

	return 0;
}

void exit_sys(const char *msg)
{
	perror(msg);

	exit(EXIT_FAILURE);
}

/*--------------------------------------------------------------------------------------------------------------------------
    Yukarıdaki örnekte önce üretici de tüketici de çalışsa çalışmanın sorunsuz yürütülebilmesi nasıl sağlanabilir? İlk akla 
    gelen yöntem başka bir semaphore'un bu iş için kullanılmasıdır. Bu iş için bir semaphore yaratılır. Ancak hangi programın
    önce çaıştırılacağı bilinmediği için her iki program da bu semaphore'u yaratmaya çalışır. Tabii yalnızca bunlardan biri
    semaphore'u yaratıp diğeri yaratılmış olanı açacaktır. Buradaki semaphore sayacının başlangıç değeri 0'da tutulur. Böylece tüketici
    bu semaphore'a bekler. Üretici IPC nesnelerini yaarattığında semaphore 1 arıtrarak tüketiciyi blokeden kurtarır. Ancak 
    üreticinin de heniz IPC nesnelerini silmeden tüketicinin işini bitirdiğinden emin olması gerekir. Bunun için yine aynı 
    semaphore kullanılabilir. Ancak burada başka bir sorun ortaya çıkmaktadır. Bu semaphore'un sayacına ilkdeğer olan 0'ı 
    kim verecektir. Eğer üretici önce çalışırsa IPC nesnelerini yaratıp semaphore sayacını artırdığında sonra tüketici çalışınca 
    tüketici de semaphore 0 değerini verirse "kilitlenme (deadlock)" oluşur. Bu problem aslında yaygın bir problemdir. 
    İşte standartlar semid_ds yapısının sem_otime elemanının henüz semop işlem yapılmadıysa 0 olmasını garanti etmektedir. 
    O zaman tüketici program semctl ile semid_ds bilgilerini elde eder. Sonra yapının bu elemanına bakar. Eğer bu elemanda 0 
    görürse demek ki daha üretici işlemine başlamamıştır. O halde tüketici devam etmek için semaphore sayacını initialize 
    edebilir. Eğer bu elemanda 0 değeri yoksa zaten üretici semaphore sayacını initialize etmiştir. Tüketicinin bunu yapmasına 
    gerek yoktur. 
---------------------------------------------------------------------------------------------------------------------------*/

/* sharing.h */

#ifndef SHARED_H_
#define SHARED_H_

#define SHM_KEY             0x12345678
#define SEM_KEY             0x12345678
#define QUEUE_SIZE          10

typedef struct tagSHARED_INFO {
    int head;
    int tail;
    int queue[QUEUE_SIZE];
    int semid;          /* two semaphore, 0 is producer, 1 iis consumer */
} SHARED_INFO;

 union semun {
    int              val;    
    struct semid_ds *buf;    
    unsigned short  *array;  
};

#endif

/* producer.c */

#include <stdio.h>
#include <stdlib.h>
#include <time.h>
#include <sys/stat.h>
#include <sys/ipc.h>
#include <sys/shm.h>
#include <sys/sem.h>
#include <unistd.h>
#include "sharing.h"

void exit_sys(const char *msg);

int main(void)
{
    int semid;
    int shmid;
    SHARED_INFO *shminfo;
    struct sembuf sbuf;
    unsigned short semvals[] = {QUEUE_SIZE, 0};
    int val;
    union semun arg;

    if ((semid = semget(SEM_KEY, 1, IPC_CREAT|S_IRUSR|S_IWUSR|S_IRGRP|S_IROTH)) == -1)
        exit_sys("semget");

    arg.val = 0;
    if (semctl(semid, 0, SETVAL, arg) == -1)
        exit_sys("semctl");
    
    srand(time(NULL));

    if ((shmid = shmget(SHM_KEY, sizeof(SHARED_INFO), IPC_CREAT|S_IRUSR|S_IWUSR|S_IRGRP|S_IROTH)) == -1)
		exit_sys("shmget");

    if ((shminfo = (SHARED_INFO *)shmat(shmid, NULL, 0)) == (void *)-1)
		exit_sys("shmat");

    shminfo->head = 0;
    shminfo->tail = 0;

    if ((shminfo->semid = semget(IPC_PRIVATE, 2, IPC_CREAT|S_IRUSR|S_IWUSR|S_IRGRP|S_IROTH)) == -1)
        exit_sys("semget");

    arg.array = semvals;
    if (semctl(shminfo->semid, 0, SETALL, arg) == -1)
        exit_sys("semctl");

    sbuf.sem_num = 0;
    sbuf.sem_op = 1;
    sbuf.sem_flg = 0;

    if (semop(semid, &sbuf, 1) == -1)
        exit_sys("semop");

    val = 0;
    for (;;) {
        usleep(rand() % 300000);

        sbuf.sem_num = 0;
        sbuf.sem_op = -1;
        sbuf.sem_flg = 0;

        if (semop(shminfo->semid, &sbuf, 1) == -1)
            exit_sys("semop");

        shminfo->queue[shminfo->tail++] = val;
        shminfo->tail %= QUEUE_SIZE;

        sbuf.sem_num = 1;
        sbuf.sem_op = 1;
        sbuf.sem_flg = 0;

        if (semop(shminfo->semid, &sbuf, 1) == -1)
            exit_sys("semop");   
         
        if (val == 99)
            break;
        ++val;
    }

    sbuf.sem_num = 0;
    sbuf.sem_op = -1;
    sbuf.sem_flg = 0;

    if (semop(semid, &sbuf, 1) == -1)
        exit_sys("semop");

    if (semctl(shminfo->semid, 0, IPC_RMID) == -1)
        exit_sys("semctl");

    if (shmdt(shminfo) == -1)
		exit_sys("shmdt");

    if (shmctl(shmid, IPC_RMID, 0) == -1)
        exit_sys("shmctl");

    if (semctl(semid, 0, IPC_RMID) == -1)
        exit_sys("semctl");

	return 0;
}

void exit_sys(const char *msg)
{
	perror(msg);

	exit(EXIT_FAILURE);
}

/* consumer.c */

#include <stdio.h>
#include <stdlib.h>
#include <time.h>
#include <sys/stat.h>
#include <sys/ipc.h>
#include <sys/shm.h>
#include <sys/sem.h>
#include <unistd.h>
#include "sharing.h"

void exit_sys(const char *msg);

int main(void)
{
    int semid;
    int shmid;
    SHARED_INFO *shminfo;
    struct sembuf sbuf;
    unsigned short semvals[] = {QUEUE_SIZE, 0};
    int val;
    union semun arg;
    struct semid_ds semds;

    srand(time(NULL));

    if ((semid = semget(SEM_KEY, 1, IPC_CREAT|S_IRUSR|S_IWUSR|S_IRGRP|S_IROTH)) == -1)
        exit_sys("semget");

    if (semctl(semid, 0, IPC_STAT, &semds) == -1)
        exit_sys("semctl");

    if (semds.sem_otime == 0) {
        arg.val = 0;
        if (semctl(semid, 0, SETVAL, arg) == -1)
            exit_sys("semct");
    }

    sbuf.sem_num = 0;
    sbuf.sem_op = -1;
    sbuf.sem_flg = 0;

    if (semop(semid, &sbuf, 1) == -1)
        exit_sys("semop");

    if ((shmid = shmget(SHM_KEY, 0, 0)) == -1)
		exit_sys("shmget");

    if ((shminfo = (SHARED_INFO *)shmat(shmid, NULL, 0)) == (void *)-1)
		exit_sys("shmat");

    val = 0;
    for (;;) {
        sbuf.sem_num = 1;
        sbuf.sem_op = -1;
        sbuf.sem_flg = 0;

        if (semop(shminfo->semid, &sbuf, 1) == -1)
            exit_sys("semop");

        val = shminfo->queue[shminfo->head++];
        shminfo->head %= QUEUE_SIZE;

        sbuf.sem_num = 0;
        sbuf.sem_op = 1;
        sbuf.sem_flg = 0;

        if (semop(shminfo->semid, &sbuf, 1) == -1)
            exit_sys("semop");  

        printf("%d ", val);
        fflush(stdout);
  
        usleep(rand() % 300000);
         
        if (val == 99)
            break;
    }
    printf("\n");

    sbuf.sem_num = 0;
    sbuf.sem_op = 1;
    sbuf.sem_flg = 0;

    if (semop(semid, &sbuf, 1) == -1)
        exit_sys("semop");

    if (shmdt(shminfo) == -1)
		exit_sys("shmdt");

	return 0;
}

void exit_sys(const char *msg)
{
	perror(msg);

	exit(EXIT_FAILURE);
}

/*--------------------------------------------------------------------------------------------------------------------------
    System 5 Semaphore nesneleri proseslerarası kullanım için tasarlanmıştır. Zaten bu nesnelerin tasarlandığı zamanlarda henüz 
    thread'ler kullanılmıyordu. Her ne kadar bu nesneleri biz aynı prosesin thread'leri arasında da kullanabiliyor olsak da 
    böyle bir kullanım verimsiz ve gereksizdir. Thread'ler arasında semaphore kullanmak istiyorsanız isimsiz POSIX semaphore'larını
    tercih etmelisiniz. POSIX senkronizasyton nesneleri UNIX türevi sistemlere thread'ler eklenirken eklenmiştir. 
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
                                                62. Ders 01/07/2023 - Cumartesi
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Barrier nesneleri nispeten az kullanılan senkronizasyon nesnelerindendir. Windows sistemlerinde bu senkronizasyon nesnesinin 
    tam bir karşılığı yoktur. Barrier nesnelerinin çalışması şöyle bir örnekle açıklanabilir: Önümüzde bir bariyer olsun. Biz 
    bu bariyeri kuvvet uygulayarak kırmaya çalışalım. Ama bizim kuvvetimiz bu bariyeri kırmaya yetmesin. Sonra başka birisi bize yardım 
    etmek istesin. Bu kez bu bariyeri iki kişi kuvvet uygulayarak kırmaya çalışalım. Yine iki kişinin kuvveti de bu bariyeri kırmaya 
    yetmiyor olsun. Sonra bir üçüncü kişi de bize yardıma gelmiş olsun. Şimdi üçümüz kuvver uygulayarak bu bariyeri kırmaya çalıştığımızda
    bunu başardığımızı düşünelim. Artık bariyer kırıldığına göre üçümüz de yollarımıza devam edebiliriz. 

    Yukarıdaki örnekte olduğu gibi bariyer nesneleri ancak n tane thread belli bir noktaya geldiğinde açılmaktadır. Örneğin 
    buradaki açılma koşulunun 3 thread olduğunu düşünelim. Birinci thread bariyere galdiğinde bloke olur. İkinci thread de bariyere 
    geldiğinde bloke olur. Ancak üçüncü thread de bariyere geldiğinde artık bariyer açılır ve diğer iki thread'in de blokesi 
    çözülerek üç thread yollarına devam eder.      
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Barrier parçalardan oluşan bir işin parçalarının çeşitli tread'lere yaptırıldığı durumlarda bu thread'lerin işlerini bitirdiği 
    zaman nihai işlemin yapılması gerektiği durumlarda kullanılmaktadır. Örneğin büyük bir dizinin sort edilmek istendiğini 
    düşünelim. Biz bu diziyi 10 parçaya ayıralım ve 10 farklı thread'le bu parçaları sıraya dizmek isteyelim. Her thread kendi parçasını 
    sıraya dizdikten sonra artık bunların birleştirilmesi gerekmektedir. Ancak birleştirme işlemi tüm thread'lerin kendi parçalarını 
    sıraya dizdikten sonra yapılmalıdır. (Sıralı dizilerin birleştirilmesi işlemine "merge" denilmektedir.)
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Barrier nesneleri aşağıdaki adımlardan geçilerek kullanılmaktadır:

    1) Önce barrier nesnesini temsil eden pthread_barrier_t türünden global bir nesne tanımlanır. pthread_barrier_t türü 
    <pthread.h> ve <sys/types.h> dosyaaları içerisinde typedef edilmiş durumdadır. POSIX standartlarına göre pthread_barrier_t
    türü herhangi bir tür olarak typedef edilmiş olabilir. Linux sistemlerinde bu tür bir yapı biçiminde typedef edilmiştir. 
    Örneğin:

    pthread_barrier_t g_barrier;

    2) Tanımlanan bu global barrier nesnesine pthread_barrier_init fonksiyonu ile ilkdeğer verilmesi gerekmektedir. Fonksiyonun 
    prototipi şöyledir:

    #include <pthread.h>

    int pthread_barrier_init(pthread_barrier_t *barrier, const pthread_barrierattr_t *attr, unsigned count);

    Fonksiyonun birinci parametresi barrier nesnesinin adresini almaktadır. İkinci parametre barrier nesnesinin özellik bilgilerinin
    bulunduğu pthread_barrierattr_t türünden nesnenin adresini almaktadır. Bu parametre NULL adres geçilebilir. Bu durumda 
    barrier nesnesi default özelliklerle yaratılmaktadır. Fonksiyonun üçüncü parametresi barrier'in kırılması için o noktaya gelecek 
    thread sayısını belirtmektedir. Fonksiyon başarı durumunda 0 değerine başarısızlık durumunda errno değerine geri dönmektedir. 
    Örneğin:

    if ((result = pthread_barrier_init(&g_barrier, NULL, 3)) != 0)
        exit_sys_errno("pthread_barrier_init", result);

    Barrier nesnelerine statik düzeyde makroyla ilkder verilememektedir. 

    3) N tane thread'in bir noktada bekletilmesi için pthread_barrier_wait fonksiyonu kullanılmaktadır. Fonksiyonun prototipi 
    şöyledir:

    #include <pthread.h>

    int pthread_barrier_wait(pthread_barrier_t *barrier);

    Fonksiyon barrier nesnesinin adresini alır. Başarı durumunda 0 değerine başarısızlık durumunda errno değerine geri 
    dönmektedir. Ancak fonksiyonun geri dönüş değeri hakkında önemli bir ayrıntı daha vardır. Birtakım thread'ler bir işin parçalarını
    yaptıktan sonra geri kalan birleştirme işleminin yalnızca bir thread tarafından yapılmasını sağlamak için pthread_barrier_wait
    fonksiyonu yalnızca tek bir thread'te PTHREAD_BARRIER_SERIAL_THREAD özel değeriyle geri dönmektedir. Yani bekleme başarılıysa 
    pthread_barrier_wait fonksiyonundan thread'ler 0 değeri ile geri dönerler. Ancak bunlardan yalnızca biri PTHREAD_BARRIER_SERIAL_THREAD 
    özel değeriyle geri dönmektedir. PTHREAD_BARRIER_SERIAL_THREAD özel değeri 0'dan farklı bir değerdir. Dolayısıyla fonksiyon 
    bu değerler geri dönmüşse başarısız kabul edilmemelidir. O halde fonksiyonun başarı kontrolü aşağıdaki gibi yapılabilir:

    if ((result = pthread_barrier_wait(&g_barrier)) != 0 && result != PTHREAD_BARRIER_SERIAL_THREAD)
        exit_sys_errno("pthread_barrier_wait", result);

    Tabii thread'lerden birinde bu birleştirme işlemi yapılacaksa ayrıca yine fonksiyonun geri dönüş değerinin kontrol edilmesi 
    gerekir. Örneğin:

    if ((result = pthread_barrier_wait(&g_barrier)) != 0 && result != PTHREAD_BARRIER_SERIAL_THREAD)
        exit_sys_errno("pthread_barrier_wait", result);
    
    if (result ==PTHREAD_BARRIER_SERIAL_THREAD) {
        /* birleştirme işlemi */
    }

    Tabii bu kontrol aşağıdaki gibi de yapılabilir:
 
    if ((result = pthread_barrier_wait(&g_barrier)) != 0) 
        if (result == PTHREAD_BARRIER_SERIAL_THREAD) {
            /* birleştirme işlemi */
        }
        else
            exit_sys_errno("pthread_barrier_wait", result);

    Barrier nesnesi açıldıktan sonra yeniden otomatik olarak pthread_barrier_init fonksiyonu çağrılmış gibi ilk durumuna gelmektedir. 

    POSIX standartları hangi thread'in PTHREAD_BARRIER_SERIAL_THREAD değeriyle geri dönceği konusunda bir garanti vermemektedir. 

    4) Kullanım bittikten sonra barrier nesnesi pthread_barrier_destroy fonksiyonu ile boşaltılmalıdır. Fonksiyonun prototipi şöyledir:

    #incude <pthread.h>

    int pthread_barrier_destroy(pthread_barrier_t *barrier);

    Fonksiyon barrier nesnesinin adresini alır başarı durumunda 0 değerine başarısızlık durumunda errno değerine geri döner. 
    Örneğin:

    if ((result = pthread_barrier_destroy(&g_barrier)) != 0)
        exit_sys_errno("pthread_barrier_destroy", result);

    5) Barrier nesneleri için tek bir özellik bilgisi vardır. O da nesnenin prosesler arasında kullanılıp kullanılmayacağını 
    belirtmektedir. Default durumda (yani pthread_barrier_init fonksiyonunun ikinci paramtresi NULL geçildiğinde) nesne prosesler 
    arasında kullanılamamaktadır. Özellik nesnesinin kullanımı diğer nesnelerde olduğu gibidir. Önce pthread_barrierattr_t 
    türünden bir nesne yaratılır. Sonra bu nesneye pthread_barrierattr_init fonksiyonu ile ilkdeğer verilir. Sonra nesnenin 
    özelliğinin set ve get edilmesi için pthread_barrierattr_setpshrared ve pthread_barrierattr_getpshrared fonksiyonları kullanılır. 
    Burada proseslerarası paylaşım PTHREAD_PROCESS_SHARED değeri ile belirtilmektedir. Tabii en sonunda bu özellik nesnesi 
    pthread_barrierattr_destroy fonksiyonu ile yok edilmelidir. Özellik ile ile ilgili fonksiyonların prototipleri şöyledir:

    #include <pthread.h>

    int pthread_barrierattr_init(pthread_barrierattr_t *attr);
    int pthread_barrierattr_getpshared(const pthread_barrierattr_t *attr, int *pshared);
    int pthread_barrierattr_setpshared(pthread_barrierattr_t *attr,int pshared); 
    int pthread_barrierattr_destroy(pthread_barrierattr_t *attr);

    Fonksiyonların hepsi başarı durumunda 0 değerine başarısızlık durumunda errno değerine geri dönmektedir. 

    Örneğin:

    pthread_barrierattr_t battr;
    ....

    if ((result = pthread_barrierattr_init(&battr)) != 0)
        exit_sys_errno("pthread_barrierattr_init", result);

    if ((result = pthread_barrierattr_setpshared(&battr, PTHREAD_PROCESS_SHARED)) != 0)
        exit_sys_errno("pthread_barrierattr_setpshared", result);

    if ((result = pthread_barrier_init(&g_barrier, &battr, 3)) != 0)
        exit_sys_errno("pthread_barrier_init", result);

    if ((result = pthread_barrierattr_destroy(&battr)) != 0)
        exit_sys_errno("pthread_barrierattr_destroy", result);   

    Tabii barrier nesnesini prosesler arasınd akullanabilmek için neneyi yine paylaşılan bellek alanında oluşturmak gerekir. 
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Aşağıdaki örnekte 3 thread pthread_barrier_wait ile aynı barrier nesnesinde bekletilmiştir. 3 thread'de rastgele zamanlarda 
    bu noktaya erişmektedir. İçlerinden yalnızca biri PTHREAD_BARRIER_SERIAL_THREAD değeriyle geri dönecektir. 
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <pthread.h>

void *thread_proc1(void *param);
void *thread_proc2(void *param);
void *thread_proc3(void *param);
void exit_sys_errno(const char *msg, int eno);

pthread_barrier_t g_barrier;

int main(void)
{
    pthread_t tid1, tid2, tid3;
    int result;

    if ((result = pthread_barrier_init(&g_barrier, NULL, 3)) != 0)
        exit_sys_errno("pthread_barrier_init", result);

    if ((result = pthread_create(&tid1, NULL, thread_proc1, NULL)) != 0)
        exit_sys_errno("pthread_create", result);

    if ((result = pthread_create(&tid2, NULL, thread_proc2, NULL)) != 0)
        exit_sys_errno("pthread_create", result);

    if ((result = pthread_create(&tid3, NULL, thread_proc3, NULL)) != 0)
        exit_sys_errno("pthread_create", result);

    if ((result = pthread_join(tid1, NULL)) != 0)
        exit_sys_errno("pthread_join", result);

    if ((result = pthread_join(tid2, NULL)) != 0)
        exit_sys_errno("pthread_join", result);

    if ((result = pthread_join(tid3, NULL)) != 0)
        exit_sys_errno("pthread_join", result);

    if ((result = pthread_barrier_destroy(&g_barrier)) != 0)
        exit_sys_errno("pthread_barrier_destroy", result);
    
    return 0;
}

void *thread_proc1(void *param)
{
    unsigned seed;
    int stime;
    int result;

    printf("thread1 starts...\n");

    seed = time(NULL) + 123;

    stime = rand_r(&seed) % 10;
    printf("thread1 running %d second(s)\n", stime);
    sleep(stime);

    if ((result = pthread_barrier_wait(&g_barrier)) != 0 && result != PTHREAD_BARRIER_SERIAL_THREAD)
        exit_sys_errno("pthread_barrier_wait", result);

    if (result == PTHREAD_BARRIER_SERIAL_THREAD) {
        printf("thread1 returns with PTHREAD_BARRIER_SERIAL_THREAD\n");
    }
    printf("thread1 terminates...\n");

    return NULL;
}

void *thread_proc2(void *param)
{
    unsigned seed;
    int stime;
    int result;

    printf("thread2 starts...\n");

    seed = time(NULL) + 456;

    stime = rand_r(&seed) % 10;
    printf("thread2 running %d second(s)\n", stime);
    sleep(stime);

    if ((result = pthread_barrier_wait(&g_barrier)) != 0 && result != PTHREAD_BARRIER_SERIAL_THREAD)
        exit_sys_errno("pthread_barrier_wait", result);

    if (result == PTHREAD_BARRIER_SERIAL_THREAD) {
        printf("thread2 returns with PTHREAD_BARRIER_SERIAL_THREAD\n");
    }
    printf("thread2 terminates...\n");
        
    return NULL;
}

void *thread_proc3(void *param)
{
    unsigned seed;
    int stime;
    int result;

    printf("thread3 starts...\n");

    seed = time(NULL) + 789;

    stime = rand_r(&seed) % 10;
    printf("thread3 running %d second(s)\n", stime);
    sleep(stime);
    
    if ((result = pthread_barrier_wait(&g_barrier)) != 0 && result != PTHREAD_BARRIER_SERIAL_THREAD)
        exit_sys_errno("pthread_barrier_wait", result);

    if (result == PTHREAD_BARRIER_SERIAL_THREAD) {
        printf("thread3 returns with PTHREAD_BARRIER_SERIAL_THREAD\n");
    }

    printf("thread3 terminates...\n");
    
    return NULL;
}

void exit_sys_errno(const char *msg, int eno)
{
    fprintf(stderr, "%s:%s\n", msg, strerror(eno));

    exit(EXIT_FAILURE);
}

/*--------------------------------------------------------------------------------------------------------------------------
    Aşağıda bir barrier kullanım örneği verilmiştir. 50000000 (elli milyon) tane rastgele değerlerden oluşan int türden bir dizi 10 parçaya 
    bölünmüş ve her parça bir thread tarafından qsort fonksiyonu ile sort edilmiştir. Sonra da bu kendi aralarında sıralı olan bu 10 dizi
    birleştirilmiştir. Sonra aynı dizi tek bir thread tarafından sıraya dizilmiştir. 3 çekirdekli bir Linux sisteminde (kullandığımız sanal makine) 
    thread'li biçim 6 saniye civarında thread'siz biçim 12 saniye civarında zaman almaktadır. 
---------------------------------------------------------------------------------------------------------------------------*/
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>
#include <unistd.h>
#include <pthread.h>

#define SIZE            50000000
#define NTHREADS        10

int comp(const void *pv1, const void *pv2);
void *thread_proc(void *param);
void merge(void);
int check(const int *nums);
void exit_sys_thread(const char *msg, int err);

pthread_barrier_t g_barrier;
int g_nums[SIZE];
int g_snums[SIZE];

int main(void)    
{
    int result;
    int i;
    pthread_t tids[NTHREADS];
    clock_t start, stop;
    double telapsed;

    srand(time(NULL));
    for (i = 0; i < SIZE; ++i)
        g_nums[i] = rand();
    
    start = clock();

    if ((result = pthread_barrier_init(&g_barrier, NULL, NTHREADS)) != 0)
        exit_sys_thread("pthread_barrier_init", result);

    for (i = 0; i < NTHREADS; ++i)
        if ((result = pthread_create(&tids[i], NULL, thread_proc, (void *)i)) != 0) 
            exit_sys_thread("pthread_create", result);       

    for (i = 0; i < NTHREADS; ++i)
        if ((result = pthread_join(tids[i], NULL)) != 0)
            exit_sys_thread("pthread_join", result);

    pthread_barrier_destroy(&g_barrier);

    stop = clock();

    telapsed = (double)(stop - start) / CLOCKS_PER_SEC;

    printf("Total second with threaded sort: %f\n", telapsed);

    printf(check(g_snums) ? "Sorted\n" : "Not Sorted\n");

    start = clock();

    qsort(g_nums, SIZE, sizeof(int), comp);

    stop = clock();

    telapsed = (double)(stop - start) / CLOCKS_PER_SEC;

    printf("Total second with threaded sort: %f\n", telapsed);

    printf(check(g_nums) ? "Sorted\n" : "Not Sorted\n");

    return 0;
}

void exit_sys_thread(const char *msg, int err)
{
    fprintf(stderr, "%s: %s\n", msg, strerror(err));
    exit(EXIT_FAILURE);
}

void *thread_proc(void *param)
{
    int part = (int)param;
    int result;

    qsort(g_snums + part * (SIZE / NTHREADS), SIZE / NTHREADS, sizeof(int), comp);
  
    if ((result = pthread_barrier_wait(&g_barrier)) && result != PTHREAD_BARRIER_SERIAL_THREAD)
        exit_sys_thread("pthread_barrier_wait", result);
    
    if (result == PTHREAD_BARRIER_SERIAL_THREAD) 
            merge();

    return NULL;
}

int comp(const void *pv1, const void *pv2)
{
    const int *pi1 = (const int *)pv1;
    const int *pi2 = (const int *)pv2;

    return *pi1 - *pi2;
}

void merge(void)
{
    int indexes[NTHREADS];
    int min, min_index;
    int i, k;
    int partsize;

    partsize = SIZE / NTHREADS;

    for (i = 0; i < NTHREADS; ++i)
        indexes[i] = i * partsize;
    
    for (i = 0; i < SIZE; ++i) {
        min = indexes[0];
        min_index = 0;

        for (k = 1; k < NTHREADS; ++k)
            if (indexes[k] < (k + 1) * partsize && g_nums[indexes[k]] < min) {
                min = g_nums[indexes[k]];
                min_index = k;
            }
        g_snums[i] = min;
        ++indexes[min_index];
    }
}

int check(const int *nums)
{
    int i;

    for  (i = 0; i < SIZE - 1; ++i) 
        if (nums[i] > nums[i + 1])
            return 0;

    return 1;
}

/*--------------------------------------------------------------------------------------------------------------------------
    Senkronizasyon dünyasında karşımıza çıkan diğer bir senkronizasyon nesnesi de "spinlock" denilen nesnedir. Spinlock nesneleri 
    tıpkı mutex'ler gibi binary semaphore'lar gibi bir kritik kodun başından sonuna kadar yalnızca tek bir thread tarafından 
    çalıştırılmasını sağlmak için kullanılmaktadır. Bu nednelerin mutex ve binary semaphore nesnelerinden farkı eğer nesne 
    kilitliyse beklemenin bloke yoluyla değil çeşgul bir döngü yoluyla blokesiz yapılmasıdır. Yani spinlock nesnelerinin içerisinde
    sonsuz bir döngü vardır. Bu döngünün içerisinde sürekli "kilit açılmış mı" diye kontrol yapılmaktadır. Şüphesiz bu biçimdeki
    çalışma eğer nesne kilitliyse gereksiz CPU zamanının harcanmasına yol açacaktır. Ancak bazı durumlarda spinlock'lar 
    hızlandırma sağlayabilmektedir. Çünkü senkronizasyon nesnelerinin kilitli olması durumunda thread'in uykuya yatırılması ve 
    uyandırılması göreli olarak önemli bir zaman kaybı da oluşturmaktadır. 

    Spinlock nesneleri yalnızca bazı özel koşullar sağlanıyorsa kullanılmalıdır. Örneğin tek işlemcili ya da tek çekirdekli 
    sistemlerde spinlock kullanımının genellikle zararından başka bir faydası yoktur. Çünkü tek işlemcili ya da tek çekirdekli 
    sistemlerde bir thread nesneyi kilitlemiş ve thread'ler arası geçiş oluşmuşsa artık o nesnenin kilidinin açılması ancak o thread'in
    yeniden CPU'ya atanmasıyla gereçekleşeceği için diğer bir thread spinlock içerisinde meşgul bir döngüde CPU zamanı harcayarak 
    bekleyecektir. Halbuki çok işlemcili ya da çekirdekli sistemlerde nesneyi kilitleyen thread bir işlemcide ya da çekirdekte, 
    spinlock'ta bekleyen thread ise başka bir işlemcide ya da çekirdekte çalışıyro olabilir. Bu duurmda spinlock çok fazla dönmeden 
    nesneyi kilitleyebilir. Tabii işletim sistemleri çok işlemcili ya da çekirdekli sistem söz konusu olsa bile bu thread'leri aynı 
    işlemci ya da çekirdeğin kuyruğuna atayabilmektedir. Öte yandan bazı aşağı seviyeli uygulamalarda sistemde tek bir işlemci ya da 
    çekirdek olsa bile bir donanım kesmesi ile kilidin açılmasını mümkün hale getiren bir mekanizma da oluşturulabilmektedir.  
    Mademki işletim sistemleri spinlock'ı kullanan thread'leri aynı işlemci ya da çekirdeğin kuyruğuna atayabilmektedir bu durumda 
    spinlock'ı kilitleyen thread'lerin daha yüksek öncelikli olması bu tür durumlardaki gereksiz beklemeleri bir ölçüde engelleyebilmektedir. 
    Özetle spinlock kullanılırken dikkat edilmesi gerekir. Uygunsuz yerde spinlock kullanımı performansı tam tersine olumsuz etkileyebilmektedir. 
    Ancak bu nesnenin gerektiği yerde kullanılması da performans üzerinde olumlu etkiler sağlayabilmektedir. 

    Spinlock kilidini almak için iki thread'in farklı işlemci ya da çekirdeklerde çalıştıı durumda bunlardan birinin spinlcok kilidini
    aldığında kısa süre içerisinde bırakması en uygun durumdur. Çünkü diğer işlemci ya da çekirdekteki thread meşgul bir döngüde 
    bekliyor olabilir. Spinlock ile oluşturulan kritik kodun kısa ve çabuk geçilen bir kod olması anlamlıdır. 

    Dagha önceden de belirttiğimiz gibi aynı prosesin thread'leri arasındaki senkronizasyon için ilk akla gelmesi gereken 
    senkronizasyon nesneleri mutex nesneleridir. Spinlock nesneleri bazı özel durumlarda performasnı artırmak için dikkatlice
    kullanılmalıdır. 

    Modern mutex, semaphore gibi nesnelerin gerçekleştiriminde de aslında kısa spin işlemleri yapılmaktadır. Örneğin pthread_mutex_lock
    hemen kilide bakıp kilit kapalıysa bloke olmamaktadır. Kısa bir süre spin içerisinde kilidin açılmasını bekleyip sonra bloke 
    olmaktadır. Yani bu nesnelerin gerçekleştiriminde de kısa spin işlemleri yapılmaktadır. 
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Spinlock nesneleri şu adımlardan geçilerek kullanılmaktadır:

    1) Spinlock nesneleri pthread_spinlock_t türüyle temsil edilmiştir. Öncelikle bu türden global bir nesnenin tanımlanması 
    gerekir. Örneğin:

    pthread_spinlock_t g_spinlock;

    pthread_spinlock_t türü yine <pthread.h> ve <sys/types.h> dosyaları içerisinde herhangi bir tür olarak typedef edilebilmektedir. 
    Linux sistemlerinde tipik olarak bu tür bir yapı belirtmektedir. 

    2) Spinlock nesnesine phread_spin_init fonksiyonu ile ilkdeğer verilir. Fonksiyonun prototipi şöyledir:

    #include <pthread.h>

    int pthread_spin_init(pthread_spinlock_t *lock, int pshared);

    Fonksiyonun birinici parametresi spinlock nesnesinin adresini alır. İkinci parametre nesnenin prosesler arasında kullanılıp 
    kullanılmayacağını belirtmektedir. Bu parametre 0 ya da PTHREAD_PROCESS_SHARED biçiminde geçilir. Nesnenin ayrıca bir 
    özellik (attribute) parametresinin olmadığına dikkat ediniz. Spinlock nesnesine ilkdeğer vermek için bir makro bulunmamaktadır. 
    Örneğin:

    if ((result = pthread_spin_init(&g_spinlock, 0)) != 0)
        exit_sys_errno("pthread_spin_init", result);  

    3) Kritik kod pthread_spin_lock ve pthread_spin_unlock fonksiyonlarıyla oluşturulmaktadır. Fonksiyonların prototipleri şöyledir:

    #include <pthread.h>

    int pthread_spin_lock(pthread_spinlock_t *lock);
    int pthread_spin_unlock(pthread_spinlock_t *lock);

    Fonksiyonlar spinlock nesnesinin adresini parametre olarak alır başarı durumunda 0 değerine, başarısızlık durumunda errno değerine geri döner. 
    Kritik kod şöyle oluşturulmaktadır (kontroller yapılmamıştır):

    pthread_spin_lock(&g_spinlock);
    .....
    .....        <KRİTİK KOD>
    .....
    pthread_spin_unlock(&g_spinlock);

    Thread'in akışı pthread_spin_lock fonksiyonuna girdiğinde meşgul döngü içerisinde kilide bakılıp beklenmektedir. 
    pthread_spşn_unlock fonksiyonu da kilidi açmaktadır. 

    Yine buradaki lock fonksiyonunun try'lı biçimi de vardır:

    #include <pthread.h>

    int pthread_spin_trylock(pthread_spinlock_t *lock);

    Fonksiyon kilit açık mı diye bakar. Eğer kilit açık değilse spin yapmadan EBUSY errno değeri ile geri dönmektedir. 

    4) Nihayet işlem bittikten sonra spinlock nesnesi pthread_spin_destoy fonksiyonu ile boşaltılmalıdır. Fonksiyonun prototipi
    şöyledir:

    #include <pthread.h>

    int pthread_spin_destroy(pthread_spinlock_t *lock);

    Fonksiyon spinlock nesnesinin adresini parametre olarak alır ve nesneyi boşaltır. Başarı durumunda 0 değerine başarısızlık 
    durumunda errno değerine geri dönmektedir. Örneğin:

    if ((result = pthread_spin_destroy(&g_spinlock)) != 0)
        exit_sys_errno("pthread_spin_destroy", result);  

---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
                                            63.Ders 02/07/2023 - Pazar
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Aşağıdaki örnekte iki thread global bir sayacı spinlock koruması ile artırmaktadır. Buradaki işlem CPU yoğun bir işlemdir. 
    Bu tür CPU yoğun işlemlerde eğer makinenizde birden fazla işlemci ya da çekirdek varsa spinlock daha iyi bir sonuç 
    verebilmektedir. Tabii eğer işletim sistemi söz konusu bu thread'leri aynı işlemci ya da çekirdeklere atarsa tam tersine 
    spinlock daha kötü bir sonuç da verebilir. Bu örnekte programın çalışma süresini time programıyla ölçebilrisiniz. Aynı örneği 
    mutex nesneleriyle yapıp sonuçlarını karşılaştırabilirsniz. Örneğin 3 çekirdeği kullanan sanal makinedeki aşağıdaki sonuçlar elde 
    edilmiştir:

    $ time ./spin
    200000000

    real	0m6,031s
    user	0m11,695s
    sys	0m0,024s
    $ time ./mutex
    200000000

    real	0m11,915s
    user	0m16,650s
    sys	0m7,002s
---------------------------------------------------------------------------------------------------------------------------*/

/* spin.c */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <pthread.h>

#define MAX_COUNT       100000000

void *thread_proc1(void *param);
void *thread_proc2(void *param);
void exit_sys_errno(const char *msg, int eno);

pthread_spinlock_t g_spinlock;
int g_count;

int main(void)
{
    pthread_t tid1, tid2;
    int result;

    if ((result = pthread_spin_init(&g_spinlock, 0)) != 0)
        exit_sys_errno("pthread_spin_init", result);  

    if ((result = pthread_create(&tid1, NULL, thread_proc1, NULL)) != 0)
        exit_sys_errno("pthread_create", result);  

    if ((result = pthread_create(&tid2, NULL, thread_proc2, NULL)) != 0)
        exit_sys_errno("pthread_create", result);  

    if ((result = pthread_join(tid1, NULL)) != 0)
        exit_sys_errno("pthread_join", result);  

    if ((result = pthread_join(tid2, NULL)) != 0)
        exit_sys_errno("pthread_join", result);  

    if ((result = pthread_spin_destroy(&g_spinlock)) != 0)
        exit_sys_errno("pthread_spin_destroy", result);  

    printf("%d\n", g_count);

    return 0;    
}

void *thread_proc1(void *param)
{
    int result;

    for (int i = 0; i < MAX_COUNT; ++i) {
        if ((result = pthread_spin_lock(&g_spinlock)) != 0)
            exit_sys_errno("pthread_spin_lock", result);

        ++g_count;

        if ((result = pthread_spin_unlock(&g_spinlock)) != 0)
            exit_sys_errno("pthread_spin_unlock", result);
    }
    
    return NULL;
}

void *thread_proc2(void *param)
{
    int result;

    for (int i = 0; i < MAX_COUNT; ++i) {
        if ((result = pthread_spin_lock(&g_spinlock)) != 0)
            exit_sys_errno("pthread_spin_lock", result);

        ++g_count;

        if ((result = pthread_spin_unlock(&g_spinlock)) != 0)
            exit_sys_errno("pthread_spin_unlock", result);
    }

    return NULL;
}

void exit_sys_errno(const char *msg, int eno)
{
    fprintf(stderr, "%s: %s\n", msg, strerror(eno));

    exit(EXIT_FAILURE);
}

/* mutex.c */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <pthread.h>

#define MAX_COUNT       100000000

void *thread_proc1(void *param);
void *thread_proc2(void *param);
void exit_sys_errno(const char *msg, int eno);

pthread_mutex_t g_mutex;

int g_count = 0;

int main(void)
{
    pthread_t tid1, tid2;
    int result;
 
    if ((result = pthread_mutex_init(&g_mutex, NULL)) != 0)
        exit_sys_errno("pthread_mutex_init", result);

    if ((result = pthread_create(&tid1, NULL, thread_proc1, NULL)) != 0)
        exit_sys_errno("pthread_create", result);

    if ((result = pthread_create(&tid2, NULL, thread_proc2, NULL)) != 0)
        exit_sys_errno("pthread_create", result);

    if ((result = pthread_join(tid1, NULL)) != 0)
        exit_sys_errno("pthread_join", result);

    if ((result = pthread_join(tid2, NULL)) != 0)
        exit_sys_errno("pthread_join", result);
        
    printf("%d\n", g_count);

    if ((result = pthread_mutex_destroy(&g_mutex)) != 0)
        exit_sys_errno("pthread_mutex_destroy", result);

    return 0;
}

void *thread_proc1(void *param)
{
    int result;

    for (int i = 0; i < MAX_COUNT; ++i) {
        if ((result = pthread_mutex_lock(&g_mutex)) != 0)
            exit_sys_errno("pthread_mutex_init", result);
    
        ++g_count;    

        if ((result = pthread_mutex_unlock(&g_mutex)) != 0)
            exit_sys_errno("pthread_mutex_init", result);
    }
        
    return NULL;
}

void *thread_proc2(void *param)
{
    int result;

    for (int i = 0; i < MAX_COUNT; ++i) {
        if ((result = pthread_mutex_lock(&g_mutex)) != 0)
                exit_sys_errno("pthread_mutex_init", result);
        
            ++g_count;    

            if ((result = pthread_mutex_unlock(&g_mutex)) != 0)
                exit_sys_errno("pthread_mutex_init", result);
     }

    return NULL;
}

void exit_sys_errno(const char *msg, int eno)
{
    fprintf(stderr, "%s:%s\n", msg, strerror(eno));

    exit(EXIT_FAILURE);
}

/*--------------------------------------------------------------------------------------------------------------------------
    Diğer sık karşılaşılan bir senkronizasyon nesnesi de "reader-writer lock" denilen nesnedir. Bu nesne bir veri yapısından 
    birden fazla thread'in okuma yapmasına izin veren ancak bir threda yazma yapıyorsa diğer thread'lerin okuma ya da yazma 
    yapmasını engelleyen bir senktronizasyon nesnedir. Bu senkronizasyon nesnesinin kullanım amacı şöyle bir örnekle açıklanabilir:
    Elimizde global bir bağlı liste olsun bu bağlı listeye eleman ekleyen bir grup thread, bu bağlı listeden eleman silen bir 
    grup thread ve bu bağlı listede arama yapan bir grup thread söz konusu olsun. Bir thread bağlı listeye eleman eklerken 
    ya da bağlı listeden eleman silerken diğer diğer thread'lerin bu işlemin bitmesini beklemesi gerekir. Benzer biçimde bir thread
    bağlı listede arama yaparken diğer thread'lerin bu arama bitene kadar eleman ekleme silme işlemlerine başlamaması gerekir. 
    Ancak buradaki kritik nokta birden fazla thread'in bağlı liste üzerinde arama yapabilmesinin bir sıkıntıya yol açmayacağıdır. 
    Yani birden fazla thread'in bağlı liste üzerinde arama yapması mümkün hale geitrilmelidir. Aslında bu örnek bağlı listeye 
    eleman ekleme ya da bağlı listeden eleman silme işlemi bir "write" işlemi olarak ele alınabilir. Benzer biçimde bağlı 
    listede eleman arama işlemi de bir "read" işlemi olarak ele alınabilir. O halde bizim sağlamamız gereken durum şöyle özetlenebilir:

    - Bir therad kaynak üzerinde write işlemi yaparken bu işlem bitene kadar diğer thread'ler aynı kaynak üzerinde read ya da 
    write işlemi yapmamalıdır. 

    - Bir thread kaynak üzerinde read işlemi yaparken diğer thread'ler bu işlem bitene kadar kaynak üzerinde WRİTE işlemi yapmamalıdır. 

    - Bir thread kaynak üzerinde read işlemi yaparken diğer thread'ler kaynak üzerinde read işlemi yapabilmelidir.

    Bu koşulları şöyle de özetleyebiliriz:

    write - write   (izin verilmemeli)
    write - read    (izin verilmemeli)
    read - write    (izin verilmemeli)
    read - read     (izin verilmeli)

    Burada açıkladığımız durumu daha önce gördüğümüz senkronizasyon nesneleriyle sağlmanın basit bir yolu yoktur. İşte bunu 
    sağlamak için "reader-writer lock" denilen özel bir senkronizasyon nesnesi kullanılmaktadır. 
    
    Yukarıdaki problemin bir mutex nesnesiyle neden çözülemeyeceğini de açıklamak istiyoruz. Biz mutex kullanırken okuma ve yazma 
    işlemleri sırasında mecburen mutex'in sahipliğini almak zorunda kalacağız. Bu da birden fazla read durumunu engelleyecektir. 
    Örneğin:

    pthread_mutex_lock(&g_mutex);
    ...
    ...         <READ İŞLEMİ>
    ...
    pthread_mutex_unlock(&g_mutex);

    Görüldüğü gibi bir therad kaynak üzerinde read işlemi yapmaya çalıştığı zaman mutex'i kilitlediği için başka bir therad de
    read işlemi yapamayacaktır. 
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Reader-Writer lock nesneleri şu adımlardan geçilerek kullanılmaktadır:

    1) Programcı pthread_rwlock_t türünden global bir nesne tanımlar. Bu tür yine <thread.h> ve <sys/types.h> dosyalarında 
    herhangi bir türdne olabilecek biçimde typedef edilmektedir. Linux sistemlerinde pthread_rwlock_t türü bir yapı belirtmektedir. 
    Örneğin:

    pthread_rwlock_t g_rwlock;

    2) pthread_rwlock_t nesnesine PTHREAD_RWLOCK_INITIALIZER makrosouyla ya da pthread_rwlock_init fonksiyonuyla ilkdeğer verilebilir. 
    pthread_rwlock_init fonksiyonunun prototipi şöyledir:

    #include <pthread.h>

    int pthread_rwlock_init(pthread_rwlock_t *rwlock, const pthread_rwlockattr_t *attr);

    Fonksiyonun birinci parametresi reader-writer lock nesnesinin adresini ikinci parametresi ise onun özellik bilgisini almaktadır. 
    Özellik parametresine NULL adres geçilebilmektedir. Fonksiyon başarı durumunda 0 değeirne, başarısızlık durumunda errno değerine 
    geri dönmektedir. 
    
    Bu durumda nesneye ilkdeğer verme işlemi aşağıdaki iki biçimden biri ile yapılabilir:

    pthread_rwlock_t g_rwlock = PTHREAD_RWLOCK_INITIALIZER;
    ...
    if ((result = pthread_rwlock_init(&g_rwlock, NULL)) != 0)
        exit_sys_errno("pthread_rwlock_init", result);

    3) Okuma amaçlı kritik kod oluşturmak için pthread_rwlock_rdlock fonksiyonu, yazma amaçlı kritik kod oluşturmak için 
    pthread_rwlock_wrlock fonksiyonu kullanılmaktadır. Nesne nasıl kilitlenmiş olursa olsun kilidi açöak için pthread_rwlock_unlock
    fonksiyonu kullanılmaktadır. Bu durumda okuma amaçlı kritik kod aşağıdaki gibi oluştrulmalıdır (kontroller yapılmamıştır):

    pthread_rwlock_rdlock(&g_rwlock);
    .....
    .....       <READ İŞLEMİ>
    .....
    pthread_rwlock_unlock(&g_rwlock);
    
    Yazma amaçlı kritik kod da şöyle oluşturulmalıdır (kontroller yapılmamıştır):

    pthread_rwlock_rwlock(&g_rwlock);
    .....
    .....       <WRITE İŞLEMİ>
    .....
    pthread_rwlock_unlock(&g_rwlock);

    Buradaki fonksiyonların prototipleri şöyledir:

    #include <pthread.h>

    int pthread_rwlock_rdlock(pthread_rwlock_t *rwlock);
    int pthread_rwlock_wrlock(pthread_rwlock_t *rwlock);
    int pthread_rwlock_unlock(pthread_rwlock_t *rwlock);

    Fonksiyonların hepsi reader-writer lock nesnesinin adresini parametre olarak alır. Başarı durumunda 0 değerine, başarısızlık 
    durumunda errno değerine geri döner. 

    4) Nesnenin kullanımı bittikten sonra nesne pthread_rwlock_destroy fonksiyonu ile boşaltılabilir. Fonksiyonun prototipi 
    şöyledir:

    #include <pthread.h>

    int pthread_rwlock_destroy(pthread_rwlock_t *rwlock);

    Fonskiyon reader-writer lock nesnesinin adresini parametre olarak alır, başarı durumunda 0 değerine başarısızlık durumunda 
    errno değerine geri döner. 

    5) Reader-writer lock nesnelerinin de bir özellik bilgisi vardır. Özellik oluşturma daha önce görmüş olduğumuz nesnelerdekine bernzer
    biçimde yapılmaktadır. Önce pthread_rwlockattr_t türünden bir özellik nesnesi tanımlanır. Sonra bu özellik nesnesine 
    pthread_rwlockattr_init fonksiyonu ile ilkdeğer verilir. Sonra da özellik nesnesine pthread_rwlockattr_setxxx fonksiyonlarıyla 
    özellikler iliştirilir. Sonra da bu özellik nesnesi kullanılarak reader-writer lock nesnesi pthread_rwlock_init fonksiyonuyla
    yaratılır. Aslında şu anda nesnenin tek bir özelliği vardır. O da onun prosesler arasında paylaşılabilirliğini 
    belirtmektedir. Nesne default durumda (yani PTHREAD_RWLOCK_INITIALIZER ile yatarıldığında ya da pthread_rwlock_init fonksiyonunda
    özellik parametresi NULL geçildiğinde) prosesler arasında paylaşılamamaktadır. Prosesler arası paylaşım için pthread_rwlock_setpshared
    fonksiyonu kullanılmaktadır.  Bu bilginin alınması için de pthread_rwlock_getpshared fonksiyonu bulunmaktadır. Tabii özellik nesnesinin 
    kullanımı bittikten sonra (yani pthread_rwlock_init fonksiyonu çağrıldıktan sonra) onun pthread_rwlock_destroy fonksiyonu ile 
    boşaltılması gerekmektedir. Buradaki fonksiyonların prototipleri aşağıda verilmiştir

    #include <pthread.h>
    
    int pthread_rwlockattr_init(pthread_rwlockattr_t *attr);
    int pthread_rwlockattr_destroy(pthread_rwlockattr_t *attr);
    int pthread_rwlockattr_setpshared(pthread_rwlockattr_t *attr, int pshared);
    int pthread_rwlockattr_getpshared(const pthread_rwlockattr_t *attr, int *pshared);
    
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Aşağıdaki örnekte dört ayrı thread yaratılmıştır. İki thread okuma amaçlı, iki thread de yazma amaçlı kritik koda girmektedir. 
    Bu örnek bir simülasyon niteliğindedir. Örnekte rastgele beklemeler yapılmıştır. Örnekten görülmesi gereken şey iç içe 
    read işleminin yapılabildiği ancak diğer işlemlerin iç içe yapılamadığıdır. Programın çalıştırılmasında aşağıdakine benzer
    bir çıktı oluşacaktır:

    thread3 ENTERS to critical section for WRITING...
    thread3 EXITS from  critical section...
    thread2 ENTERS to critical section for READING...
    thread1 ENTERS to critical section for READING...
    thread1 EXITS from  critical section...
    thread2 EXITS from  critical section...
    thread4 ENTERS to critical section for WRITING...
    thread4 EXITS from  critical section...
    thread1 ENTERS to critical section for READING...
    thread1 EXITS from  critical section...
    thread3 ENTERS to critical section for WRITING...
    thread3 EXITS from  critical section...
    thread2 ENTERS to critical section for READING...
    thread1 ENTERS to critical section for READING...
    thread2 EXITS from  critical section...
    thread1 EXITS from  critical section...
    ....

---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>
#include <unistd.h>
#include <pthread.h>

void exit_sys_errno(const char *msg, int err);
void *thread_proc1(void *param);
void *thread_proc2(void *param);
void *thread_proc3(void *param);
void *thread_proc4(void *param);

pthread_rwlock_t g_rwlock = PTHREAD_RWLOCK_INITIALIZER;

int main(void)    
{
    int result;
    pthread_t tid1, tid2, tid3, tid4;

    if ((result = pthread_create(&tid1, NULL, thread_proc1, NULL)) != 0) 
        exit_sys_errno("pthread_create", result);
    
    if ((result = pthread_create(&tid2, NULL, thread_proc2, NULL)) != 0) 
        exit_sys_errno("pthread_create", result);
    
    if ((result = pthread_create(&tid3, NULL, thread_proc3, NULL)) != 0) 
        exit_sys_errno("pthread_create", result);
    
    if ((result = pthread_create(&tid4, NULL, thread_proc4, NULL)) != 0) 
        exit_sys_errno("pthread_create", result);
    
    if ((result = pthread_join(tid1, NULL)) != 0)
        exit_sys_errno("pthread_join", result);

    if ((result = pthread_join(tid2, NULL)) != 0)
        exit_sys_errno("pthread_join", result);

    if ((result = pthread_join(tid3, NULL)) != 0)
        exit_sys_errno("pthread_join", result);

    if ((result = pthread_join(tid4, NULL)) != 0)
        exit_sys_errno("pthread_join", result);

    pthread_rwlock_destroy(&g_rwlock);

    return 0;
}

void exit_sys_errno(const char *msg, int err)
{
    fprintf(stderr, "%s: %s\n", msg, strerror(err));
    exit(EXIT_FAILURE);
}

void *thread_proc1(void *param)
{
    int result;
    int seedval;

    seedval = (unsigned int)time(NULL) + 12345;

    for (int i = 0; i < 10; ++i) {
        usleep(rand_r(&seedval) % 300000);

        if ((result = pthread_rwlock_rdlock(&g_rwlock)) != 0)
            exit_sys_errno("pthread_rwlock_rdlock", result);

        printf("thread1 ENTERS to critical section for READING...\n");

        usleep(rand_r(&seedval) % 300000);

        printf("thread1 EXITS from  critical section...\n");

        if ((result = pthread_rwlock_unlock(&g_rwlock)) != 0)
            exit_sys_errno("pthread_rwlock_rdlock", result);
    }

    return NULL;
}

void *thread_proc2(void *param)
{
    int result;
    int seedval;

    seedval = (unsigned int)time(NULL) + 23456;

    for (int i = 0; i < 10; ++i) {
        usleep(rand_r(&seedval) % 300000);

        if ((result = pthread_rwlock_rdlock(&g_rwlock)) != 0)
            exit_sys_errno("pthread_rwlock_rdlock", result);

        printf("thread2 ENTERS to critical section for READING...\n");

        usleep(rand_r(&seedval) % 300000);

        printf("thread2 EXITS from  critical section...\n");

        if ((result = pthread_rwlock_unlock(&g_rwlock)) != 0)
            exit_sys_errno("pthread_rwlock_rdlock", result);
    }

    return NULL;
}

void *thread_proc3(void *param)
{
    int result;
    int seedval;

    seedval = (unsigned int)time(NULL) + 35678;

    for (int i = 0; i < 10; ++i) {
        usleep(rand_r(&seedval) % 300000);

        if ((result = pthread_rwlock_wrlock(&g_rwlock)) == -1)
            exit_sys_errno("pthread_rwlock_rdlock", result);

        printf("thread3 ENTERS to critical section for WRITING...\n");

        usleep(rand_r(&seedval) % 300000);

        printf("thread3 EXITS from  critical section...\n");

        if ((result = pthread_rwlock_unlock(&g_rwlock)) == -1)
            exit_sys_errno("pthread_rwlock_rdlock", result);
    }

    return NULL;
}

void *thread_proc4(void *param)
{
    int result;
    int seedval;

    seedval = (unsigned int)time(NULL) + 356123;

    for (int i = 0; i < 10; ++i) {
        usleep(rand_r(&seedval) % 300000);

        if ((result = pthread_rwlock_wrlock(&g_rwlock)) == -1)
            exit_sys_errno("pthread_rwlock_rdlock", result);

        printf("thread4 ENTERS to critical section for WRITING...\n");

        usleep(rand_r(&seedval) % 300000);

        printf("thread4 EXITS from  critical section...\n");

        if ((result = pthread_rwlock_unlock(&g_rwlock)) == -1)
            exit_sys_errno("pthread_rwlock_rdlock", result);
    }

    return NULL;
}

/*--------------------------------------------------------------------------------------------------------------------------
    İşlemcileri CISC (Complex Intruction Set Computing) ve RISC (Reduced Instruction Set Computing) olmak üzere iki sınıfa 
    ayırabiliriz. Tabii bu iki sınıf aslında bir spektrumdur. Yani işlemciler bir tarafı CISC olan diğer tarafı RISC olan 
    bu spektrumda herhangi bir yerde olabilirler. Intel X86 işlemcileri CISC işlemlerine örnek oluştururken ARM işlemcileri 
    RISC işlemlerine bir örnek oluşturmaktadır. İki işlemci ailesi arasında temel farklılıklar şunlardır:

    - CISC işlemlerinde çok sayıda makine komutu vardır. Bu komutların bazıları karmaşık işlemler yapmaktadır. Ancak RISC 
    işlemcilerinde az sayıda makine komutu daha etkin çalışacak biçimde tasarlanmıştır. 

    - CISC işlemcilerinde makine komutları değişik uzunlukta olabilmektedir. Ancak CISC işlemcilerinde tüm makine komutları 
    aynı uzunluktadır. 

    - CISC işlemcilerinde genel amaçlı az sayıda CPU yazmacı vardır. Ancak RISC işlemcilerinde çok sayıda genel amaçlı CPU yazmacı 
    bulunmaktadır. 

    - CISC işlemcilerinde komutlar değişik çalışma sürelerine sahiptir. Ancak RISC işlemcilerinde genellikle aynı çalışma süresine 
    sahiptir.

    - RISC işlemcilerinde pipieline işlemleri CISC işlemcilerine göre daha etkin yapılabilmektedir. 

    - CISC işlemcilerinde doğrudan bellek üzerinde işlem yapan makine kaomutları bulunmaktadır. RISC işlemcilerine ise "load/store"
    işlemcileri denilmektedir. Bellek üzerinde dorudan işlemler yapılmaz. Her zmana bellekteki nesneler önce CPU yazmaçlarına çekilir. 

    - CISC işlemcilerinde genel olarak makine komutlarının iki operandı bulunur. İşlem sonrasında işleme giren bir yazmacın değeri 
    bozulmaktadır. Ancak RISC işlemcilerinde makine komutlarının genel olarak üç operand'ı bulunmaktadır. İşlem sonucu operand'ları
    bozmamaktadır.

    - CISC işlemcileri daha fazla güç harcama eğilimdedir. Ancak RISC işlemcileri daha az güç harcama eğilimindedir. 

    Bugün artık RISC tarasımının daha iyi bir tasarım olduğu kabul edilmektedir. Ancak Intel x(6 serisi gibi gibi bazı işlemciler 
    çok yaygın kullanıldığı için halen CISC mimarisini devam ettirmektedir. 
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Bugün çok işlemcili ve çok çekirdekli sistemlerde işlemci-bellek bağlantısında iki mimari kullanılmaktadır: 
    
    - SMP (symmetric Multiprocessor) Mimarisi
    - NUMA (Nun Unified Memory Access) Mimarisi 

    SMP mimarisi pek işlemci tarafından default olarak kullanılan mimaridir. Bu mimnaride işlemciler ya da çekirdekler 
    aynı RAM'e erişmektedir. Dolayısıyla bus çakışmasını ortadan kaldırmak için bir işlemci ya da çeekirdek RAM'e erişirken 
    diğerleri onun işini bitirmesini beklemektedir. Dolayısıyla bu mimaride aslında işlemci ya da çekirdek sayısı arttıkça
    bus çakışmaları da artar ve performans düşe başlar. Tabii bu mimaride her işlemcinin ve çekirdeğin ayrı bir cache sistemi de
    bulunmaktadır. Bu işlemciler ya da çekirdekler önce bu cache sistemine başvurmakta bilgi orada yoksa RAM'e başvurmaktadırlar. 
    Tabii cache tutarlılığı (cache consistency) da donanımsal olarak sağlanmaktadır. 

    NUMA mimarisinde her işlemcinin ya da her çekirdeğin RAM'de bağımsız olarak erişebileceği ayrı bir bank'ı vardır. Her işlemci
    ya da çekirdek kendi bank'ına hızlı erişir ancak diğer işlemcilerin ya da çekirdeklerin bank'larına yavaş erişir. Bu nedenle 
    işlemcilerin ve çekirdeklerin belleğe erişim süreleri erişitirkleri yere bağlı olarak (non unified) değişebilmektedir. 
    Bugün NUMA mşmarisini kullanan işlemciler ve board'lar oldukça azdır. örneğin Intel Xeon, AMD  EPYC, Opertorn gibi işlemciler
    NUMA kullanmaktadır. 
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Thread'ler dünyasında "atomiklik (atomicity)" bir işlemin kesilmeden tel parça halinde yapılmasına denilmektedir. Atomik 
    işlemler tek bir parça halinde therad'ler arası geçiş oluşmadan yapılan işlemlerdir. Pekiyi makine komutları atomik midir?
    Genel olarak makine komutlarının atomik olduğunu söyleyebiliriz. Yani bir makine komutu çalıştırılırken kesilme olmaz. 
    Bir makine komutu çalıştırılırken çalıştırmanın ortasında therad'ler arası geçiş oluşamaz. Çünkü thread'ler arası geçiş 
    donanım kesmeleriyle sağlanmaktadır. Donanım kesmeleri de ancak makine komutlarının arasında etkili olabilmektedir. 

    Pekiyi iki işlemci ya da çekirdek aynı global değişkeni aynı anda değiştirmek isteseler ne olur? Burada normalde 
    hangisi bu işlemi geç yaparsa o değişkende o değer gözükecektir. Peki aynı anda bu işlemi yaparlarsa ne olacaktır? 
    Her ne kadar işlemciler ya da çekirdekler RAM'e erişirken diğerleri onu bekliyorsa da (yani erişim aslında aynı anda 
    gerçeklemiyorsa da) yine de özel bazı durumlarda değişkende bozulmalar olabilmektedir. Şöyle ki, aşağıdaki gibi bir
    INTEL makine komutunu düşünelim:

    INC g_count

    Bu komut çalışırken her ne kadar thread'ler arası geçiş oluşmayacak olsa da maalesef duruma INTEL işlemcisi ya da çekirdeği
    bu işlem sırasında işlemin başından sonuna kadar BUS'ı tutup işlemi atomik yapmamaktadır. Bu tarz işlemlerde INTEL işlemcileri 
    bus'ı tutup bırakmakta yeniden tutup bırakmakta yani birden fazla kes kesikli bir biçimde bus'ı tutup bırakabilmektedir. 
    İşte bu işlemler sırasında başka bir işlemci ya da çekirdek bus'ın kontrolünü alıp oaraya bir şeyler yazmak isteyebilir. 
    Bu durumda o nesnede bozuk bir değer oluşabilir. Tabii bunun olasılığı çok düşüktür. Ancak böyle bir olasılık söz konusu olmaktadır. 
    Şimdi INTEL mimarisinde iki ayrı çekirdeğin aynı global değişkene tek bir makine komutuyla atama yaptığını düşünelim:

    Birinci Çekirdek

    MOV g_val, 100

    İkinci Çekirdek 

    MOV g_val, 200

    Burada g_val içerisinde 100 ya da 200 olması normal karşılanaacak bir durumdur. Ancak bozuk bir değeirn bulunması istenemeyen
    bir durumdur. İşte INTEL işlemcilerinde buradaki g_val belleğe düzgün hizalanmamışsa böyle riskli bir durum oluşabilmektedir. 

    Tabii işlemciler genellikle bu biçimdeki erişimlerde makine komutlarının sonuna kadar bus'ın tutulması için de olanak sağlamaktadır. 
    Örneğin INTEL işlemcilerinde komutun başına LOCK prefix'i sayesinde işlemci baştan sona kadar bus'ı tutabilmektedir:

    LOCK INC g_val

    Tabii buradaki LOCK prefix'i komutu yavaşlatmaktadır. Bu durumda derleyiciler böyle bir prefix'i default durumda kullanmazlar. 

    Biz daha önce iki thread'in aynı global değişkeni artırmasına yönelik bir örnek yapmıştık:

    for (int i = 0; i < 1000000; ++i)
        ++g_count;

    Elimizde C derleyicilrinin çoğu bu artırım işlemini tek bir makine komutuyla değil üç ayrı makine komutuyla yapmaktadır. 
    Çünkü aslında bu üç ayrı makine komutu doğrudan belleği artıran makine komutundan daha hızlı çalışmaktadır:

    MOV reg, g_count
    INC reg
    MOV g_count, reg

    Tabii artık artırma işlemi atomik olmadığı için therad'ler arası geçiş değişkende bozulma yaratacaktır. Biz bu bozulmayı 
    engellemek için krtik kod bloğu oluşturmuştuk. Pekiyi derleyicimiz yukarıdaki artırma için yavaş olmasına karşın tek bir makine 
    komutu üretseydi bu durumda bozulma oluşur muydu?

    INC g_count

    İşte koşullara bağlık olarak olasılık düşük olsa bile bu durumda bozulma olasılığı yşne vardır. Tabii derleyicimiz tek bir 
    makine komutu ile bu işlemi yapıp komutun başına da LOCK gibi bir prefix getirseydi bu duurmda bir sorun oluşmazdı:

    LOCK INC g_count

    Burada öneml nok şudur: Aslında biz tek bir makine komutu ile yapılacak bazı işlemlerin atomik bir biçimde yapılmasını sağlayabiliriz. 
    Ancak derleyicimiz bunu bizim için sağlayamamaktadır. Bazı C derleyicilerinde C ile yazarken arada sembolik makine kodlarını 
    kullanabilmekteyiz. Bu kullanım derleyiciye özgüdür ve bu kullanımın ismine "inline assembly" denilmektedir. Ancak "inline assembly"
    yazmak zahmetlidir va makine dili bilgisi gerektirmektedir. 
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
     İşte gcc derleyicisi artırıma, eksiltme ve karşılaştırma gibi basit işlemlerin atomik bir biçimde yapılabilmesi için özel 
    built-in (intrinsic) fonksiyonlar bulundurmuştur. Build-in fonksiyonlar gcc tarafından doğrudan tanınıp bir makro gibi bunlar 
    için kısa kodlar üretilebilmektedir. gcc'deki atomik builtin fonksiyonlar __sync_xxx biçiminde isimlendirilmiştir. Bunlar builtin
    olduğu için prototip gereksinimleri yoktur. Ancak daha sonra gcc C++11'deki atomik semantiğini uygulayabilmek için bu builtin
    fonksiyonları __atomic_xxx ismiyle yenilemiştir. Bu yeni versiyonlar ekstra "memory order" parametresi almaktadır. 

    Aşağıdak örnekte iki thread aynı global değişkeni hiç mutex ile kritik kod oluşturmadan atomik bir biçimde artırmaktadır. 
    Bu işlem 1000000000 döngü için 25.9 saniye sürmüştür. Aynı programın mutex versiyonu ise 4 dakika 11 saniye sürmüştür.
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <pthread.h>

#define SIZE        1000000000

void exit_sys_thread(const char *msg, int err);
void *thread_proc1(void *param);
void *thread_proc2(void *param);

int g_count;

int main(void)    
{
    int result;
    pthread_t tid1, tid2;

    if ((result = pthread_create(&tid1, NULL, thread_proc1, NULL)) != 0) 
        exit_sys_thread("pthread_create", result);
    
    if ((result = pthread_create(&tid2, NULL, thread_proc2, NULL)) != 0) 
        exit_sys_thread("pthread_create", result);
    
    if ((result = pthread_join(tid1, NULL)) != 0)
        exit_sys_thread("pthread_join", result);

    if ((result = pthread_join(tid2, NULL)) != 0)
        exit_sys_thread("pthread_join", result);

    printf("%d\n", g_count);

    return 0;
}

void exit_sys_thread(const char *msg, int err)
{
    fprintf(stderr, "%s: %s\n", msg, strerror(err));
    exit(EXIT_FAILURE);
}

void *thread_proc1(void *param)
{
    int i;

    for (i = 0; i < SIZE; ++i) {
         __sync_fetch_and_add(&g_count, 1);
    }

    return NULL;
}

void *thread_proc2(void *param)
{
    int i;

    for (i = 0; i < SIZE; ++i) {
        __sync_fetch_and_add(&g_count, 1);
    }

    return NULL;
}

/*--------------------------------------------------------------------------------------------------------------------------
    Yukarıdaki programın __atomic_xxx builtin fonksiyonları ile eşdeğeri aşağıdadır. __atomic_xxx fonksiyonlarının son 
    parametresi olan "memory order" için __ATOMIC_SEQ_CST kullanılmıştır. Bu parametre __sync_xxx ile aynı semantiği sağlamaktadır.
    Buradaki memory order parametresi için ilgi dokümanlara başvurabilirsiniz.
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <pthread.h>

#define SIZE        1000000000

void exit_sys_thread(const char *msg, int err);
void *thread_proc1(void *param);
void *thread_proc2(void *param);

int g_count;

int main(void)    
{
    int result;
    pthread_t tid1, tid2;

    if ((result = pthread_create(&tid1, NULL, thread_proc1, NULL)) != 0) 
        exit_sys_thread("pthread_create", result);
    
    if ((result = pthread_create(&tid2, NULL, thread_proc2, NULL)) != 0) 
        exit_sys_thread("pthread_create", result);
    
    if ((result = pthread_join(tid1, NULL)) != 0)
        exit_sys_thread("pthread_join", result);

    if ((result = pthread_join(tid2, NULL)) != 0)
        exit_sys_thread("pthread_join", result);

    printf("%d\n", g_count);

    return 0;
}

void exit_sys_thread(const char *msg, int err)
{
    fprintf(stderr, "%s: %s\n", msg, strerror(err));
    exit(EXIT_FAILURE);
}

void *thread_proc1(void *param)
{
    int i;

    for (i = 0; i < SIZE; ++i) {
         __atomic_add_fetch(&g_count, 1, __ATOMIC_SEQ_CST);
    }

    return NULL;
}

void *thread_proc2(void *param)
{
    int i;

    for (i = 0; i < SIZE; ++i) {
        __atomic_add_fetch(&g_count, 1, __ATOMIC_SEQ_CST);
    }

    return NULL;
}

/*--------------------------------------------------------------------------------------------------------------------------
    C'nin 2011 revizyonunda (C11) dile _Atomic isminde bir tür niteleyicisi (type qualifier) eklenmiştir. Bir nesne bu niteleyici ile
    bildirilirse +=, -=, |= gibi işlemler thread güvenli bir biçimde atomik olarak gerçekleştirilmeketdir. Aşağıdaki programda
    bu özellik kullanılmıştır. _Atomic anahtar sözcüğü C11 ile geldiği için gcc derlemesinde -std=c11 ya da -std=c17 seçeneğini
    bulundurunuz.
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <pthread.h>

#define SIZE        10000000

void exit_sys_thread(const char *msg, int err);
void *thread_proc1(void *param);
void *thread_proc2(void *param);

_Atomic int g_count;

int main(void)    
{
    int result;
    pthread_t tid1, tid2;

    if ((result = pthread_create(&tid1, NULL, thread_proc1, NULL)) != 0) 
        exit_sys_thread("pthread_create", result);
    
    if ((result = pthread_create(&tid2, NULL, thread_proc2, NULL)) != 0) 
        exit_sys_thread("pthread_create", result);
    
    if ((result = pthread_join(tid1, NULL)) != 0)
        exit_sys_thread("pthread_join", result);

    if ((result = pthread_join(tid2, NULL)) != 0)
        exit_sys_thread("pthread_join", result);

    printf("%d\n", g_count);

    return 0;
}

void exit_sys_thread(const char *msg, int err)
{
    fprintf(stderr, "%s: %s\n", msg, strerror(err));
    exit(EXIT_FAILURE);
}

void *thread_proc1(void *param)
{
    int i;

    for (i = 0; i < SIZE; ++i) {
        ++g_count;
    }

    return NULL;
}

void *thread_proc2(void *param)
{
    int i;

    for (i = 0; i < SIZE; ++i) {
        ++g_count;
    }

    return NULL;
}

/*--------------------------------------------------------------------------------------------------------------------------
    C++'ta <atomic> başlık dosyası içerisindeti template atomic sınıfı atomik işlemler yapmaktadır. Aşağıda bu sınıf kullanılarak
    C++ örneği verilmiştir.
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <pthread.h>
#include <atomic>

#define SIZE        10000000

void exit_sys_thread(const char *msg, int err);
void *thread_proc1(void *param);
void *thread_proc2(void *param);

using namespace std;

atomic<int> g_count;

int main(void)    
{
    int result;
    pthread_t tid1, tid2;

    if ((result = pthread_create(&tid1, NULL, thread_proc1, NULL)) != 0) 
        exit_sys_thread("pthread_create", result);
    
    if ((result = pthread_create(&tid2, NULL, thread_proc2, NULL)) != 0) 
        exit_sys_thread("pthread_create", result);
    
    if ((result = pthread_join(tid1, NULL)) != 0)
        exit_sys_thread("pthread_join", result);

    if ((result = pthread_join(tid2, NULL)) != 0)
        exit_sys_thread("pthread_join", result);

    printf("%d\n", (int)g_count);

    return 0;
}

void exit_sys_thread(const char *msg, int err)
{
    fprintf(stderr, "%s: %s\n", msg, strerror(err));
    exit(EXIT_FAILURE);
}

void *thread_proc1(void *param)
{
    int i;

    for (i = 0; i < SIZE; ++i) {
        ++g_count;
    }

    return NULL;
}

void *thread_proc2(void *param)
{
    int i;

    for (i = 0; i < SIZE; ++i) {
        ++g_count;
    }

    return NULL;
}

/*--------------------------------------------------------------------------------------------------------------------------
    C'nin stdio dosya fonksiyonları POSIX sistemlerinde (fakat standart C'de değil) zaten thread güvenlidir. Dolayısıyla iki 
    thread aynı dosyaya yazma ya da okuma yaparken programcının fwrite, fread gibi fonksiyonları senkronize etmesine gerek yoktur. 
    Aşağıdaki programda iki thread aynı dosyaya fwrite fonksiyonlarıyla 0'dan SIZE'a kadar int değerleri yazmaktadır. Thread'lerdne biri
    tek sayıları yazarken diğeri çift sayıları yazmaktadır. İşlemin sonunda yazma işleminde bir sorun olup olmadığı test edilmiştir.

    Her ne kadar standart C'nin stdio fonksiyonları POSIX sistemlerinde thread güvenli olsa da yine de birden fazla art arda çağrılarda 
    senkronizasyon sorunları ortaya çıkabilir. Örneğin iki thread fseek uyguladıktan sonra fwrite işlemi yapsa thread'lerdne biri 
    istemediği bir bölgeye yazma yapabilir. Bu durumda bit mutex koruması düşünülebilir. Ancak POSIX sistemlerinde içsel olarak böyle
    bir mutex kontrolü düşünülmüştür. flockfile ile bir stdio dosyasını kilitlersek funlockfile uygulayana kadar başka bir thread
    bu dosya üzerinde işlem yapmak istediğinde blokede beklemektedir. 
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <pthread.h>

#define SIZE        1000000

FILE *g_f;

void exit_sys_thread(const char *msg, int err);
void *thread_proc1(void *param);
void *thread_proc2(void *param);
int check(void);

int main(void)    
{
    int result;
    pthread_t tid1, tid2;
    int i;

    if ((g_f = fopen("test.dat", "w+")) == NULL) {
        perror("fopen");
        exit(EXIT_FAILURE);
    }

    if ((result = pthread_create(&tid1, NULL, thread_proc1, NULL)) != 0) 
        exit_sys_thread("pthread_create", result);
    
    if ((result = pthread_create(&tid2, NULL, thread_proc2, NULL)) != 0) 
        exit_sys_thread("pthread_create", result);
    
    if ((result = pthread_join(tid1, NULL)) != 0)
        exit_sys_thread("pthread_join", result);

    if ((result = pthread_join(tid2, NULL)) != 0)
        exit_sys_thread("pthread_join", result);

    printf(check() ? "success...\n" : "failed...\n");

    
    return 0;
}

void exit_sys_thread(const char *msg, int err)
{
    fprintf(stderr, "%s: %s\n", msg, strerror(err));
    exit(EXIT_FAILURE);
}

void *thread_proc1(void *param)
{
    int i;

    for (i = 0; i < SIZE; i += 2)
        if (fwrite(&i, sizeof(int), 1, g_f) != 1) {
            perror("fwrite");
            exit(EXIT_FAILURE);
        }

    return NULL;
}

void *thread_proc2(void *param)
{
    int i;

    for (i = 1; i < SIZE; i += 2)
        if (fwrite(&i, sizeof(int), 1, g_f) != 1) {
            perror("fwrite");
            exit(EXIT_FAILURE);
        }
    return NULL;
}


int check(void)
{
    char flags[SIZE] = {0};
    int val;
    int i;

    rewind(g_f);
    while (fread(&val, sizeof(int), 1, g_f) == 1) {
        if (flags[val])
            return 0;
        flags[val] = 1;
    }

    if (ferror(g_f)) {
        perror("fread");
        exit(EXIT_FAILURE);
    }

    for (i = 0; i < SIZE; ++i)
        if (!flags[i])
            return 0;

    return 1;
}

/*--------------------------------------------------------------------------------------------------------------------------
    Bir proses birtakım thread'ler yarattıktan sonra fork işlemi yaparsa alt proses her zaman tek bir thread ile çalışmaya devam
    eder. O da üst prosesin fork işleminin yapıldığı thread'tir.
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/wait.h>
#include <pthread.h>

void exit_sys(const char *msg);
void exit_sys_thread(const char *msg, int err);
void *thread_proc1(void *param);
void *thread_proc2(void *param);

int main(void)    
{
    int result;
    pthread_t tid1, tid2;
    pid_t pid;

    if ((result = pthread_create(&tid1, NULL, thread_proc1, NULL)) != 0) 
        exit_sys_thread("pthread_create", result);
    
    if ((result = pthread_create(&tid2, NULL, thread_proc2, NULL)) != 0) 
        exit_sys_thread("pthread_create", result);

    if ((pid = fork()) == -1) 
        exit_sys("fork");

    if (pid != 0)
        printf("parent process\n");
    else
    {
        printf("child process\n");
        pthread_exit(NULL);
    }

    if ((result = pthread_join(tid1, NULL)) != 0)
        exit_sys_thread("pthread_join", result);

    if ((result = pthread_join(tid2, NULL)) != 0)
        exit_sys_thread("pthread_join", result);

    if (waitpid(pid, NULL, 0) == -1)
        exit_sys("waitpid");
    
    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

void exit_sys_thread(const char *msg, int err)
{
    fprintf(stderr, "%s: %s\n", msg, strerror(err));
    exit(EXIT_FAILURE);
}

void *thread_proc1(void *param)
{
    int i;

    for (i = 0; i < 20; ++i) {
        printf("thread-1: %d\n", i);
        sleep(1);
    }

    return NULL;
}

void *thread_proc2(void *param)
{
    int i;

    for (i = 0; i < 20; ++i) {
        printf("thread-2: %d\n", i);
        sleep(1);
    }
  
    return NULL;
}

/*--------------------------------------------------------------------------------------------------------------------------
    Bir C programının exit fonksiyonuyla ya da main fonksiyonun bitmesiyle sonlandığını biliyorsunuz. Ancak programın ana thread'i
    pthread_exit fonksiyonuyla sonlandırılabilir. Bu durumda proses onun son thread'i sonlandığında sonlandırılır. 

    Aşağıdaki programda fork işlemi ana thread'te değil başka bir thread'te uygulanmıştır. Alt proses tek bir thread'le çalışmaya
    başlayacakltır. O da fork fonksiyonunu uygulayan thread'tir. Programın çıktısını inceleyiniz.
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/wait.h>
#include <pthread.h>

void exit_sys(const char *msg);
void exit_sys_thread(const char *msg, int err);
void *thread_proc1(void *param);
void *thread_proc2(void *param);

int main(void)    
{
    int result;
    pthread_t tid1, tid2;

    if ((result = pthread_create(&tid1, NULL, thread_proc1, NULL)) != 0) 
        exit_sys_thread("pthread_create", result);
    
    if ((result = pthread_create(&tid2, NULL, thread_proc2, NULL)) != 0) 
        exit_sys_thread("pthread_create", result);

    if ((result = pthread_join(tid1, NULL)) != 0)
        exit_sys_thread("pthread_join", result);

    if ((result = pthread_join(tid2, NULL)) != 0)
        exit_sys_thread("pthread_join", result);

    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

void exit_sys_thread(const char *msg, int err)
{
    fprintf(stderr, "%s: %s\n", msg, strerror(err));
    exit(EXIT_FAILURE);
}

void *thread_proc1(void *param)
{
    int i;
    pid_t pid;

    for (i = 0; i < 20; ++i) {
        printf("thread-1: %d\n", i);
        if (i == 10) {
              if ((pid = fork()) == -1) 
                exit_sys("fork");
        } 
        sleep(1);
    }

    if (pid != 0 && waitpid(pid, NULL, 0) == -1)
        exit_sys("waitpid");
    
    return NULL;
}

void *thread_proc2(void *param)
{
    int i;

    for (i = 0; i < 20; ++i) {
        printf("thread-2: %d\n", i);
        sleep(1);
    }
  
    return NULL;
}

/*--------------------------------------------------------------------------------------------------------------------------
    Aslında çok thread'li proseslerde fork işlemi organizasyonel bakımdan karmaşık birtakım sonuçlar doğurmaktadır. 
    Bu nedenle çok thread'li uygulamalarda ya fork yapılmamalı ya da fork yapılacaksa alt proseste hemen exec uygulanmalıdır. 

    Bir proses birtakım thread'ler yarattıktan sonra herhangi bir thread'te exec işlemi uygularsa programın bütün bellek alanı
    boşaltılacağına göre exec yapılan prog tek bir thread'le çalışmasına devam edecekt.r exec işlemi başarı durumunda exec işlemini uygulayan
    thread dışında prosesin bütün thread'lerini otomatik olarak yok etmektedir. Yani exec işlemi sonucunda exec edilen kod her zaman
    tek bir thread'le çalışmaya başlar.
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/wait.h>
#include <pthread.h>

void exit_sys(const char *msg);
void exit_sys_thread(const char *msg, int err);
void *thread_proc1(void *param);
void *thread_proc2(void *param);

int main(void)    
{
    int result;
    pthread_t tid1, tid2;

    if ((result = pthread_create(&tid1, NULL, thread_proc1, NULL)) != 0) 
        exit_sys_thread("pthread_create", result);
    
    if ((result = pthread_create(&tid2, NULL, thread_proc2, NULL)) != 0) 
        exit_sys_thread("pthread_create", result);

    if ((result = pthread_join(tid1, NULL)) != 0)
        exit_sys_thread("pthread_join", result);

    if ((result = pthread_join(tid2, NULL)) != 0)
        exit_sys_thread("pthread_join", result);

    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

void exit_sys_thread(const char *msg, int err)
{
    fprintf(stderr, "%s: %s\n", msg, strerror(err));
    exit(EXIT_FAILURE);
}

void *thread_proc1(void *param)
{
    int i;
    pid_t pid;

    for (i = 0; i < 20; ++i) {
        printf("thread-1: %d\n", i);
        if (i == 10) {
            if ((pid = fork()) == -1) 
                exit_sys("fork");
            if (pid == 0)
                if (execlp("ls", "ls", "-l", (char *)NULL) == -1)
                    exit_sys("execlp");
            /* unreachable code */
        } 
        sleep(1);
    }

    if (pid != 0 && waitpid(pid, NULL, 0) == -1)
        exit_sys("waitpid");
    
    return NULL;
}

void *thread_proc2(void *param)
{
    int i;

    for (i = 0; i < 20; ++i) {
        printf("thread-2: %d\n", i);
        sleep(1);
    }
  
    return NULL;
}

/*--------------------------------------------------------------------------------------------------------------------------
    Thread'li programların exec işlemi dışında fork yapması organizasyonel birtakım problemler doğurabilmektedir. Üst proseste birtakım
    senkronizasyon nesneleri varsa alt prosese bu senkronizasyon nesneleri akratıldığı için organizasyonel sorunlar oluşabilmektedir.
     Çünkü üst proses fork işlemi sırasına bazı senkronizasyon nesnelerini kilitlemiş olabilir. 
    Bu senkronizasyon nesneleri kilitli bir biçimde alt prosese aktarıldığında alt proseste kilitlenmelere (deadlocks) yol açabilemektedir. 
    Bu nedenle üst prosesteki bu senkronizasyon nesnelerinin kararlı bir durumda alt prosese aktarılabilmesi için pthread_atfork isimli bir POSIX
    fonksiyonu düşünülmüştür. Bu fonksiyonun "prepare", "parent" ve "child" biçiminde üç fonksiyon göstericisi parametresi vardır. prepare ile belirtilen
    fonksiyon fork işleminin hemen öncsinde öncesinde üst proses tarafından otomatik çalıştırılır. Programcının bu fonksiyonda tüm senkronizasyon ensnelerini 
    kilitlemesi uygun olur. parent isimli fonksiyon fork sonrasında üset proses tarafından child isimli fonksiyon ise fork işlemi sonrasında alt proses 
    tarafından çalıştırılır. Her iki fonksiyonda da programcının bu kilitlediği senkronizasyon nesnelerini açması beklenmektedir. Böylece hiç olmazsa
    alt proseste fork sonrasında bütün senkronizasyon nesnelerinin açık bir biçimde olacağı garanti edilmiş olur. Aşağıdaki örnekte bu semantik uygulanmıştır. 
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/wait.h>
#include <pthread.h>

void exit_sys(const char *msg);
void exit_sys_thread(const char *msg, int err);
void *thread_proc1(void *param);
void *thread_proc2(void *param);

void prepare(void);
void parent(void);
void child(void);

pthread_mutex_t g_mutex1 = PTHREAD_MUTEX_INITIALIZER;
pthread_mutex_t g_mutex2 = PTHREAD_MUTEX_INITIALIZER;

int main(void)    
{
    int result;
    pthread_t tid1, tid2;

    if ((result = pthread_atfork(prepare, parent, child)) != 0)
        exit_sys_thread("pthread_atfork", result);

    if ((result = pthread_create(&tid1, NULL, thread_proc1, NULL)) != 0) 
        exit_sys_thread("pthread_create", result);
    
    if ((result = pthread_create(&tid2, NULL, thread_proc2, NULL)) != 0) 
        exit_sys_thread("pthread_create", result);

    if ((result = pthread_join(tid1, NULL)) != 0)
        exit_sys_thread("pthread_join", result);

    if ((result = pthread_join(tid2, NULL)) != 0)
        exit_sys_thread("pthread_join", result);

    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

void exit_sys_thread(const char *msg, int err)
{
    fprintf(stderr, "%s: %s\n", msg, strerror(err));
    exit(EXIT_FAILURE);
}

void *thread_proc1(void *param)
{
    int i;
    pid_t pid;

    for (i = 0; i < 20; ++i) {
        printf("thread-1: %d\n", i);
        if (i == 10) {
            if ((pid = fork()) == -1) 
                exit_sys("fork");
            /* unreachable code */
        } 
        sleep(1);
    }

    if (pid != 0 && waitpid(pid, NULL, 0) == -1)
        exit_sys("waitpid");
    
    return NULL;
}

void *thread_proc2(void *param)
{
    int i;

    for (i = 0; i < 20; ++i) {
        printf("thread-2: %d\n", i);
        sleep(1);
    }
  
    return NULL;
}

void prepare(void)
{
    int result;

    printf("prepared...\n");

    if ((result = pthread_mutex_lock(&g_mutex1)) != 0)
        exit_sys_thread("pthread_mutex_lock", result);

    if ((result = pthread_mutex_lock(&g_mutex2)) != 0)
        exit_sys_thread("pthread_mutex_lock", result);
}

void parent(void)
{
    int result;

    printf("parent\n");

    if ((result = pthread_mutex_unlock(&g_mutex1)) != 0)
        exit_sys_thread("pthread_mutex_unlock", result);

    if ((result = pthread_mutex_unlock(&g_mutex2)) != 0)
        exit_sys_thread("pthread_mutex_lock", result);
}

void child(void)
{
    int result;

    printf("child\n");

    if ((result = pthread_mutex_unlock(&g_mutex1)) != 0)
        exit_sys_thread("pthread_mutex_unlock", result);

    if ((result = pthread_mutex_unlock(&g_mutex2)) != 0)
        exit_sys_thread("pthread_mutex_lock", result);
}

/*--------------------------------------------------------------------------------------------------------------------------
    Global ya da static yerel nesne kullanan fonksiyonlar thread güvenli değildir. Bunları prototiplerini değiştirmeden 
    thread güvenli yapabilmek için thread'e özgü global değişken etkisinin yaratılması gerekir. İşte işletim sistemleri bu tür
    thread güvenli kodların yazılabilmesi için thread'e özgü global alanlar oluşturmaktadır. Bu alanlara Windows sistemlerinde
    "Thread Local Storage", UNIX/Linux sistemlerinde "Thread Specific Data" denilmektedir. Nasl her thread'in bir stack'i varsa bir de
    TSD alanı vardır. Bu alan slotlardan oluşmaktadır. Slotların numaraları vardır. Bu numaralar pthread_key_t türüyle temsil 
    edilmiştir. Programcı önce pthread_key_create fonksiyonu ile bir slot (ya da anahtar) yaratır. Slotlar thread'ler için ayrı ayrı
    yaratılmamaktadır. Bir slot yaratıldığında tüm thread'ler için (daha önce yaratılmış ve daha sonra yaratılacak olanlar da dahil olmak üzere)
    yaratılmaktadır. Slotlara void bir adres yerleştirilip geri alınabilmektedir. Bunun için pthread_setspecific ve pthread_getspecific
    fonksiyonları kullanılmaktadır. Slot yaratıldığında içerisinde NULL adres olduğu garanti edilmiştir. Programcı tipik olarak 
    malloc ile heap'te bir alan tahsis edip onun adresini slota yerleştirir. Tabii tek bilgi aşağıdaki örnekte olduğu gibi
    bir adres gibi de doğrudan slotlara yerleştirilebilmektedir. Böylece her thread aynı anahtarı kullansa da aslında kendi thread'inin 
    slotuna erişir. En sonunda yaratılmış olan slot (anahtar) pthread_key_delete fonksiyonu ile yok edilebilmektedir. 
    
    Aşağıdaki örnekte  rand ve srand fonksiyonları TSD kullanılarak thread güvenli hale getirilmiştir
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <pthread.h>

void exit_sys_thread(const char *msg, int err);
void *thread_proc1(void *param);
void *thread_proc2(void *param);

pthread_key_t g_key;

int myrand(void)
{
    void *val;
    unsigned seed;
    int result;

    if ((val = pthread_getspecific(g_key)) == NULL) {
        if ((result = pthread_setspecific(g_key, (void *)1)) != 0)
            exit_sys_thread("pthread_setspecific", result); 
        seed = 1;   
    }
    else 
        seed = (unsigned) val;

    seed = seed * 1103515245 + 12345;
    if ((result = pthread_setspecific(g_key, (void *)seed)) != 0)
        exit_sys_thread("pthread_setspecific", result);    

    return seed / 65536 % 32768;
}

void mysrand(unsigned seed)
{
    int result;

    if ((result = pthread_setspecific(g_key, (void *)seed)) != 0)
        exit_sys_thread("pthread_setspecific", result);    
}

int main(void)    
{
    int result;
    pthread_t tid1, tid2;
    
    if ((result = pthread_key_create(&g_key, NULL)) != 0)
        exit_sys_thread("pthread_key_create", result);   

    if ((result = pthread_create(&tid1, NULL, thread_proc1, NULL)) != 0) 
        exit_sys_thread("pthread_create", result);
    
    if ((result = pthread_create(&tid2, NULL, thread_proc2, NULL)) != 0) 
        exit_sys_thread("pthread_create", result);

    if ((result = pthread_join(tid1, NULL)) != 0)
        exit_sys_thread("pthread_join", result);

    if ((result = pthread_join(tid2, NULL)) != 0)
        exit_sys_thread("pthread_join", result);

    if ((result = pthread_key_delete(g_key)) != 0)
        exit_sys_thread("pthread_key_delete", result);

    return 0;
}

void exit_sys_thread(const char *msg, int err)
{
    fprintf(stderr, "%s: %s\n", msg, strerror(err));
    exit(EXIT_FAILURE);
}

void *thread_proc1(void *param)
{
    int i;
    int val;

    for (i = 0; i < 10; ++i) {
        val = myrand();
        printf("Thread-1: %d\n", val % 100);
    }
    printf("\n");

    return NULL;
}

void *thread_proc2(void *param)
{
    int i;
    int val;

    for (i = 0; i < 10; ++i) {
        val = myrand();
        printf("Thread-2: %d\n", val % 100);
    }
    printf("\n");

    return NULL;
}

/*--------------------------------------------------------------------------------------------------------------------------
    Aşağıda getenv fonksiyonu TSD kulanılarak thread güvenli hale getirilmiştir. Read/Write lock nesnesi başka bir thread çevre değişkenlerini
    değiştirirken ya da çevre değişkenlerine ekleme yaparken bozulmayı engllemek için kullanılıştır. Tabii bunu değiştirecek thread de aynı nesneyle 
    write amaçlı kilidi elde etmeye çalışmalıdır. Thread ilk kez slota yerleştirme yapacağı zaman bellek tahsis edip onun adresini slota yerleştirmiştir. 
    Diğer çağrılarda artık bu tahsis ettiği alanı kullanmaktadır. Bu alanın otomatik free getirilmesi için pthread_key_create fonksiyonunda "destructor" parametresi
    kullanılmıştır. Destructor parametresiyle verilen fonksiyon pthread_key_delete tarafından değil thread sonlanırken çağrılmaktadır. 
    Ancak proses sonlanırken bu destructor fonksiyonları çağrılmaz. Destructor fonksiyonun çağrılması için slotta NULL dışında bir değerin bulunuyor olması gerekir.
    (Yani destructor parametresi girildiği halde slota yerleştirme yapılmamışsa bu fonksiyon çağrılmamaktadır.) Destructor fonksiyonu thread pthread_cancel
    fonksiyonuyla başka bir thread tarafından sonlandırılırken de çağrılmaktadır. Eğer thread birden fazla slot için destructor fonksiyonuna sahipse
    bu durumda her slot için destructor fonksiyonu çağrılır. Ancak buların sırası hakkında bir belirlemede bulunulmamıştır. 
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <pthread.h>

#define MAX_ENV     4096

void exit_sys(const char *msg);
void exit_sys_thread(const char *msg, int err);
void *thread_proc1(void *param);
void *thread_proc2(void *param);
char *mygetenv(const char *env);
void destructor(void *param);

extern char **environ;
pthread_key_t g_envkey;
pthread_rwlock_t g_rwlock = PTHREAD_RWLOCK_INITIALIZER;

char *mygetenv(const char *env)
{
    char *pval = NULL;
    void *pv;
    int result;
    size_t len;
    int i;

    if ((pval = (char *)pthread_getspecific(g_envkey)) == NULL) {
        if ((pv = malloc(MAX_ENV)) == NULL)
            return NULL;
        if ((result = pthread_setspecific(g_envkey, pv)) != 0)
            exit_sys_thread("pthread_setspecific", result);       
        pval = (char *)pv;
    }

    if ((result = pthread_rwlock_rdlock(&g_rwlock)) != 0)
            exit_sys_thread("pthread_rwlock_rdlock", result);
    for (i = 0; environ[i] != NULL; ++i) {
        len = strlen(env);
        if (!strncmp(env, environ[i], len)) {
            if (environ[i][len] != '=')
                break;
            strcpy(pval, &environ[i][len + 1]);
            break;
        }
    }
    if ((result = pthread_rwlock_unlock(&g_rwlock)) != 0)
            exit_sys_thread("pthread_rwlock_unlock", result);

    return pval;
}

int main(void)    
{
    int result;
    pthread_t tid1, tid2;
    
    if ((result = pthread_key_create(&g_envkey, destructor)) != 0)
        exit_sys_thread("pthread_key_create", result);   

    if ((result = pthread_create(&tid1, NULL, thread_proc1, NULL)) != 0) 
        exit_sys_thread("pthread_create", result);
    
    if ((result = pthread_create(&tid2, NULL, thread_proc2, NULL)) != 0) 
        exit_sys_thread("pthread_create", result);

    if ((result = pthread_join(tid1, NULL)) != 0)
        exit_sys_thread("pthread_join", result);

    if ((result = pthread_join(tid2, NULL)) != 0)
        exit_sys_thread("pthread_join", result);

    if ((result = pthread_key_delete(g_envkey)) != 0)
        exit_sys_thread("pthread_key_delete", result);
    

    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

void exit_sys_thread(const char *msg, int err)
{
    fprintf(stderr, "%s: %s\n", msg, strerror(err));
    exit(EXIT_FAILURE);
}

void *thread_proc1(void *param)
{
    char *val;

    if ((val = mygetenv("PATH")) == NULL)
        exit_sys("mygetenv");
    puts(val);

    return NULL;
}

void *thread_proc2(void *param)
{
    char *val;

    if ((val = mygetenv("HOME")) == NULL)
        exit_sys("mygetenv");
    puts(val);

    return NULL;
}

void destructor(void *param)
{
    free(param);
}

/*--------------------------------------------------------------------------------------------------------------------------
    C11 ile birlikte ve C++11 ile birlikte C ve C++ dillerine thread_local isimli bir yer belirleyicisi de eklenmiştir. 
    Bir global değişkeni ya da static yerel değişkeni biz bu belirleyici ile bildirdiğimizde derleyici onu thread specific alanda yaratır. 
    Dolayısıyla bu değişken thread'e özgü global ya da static yerel değişken durumunda olur. Bu sayede biz Windows ve Linux farklı sistemlerde
    thread'e özgü alanları farklı kodlarla oluşturmak zorunda kalmayız. 

    Aşağıdaki kodu g++ derleyicisi ile -std=c++11 seçeneği ile derleyiniz. 
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <pthread.h>

thread_local int g_i;

void exit_sys_thread(const char *msg, int err);
void *thread_proc1(void *param);
void *thread_proc2(void *param);

int main(void)    
{
    int result;
    pthread_t tid1, tid2;
    
    if ((result = pthread_create(&tid1, NULL, thread_proc1, NULL)) != 0) 
        exit_sys_thread("pthread_create", result);
    
    if ((result = pthread_create(&tid2, NULL, thread_proc2, NULL)) != 0) 
        exit_sys_thread("pthread_create", result);

    if ((result = pthread_join(tid1, NULL)) != 0)
        exit_sys_thread("pthread_join", result);

    if ((result = pthread_join(tid2, NULL)) != 0)
        exit_sys_thread("pthread_join", result);

    return 0;
}

void exit_sys_thread(const char *msg, int err)
{
    fprintf(stderr, "%s: %s\n", msg, strerror(err));
    exit(EXIT_FAILURE);
}

void *thread_proc1(void *param)
{
    for (g_i = 0; g_i < 10; ++g_i) {
        printf("thread1: %d\n", g_i);
        sleep(1);
    }

    return NULL;
}

void *thread_proc2(void *param)
{
    for (g_i = 0; g_i < 10; ++g_i) {
        printf("thread1: %d\n", g_i);
        sleep(1);
    }
    
    return NULL;
}

/*--------------------------------------------------------------------------------------------------------------------------
    Birden fazla thread aynı kod üzerinde ilerlerken belli bir kod paraçasının yalnızca tek bir thread tarafından çalıştırılmasını
    isteyebiliriz. Özellikle TSD uygulamalarında bu tür isteklerle karşılaşılmaktadır. Bu işlemi pthread_once isimli fonksiyon yapar. 
    Bu fonksiyona biz bir fonksiyon adresi veririz. Peç çok thread pthread_once fonksiyonunu görse de bu fonksiyon bizim verdiğimiz fonksiyonun
    yalnızca bir kez ilk thread akışı tarafından çağrılmasını sağlar. 

    Aşağıdaki örnekte iki thread foo fonksionunu çağırmıştır. foo içerisinde iki thread de pthread_once çağrısına girmiştir. Ancak 
    thread'lerden yalnızca bir tanesi pthread_once fonksiyonunda belirttiğimiz bar fonksiyonunu çağıracaktır. 
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <pthread.h>

void exit_sys_thread(const char *msg, int err);
void *thread_proc1(void *param);
void *thread_proc2(void *param);
void foo(void);
void bar(void);

pthread_once_t g_once = PTHREAD_ONCE_INIT;

int main(void)    
{
    int result;
    pthread_t tid1, tid2;
    
    if ((result = pthread_create(&tid1, NULL, thread_proc1, NULL)) != 0) 
        exit_sys_thread("pthread_create", result);
    
    if ((result = pthread_create(&tid2, NULL, thread_proc2, NULL)) != 0) 
        exit_sys_thread("pthread_create", result);

    if ((result = pthread_join(tid1, NULL)) != 0)
        exit_sys_thread("pthread_join", result);

    if ((result = pthread_join(tid2, NULL)) != 0)
        exit_sys_thread("pthread_join", result);
  
    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

void exit_sys_thread(const char *msg, int err)
{
    fprintf(stderr, "%s: %s\n", msg, strerror(err));
    exit(EXIT_FAILURE);
}

void *thread_proc1(void *param)
{
    foo();

    return NULL;
}

void *thread_proc2(void *param)
{
    foo();

    return NULL;
}

void foo(void)
{
    int result;

    printf("foo called...\n");

    if ((result = pthread_once(&g_once, bar)) != 0)
        exit_sys_thread("pthread_once", result);
}

void bar(void)
{
    printf("bar only called once...\n");
}

/*--------------------------------------------------------------------------------------------------------------------------
    ptherad_once fonksiyonu genellikle TSD kullanan programlarda karşımıza çıkmaktadır. Programcı TSD slotunu işin başında
    thread'leri yaratmadan pthread_key_create ile yaratabilir. Ancak bu durumda söz konusu thread güvenli fonksiyon hiç çağrılmazsa
    bu slot boşuna yaratılmış olacaktır. İşte bu durumu engellemek için thread güvenli hale getirilen fonksiyon ilk kez çağrıldığında
    TSD slotu yaratılır. 

    Aşağıdaki örnekte myrand ya da mysrand fonksiyonları ilk kez herhangi bir thread tarafından çağrıldığında TSD slotu pthread_once
    fonksiyonu sayesinde yaratılmıştır. 
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <pthread.h>

void mysrand(unsigned seed);
int myrand(void);
void thread_once_proc(void);

void exit_sys_thread(const char *msg, int err);
void *thread_proc1(void *param);
void *thread_proc2(void *param);

pthread_key_t g_key;
pthread_once_t g_once = PTHREAD_ONCE_INIT;

int myrand(void)
{
    void *val;
    unsigned seed;
    int result;

    if ((result = pthread_once(&g_once, thread_once_proc)) != 0)
        exit_sys_thread("pthread_once", result); 

    if ((val = pthread_getspecific(g_key)) == NULL) {
        if ((result = pthread_setspecific(g_key, (void *)1)) != 0)
            exit_sys_thread("pthread_setspecific", result); 
        seed = 1;   
    }
    else 
        seed = (unsigned) val;

    seed = seed * 1103515245 + 12345;
    if ((result = pthread_setspecific(g_key, (void *)seed)) != 0)
        exit_sys_thread("pthread_setspecific", result);    

    return seed / 65536 % 32768;
}

void mysrand(unsigned seed)
{
    int result;

    if ((result = pthread_once(&g_once, thread_once_proc)) != 0)
        exit_sys_thread("pthread_once", result); 

    if ((result = pthread_setspecific(g_key, (void *)seed)) != 0)
        exit_sys_thread("pthread_setspecific", result);    
}

void thread_once_proc(void)
{  
    int result;
    
    if ((result = pthread_key_create(&g_key, NULL)) != 0)
        exit_sys_thread("pthread_key_create", result);  
}

int main(void)    
{
    int result;
    pthread_t tid1, tid2; 

    if ((result = pthread_create(&tid1, NULL, thread_proc1, NULL)) != 0) 
        exit_sys_thread("pthread_create", result);
    
    if ((result = pthread_create(&tid2, NULL, thread_proc2, NULL)) != 0) 
        exit_sys_thread("pthread_create", result);

    if ((result = pthread_join(tid1, NULL)) != 0)
        exit_sys_thread("pthread_join", result);

    if ((result = pthread_join(tid2, NULL)) != 0)
        exit_sys_thread("pthread_join", result);

    return 0;
}

void exit_sys_thread(const char *msg, int err)
{
    fprintf(stderr, "%s: %s\n", msg, strerror(err));
    exit(EXIT_FAILURE);
}

void *thread_proc1(void *param)
{
    int i;
    int val;

    for (i = 0; i < 10; ++i) {
        val = myrand();
        printf("Thread-1: %d\n", val % 100);
    }
    printf("\n");

    return NULL;
}

void *thread_proc2(void *param)
{
    int i;
    int val;

    for (i = 0; i < 10; ++i) {
        val = myrand();
        printf("Thread-2: %d\n", val % 100);
    }
    printf("\n");

    return NULL;
}

/*--------------------------------------------------------------------------------------------------------------------------
    Aslında Linux işletim sisteminde proses ve thread yaratımı benzer biçimde yapılmaktadır. Thread'lerin de birer task_struct yapısı vardır. 
    Bu task_struct içerisinde tüm proesler ve prosesin thread'leri bağlı listelerle tutulmuştur. task_struct içerisindeki alanlar ve anlamları
    şöyledir:

    - parent ve real_parent: Üst prosesin task_struct adresi
    - children: Prosesin alt proses listesindeki ilk alt prosesin task_struct adresi
    - sibling: Prosesin alt prosesleri dolaşılırken kullanılan sonraki kardeş prosesin task_struct adresi
    - thread_group: Aynı prosesin içerisindeki thread'lerin task_struct listesi. Her task_struct'ın thread_group göstericisi
    prosesin sonraki bir thread'inin task_struct yapısını gösterir. 
    - group_leader: Prosesin ana thread'inin task_struct adresi

    Linux işletim sistemi her zaman o anda çalışmakta olan kodun task_struct adresini biliyor durumdadır. Kernel içerisindeki current makrosu
    her zaman o anda çalışmakta olan thread'in task_struct adresini vermektedir. Örneğin bir thread read fonksiyonuyla bir dosyadna okuma yapacak olsa
    o thread'in task_struct yapısından hareketle prosesin dosya betimleyici tablosuna erişilmektedir. Her task_strucy yapısının ayrı bir pid 
    değeri vardır. Ancak POSIX'in getpid fonksiyonu çağrıldığında o anda çalışmakta olan thread'in task_struct pid'si verilmez. prosesin ana thread'inin
    pid'si verilir. Çünkü POSIX standartlarında thread'lerin pid'leri yoktur. Yalnızca proseslerin pid'leri vardır. Linux'a özgü gettid fonksiyonu 
    aslında o thread'in pid'sini vermektedir. Sistemde yaratılabilecek toplam task_struct sayısı bellidir. Bu sayı /proc/sys/kernel/threads-max 
    dosyasında belirtilmektedir. 

    Linux'un sys_clone isimli sistem fonksiyonu aslında proses ve thread yaratımının yapıldığı en genel sistem fonksiyonudur. 
    fork fonksiyonun özel bir clone çağırması olduğunu belirtelim. pthread kütüphanesi de sonuçta thread'i bu clone sistem fonksiyonuyla 
    yaratmaktadır. clone sistem fonksiyonu bir kütüphane fonksiyonu olarak da (tabii ki POSIX fonksiyonu değil) Linux sistemlerinde bulunmaktadır. 

    Linux'un çizelgeleyici alt sistemi prosesleri çizelgelemez. Thread'leri çizelgeler. Dolayısıyla aslında çizelgeleyici task_struct'lardan hareketle
    context switch yapmaktadır. 

---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    POSIX standartlarına göre thread çizelgelemesi thread'lerin çizelgeleme politikalarına (scheduling policies) bağlıdır. 
    POSIX dört çizelgeleme politikası tanımlamıştır. Ancak işletim sistemlerinin daha fazla politikaya sahip olabileceği belirtilmiştir. 
    SCHED_FIFO ve SCHED_RR çizelgeleme politikalarına "gerçek zamanlı (real time)" çizelgeleme politikaları denilmektedir. Thread'lerin
    default çizelgeleme politikaları SCHED_OTHER biçimindedir. Ancak SCHED_OTHER politikası default durumda SCHED_RR ya da SCHED_FIFO da 
    olabilmektedir. SCHED_OTHER çizelgeleme politikası POSIX standartlarında tamamen işletim sistemini yazanların isteğine bırakılmıştır. 
    Yani pratikte karşılaştığımız çizelgeleme politikası hep SCHED_OTHER biçimindedir. Bu da işletim sisteminden işletim sistemine  
    farklılıklar gösterebilmektedir. 

    POSIX standartlarında bloke olmamış thread'lerin bir run kuyruğunda bekledikleri varsayılmaktadır. Çizelgeleyici alt sistemin görevi ise
    buradan uygun thread'i seçip CPU'ya atamaktır. SCHED_RR ve SHED_FIFO çizelgeleme politikalarına sahip olan thread'ler her zaman SCHED_OTHER
    çizelgeleme politikasına sahip thread'lerden üstündür. Yani çizelgeleyici alt sistem her zaman SCHED_FIFO ya da SCHED_RR polikasına sahip 
    thread'lere öncelik vermektedir. Başka bir deyişle bir SCHED_OTHER thread'inin çalışabilmesi için run kuyruğunda SCHED_FIFO ve SCHED_RR politikalarına
    sahip thread'lerin olmaması gerekir. 

    SCHED_FIFO ve SCHED_RR politikalarına sahip thread'lerin birer statik öncelik derecesi vardır. Bu statik öncelik derecesi [1-99]
    arasında bir değere sahiptir. Sistem her zaman run kuyruğunda SCHED_FIFO ve SCHED_RR thread'lerinin en yüksek öncelikli olanını 
    alarak CPU'ya verir. Ancak eğer aynı statik önceliğe sahip birden fazla SCHED_FIFO ve SCHED_RR prosesi varsa kuyrukta önce olan 
    thread CPU'ya verilmektedir. Bu therad bir quanta süresi kadar çalıştırılır. Quanta bittiğinde eğer bu thread SCHED_FIFO politikasına
    sahip ise kuyruğun başına SCHED_RR politikasına sahipse kuyruğun sonuna yerleştirilir. Yeniden run kuyruğuna bakılarak en yüksek öncelikli 
    kuyruğun önündeki thread alınarak CPU'ya atanır. İşlemler böyle devam ettirilir. Örneğin run kuruğunda şu thread'ler bulunuyor olsun:

    FIFO (50), OTHER, RR (50), RR(50) OTHER

    Burada en yüksek statik öncelikli kuyruğun önündeki thread ilk thread'tir. Sistem bunu CPU atar. Bir quanta çalıştırır. 
    Quanta bitince kuyruğun başına yerleştirir. Bu durumda yine onu CPU'ya atar. Yani bu durumda bu thread sonlanana kadar ya da bloke olup
    run kuyruğundan çıkana kadar çalışacaktır. Şimdi bu thread'in bloke olduğunu düşünelim. Run kuyruğu şöyle olacaktır:

    OTHER, RR(50), RR(50), OTHER

    Burada ikinci sırada bulunan RR (50) thread'i CPU'ya verilecek ve 1 quanta çalıştıtrılacaktır. Quanta bitince kuyruğun sonuna yerleştirileceği 
    için artık üçüncü sıradaki RR(50) thread'i CPU'ya verilecektir. Böylece bu iki thread bloke olana kadar döngüsel çizelgeleme yöntemiyle
    çalıştırılacaktır. Görüldüğü gibi SCHED_OTHER thread'ler bunlar varken çalışma fırsatı bulamayacaktır. 

    Bir SCHED_RR ya da SCHED_FIFO thread çalışırken bloke çözülmüş olan daha yüksek öncelikli bir thread run kuyruğuna yerleştirilirse hemen
    context switch yapılarak çalışma bu thread'e verilmektedir. Zaten "real time" çizelgelemeden beklenen budur. (POSIX sistemleri real time sistemler değildir.)

    Genel olarak SCHED_FIFO ya da SCHED_RR thread'lerin IO yoğun thread'ler olması uygundur. Aksi takirde diğer diğer thread'ler çalışmaya fırsat 
    bulamayacaklardır. 

    Birden fazla CPU ya da çekirdek olduğu durumda bu CPU'ya ya da çekirdeklerin aynı run kuyruğuna bakarak seçim yaptıkları düşünülmelidir. Örneğin:

    FIFO (50), OTHER, RR (50), RR(50) OTHER

    Bu durumda iki CPU varsa, sistem FIFO(50) thread'ini bunlardan birine RR(50) thread'ini diğerine atar. Diğer CPU'da RR(50) thread'leri
    döngüsel çizelgeleme yoluyla çalışacaktır. 

    SCHED_OTHER politikasının işlevi POSIX standartlarında işletim sisteminin tanımlamasına bırakılmıştır. Ancak bu politikaların SCHED_FIFO ya da SCHED_RR
    ile özdeş olabilmesine de izin verilmiştir. Linux işletin sisteminde SCHED_OTHER thread'ler için çizelgeleme algoritması üç kere değiştirilmiştir. 

    Her ne kadar POSIX standartları SCHED_OTHER thread'ler konusunda belirlemeyi işletim sistemini yazanlara bırakmış olsa da
    bu thread'lerin bir dinamik önceliğinin olduğu ve bu önceliğin bu thread'lerin kullanacakları quanta sürelerini belirlemeye
    yaradığından bahsetmiştir. Gerçekten de Linux ve diğer POSIX sistemlerinde SCHED_OTHER politikasına sahip thread'lerin birer dinamik 
    önceliği vardır. Bu dinamik önceliğe "nice değeri" de denilmektedir. Linux'ta SCHED_OTHER thread'lerinin dinamik önceliği [0-39] arasındadır. 
    Ancak yüksek öncelik düşük bir quanta süresi anlamına gelmektedir. Bu durumda en çok quanta kullanan dinamik öncelik 0'dır. SCHED_OTHER 
    thread'leerin dinamik önceliği için aslında -20 ile +19 arasında değerler kullanılmaktadır. Ancak kernel bu değerlere 20 toplayarak onları
    0 ile 29 arasında normalize etmektedir. Default olarak SCHED_OTHER thread'lerin dinamik öncelikleri normalizde edilmiş değer olarak 20
    -20, +19 arasında normalize edilmemiş değer olarak 0'dır. Yani default durumda aslında SCHED_OTHER politikasına sahip her thread'in 
    quanta süresi aynıdır. 

    Linux sistemlerinde SCHED_OTHER politikasına sahip thread'lerin çizelgeleme algoritmaları üç kere değiştirilmiştir. İlk algoritma 
    tipik olandır. Buna özel bir isim verilmemiştir. İkinci algoritma Linux 2.6 versiyonlarında kullanılmaya başlanmıştır. Buna
    "O(1) Çizelgelemesi" denilmektedir. Nihayet 2.6.23 ile birlikte şu anda kullanılmakta olan "CFS (completely Fair Scheduling)" algoritmasına 
    geçilmiştir. 

    SCHED_OTHER thread'lerin dinamik öncelikleri onların kaç mili saniye quanta süresi kullanacaklarını dolaylı olarak belirtmektedir. Yani 
    sistemde n tane SCHED_OTHER thread var ise bunlar döngüsel çizelgelenmekle birlikte hepsi aynı sürede quanta kullanmak zorunda değildir. 
    Buradaki detay Lİnux'un versiyonundan versiyonuna değişebilmektedir. 

    Genel olarak Linux çekirdeğininin pek çok vesiyonunda SCHED_OTHER thread'lerin kullanacakları quanta süreleri onların dinamik öncelikleri 
    ile ilişkilendirilmiştir. Run kuyruğundaki thread'lerin hepsinin quanta süresi bitmeden yeniden doldurma yapılmamaktadır. Linux'un
    pek çok versiyonunda timer kesmesi 10 ms'ye kurulmuştur. (Bu kesme bilgisayarlar hızlanınca artık 1 ms'yeye kurulmaya başlandı.) Her timer kesmesi
    oluştuğunda task_struct içerisindeki quanta sayacı olan counter elemanı 1 eksiltilir. Bu eleman 0'a düştüğünde thread tüm quanta süresini kullanmış olur.
    İşte run kuyruğundaki tüm thread'lerin coutnter değerleri 0'a düştüğünde yeniden bunlara dinamik öncelik temelinde yeni değerler atanmaktadır. 
    Linux çekirdekleri genel olarak run kuyruğunda counter değeri en yüksek olan SCHED_OTHER thread'i CPU'ya atamaktadır. Böylece o zamana kadar 
    az CPU kullanan thread'lere öncelik verilmiş olmaktadır. Linux'un CFS sistemine kadar SCHED_OTHER therad'lerin dinamik öncelikleri
    default durumda 20 idi. Bu da 200 ms. bir quanta süresine karşılık gelmektedir. Mademki dinamik öncelik en fazla 1 olabilir. Bu durumda (40 - 1 = 39) 
    thread en fazla 390 ms. quanta süresine sahip olabilir. CSF algıritmasında bazı değişikler yapılmıştır. 
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    sched_setscheduler isimli POSIX fonksiyonu bir prosesin id değerini alarak onun çizelgeleme politikasını ve statik ya da dinamik
    önceliğini değiştirmekte kullanılır. Fonksiyon struct sched_param türünden bir yapı nesnesini de parametre olarak almaktadır. 
    Bu yapının sched_priority isminde tek bir elemanı vardır. Bu eleman SCHED_FIFO ve SCHED_RR için statik öceliği, SCHED_OTHER için 
    dinamik önceliği belirtir. POSIX standartlarına göre bir prosesin çizelgeleme politikası bu fonksiyonla değiştirildiğinde prosesin
    tüm thread'lerinin çizelgeleme politikaları değiştirilmiş olur. Ancak Linux bunu desteklememektedir. Linux'ta bu fonksiyon çağrıldığında
    prosesin yalnızca ana thread'inin çizelgeleme politikası değiştirilmiş olur. Prosesin diğer thread'lerinin çizelgeleme politikası
    Linux'ta bu fonksiyonun pid parametresi yerine gettid fonksiyonuyla elde edilen değerin verilmesiyle yapılabilmektedir. Fonksiyonun 
    POSIX standartlarında proseslerin çizelgeleme politikalarının değiştirimesi için nasıl bir yetkiye sahip olunacağı işletim sistemlerini 
    yazanların isteğine bırakılmıştır. Linux sistemlerinde herhangi bir prosesin çizelgeleme politikasısını statik öncelik ne olursa olsun 
    SCHED_FIFO ya da SCHED_RR haline dönüştürmek için prosesin ugun önceliği (root) sahip olması gerekmektedir. Bu durumda getpid() anlaşılmaktadır.
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <sched.h>

void exit_sys(const char *msg);

int main(void)    
{
    struct sched_param sparam;

    sparam.sched_priority = 50;

    if (sched_setscheduler(getpid(), SCHED_FIFO, &sparam) == -1)
        exit_sys("sched_setscheduler");

    printf("Ok\n");

    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/*--------------------------------------------------------------------------------------------------------------------------
    Belli bir thread'in (ana thread de dahil olmak üzere) çizelgeleme politikası ve thread önceliği pthread_getschedparam POSIX fonksiyonu
    ile alınıp pthread_setschedparam POSIX fonksiyonuyla set edilebilir. Set işleminin yapılabilmesi için prosesin yine root önceliğinde 
    olması gerekir.
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <pthread.h>

void exit_sys_thread(const char *msg, int err);
void *thread_proc(void *param);

int main(void)    
{
    int result;
    pthread_t tid;
    struct sched_param param;
    
    if ((result = pthread_create(&tid, NULL, thread_proc, NULL)) != 0) 
        exit_sys_thread("pthread_create", result);
    
    param.sched_priority = 30;

    if ((result = pthread_setschedparam(tid, SCHED_FIFO, &param)) != 0)
        exit_sys_thread("pthread_setschedparam", result);

    if ((result = pthread_join(tid, NULL)) != 0)
        exit_sys_thread("pthread_join", result);

    return 0;
}

void exit_sys_thread(const char *msg, int err)
{
    fprintf(stderr, "%s: %s\n", msg, strerror(err));
    exit(EXIT_FAILURE);
}

void *thread_proc(void *param)
{
    int i;

    for (i = 0; i < 10; ++i) {
        printf("%d ", i);
        fflush(stdout);
        sleep(1);
    }
    printf("\n");

    return NULL;
}

/*--------------------------------------------------------------------------------------------------------------------------
    gettid fonksiyonu belli bir süredir GNU kütüphanesinde bulunmamaktadır. Bu Linux'ta bir sistem fonksiyonudur. Bu nedenle
    bu fonksiyon syscall fonksiyonu ile çağrılabilir. Aşağıdaki örnekte ana thread'in ve yaratılan thread'in task_struct pid değerleri
    ekrana yazdırılmıştır. Tabii ana thread'in task_struct pid değeri aslında getpid fonksiyonuyla da elde edibilir. 

    Aslında pthread_setschedparam fonksiyonu yerine Linux sistemlerinde thread'in task_struct pid değeri elde edilerek 
    sched_setscheduler fonksiyonu da kullanılabilir. 
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/types.h>
#include <unistd.h>
#include <pthread.h>
#include <sys/syscall.h>

void exit_sys_thread(const char *msg, int err);
void *thread_proc(void *param);

int main(void)    
{
    int result;
    pthread_t tid;
    struct sched_param param;
    long task_pid;
    
    if ((task_pid = syscall(SYS_gettid)) == -1) {       // quivalent getpid()  
        perror("syscall");
        exit(EXIT_FAILURE);
    }
    
    printf("Main thread task_struct pid: %ld\n", task_pid);
   
    if ((result = pthread_create(&tid, NULL, thread_proc, NULL)) != 0) 
        exit_sys_thread("pthread_create", result);
    
    param.sched_priority = 30;

    if ((result = pthread_setschedparam(tid, SCHED_FIFO, &param)) != 0)
        exit_sys_thread("pthread_setschedparam", result);

    if ((result = pthread_join(tid, NULL)) != 0)
        exit_sys_thread("pthread_join", result);

    return 0;
}

void exit_sys_thread(const char *msg, int err)
{
    fprintf(stderr, "%s: %s\n", msg, strerror(err));
    exit(EXIT_FAILURE);
}

void *thread_proc(void *param)
{
    int i;
    long task_pid;

    if ((task_pid = syscall(SYS_gettid)) == -1) {
        perror("syscall");
        exit(EXIT_FAILURE);
    }
    
    printf("Thread task_struct pid: %ld\n", task_pid);
    
    for (i = 0; i < 100; ++i) {
        printf("%d ", i);
        fflush(stdout);
        sleep(1);
    }
    printf("\n");

    return NULL;
}

/*--------------------------------------------------------------------------------------------------------------------------
    Proseslere ilişkin bilgiler bilindiği gibi ps komutuyla elde edilmektedir. ps komutunda -o parametresi istenilen sütunları ayarlamak için 
    kullanılmaktadır. -T thread bilgilerini de verir. Örneğin:

    ps -a -T -o pid,pri,tid,cmd,policy

    Burada aaynı kullanıcının tüm terminallerde çalışan prosesleri (-a) ve threadleri (-T) görüntülenmiştir. Görüntülemede 
    pid, pri (öncelik), tid (task_pid), cmd (komut), ve policy (çizelgeleme politikası) sütunları kullanılmıştır. Örneğin:

       PID PRI    TID CMD                         POL
    13480  19  13480 sudo ./sample               TS
    13482  19  13482 ./sample                    TS
    13482  70  13483 ./sample                    FF
    13566  19  13566 ps -a -T -o pid,pri,tid,cmd TS

    Burada ./sample satırlarında pid değeri tid değerine eşit olan satırdaki ./sample prosesin ana thread'ini diğeri ise 
    sonradan yaratılan thread'i belirtmektedir. PRI sütunu SCHED_OTHER prosesler için dinamik önceliği belirtmektedir. 
    SCHED_FIFO ve SCHED_RR proseslerin statik öncelikleri makismum dinamik önceliğe (40) eklenerek gösterilmektedir. Örneğin
    13483 task_pid değerine sahip olan thread'in çizelgeleme politikası SCHED_FIFO biçimindedir. Tatik öceliği 30'dur. 

    pstree isimli kabul komutu prosesleri (ve onların thread'lerini) ve alt prosesleri bir ağaç biçiminde göstermektedir. 
    Tipik olarak -p <pid> seçeneğiyşe kullanılmaktadır. 

    Komut satırında bir prosesi belli bir çizelgeleme politikası ve statik/dinamik öncelikle çalıştırabilmek için chrt komutu
    kullanılmaktadır. Komutta sırasıyla önce çizelgeleme politikası sonra öncelik sonra da çalıştırılacak komut belirtilir. Örneğin:

     sudo chrt --fifo 30 ls

    Burada ls programı SCHED_FIFO çizelgeleme politikasıyla 30 statik önceliğe sahip olacak biçimde çalıştırılmaktadır. 
    Burada çalıştıtrılan program (örnekte ls) eğer thread yaratırsa bu thread'ler de SCHED_FIFO politikasına sahip olacaktır. 
    Çünkü Linux'ta (ve POSIX standartlarında da böyle) thread'lerin çizelgeleme politikaları onu yaratan thread'ten alınmaktadır. 

    chrt komutu ile çalışmakta olan programların da çizelgeleme politikaları değiştirilebilir. Bunun için program ismi yerine
    prosesin id'si belirtilmektedir. Örneğin:

    sudo chrt -f -p 30 13482
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Aslında bir thread'in çizelgeleme politikası ve statik/dinamik önceliği thread yaratıldıktan sonra değil, thread yaratılırken thread attribute bilgisiyle 
    de değiştirilebilmektedir. Bunun için pthread_attr_setpolicy, pthread_attr_setschedparam fonksiyonu ile bu özelliğin set edilmesi gerekir. Default durumda
    thread'lerin politikaları ve öncelikleri onu yaratan thread'ten alınmaktadır. Bunun olmaması için ayrıca programcının 
    pthread_attr_setinheritsched  ile PTHREAD_EXPLICIT_SCHED ayarlama yapması gerekmektedir. 
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/types.h>
#include <unistd.h>
#include <pthread.h>

void exit_sys_thread(const char *msg, int err);
void *thread_proc(void *param);

int main(void)    
{
    int result;
    pthread_t tid;
    pthread_attr_t attr;
    struct sched_param param;

    if ((result = pthread_attr_init(&attr)) != 0)
        exit_sys_thread("pthread_attr_init", result);

    if ((result = pthread_attr_setschedpolicy(&attr, SCHED_FIFO)) != 0)
        exit_sys_thread("pthread_attr_setschedpolicy", result);

    param.sched_priority = 30;
    if ((result = pthread_attr_setschedparam(&attr, &param)) != 0)
        exit_sys_thread("pthread_attr_setschedparam", result);

    if ((result = pthread_attr_setinheritsched(&attr, PTHREAD_EXPLICIT_SCHED)) != 0)
        exit_sys_thread("pthread_attr_setinheritsched", result);

    if ((result = pthread_create(&tid, &attr, thread_proc, NULL)) != 0) 
        exit_sys_thread("pthread_create", result);
    
    pthread_attr_destroy(&attr);

    if ((result = pthread_join(tid, NULL)) != 0)
        exit_sys_thread("pthread_join", result);

    return 0;
}

void exit_sys_thread(const char *msg, int err)
{
    fprintf(stderr, "%s: %s\n", msg, strerror(err));
    exit(EXIT_FAILURE);
}

void *thread_proc(void *param)
{
    int i;
    
    for (i = 0; ; ++i) {
        printf("%d ", i);
        fflush(stdout);
        sleep(1);
    }
    printf("\n");

    return NULL;
}

/*--------------------------------------------------------------------------------------------------------------------------
    SCHED_OTHER politikasına sahip prosesin dinamik önceliği nice isimli POSIX fonksiyonuyla değiştirilebilmektedir. nice fonksiyonu
    mevcut dinamik önceliğe artırım ya da eksiltim yapar. Artırmak quantayı düşürmek eksiltmek quantayı yükseltmek anlamına gelmektedir. 
    (Örneğin 1 nice değeri 10 ms. gibi bir etkiye yol açtığı varsayılabilir.) POSIX standartlarına göre nice fonksiyonu prosesin 
    tüm thread'leri üzerinde etkili olmaktadır. Ancak Linux'ta yalnızca ana thread üzerinde etkili olur. Linux işletim sisteminde bir thread 
    çizelgeleme politikasını ve öncelik derecesini onu yaratan thread'ten almaktadır. Yine nice ile dinamik önceliğin yükseltilmesi 
    için prosesin root önceliğinde olması gerekmektedir. 
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/types.h>
#include <unistd.h>
#include <pthread.h>

void exit_sys_thread(const char *msg, int err);
void *thread_proc(void *param);

int main(void)    
{
    int result;
    pthread_t tid;
  
    if ((result = pthread_create(&tid, NULL, thread_proc, NULL)) != 0) 
        exit_sys_thread("pthread_create", result);
    
    if (nice(-10) == -1) {
        perror("nice");
        exit(EXIT_FAILURE);
    }

    if ((result = pthread_join(tid, NULL)) != 0)
        exit_sys_thread("pthread_join", result);

    return 0;
}

void exit_sys_thread(const char *msg, int err)
{
    fprintf(stderr, "%s: %s\n", msg, strerror(err));
    exit(EXIT_FAILURE);
}

void *thread_proc(void *param)
{
    int i;
    
    for (i = 0; ; ++i) {
        printf("%d ", i);
        fflush(stdout);
        sleep(1);
    }
    printf("\n");

    return NULL;
}

/*--------------------------------------------------------------------------------------------------------------------------
    Komut satırından bir programı SCHED_OTHER olarak dinamik önceliği -20, +19 arasında değiştirerek çalıştırabilmek için 
    nice komutu kullanılmaktadır. Örneğin:

    sudo nice -n -10 ./sample

    Ayrıca bir de renice isimli bir komut vardır. Ancak bu komut zaten çalışmakta olan bir prosesin nice değerini değiştirmek için
    kullanılır. 
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Linux sistemlerinde nice fonksiyonunun POSIX uyumlu olmadığını belirtmiştik. Bu fonksiyon Linux sistemlerinde yalnızca 
    ana thread'in dinamik önceliğini değiştiriyordu. Pekiyi Linux'ta herhangi bir SCHED_OTHER politikasına sahip thread'in
    dinamik önceliği nasıl değiştirilmektedir? Bunun için aslında sched_setscheduler fonksiyonu gettid ile kullanılabilir. 
    Ya da benzer biçimde pthread_setschedparam fonksiyonu da kulalnılabilir. Fakat bu iş için getpriority ve
    setpriority POSIX fonksiyonları da kullanılmaktadır. 
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/types.h>
#include <unistd.h>
#include <pthread.h>
#include <sys/syscall.h>
#include <sys/resource.h>

void exit_sys_thread(const char *msg, int err);
void *thread_proc(void *param);

int main(void)    
{
    int result;
    pthread_t tid;
  
    if ((result = pthread_create(&tid, NULL, thread_proc, NULL)) != 0) 
        exit_sys_thread("pthread_create", result);
    
    if ((result = pthread_join(tid, NULL)) != 0)
        exit_sys_thread("pthread_join", result);

    return 0;
}

void exit_sys_thread(const char *msg, int err)
{
    fprintf(stderr, "%s: %s\n", msg, strerror(err));
    exit(EXIT_FAILURE);
}

void *thread_proc(void *param)
{
    int i;
    long task_pid;

    if ((task_pid = syscall(SYS_gettid)) == -1) {
        perror("syscall");
        exit(EXIT_FAILURE);
    }

    if (setpriority(PRIO_PROCESS, task_pid, -10) == -1) {
        perror("setpriority");
        exit(EXIT_FAILURE);
    }
    
    for (i = 0; ; ++i) {
        printf("%d ", i);
        fflush(stdout);
        sleep(1);
    }
    printf("\n");

    return NULL;
}

/*--------------------------------------------------------------------------------------------------------------------------
    Belli thread'lerin belli CPU ya da çekirdeklere atanması paralel programlama uygulamalarında gerekebilmektedir. 
    Bir thread'in hangi CPU ya da çekirdeklere atanabileceği "affinity mask" denilen bir özellikle belirlenmektedir. Default durumda 
    thread'ler mevcut tüm CPU ya da çekirdeklere atanabilirler. Biz thread'leri farklı CPU ya da çekirdeklere atayarak onların aynı 
    anda birlikte çalışmasını sağlayabiliriz. 

    Linux sistemlerinde affinity işlemleri için 4 fonksiyon kullanılmaktadır. sched_getaffinity bir prosesin (prosesin ana thread'inin)
    affinity değerini verir, sched_setaffinity fonksiyonu ise bunu set etmemizi sağlar. Aşağıdaki örnekte 2 çekirdekli bir sistemde
    prosesin ana thread'inin hangi CPU ya da çekirdeklere atanabilecekleri gösterilmiştir. Default durumda işletim sistemi
    thread'leri tüm CPU ya da çekirdeklere atayabilmektedir. 
---------------------------------------------------------------------------------------------------------------------------*/

#define _GNU_SOURCE 

#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <sched.h>

void exit_sys(const char *msg);

int main(void)    
{
    cpu_set_t set;
    int i;

    if (sched_getaffinity(getpid(), sizeof(set), &set) == -1)
        exit_sys("sched_getaffinity");
        
    for (i = 0; i < 2; ++i)
        printf("%d-CPU: %s\n", i, CPU_ISSET(i, &set) ? "YES" : "NO");

    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/*--------------------------------------------------------------------------------------------------------------------------
    sched_setaffinity fonksiyonu belli bir prosesin (prosesin ana thread'inin) belli  CPU ya da çekirdeklerde çalışmasını  
    sağlamak için kullanılmaktadır. Bunun için prosesin etkin kullanıcı id'sinin affinity değişikliği yapılacak prosesin
    gerçek ya da etkin kullanıcı id'si ile aynı olması ya da root önceliğine sahip olması ya da CAP_SYS_NICE yeteneğine sahip
    olması gerekmektedir. Biz bu fonksiyon ile bir prosesin belli bir thread'inin affinity'sini de değiştirebiliriz. Tabii bunun için
    ilgili thread'in task_struct pid değerinin gettid sistem fonksiyonuyla elde edilmesi gerekmektedir. 

    Programı çalıştırıp aşağıdaki gibi ps komutuyla prosesin ana thread'inin 1 numaralı CPU'ya atanıp atanmadığını kontrol ediniz:

    ps -a -o pid,psr,cmd
---------------------------------------------------------------------------------------------------------------------------*/

#define _GNU_SOURCE 

#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <sched.h>

void exit_sys(const char *msg);

int main(void)    
{
    cpu_set_t set;

    CPU_ZERO(&set);
    CPU_SET(1, &set);

    if ((sched_setaffinity(getpid(), sizeof(set), &set)) == -1)
        exit_sys("sched_setaffinity");

    for (;;) 
        ;
   
    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/*--------------------------------------------------------------------------------------------------------------------------
    Belli bir thread'e affinty uygulamak için yukarıda da belirtildiği gibi gettid ile sched_setaffinity fonksiyonu kullanılabilir. 
    Ancak Linux'a özgü bir biçimde zaten pthread_setaffinity_np ve pthread_getaffinity_np isimli fonksiyonlar da bulundurulmuştur. 
    Bu fonksiyonlar doğrudan thread id'lerle çalışmaktadır. Aşağıdaki programda iki thread farklı CPU ya da çekirdeklere atanarak bunlara CPU yoğun
    iş yaptırılmıştır.
---------------------------------------------------------------------------------------------------------------------------*/

#define _GNU_SOURCE 

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sched.h>
#include <pthread.h>

void exit_sys_thread(const char *msg, int err);
void *thread_proc1(void *param);
void *thread_proc2(void *param);

int main(void)    
{
    int result;
    pthread_t tid1, tid2;
    cpu_set_t set;
    
    if ((result = pthread_create(&tid1, NULL, thread_proc1, NULL)) != 0) 
        exit_sys_thread("pthread_create", result);
    
    if ((result = pthread_create(&tid2, NULL, thread_proc2, NULL)) != 0) 
        exit_sys_thread("pthread_create", result);

    CPU_ZERO(&set);
    CPU_SET(0, &set);

    if ((result = pthread_setaffinity_np(tid1, sizeof(set), &set)) != 0)
        exit_sys_thread("pthread_setaffinty", result);

    CPU_ZERO(&set);
    CPU_SET(1, &set);

    if ((result = pthread_setaffinity_np(tid1, sizeof(set), &set)) != 0)
        exit_sys_thread("pthread_setaffinty", result);

    if ((result = pthread_join(tid1, NULL)) != 0)
        exit_sys_thread("pthread_join", result);

    if ((result = pthread_join(tid2, NULL)) != 0)
        exit_sys_thread("pthread_join", result);
  
    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

void exit_sys_thread(const char *msg, int err)
{
    fprintf(stderr, "%s: %s\n", msg, strerror(err));
    exit(EXIT_FAILURE);
}

void *thread_proc1(void *param)
{
    int i;

    for (i = 0;i < 1000000000; ++i)
        ;

    return NULL;
}

void *thread_proc2(void *param)
{
    int i;

    for (i = 0;i < 1000000000; ++i)
        ;

    return NULL;
}

/*--------------------------------------------------------------------------------------------------------------------------
    Sinyal oluştuğunda çağrılacak fonksiyonu (signal handler) set etmek için iki POSIX fonksiyonu kullanılmaktadır: signal ve sigaction.
    signal fonksiyonu eskidir ve maalesef semantik konusunda problemleri vardır. Bu nedenle signal fonksiyonunu değişik sistemler
    değişik biçimde gerçekleştirmişleridir. sigaction fonksiyonunda bu semantik kusurlar ortadan kaldırılmıştır. 

    Aşağıda SIGINT sinyali oluştuğunda (Klavyeden Ctrl + C tuşuna basıldığında SIGINT sinyali oluşmaktadır) çağrılacak 
    fonksiyon set edilmiştir.
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <signal.h>

void exit_sys(const char *msg);
void sigint_handler(int sno);

int main(void)    
{
    int i;

    if (signal(SIGINT, sigint_handler) == SIG_ERR)
        exit_sys("signal");

    for (i = 0; i < 20; ++i) {
        printf("%d\n", i);
        sleep(1);
    }

    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

void sigint_handler(int sno)
{
    printf("SIGINT handler running...\n");
}

/*--------------------------------------------------------------------------------------------------------------------------
    signal fonksiyonun ikinci parametresine SIG_DFL özel değeri geçilirse sinyal fonksiyonu default duruma çekilir. Yani artık
    sinyal oluştuğunda "default action" uygulanır. Bu parametreye SIG_IGN özel değeri geçilirse sinyal işletim sistemi tarafından
    görmeden gelinir (ignore edilir).
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <signal.h>

void exit_sys(const char *msg);

int main(void)    
{
    int i;

    if (signal(SIGINT, SIG_IGN) == SIG_ERR)
        exit_sys("signal");

    for (i = 0; i < 20; ++i) {
        printf("%d\n", i);
        sleep(1);
    }

    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/*--------------------------------------------------------------------------------------------------------------------------
    kill isimli POSIX fonksiyonu (ismi yanlış uydurulmuştur) bir prosese ya da proses grubuna sinyal göndermek için kullanılmaktadır. 
    Eğer birinci parametresi olan pid "> 0" ise spesik prosese sinyal gönderir. Eğer bu parametre "= 0" ise kendi proses grubundaki
    tüm proseslere sinyal gönderir. Eğer bu parametre "< 0" ise abs(pid) değerine sahip pross grubun tüm proseslerine sinyal gönderir. 
    Eğer bu parametre "= -1" ise sinyal gönderebileceği tüm proseslere sinyal gönderir. 

    kill fonksiyonu ile sinyal gönderebilmek için gönderen prosesin gerçek ya da etkin kullanıcı id'sinin gönderilen prosesin gerçek ya da
    saved set kullanıcı id'sine eşit olması gerekir. Tabii root prosesi her prosese sinyal gönderebilir. (Ya da Linux'ta CAP_KILL yeteneğine 
    sahip prosesler de tüm proseslere sinyal gönderebilirler.)

    Aşağıda proc2 programı SIGUSR1 numaları sinyali proc1'e göndermek için yazılmıştır. proc1'i önce çalıştırınız. ps -a ile
    onun pid değerini bakıp o değerler proc2'yi çalıştırınız.
---------------------------------------------------------------------------------------------------------------------------*/

/* proc1.c */

#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <signal.h>

void exit_sys(const char *msg);
void sigusr1_handler(int sno);

int main(void)    
{
    int i;

    if (signal(SIGUSR1, sigusr1_handler) == SIG_ERR)
        exit_sys("signal");

    for (i = 0;; ++i) {
        printf("%d\n", i);
        sleep(1);
    }
        
    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

void sigusr1_handler(int sno)
{
    printf("SIGUSR1 ocurred...\n");
}

/* proc2.c */

#include <stdio.h>
#include <stdlib.h>
#include <signal.h>

void exit_sys(const char *msg);

int main(int argc, char *argv[])    
{
    pid_t pid;

    if (argc != 2) {
        fprintf(stderr, "wrong number of arguments!..\n");
        exit(EXIT_FAILURE);
    }

    pid = (pid_t)strtol(argv[1], NULL, 10);

    if (kill(pid, SIGUSR1) == -1)
        exit_sys("kill");

    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/*--------------------------------------------------------------------------------------------------------------------------
    Komut satırından da bir prosese sinyal göndermek için kill isimli komut kullanılmaktadır. kill komutunun basit kullanımı şöyledir:

    kill -<numara> <process-id'ler>

    Örneğin:

    kill -15 15711

    Numara yerine sinyallerin sembolik sabit isimleri de kullanılabilir. Bunun için SIGXXX isimli sinyal -XXX biçiminde belirtilmelidir. 

    Örneğin:

    kill -TERM 15711

    Eğer kill komutunda sinyal numarası belirtilmezse -TERM (yani -15) belirtilmiş gibi işlem görülür. Bu durumda bir prosesi garantili
    sonlandırmak için -KILL ya da -9 seçenekleri kullanılmalıdır. 

---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Bir prosesi sonlandırmak için sıklıkla iki sinyal kullanılmaktadır: SIGTREM (15) ve SIGKILL (9). SIGTERM sinyali için
    sinyal fonksiyonu set edilebilir fakat SIGKILL için edilemez. Benzer biçimde SIGTERM sinyali SIG_IGN ile ignore edilebilir ancak
    SIGKILL sinyali ignore edilemez. Yani SIGTERM ile sonlandırma garanti değildir ancak SIGKILL ile 
    sonlandırma garantidir. Örneğin:

    kill -KILL 15711

    Aşağıdaki programı bir terminalde çalıştırığ diğeri ile önce SIGTERM sonra da SIGKILL sinyallarini göndermeyi deneyiniz
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <signal.h>

void exit_sys(const char *msg);
void sigterm_handler(int sno);

int main(void)    
{
    int i;

    if (signal(SIGTERM, sigterm_handler) == SIG_ERR)
        exit_sys("signal");

    for (i = 0;; ++i) {
        printf("%d\n", i);
        sleep(1);
    }
        
    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

void sigterm_handler(int sno)
{
    printf("SIGTERM ocurred...\n");
}

/*--------------------------------------------------------------------------------------------------------------------------
    signal fonksiyonu il sinyal set etmek biraz problemlidir. Problem bu fonksiyonun davranışının UNIX türevi sistemlerde farklı
    olabilmesinden kaynaklanmaktadır. Eski UNIX sistemleri signal fonksiyonu ile sinyal set edildiğinde sinyal fonksiyonu çalışırken
    aynı sinyalin oluşmasına izin veriyordu. Böylece aynı sinyal fonksiyonu iç içe çalışabiliyordu. Ancak BSD sistemleri sinyal oluştuğunda
    sinyal fonklsiyonu çalıştırılırken bu sinyali bloke edip bekletmektedir. Ta ki sinyal fonksiyonu işini bitiren kadar. Böylece iç içe
    geçme olmamaktadır. Yşne eski UNIX sistemlerinde signal fonksiyonu ile set yapıldığında sinyal fonksiyonu çağrılır çağrılmaz 
    o numaralı sinyal otomatik default'a çekiliyordu (yani set edilmemiş duruma getiriliyordu). Ancak BSD sistemleri bunu yapmıyordu.
    Yine bu fonksiyon ile set yapıldığında yavaş sistem fonksiyonlarının otomatik restart edilip edilmeyeceği sistemler arasında 
    farklılık gösterebiliyordu. 

    Linux işletim sisteminde signal ve sigaction isimli iki sistem fonksiyonu vardır. signal sistem fonksiyonu Sistem 5 semantiği ile
    sinyal fonksiyonunu set etmektedir. sigaction modern olandır. Fakat glibc kütüphanesindeki signal fonksiyonu glibc 2.0'dan sonra 
    signal sistem fonksiyonunu değil sigaction sistem fonksiyonunu çağırarak yazılmış durumdadır.

    Linux işletim sistemi signal isimli sistem fonksiyonunda eski UNIX System-5 semantiğini uygulamaktadır. Yani:

    - Sinyal fonksiyonu çalıştırılırken sinyal default'a çekilir.
    - Aynı sinyal bloke edilmez. Sinyal fonksiyonu iç içe çalışabilir.
    - Yavaş sistem fonksiyonları restart edilmez. 

    glibc 2.0 öncesinde Linux'taki signal POSIX fonksiyonu signal sistem fonksiyonunu çağırdığı için Sistem 5 semantiğini uyguluyordu. Fakat
    glibc 2.0'dan sonra Linux'taki signal POSIX fonksiyonu sigaction fonksiyonu çağrılarak BSD semantiğini uygulamaktadır. Yani:

    - Sinyal fonksiyonu çalışırken sinyal default'a çekilmez. 
    - Aynı sinyal otomatik bloke edilir.
    - Yavaş sistem fonksiyonları otomatik restart edilir. 

    Maalesef sistem 5 semantiği default'a çekme yüzünden kusurlu tasarlanmıştır. Çünkü aşağıdaki gibi bir işlemde her zaman 
    program çökebilmektedir:

    void signal_handler(int sno)
    {
        // burada yeniden sinyal gelirse prosess sonlanır 
        signal(sno, signal_handler);
        ....
    }

    signal fonksiyonu ile sinyal set etmeye UNIX dünyasında "unreliable signal" da denilmektedir.

---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Sinyal oluştuğunda set çağrılmak üzere set edilen fonksiyonun (signal handler) int parametresi oluşan sinyalin numarasını
    belirtmektedir. Böylece farklı sinyaller için aynı fonksiyon set edilebilir ve bu parametreye bakarak ayrıştırma yapılabilir.
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <signal.h>

void exit_sys(const char *msg);
void signal_handler(int sno);

int main(void)    
{
    int i;

    if (signal(SIGUSR1, signal_handler) == SIG_ERR)
        exit_sys("signal");

    if (signal(SIGUSR2, signal_handler) == SIG_ERR)
        exit_sys("signal");

    for (i = 0;; ++i) {
        printf("%d\n", i);
        sleep(1);
    }
        
    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

void signal_handler(int sno)
{
    if (sno == SIGUSR1)
        printf("SIGUSR1\n");
    else if (SIGUSR2)
        printf("SIGUSR2\n");
}

/*--------------------------------------------------------------------------------------------------------------------------
    sigaction fonksiyonunun prototipi şöyledir:

    #include <signal.h>

    int sigaction(int sig, const struct sigaction *act, struct sigaction *oact);

    Fonksiyonun birinci parametresi set edilecek sinyalin numarasını almaktadır. İkinci parametre sigaction isimli bir yapı nesnesinin
    adresini almaktadır. Programcı bu yapı türünden bir nesne tanımlayıp içini doldurur ve onu fonksiyona parametre olarak 
    geçirir. Üçüncü parametre sinyalin eski bilgilerinin set edileceği sigaction nesnesinin adresini almaktadır. Fonksiyonun ikinci ve üçüncü 
    parametrelerine NULL adres geçilebilir. Genellikle programcılar üçüncü parametreyi NULL adres geçerek fonksiyonu çağırırlar. 
    
    sigaction fonksiyonun semantiği her sistemde aynıdır. Dolayısıyla signal fonksiyonu yerine bu fonksiyon tercih edilmelidir. 
    Bu fonksiyonda struct sigaction isimli bir yapı nesnesinin içi doldurulur ve fonksiyona verilir. Bu yapının doldurulması gereken 
    elemanları şunlardır:

    sa_handler: Çağrılacak sinyal fonksiyonun adresi buraya yerleştirilir. Bu parametreye yine SIG_DFL ve SIG_IGN değerleri geçilebilir. 
    
    sa_mask: Bu eleman sigset_t türündendir. Sinyal fonksiyonu çalıştığı sürece prosesin signal mask'ine burada belirtilen 
    sinyaller eklenir. Fonksiyonun çalışması bittiğinde eklenmiş olan bu sinyaller prosesin signal mask'inden çıkartılır. 
    Bu bit  dizisi üzerinde işlem yapan sigemptyset, sigfillset, sigaddset, sigdelset ve sigismember isimli fonksiyonlar blunmaktadır:

    sa_flags: Bu elemana SA_XXXX biçiminde çeşitli bayraklar OR'lanarak girilir. SA_RESETHAND sinyal fonksiyonu çalıştırılırken
    sinyalin default'a çekileceğini belirtir. Bu flag set edilmezse sinyal default'a çekilmemektedir. SA_NODEFER bayrağı sinyal fonksiyonu
    çalıştığı sürece aynı numaralı sinyalin bloke edilmeyeceği anlamına gelir. Bu flag belirtilmezse sinyal fonksiyonu çalışırken 
    sa_mask dikkate alınmaksızın aynı numaralı sinyal bloke edilmektedir. SA_RESTART yavaş sistem fonksiyonlarınun yeniden otomatik 
    başlatılacağı anlamına gelmektedir. Default durumda yavaş sistem fonksiyonları restart edilmez. Dolayıısyla bu fonksiyonlar 
    EINTR errno değeri set edilerek başarısız olurlar. 

    Sistem 5 semantiği için sa_falgs elemanının SA_NODEFER | SA_RESETHAND biçiminde olması gerekir. BSD semantiği için ise
    flags elemanı SA_RESTART biçiminde olması gerekir. Bu durumda bu eleman 0'da tutulursa otomatik default'a çekme uygulanmaz, 
    sinyal fonksiyonu çalıştığı sürece aynı numaaralı sinyal bloke edilir ve sistem fonksiyonları otomatik restart edilmez. Linux'taki
    signal POSIX fonksiyonu glibc 2.0'dan sonra sa_flags = SA_RESTART biçimindedir ve BSD semantiğini uygulamaktadır.

    sa_sigaction: Yapının bu elemanı alternatif parametrik yapıya sahip sinyal fonksiyonunu set etmek için kullanılmaktadır. Bu elemana
    aşağıdaki parametrik yapıya sahip bir fonksiyonun adresi geçilebilir:

    void some_name(int signo, siginfo_t si, void *data);

    Ancak yapının sa_handler elemanın mı yoksa sa_sigaction elemanının mı kullanılacağı sa_flags parametresindeki SA_SIGINFO bayrağı 
    ile belirlenmektedir. Bu bayrak belirtilmezse yapının sa_handler elemanında set edilmiş olan sinyal fonksiyonu kullanılır. Bu bayrak 
    set edilirse yapının sa_sigaction elemanında belirtilen sinyal fonksiyonu kullanılır. 

    sigaction fonksiyonu başarı durumunda 0 değerine başarısılık durumunda -1 değerine geri dönber ve errno değişkeni uygun biçimde set 
    edilir. 

---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <signal.h>

void exit_sys(const char *msg);
void sigint_handler(int sno);

int main(void)    
{
    struct sigaction act;
    int i;

    act.sa_handler = sigint_handler;
    sigemptyset(&act.sa_mask);
    act.sa_flags = 0;

    if (sigaction(SIGINT, &act, NULL) == -1)
        exit_sys("sigaction");   
    
    for (i = 0;; ++i) {
        printf("%d\n", i);
        sleep(1);
    }
        
    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

void sigint_handler(int sno)
{
    printf("sigint signal occurs...\n");
}

/*--------------------------------------------------------------------------------------------------------------------------
    Her prosesin bloke edilmiş sinyalleri belirten bir signal mask'i vardır. Prosesin signal mask'i Linux sistemlerinde task_struct
    içerisinde saklanmaktadır. Bloke edilen sinyal oluşursa işletim sistemi sinyali prosese teslim etmez (deliver etmez). Onu bekletir.
    Bu beklemedeki bir sinyale "pending" durumda denilmektedir. Eğer proses bloke edilen sinyalin blokesini açarsa bu durumda
    işletim sistemi artık o pending durumda olan sinyali prosese teslim eder. Prosesin signal mask'ine yeni sinyallerin yerleştirilmesi
    ya da oradan sinyal çıkartılması sigprocmask isimli POSIX fonksiyonuyla yapılmaktadır. 

    UNIX türevi sistemlerde klasik sinyallerde kuyruklama yoktur. Yani bloke edilmiş bir sinyal birden fazla kez oluşursa 
    sinyalin blokesi çözüldüğünde yalnızca 1 kez bu sinyalden oluşur.

    sigprocmask fonksiyonunun prototipi şöyledir:

    #include <signal.h>

    int sigprocmask(int how, const sigset_t *set, sigset_t *oset); 

    Fonksiyonun birinci parametresi yapılacak işlemi belirtmektedir. Bu parametreye şunlardan biri girilebilir:

    SIG_BLOCK
    SIG_SETMASK
    SIG_UNBLOCK

    Fonksiyonun ikinci parametresi sinyal kümesini belirtmektedir. Üçüncü parametresi ise eski sinyal kmesini belirtmektedir. 
    İkinci ve üçüncü parametre NULL adres geçilebilir. SIG_BLOCK ikinci parametredeki sinyallerin sinyalin bloke kümesine ekleneceğini,
    SIG_UNBLOCK ikinci parametredeki sinyallerin sinyalin bloke kümesinden çıkartılacağını ve SIG_SETMASK ise ikinci parametrede belirtilen
    sinyallerin tamamen sinyal bloke kümasi haline getirileceğini belirtmektedir. Fonksiyon başarı durumuda 0 değerine başarısılık durumunda -1
    değerine geri döner.

    Aşağıdaki örnekte SIGINT sinyali önce prosesin signal mask'ine eklenerek bloke edilmiş sonra da açılmıştır. 

---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <signal.h>

void exit_sys(const char *msg);
void sigint_handler(int sno);

int main(void)    
{
    int i;
    sigset_t sset;
    struct sigaction act;

    act.sa_handler = sigint_handler;
    sigemptyset(&act.sa_mask);
    act.sa_flags = 0;

    if (sigaction(SIGINT, &act, NULL) == -1)
        exit_sys("sigaction");

    sigemptyset(&sset);
    sigaddset(&sset, SIGINT);

    if (sigprocmask(SIG_BLOCK, &sset, NULL) == -1)
        exit_sys("sigprocmask");

    for (i = 0;; ++i) {
        printf("%d\n", i);
        if (i == 10) 
            if (sigprocmask(SIG_UNBLOCK, &sset, NULL) == -1)
                exit_sys("sigprocmask");
        sleep(1);
    }
        
    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

void sigint_handler(int sno)
{
    printf("SIGINT occurred...\n");
}

/*--------------------------------------------------------------------------------------------------------------------------
    pause isimli POSIX fonksiyonu bir sinyal oluşana kadar blokede beklemeye yol açar. Eğer bir sinyal için sinyal fonksiyonu
    set edilmişse pause fonksiyonu sinyal fonksiyonu çalıştırıldıktan sonra geri dönmektedir. Fonksiyon her zaman -1 değerine geri 
    döner ve errno değeri de her zaman EINTR olarak set edilir. 
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <signal.h>

void exit_sys(const char *msg);
void sigint_handler(int sno);

int main(void)    
{
    struct sigaction act;

    act.sa_handler = sigint_handler;
    sigemptyset(&act.sa_mask);
    act.sa_flags = 0;

    if (sigaction(SIGINT, &act, NULL) == -1)
        exit_sys("sigaction");

    printf("waiting for a signal\n");
    
    pause();

    printf("ok\n");

    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

void sigint_handler(int sno)
{
    printf("SIGINT occurred...\n");
}

/*--------------------------------------------------------------------------------------------------------------------------
    Bazen programlar sonsuz döngüde sinyalleri bekleyerek işlevlerini gerçekleştirebilmektedir.
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <signal.h>

void exit_sys(const char *msg);
void sigint_handler(int sno);

int main(void)    
{
    struct sigaction act;

    act.sa_handler = sigint_handler;
    sigemptyset(&act.sa_mask);
    act.sa_flags = 0;

    if (sigaction(SIGINT, &act, NULL) == -1)
        exit_sys("sigaction");

    printf("waiting for a signal\n");

    for (;;)
        pause();
  
    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

void sigint_handler(int sno)
{
    printf("SIGINT occurred...\n");
}

/*--------------------------------------------------------------------------------------------------------------------------
    abort standart C fonksiyonu parametresizdir ve geri dönüş değerine sahip değildir. Bu fonksiyon anormal çıkışlar için düşünülmüştür.
    Bir programda çok ciddi birtakım sorunlar tespit edilmişse çıkış exit ile değil abort ile yapılmalıdır. abort SIGABRT isimli 
    sinyalin oluşmasına yol açmaktadır. 
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>

int main(void)    
{
   printf("program runs...\n");

   abort();

   printf("unreachable code...\n");

    return 0;
}

/*--------------------------------------------------------------------------------------------------------------------------
    abort fonksiyonu çağrıldığında SIGABRT sinyali "raise" edilmektedir. (Sinyalin raise edilmesi sonraki örneklerde ele alınmaktadır.)
    Bu durumda eğer sinyal fonksiyonu set edilmişse o fonksiyon çalıştırılır fonksiyonun çalışması bittiğinde proses sonlandırılır. 
    SIGABRT sinyali her zaman core dosyasının oluşmasına yol açmaktadır. 
    
    Aşağıdaki örnekte abort fonksiyonu çağrılında set edilen fonksiyonu çalışacak bu fonksiyon bittiğinde program sonlandırılacaktır. 
    Yani abort'tan sonraki "ok" yazısı ekranda görülmeyecektir. 
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <signal.h>

void exit_sys(const char *msg);
void sigabrt_handler(int sno);

int main(void)    
{
    struct sigaction act;

    act.sa_handler = sigabrt_handler;
    sigemptyset(&act.sa_mask);
    act.sa_flags = 0;

    if (sigaction(SIGABRT, &act, NULL) == -1)
        exit_sys("sigaction");

    printf("waiting for a signal\n");

    abort();

    printf("ok\n");
  
    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

void sigabrt_handler(int sno)
{
    printf("SIGABRT occurred...\n");
}

/*--------------------------------------------------------------------------------------------------------------------------
    SIGABRT sinyali abort tarafından değil de kill gibi bir fonksiyon tarafından gönderilirse sinyal fonksiyonu çalıştıktan sonra
    program sonlanmaz. Çünkü programı  raise işlemi sonrasında abort fonksiyonu sonlandırmaktadır.

    Aşağıdaki programı çalıştırıp başka bir terminalden kill -ABRT <pid> komutu ile SIGABRT sinyalini gönderiniz.
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <signal.h>

void exit_sys(const char *msg);
void sigabrt_handler(int sno);

int main(void)    
{
    struct sigaction act;

    act.sa_handler = sigabrt_handler;
    sigemptyset(&act.sa_mask);
    act.sa_flags = 0;

    if (sigaction(SIGABRT, &act, NULL) == -1)
        exit_sys("sigaction");

    printf("waiting for a signal\n");

    pause();

    printf("ok\n");
  
    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

void sigabrt_handler(int sno)
{
    printf("SIGABRT occurred...\n");
}

/*--------------------------------------------------------------------------------------------------------------------------
    C'de goto deyimi aynı fonksiyon içerisindeki atlamalarda kullanılır. Bir fonksiyondan başka bir fonksiyona atlamaya
    "nonlocal jump" ya da "long jump" denilmektedir. Ancak programcı herhangi bir yere long jump yapamaz. Ancak daha önce
    geçmiş olduğu bir noktaya long jump yapabilir. İşte setjmp fonksiyonu ile önce geri dönülecek yer belirlenir. Sonra longjmp ile
    buraya geri dönülür. setjmp fonksiyonu ilk çağrıda 0 ile geri dönmektedir. longjmp yapıldığında akış yine setjmp'ın içerisinden çıkar.
    Fakat bu kez setjmp 0 ile değil longjmp'de belirtilen değerle geri dönmektedir. Nesne yönelimli programlama dillerindeki try-cathc-throw
    mekanizmaları da aynı yöntemle derleyici tarafından sağlanmaktadır. 
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <setjmp.h>

void foo(void);
void bar(void);

jmp_buf g_jb;

int main(void)    
{
    int result;

    printf("main begins...\n");

    if ((result = setjmp(g_jb)) == 0)
        printf("first set...\n");
    else if (result == 1) {
        printf("return from longjmp...\n");
        exit(EXIT_SUCCESS);
    }
    
    foo();

    return 0;
}

void foo(void)
{
    printf("foo begins...\n");
    bar();
    printf("foo ends...\n");
}

void bar(void)
{
    printf("bar begins...\n");
    longjmp(g_jb, 1);
    printf("bar ends...\n");
}

/*--------------------------------------------------------------------------------------------------------------------------
    Eğer SIGABRT sinyali set edilen fonksiyonda longjmp yapılırsa abort fonksiyonu prosesi sonlandıramaz.
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <setjmp.h>
#include <unistd.h>
#include <signal.h>

void exit_sys(const char *msg);
void sigabrt_handler(int sno);

jmp_buf g_jb;

int main(void)    
{
    struct sigaction act;
    int result, i;

    act.sa_handler = sigabrt_handler;
    sigemptyset(&act.sa_mask);
    act.sa_flags = 0;

    if (sigaction(SIGABRT, &act, NULL) == -1)
        exit_sys("sigaction");

    if ((result = setjmp(g_jb)) == 1) 
        goto CONTINUE;
       
    abort();

CONTINUE:
    for (i = 0; i < 10; ++i) {
        printf("%d ", i), fflush(stdout);
        sleep(1);
    }
    printf("\n");
  
    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

void sigabrt_handler(int sno)
{
    printf("SIGABRT occurred...\n");

    longjmp(g_jb, 1);
}

/*--------------------------------------------------------------------------------------------------------------------------
    raise POSIX fonksiyonu kendi prosesine sinyal göndermek için kullanılır. Aslında raise(signo) ile kill(getpid(), signo) tamamen 
    eşdeğerdir. raise aynı zamanda standart bir C fonksiyonudur. raise fonksiyonu ile sinyal gönderildiğinde fonksiyon geri dönmeden kesinlikle
    sinyal fonksiyonun çalışmış olacağı garanti edilmiştir. Aynı garanti kill fonksiyonu ile kendi prosesimize sinyal gönderirken de verilmiştir.
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <signal.h>

void exit_sys(const char *msg);
void sigusr1_handler(int sno);

int main(void)    
{
    struct sigaction act;

    act.sa_handler = sigusr1_handler;
    sigemptyset(&act.sa_mask);
    act.sa_flags = 0;

    if (sigaction(SIGUSR1, &act, NULL) == -1)
        exit_sys("sigaction");

    printf("raise will be called...\n");

    if (raise(SIGUSR1) == -1)
        exit_sys("raise");

    printf("raise called...\n");

    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

void sigusr1_handler(int sno)
{
    printf("SIGUSR1 occurred...\n");
}

/*--------------------------------------------------------------------------------------------------------------------------
    alarm fonksiyonu belli bir saniye sonra kendi prosesine SIGALRM sinyalinin gönderilmesine yol açar. Eüer daha önce bir 
    alarm set edilmişse o silinir yenisi set edilmiş olur. Fonksiyonun parametresi 0 olarak geçilirse eski alarm iptal edilmektedir. 
    Fonksiyon bir önce set edilmiş alarm'daki kalan saniye sayısını vermektedir. 
---------------------------------------------------------------------------------------------------------------------------*/

    #include <stdio.h>
    #include <stdlib.h>
    #include <unistd.h>
    #include <signal.h>

    void exit_sys(const char *msg);
    void sigalrm_handler(int sno);

    int main(void)    
    {
        struct sigaction act;
        
        act.sa_handler = sigalrm_handler;
        sigemptyset(&act.sa_mask);
        act.sa_flags = 0;

        if (sigaction(SIGALRM, &act, NULL) == -1)
            exit_sys("sigaction");

        alarm(10);

        pause();

        return 0;
    }

    void exit_sys(const char *msg)
    {
        perror(msg);

        exit(EXIT_FAILURE);
    }

    void sigalrm_handler(int sno)
    {
        printf("SIGALRM occurred...\n");
    }

/*--------------------------------------------------------------------------------------------------------------------------
    Programcılar genellikle periyodik timer oluşturmak için alarm sinyal fonksiyonunda yeniden alarm çağırması yaparlar. 
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <signal.h>

void exit_sys(const char *msg);
void sigalrm_handler(int sno);

int main(void)    
{
    struct sigaction act;
    
    act.sa_handler = sigalrm_handler;
    sigemptyset(&act.sa_mask);
    act.sa_flags = 0;

    if (sigaction(SIGALRM, &act, NULL) == -1)
        exit_sys("sigaction");

    alarm(1);

    for(;;)
        pause();

    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

void sigalrm_handler(int sno)
{
    printf("SIGALRM occurred...\n");

    alarm(1);
}

/*--------------------------------------------------------------------------------------------------------------------------
    Bir sinyal için sinyal fonksiyonu (signal handler) set ettiğimizde o sinyal fonksiyonun içerisinde çağıracağımız fonksiyonlara
    dikkat etmeliyiz. Sinyal fonksiyonlarının içerisinde ancak "sinyal güvenli (async-signal safe)" fonksiyonları çağırmalıyız. 
    POSIX standartlarında sinyal güvenli fonksiyonların neler olduğu listelenmiştir. Tabii bazı koşullar altında dikkat olmak koşuluyla
    sinyal fonksiyonlarının içerisinde sinyal güvenli olmayan fonksiyonları da çağırabiliriz. 

    Bir POSIX fonksiyonu çalışırken onun içerisinde sinyal oluşursa ve sinyal fonksiyonu da aynı fonksiyonu çağırırsa üstelik bu fonksiyon sinyal güvenli
    değilse sorun oluşabilir. Thread güvenlilikle sinyal güvenlilik aynı anlamda değildir. Bir fonksiyon şu kategorilerden
    birine girebilir:

    1) Hem thread güvenli hem de sinyal güvenli
    2) Thread güvenli fakat sinyal güvenli değil
    3) Sinyal güvenli ama thread güvenli değil
    4) Thread güvenli de değil, sinyal güvenli de değil

    Örneğin aşağıdaki fonksiyon thread güvenli olduğu halde sinyal güvenli değildir:

    thread_local int g_i;

    void foo(void)
    {
        g_i = 10;
        ...
        g_i = 20;
        ...
        g_i = 30;
    }

    Bazı POSIX fonksiyonlarının thread güvenli olduğu olduğu halde sinyal güvenli olmadığına dikkat ediniz: Örneğin malloc, calloc, 
    stdio fonksiyonları gibi...
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Bir sinyal fonksiyonu içerisinde errno'yu değiştiren bir POSIX fonksiyonu kullanılırsa sinyal kestiği fonksiyonun set ettiği errno 
    değeri bozulabilir. Bunun için eğer böyle bir fonksiyon çağrılacaksa sinyal fonksiyonlarının başında errno değerini 
    saklayıp sonunda yeniden set etmek iyi bir tekniktir. Örneğin:

    void signal_handler(int signo)
    {
        int temp = errno;
        ....
        errno = temp;
    }

    POSIX fonksiyonları başarı durumunda errno değerini 0 olarak set etmezler. POSIX standartlarına göre errno hiçbir fonksiyon tarafından 0'a 
    çekilmemektedir. POSIX standarları başarı durumunda errno değerinin fonksiyon tarafından değiştirilebileceğini açıkça belirtmiştir. 
    Ancak başarı durumunda errno değerini başka değerlere set eden POSIX fonksiyonları vardır. Bu nedenle programcının errno değişkenini 
    saklayıp geri yerleştirmesi uygun olur. 
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Alt proses sonlandığında işletim sistemi o prosesin üst prosesine SIGCHLD sinyali göndermektedir. Bu sinyalin ismi AT&T
    UNIX sistemlerinde eskiden SIGCLD biçimindeydi. Ancak POSIX BSD ismi olan SIGCHLD ismini tercih etti. O zamanlar SIGCLD
    sinyaliin semantiği ile SIGCHLD sinyalinin semantiği arasında da küçük farklılıklar vardı. POSIX standartları bu farklılıkları
    "implementation dependent" hale getirmiştir. 
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/wait.h>
#include <signal.h>

void exit_sys(const char *msg);
void sigchld_handler(int sno);

int main(void)    
{
    struct sigaction act;
    pid_t pid;
    
    act.sa_handler = sigchld_handler;
    sigemptyset(&act.sa_mask);
    act.sa_flags = 0;

    if (sigaction(SIGCHLD, &act, NULL) == -1)
        exit_sys("sigaction");

    if ((pid = fork()) == -1)
        exit_sys("fork");

    if (pid == 0) {
        sleep(5);
        _exit(EXIT_FAILURE);
    }

    pause();

    if (waitpid(pid, NULL, 0) == -1)
        exit_sys("waitpid");

    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

void sigchld_handler(int sno)
{
    printf("SIGCHLD occurred...\n");
}

/*--------------------------------------------------------------------------------------------------------------------------
    SIGCHLD sinyali genellikle zombie proses oluşumunu otomatik engellemek için kullanılmaktadır. Yani tipik olarak programcı
    bu sinyale ilişkin sinyal fonksiyonu içerisinde wait fonksiyonlarını uygular.
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/wait.h>
#include <signal.h>

void exit_sys(const char *msg);
void sigchld_handler(int sno);

int main(void)    
{
    struct sigaction act;
    pid_t pid;
    
    act.sa_handler = sigchld_handler;
    sigemptyset(&act.sa_mask);
    act.sa_flags = 0;

    if (sigaction(SIGCHLD, &act, NULL) == -1)
        exit_sys("sigaction");

    if ((pid = fork()) == -1)
        exit_sys("fork");

    if (pid == 0) {
        sleep(5);
        _exit(EXIT_FAILURE);
    }

    pause();

    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

void sigchld_handler(int sno)
{
    if (waitpid(-1, NULL, 0) == -1)
        exit_sys("waitpid");
}

/*--------------------------------------------------------------------------------------------------------------------------
    Üst prosesin birden fazla alt proses yarattığı durumda bu alt prosesler birbirlerine yakın zamanlarda sonlanırsa sinyaller
    kuyruklanmadığından her alt proses için bir kez SIGCHLD sinyali oluşmayabilir. Bu durum da otomatik zombie engellemeyi
    sekteye uğratabilir. Örneğin aşağıda 10 tane alt proses yaratılmıştır. Ancak sinyal fonksiyonu 10 kere çağrılmamaktadır.
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/wait.h>
#include <signal.h>

void exit_sys(const char *msg);
void sigchld_handler(int sno);

int main(void)    
{
    struct sigaction act;
    pid_t pids[10];
    int i;
    
    act.sa_handler = sigchld_handler;
    sigemptyset(&act.sa_mask);
    act.sa_flags = 0;

    if (sigaction(SIGCHLD, &act, NULL) == -1)
        exit_sys("sigaction");


    for (i = 0; i < 10; ++i) {
        if ((pids[i] = fork()) == -1)
            exit_sys("fork");
        if (pids[i] == 0) {
            sleep(5);
            _exit(EXIT_FAILURE);
        }
    }

    for (;;)
        pause();

    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

void sigchld_handler(int sno)
{
    int temp = errno;

    printf("SIGCHLD occurred...\n");

    errno = temp;
}

/*--------------------------------------------------------------------------------------------------------------------------
    Yukarıdaki problem aşağıdaki gibi SIGCHLD sinyal fonksiyonunda bir döngü içerisinde wait fonksiyonları uygulanarak 
    giderilebilir. Ekrana yazıdırılan yazıların sayısına bakarak 10 tane olduğunu görünüz.
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/wait.h>
#include <errno.h>
#include <signal.h>

void exit_sys(const char *msg);
void sigchld_handler(int sno);

int main(void)    
{
    struct sigaction act;
    pid_t pids[10];
    int i;
    
    act.sa_handler = sigchld_handler;
    sigemptyset(&act.sa_mask);
    act.sa_flags = 0;

    if (sigaction(SIGCHLD, &act, NULL) == -1)
        exit_sys("sigaction");


    for (i = 0; i < 10; ++i) {
        if ((pids[i] = fork()) == -1)
            exit_sys("fork");
        if (pids[i] == 0) {
            sleep(5);
            _exit(EXIT_FAILURE);
        }
    }

    for (;;)
        pause();

    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

void sigchld_handler(int sno)
{
    int temp = errno;

    while (waitpid(-1, NULL, WNOHANG) > 0) 
        printf("prevented child to be zombie!..\n");

    errno = temp;
}

/*--------------------------------------------------------------------------------------------------------------------------
    POSIX standartlarına göre otomatik zombie engellenemenin iki yolu daha vardır:

    1) SIGCHLD sinyali ignore'a çekilir (SIG_IGN)
    2) SIGCHLD sinyali için sigaction fonksiyonunda set yapılırken SA_NOCLDWAIT bayrağı da kullanılır.

    POSIX standartları SIGCHLD sinyali için SA_NOCLDWAIT bayrağı kullanıldığında sinyal fonksiyonun çağrılıp çağrılamayacağını
    işletim sisteminin isteğine bırakmıştır. Linux sistemleri sinyal fonksiyonunu çağırmaktadır. 

    Her ne kadar SIGCHLD sinyalinin default eylemi (default action) "ignore" olsa da burada "ignore'a çekmek" açıkça
    signal fonksiyonuyla ya da sigaction fonksiyonuyla SIG_IGN kullanmak anlamındadır. 

    Bu biçimde otomatik zombie engellendiğinde artık wait fonksiyonları kullanılmamalıdır. Eğer kullanılırsa bu fonksiyonlar -1'e
    geri dönerler ve errno da ECHILD olarak set edilir. Dolayısıyla aşağıdaki örnekte waitpid fonksiyonu otomatik zombie 
    engellendiği için başarısızlıkla geri dönecektir.
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/wait.h>
#include <errno.h>
#include <signal.h>

void exit_sys(const char *msg);

int main(void)    
{
    struct sigaction act;
    pid_t pids[10];
    int i;
    
    act.sa_handler = SIG_IGN;
    sigemptyset(&act.sa_mask);
    act.sa_flags = 0;

    if (sigaction(SIGCHLD, &act, NULL) == -1)
        exit_sys("sigaction");

    /* signal(SIGCHLD, SIG_IGN); */

    for (i = 0; i < 10; ++i) {
        if ((pids[i] = fork()) == -1)
            exit_sys("fork");
        if (pids[i] == 0) {
            _exit(EXIT_FAILURE);
        }
    }

    printf("press ENTER to continue...\n");
    getchar();

    if (waitpid(-1, NULL, 0) == -1)     /* waitpid will fail!.. */
        exit_sys("waitpid");

    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/*--------------------------------------------------------------------------------------------------------------------------
    Eğer sigaction fonksiyonunda SIGCHLD sinyali için hem fonksiyon set edilir hem de SA_NOCLDWAIT bayrağı kullanılırsa 
    bu durumda otomatik zombie yine engellenmekle birlikte sinyal fonksiyonun çağrılıp çağrılmayacağı işletim sistemine
    bırakılmıştır (implementation dependent). Linux'ta çağırma yapılmaktadır. SA_NOCLDWAIT bayrağı yalnızca SIGCHLD sinyali 
    için anlamlıdır.
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/wait.h>
#include <errno.h>
#include <signal.h>

void exit_sys(const char *msg);
void sigchld_handler(int sno);

int main(void)    
{
    struct sigaction act;
    pid_t pids[10];
    int i;
    
    act.sa_handler = sigchld_handler;
    sigemptyset(&act.sa_mask);
    act.sa_flags = SA_NOCLDWAIT;

    if (sigaction(SIGCHLD, &act, NULL) == -1)
        exit_sys("sigaction");

    for (i = 0; i < 10; ++i) {
        if ((pids[i] = fork()) == -1)
            exit_sys("fork");
        if (pids[i] == 0) {
            sleep(1);
            _exit(EXIT_FAILURE);
        }
    }

   for(;;)
        pause();

    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

void sigchld_handler(int sno)
{
    int temp = errno;   

    printf("SIGCHLD occurred...\n");        /* wait should'nt be used! */

    errno = temp;
}

/*--------------------------------------------------------------------------------------------------------------------------
    Bazı sistem fonksiyonları (read, write, sleep gibi) bazı kaynaklarla çalışırken uzun süre bekleme yapabilmektedir. Çünkü
    bu sistem fonksiyonları istenen şey gerçekleşene kadar çizelgeden çıakrtılıp blokeye yol açmaktadır. Pekiyi bir proses
    bu sistem fonksiyonlarında blokede beklerken bir sinyal oluştuğunda ne olur? İşte işletim sistemi bu durumda sinyali hemen
    teslim edebilmek için fonksiyonun yol açtığı blokenin bitmesini beklemez. Sistem fonksiyonunu başarısızlıkla sonlandırır ve
    hemen prosesi çizelgeye sokarak ona sinyali teslim eder. Bu tür sistem fonksiyonları (yani bunları çağıran POSIX fonksiyonları)
    -1 değerine geri dönüp errno değerini EINTR olarak set etmektedir. Bu durumda biz böylesi bir durumla karşılaştığımızda
    fonksiyonun yaptığı işte başarız olduğunu düşünmemeliyiz. Fonksiyonun sinyal geldiğinden dolayı başarısız olduğunu ve
    yeniden çağrılırsa başarılı olabileceğini düşünmeliyiz. O halde bu tür sistem fonksiyonlarını çağırırken bizim eğer 
    başarısızlığın nedeni sinyal ise (EINTR) bu fonksiyonu yeniden çağrımamız gerekir. Bu da maalesef programlama açısından sıkıntılıdır. 

    Aşağıdaki programda alarm fonksiyonu dolayısıyla SIGALRM sinyali gönderildiğinde scanf fonksiyonu (yani aslında onun çağırdığı read fonksiyonu)
    başarız olacaktır ve errno EINTR ile set edilecektir. 
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <errno.h>
#include <signal.h>

void exit_sys(const char *msg);
void sigalrm_handler(int sno);

int main(void)    
{
    struct sigaction act;
    int val;
    
    act.sa_handler = sigalrm_handler;
    sigemptyset(&act.sa_mask);
    act.sa_flags = 0;

    if (sigaction(SIGALRM, &act, NULL) == -1)
        exit_sys("sigaction");

    alarm(1);

    printf("Bir sayı giriniz:");
    fflush(stdout);
    scanf("%d", &val);
    printf("%d\n", val * val);

    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

void sigalrm_handler(int sno)
{
    /* do something */
}

/*--------------------------------------------------------------------------------------------------------------------------
    İşte bu tür durumlarda yöntemlerden birisi eğer fonksiyon sinyal yüzünden başarısız olmuşsa bir döngü içerisinde onu 
    yeniden çağırmaktır. Tabii eğer programcı kendi programında bir sinyal işliyorsa bu yola gitmelidir. Yoksa zaten işlenmeyen
    sinyaller için proses sonlandırılır. Bir sinyalin default eylemi (default action) eğer "ignore" ise bu durumda işletim 
    sistemi yavaş sistem fonksiyonlarını başarısızlıkla sonlandırmaz.
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <errno.h>
#include <signal.h>

void exit_sys(const char *msg);
void sigalrm_handler(int sno);

int main(void)    
{
    struct sigaction act;
    int val;
    
    act.sa_handler = sigalrm_handler;
    sigemptyset(&act.sa_mask);
    act.sa_flags = 0;

    if (sigaction(SIGALRM, &act, NULL) == -1)
        exit_sys("sigaction");

    alarm(1);

    printf("Bir sayı giriniz:");
    fflush(stdout);

    while (scanf("%d", &val) == -1 && errno == EINTR)
        ;

    printf("%d\n", val * val);

    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

void sigalrm_handler(int sno)
{
    /* do something */
}

/*--------------------------------------------------------------------------------------------------------------------------
    Bu çok sıkıcı bir işelmdir. Bazı programcılar bunun için aşağıdaki gibi bir makro kullanabilmektedir:

    #define EINTR_LOOP(statement)   while ((statement) == -1 && errno == EINTR)
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <errno.h>
#include <signal.h>

#define EINTR_LOOP(statement)       while ((statement) == -1 && errno == EINTR)

void exit_sys(const char *msg);
void sigalrm_handler(int sno);

int main(void)    
{
    struct sigaction act;
    int val;
    
    act.sa_handler = sigalrm_handler;
    sigemptyset(&act.sa_mask);
    act.sa_flags = 0;

    if (sigaction(SIGALRM, &act, NULL) == -1)
        exit_sys("sigaction");

    alarm(1);

    printf("Bir sayı giriniz:");
    fflush(stdout);

    EINTR_LOOP(scanf("%d", &val));
    printf("%d\n", val * val);

    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

void sigalrm_handler(int sno)
{
    /* do something */
}

/*--------------------------------------------------------------------------------------------------------------------------
    Bazı yavaş sistem fonksiyonlarının çekirdek tarafından otomatik restart edilmesi için sigaction fonksiyonunda sa_flags
    parametresi SA_RESTART girilmelidir. Bu durumda artık programcının sinyal nedeniyle sonlanmalar için kendisinin bir döngü oluşturmasına
    gerek kalmaz. 
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <errno.h>
#include <signal.h>

void exit_sys(const char *msg);
void sigalrm_handler(int sno);

int main(void)    
{
    struct sigaction act;
    int val;
    
    act.sa_handler = sigalrm_handler;
    sigemptyset(&act.sa_mask);
    act.sa_flags = SA_RESTART;

    if (sigaction(SIGALRM, &act, NULL) == -1)
        exit_sys("sigaction");

    alarm(1);

    printf("Bir sayı giriniz:");
    fflush(stdout);

    if (scanf("%d", &val) == -1)
        exit_sys("scanf");
    
    printf("%d\n", val * val);

    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

void sigalrm_handler(int sno)
{
    /* do something */
}

/*--------------------------------------------------------------------------------------------------------------------------
    Anımsanacağı gibi eski signal fonksiyonunda sinyal oluştuğunda yavaş fonksiyonlarında otomatik restart işlemi işletim sistemine
    bağlı olarak değişebiliyordu (implementation dependent). Linux sistemlerinde otomatik restart yapıldığını anımsayınız.
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <errno.h>
#include <signal.h>

void exit_sys(const char *msg);
void sigalrm_handler(int sno);

int main(void)    
{
    int val;

    if (signal(SIGALRM, sigalrm_handler) == SIG_ERR)
        exit_sys("signal");

    alarm(1);

    printf("Bir sayı giriniz:");
    fflush(stdout);

    if (scanf("%d", &val) == -1)
        exit_sys("scanf");
    
    printf("%d\n", val * val);

    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

void sigalrm_handler(int sno)
{
    /* do something */
}

/*--------------------------------------------------------------------------------------------------------------------------
    Biz sigaction fonksiyonunda flags parametresinde SA_RESTART girmiş olsak bile bazı yavaş sistem fonksiyonları doğası gereği
    restart edilememektedir. SA_RESTART bayrağı belirtildiğinde genel olarak POSIX standartlarında hangi fonksiyonların hangi 
    koşullar altında restart edileceği belirtlmemiştir. Örneğin sleep, nanosleep gibi bekleme fonksiyonları restart işlemi 
    yapmazlar. Zaten bu işlemin bu fonksiyonlarda yapılması anlamlı değildir.   
    read (write vs.) fonksiyonu talep edildiği kadar bilgiyi henüz okuyamamışken sinyal oluşabilir. Bu durumda SA_RESTART bayrağı
    set edilmemiş olsa bile fonksiyon başarısız olmaz. Okuduğu kadar bilgiye geri döner.  
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <errno.h>
#include <signal.h>

void exit_sys(const char *msg);
void sigusr1_handler(int sno);

int main(void)    
{
    struct sigaction act;
    
    act.sa_handler = sigusr1_handler;
    sigemptyset(&act.sa_mask);
    act.sa_flags = SA_RESTART;

    if (sigaction(SIGUSR1, &act, NULL) == -1)
        exit_sys("sigaction");

    if (sleep(60) != 0) 
        if (errno == EINTR)
            printf("sleep finished due to signal...\n");
        else  
            exit_sys("sleep");
    else
        printf("sleep finished normally...\n");

    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

void sigusr1_handler(int sno)
{
    /* do something */
}

/*--------------------------------------------------------------------------------------------------------------------------
    open, read write gibi fonksiyonları bloke durumunda sinyal geldiğinde eğer proses sonlanmazsa başarısız olmaktadır.
    Aşağıdaki örnekte "myfifo" isimli bir boru dosyası açılmak istenmiştir. Başka bir proses boruyu yazma modunda açana kadar
    bloke oluşacaktır. Bu duurmda başka bir terminalden SIGUSR1 sinyalini prosese göndererek open fonksiyonunun EINTR errno
    değeriyle başarısız olduğunu görünüz.
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <fcntl.h>
#include <unistd.h>
#include <errno.h>
#include <signal.h>

void exit_sys(const char *msg);
void sigusr1_handler(int sno);

int main(void)    
{
    struct sigaction act;
    int fd;
    ssize_t size;
    char buf[10];
    
    act.sa_handler = sigusr1_handler;
    sigemptyset(&act.sa_mask);
    act.sa_flags = 0;

    if (sigaction(SIGUSR1, &act, NULL) == -1)
        exit_sys("sigaction");

    if ((fd = open("myfifo", O_RDONLY)) == -1)
        exit_sys("open");

    printf("pipe opened successfully...\n");

    if ((size = read(fd, buf, 10)) == -1)
        exit_sys("read");

    printf("read read successfully\n");

    close(fd);
   
    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

void sigusr1_handler(int sno)
{
    /* do something */
}

/*--------------------------------------------------------------------------------------------------------------------------
    POSIX'e 90 yılların ortalarında "realtime extensions" başlığı altında "gerçek zamanlı (realtime)" sinyal kavramı da eklendi.
    Gerçek zamanlı sinyallarin numaraları [SIGRTMIN, SIGRTMAX] arasındadır. Bunlara ayrı isimler verilmemiştir. Gerçek zamanlı
    sinyallerin normal sinyallerden (ilk 32 sinyal numarası normal sinyaller için ayrılmıştır) farkları şunlardır:

    1) Gerçek zamanlı sinyaller kuyruklanmaktadır. Yani birden fazla gerçek zamanlı aynı sinyal oluştuğunda kaç tane oluşmuş olduğu tutulur
    ve o sayıda sinyal prosese teslim edilir. 
    2) Gerçek zamanlı sinyallerde bir bilgi de sinyale iliştirilebilmektedir. Bu bilgi ya int bir değer ya da bir gösterici olur.
    Gösterici kullanıldığında bu göstericinin gösterdiği yerin hedef proseste anlamlı olması gerekmektedir.
    3) Gerçek zamanlı sinyallerde bir öncelik ilişkisi (priority) vardır. Birden fazla farklı numaralı gerçek zamanlı sinyal 
    bloke edildiği durumda bloke açılınca bunların oluşma sırası küçük numaradan büyük numaraya göredir. 

    Gerçek zamanlı sinyaller kill fonksiyonu ile değil sigqueue isimli fonksiyonla gönderilmektedir. Eğer bu sinyaller kill ile
    gönderilirse kuyruklama yapılıp yapılmayacağı sistemden sisteme değişebilmektedir. 

    Gerçek zamanlı sinyaller işlenirken yine sigaction fonksiyonu kullanılmak zorundadır. Bu fonksiyonda sinyal fonksiyonu için
    artık sigaction yapısının sa_handler elemanına değil sa_sigaction elemanına atama yapılmalıdır. Tabii fonksiyonun bunu anlaması 
    için flags parametresine de ayrıca SA_SIGINFO eklenmelidir. (Yani başka bir deyişle fonkisyon sa_flags parametresinde SA_SIGINFO 
    değerini gördüğünde artık sinyal fonksiyonu için yapının sa_sigaction elemanı bakar.)

    Aşağıdaki örnekte proc1 programı n tane gerçek zamanlı sinyal gönderir. proc2 ise bunları almaktadır. Programlaro çalıştırarak
    kuyruklamanın yapıldığına dikkat ediniz. sigqueue fonksiyonunda iliştirilen sinyal bilgisi siginfo_t yapısının si_value
    elemanından alınmaktadır. 

    sigqueue fonksiyonuyla set edilen inyal fonksiyonundaki siginfo_t yapısının diğer elemanlarını ilgili dokimanlardan inceleyniz.
    (Örneğin burada sinyali gönderen proses id'si, gerçek kullanıcı id'si, sinyalin neden gönderildiği gibi bilgiler vardır.)

---------------------------------------------------------------------------------------------------------------------------*/

/* prog1.c */

#include <stdio.h>
#include <stdlib.h>
#include <signal.h>

void exit_sys(const char *msg);

/* ./prog1 <realtime signal no> <process id> <count> */

int main(int argc, char *argv[])    
{
    int signo;
    pid_t pid;
    int count;
    int i;
    union sigval val;

    if (argc != 4) {
        fprintf(stderr, "wrong number of arguments!..\n");
        exit(EXIT_FAILURE);
    }

    signo = (int)strtol(argv[1], NULL, 10);
    pid = (pid_t)strtol(argv[2], NULL, 10);
    count = (int)strtol(argv[3], NULL, 10);

    for (i = 0; i < count; ++i) {
        val.sival_int = i;
        if (sigqueue(pid, SIGRTMIN + signo, val) == -1)
            exit_sys("sigqueue");
    }

    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/* prog2.c */

#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <signal.h>

void exit_sys(const char *msg);
void sigrt_handler(int signo, siginfo_t *info, void *context);

/* ./prog2 <realtime signal no> */

int main(int argc, char *argv[])    
{
    struct sigaction act;
    int signo;

    if (argc != 2) {
        fprintf(stderr, "wrong number of arguments!..\n");
        exit(EXIT_FAILURE);
    }
    
    signo = (int)strtol(argv[1], NULL, 10);

    act.sa_sigaction = sigrt_handler;
    sigemptyset(&act.sa_mask);
    act.sa_flags = SA_SIGINFO;

    if (sigaction(SIGRTMIN + signo, &act, NULL) == -1)
        exit_sys("sigaction");

    for(;;)
        pause();
   
    return 0;
}

void sigrt_handler(int signo, siginfo_t *info, void *context)
{
    printf("SIGRTMIN + %d occurred with %d code\n", signo - SIGRTMIN, info->si_value.sival_int);
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/*--------------------------------------------------------------------------------------------------------------------------
    Sinyal konusu UNIX türevi sistemlerde 70'lerin başlarından beri vardı. Oysa thread'ler 90'ların ortalarında bu sistemlere
    sokulmuştur. Yani aslında sinyal konusu thread'siz bir ortamda ortaya çıkmış ve kullanılmaya başlanmıştır. Ancak thread'ler 
    eklendikten sonra bazı belirlemelerin de yapılması gerekmiştir. Sinyaller default olarak kill ve sigqueue fonksiyonları tarafından
    prosese gönderilirler. Proses bu sinyalleri herhangi bir thread akışı tarafından işletebilir. Prosese gönderilen sinyalin hangi
    thread tarafından işletileceği POSIX standartlarında belirsiz bırakılmıştır. 

    Aşağıdaki programda 3 thread yaratılmıştır. Ana thread'le birlikte toplam 4 thread vardır. Siz de başka bir terminalden 
    prosese kill komutuyla (kill fonksiyonuyla) SIGUSR1 sinyalini göndererek bu sinyalin hangi thread tarafından ele alındığına bakınız.
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <pthread.h>
#include <signal.h>

void exit_sys(const char *msg);
void exit_sys_thread(const char *msg, int err);
void *thread_proc1(void *param);
void *thread_proc2(void *param);
void *thread_proc3(void *param);
void sigusr1_handler(int sno);

int main(void)    
{
    int result;
    pthread_t tid1, tid2, tid3;
    struct sigaction act;

    act.sa_handler = sigusr1_handler;
    sigemptyset(&act.sa_mask);
    act.sa_flags = 0;

    if (sigaction(SIGUSR1, &act, NULL) == -1)
        exit_sys("sigaction");

    if ((result = pthread_create(&tid1, NULL, thread_proc1, NULL)) != 0) 
        exit_sys_thread("pthread_create", result);

    if ((result = pthread_create(&tid2, NULL, thread_proc2, NULL)) != 0) 
        exit_sys_thread("pthread_create", result);

    if ((result = pthread_create(&tid3, NULL, thread_proc3, NULL)) != 0) 
        exit_sys_thread("pthread_create", result);

    printf("main thread waiting at pause...\n");
    pause();
    printf("main thread resuming...\n");

    if ((result = pthread_join(tid1, NULL)) != 0)
        exit_sys_thread("pthread_join", result);

    if ((result = pthread_join(tid2, NULL)) != 0)
        exit_sys_thread("pthread_join", result);

    if ((result = pthread_join(tid3, NULL)) != 0)
        exit_sys_thread("pthread_join", result);

    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

void exit_sys_thread(const char *msg, int err)
{
    fprintf(stderr, "%s: %s\n", msg, strerror(err));
    exit(EXIT_FAILURE);
}

void *thread_proc1(void *param)
{
    printf("thread1 waiting at pause...\n");
    pause();
    printf("thread1 resuming...\n");

    return NULL;
}

void *thread_proc2(void *param)
{
    printf("thread2 waiting at pause...\n");
    pause();
    printf("thread2 resuming...\n");

    return NULL;
}

void *thread_proc3(void *param)
{
    printf("thread3 waiting at pause...\n");
    pause();
    printf("thread3 resuming...\n");

    return NULL;
}

void sigusr1_handler(int sno)
{
    printf("SIGUSR1 occurred...\n");
}

/*--------------------------------------------------------------------------------------------------------------------------
    Sinyal set işlemi (signal disposition) thread'e özgü bir işlem değildir. Prosese özgü bir işlemdir. Yani biz falanca thread için
    sinyal set edemeyiz. Proses için edebiliriz. Ancak istersek prosesin hangi thread'inin bir sinyali işleyeceğini belirleyebiliriz.
    pthread_kill isimli fonksiyon prosesin belli bir thread'ine sinyal gönderir. Yani kesinlikle sinyal fonksiyonu o thread tarafından 
    çalıştırılacaktır. Ancak pthread_kill ile başka bir proses başka bir prosesin thread'ine sinyal gönderemez. Aynı proses kendi 
    thread'ine sinyal gönderebilir. (Anımsanacağı gibi thread id'sini belirten pthread_t değeri o proseste anlamlıdır. Sistem genelinde
    tek değildir.)

    Aşağıdaki programda prosesin ana thread'i prosesin başka bşir thread'ine SIGUSR1 sinyalini göndermiştir.
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <pthread.h>
#include <signal.h>

void exit_sys(const char *msg);
void exit_sys_thread(const char *msg, int err);
void *thread_proc1(void *param);
void *thread_proc2(void *param);
void *thread_proc3(void *param);
void sigusr1_handler(int sno);

int main(void)    
{
    int result;
    pthread_t tid1, tid2, tid3;
    struct sigaction act;

    act.sa_handler = sigusr1_handler;
    sigemptyset(&act.sa_mask);
    act.sa_flags = 0;

    if (sigaction(SIGUSR1, &act, NULL) == -1)
        exit_sys("sigaction");

    if ((result = pthread_create(&tid1, NULL, thread_proc1, NULL)) != 0) 
        exit_sys_thread("pthread_create", result);

    if ((result = pthread_create(&tid2, NULL, thread_proc2, NULL)) != 0) 
        exit_sys_thread("pthread_create", result);

    if ((result = pthread_create(&tid3, NULL, thread_proc3, NULL)) != 0) 
        exit_sys_thread("pthread_create", result);

    sleep(5);

    if (pthread_kill(tid2, SIGUSR1) == -1)
        exit_sys("pthread_kill");

    if ((result = pthread_join(tid1, NULL)) != 0)
        exit_sys_thread("pthread_join", result);

    if ((result = pthread_join(tid2, NULL)) != 0)
        exit_sys_thread("pthread_join", result);

    if ((result = pthread_join(tid3, NULL)) != 0)
        exit_sys_thread("pthread_join", result);

    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

void exit_sys_thread(const char *msg, int err)
{
    fprintf(stderr, "%s: %s\n", msg, strerror(err));
    exit(EXIT_FAILURE);
}

void *thread_proc1(void *param)
{
    printf("thread1 waiting at pause...\n");
    pause();
    printf("thread1 resuming...\n");

    return NULL;
}

void *thread_proc2(void *param)
{
    printf("thread2 waiting at pause...\n");
    pause();
    printf("thread2 resuming...\n");

    return NULL;
}

void *thread_proc3(void *param)
{
    printf("thread3 waiting at pause...\n");
    pause();
    printf("thread3 resuming...\n");

    return NULL;
}

void sigusr1_handler(int sno)
{
    printf("SIGUSR1 occurred...\n");
}

/*--------------------------------------------------------------------------------------------------------------------------
    Başka bir prosesten başka bir prosesin thread'ine sinyal göndermek için POSIX standartlarında bir yöntem yoktur. Ancak Linux 
    sistemlerinde bunun için tkill ve tgkill isimli sistem fonksiyonları bulundurulmuştur. Fakat maalesef bu sistem fonksiyonlarını
    çağıran sarma kütüphane fonksiyonları (wrapper) bulunmamaktadır. tgkill sistem fonksiyonu tkill fonksiyonundan bir parametre daha fazladır.
    Bu fonksiyonda biz sinyal göndereceğimiz prosesin id değerini, sinyal göndereceğimiz thread'in task struct pid değerini ve sinyal
    numarasını veriririz. kill fonksiyonuyla (ya da komut satırından kill komutuyla) tid değeri verilerek sinyal gönderilmeye çalışılırsa 
    maalesef bu durumda sinyal thread'e değil thread'in ilişkin olduğu prosese gönderilmektedir. 

    Aşağıdaki örnekte tgkill.c programı thread'e sinyal göndermektedir. sample.c programı ise üç thread oluşturup sinyal gelmesini 
    beklemektedir. Bu iki programı farklı terminallerde çalıştırınız. tgkill ile sinyal göndermeden önce ps -a -L -o pid, tid, cmd
    komutu ile yaratılmış olan thread'lerin task_struct pid değerlerini görünüz. sample.c programı SIGUSR1 sinyalini işlemektedir. 
    Bu sinyalin Linux sistemlerindekiş numarası 10'dur. 
---------------------------------------------------------------------------------------------------------------------------*/

/* tgkill.c */

#include <stdio.h>
#include <stdlib.h>
#include <signal.h>
#include <unistd.h>
#include <sys/syscall.h>

void exit_sys(const char *msg);

int tgkill(int tgid, int tid, int signo)
{
    return syscall(SYS_tgkill, tgid, tid, signo);
}

/* ./tgkill <process id> <thread task struct process id> <signal no> */

int main(int argc, char *argv[])    
{
    int tgid, tid, signo;

    if (argc != 4) {
        fprintf(stderr, "wrong number of arguments!..\n");
        exit(EXIT_FAILURE);
    }

    tgid = (int)strtol(argv[1], NULL, 10);
    tid = (int)strtol(argv[2], NULL, 10);
    signo = (int)strtol(argv[3], NULL, 10);

    if (tgkill(tgid, tid, signo) == -1)
        exit_sys("tgkill");

    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/* sample.c */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <pthread.h>
#include <signal.h>

void exit_sys(const char *msg);
void exit_sys_thread(const char *msg, int err);
void *thread_proc1(void *param);
void *thread_proc2(void *param);
void *thread_proc3(void *param);
void sigusr1_handler(int sno);

int main(void)    
{
    int result;
    pthread_t tid1, tid2, tid3;
    struct sigaction act;

    act.sa_handler = sigusr1_handler;
    sigemptyset(&act.sa_mask);
    act.sa_flags = 0;

    if (sigaction(SIGUSR1, &act, NULL) == -1)
        exit_sys("sigaction");

    if ((result = pthread_create(&tid1, NULL, thread_proc1, NULL)) != 0) 
        exit_sys_thread("pthread_create", result);

    if ((result = pthread_create(&tid2, NULL, thread_proc2, NULL)) != 0) 
        exit_sys_thread("pthread_create", result);

    if ((result = pthread_create(&tid3, NULL, thread_proc3, NULL)) != 0) 
        exit_sys_thread("pthread_create", result);

    if ((result = pthread_join(tid1, NULL)) != 0)
        exit_sys_thread("pthread_join", result);

    if ((result = pthread_join(tid2, NULL)) != 0)
        exit_sys_thread("pthread_join", result);

    if ((result = pthread_join(tid3, NULL)) != 0)
        exit_sys_thread("pthread_join", result);

    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

void exit_sys_thread(const char *msg, int err)
{
    fprintf(stderr, "%s: %s\n", msg, strerror(err));
    exit(EXIT_FAILURE);
}

void *thread_proc1(void *param)
{
    printf("thread1 waiting at pause...\n");
    pause();
    printf("thread1 resuming...\n");

    return NULL;
}

void *thread_proc2(void *param)
{
    printf("thread2 waiting at pause...\n");
    pause();
    printf("thread2 resuming...\n");

    return NULL;
}

void *thread_proc3(void *param)
{
    printf("thread3 waiting at pause...\n");
    pause();
    printf("thread3 resuming...\n");

    return NULL;
}

void sigusr1_handler(int sno)
{
    printf("SIGUSR1 occurred...\n");
}

/*--------------------------------------------------------------------------------------------------------------------------
    Bir thread'e gerçek zamanlı sinyal gönderebilmek için ise pthread_sigqueue fonksiyonu kullanılmaktadır. Tabii bu fonksiyon da
    bizeden pthread_t aldığı için ancak aynı proses içerisinde kullanılabilir. Başka bir prosesten başka bir prosesin belli bir thread'ine
    gerçek zamanlı sinyakl gönderebilmek için bir POSIX fonksiyonu yoktur. Ancak Linux sistemlerinde  rt_tgsigqueueinfo isimli
    sistem fonksiyonu ile bu yapılabilir. Fakat bu sistem fonksiyonunu çağıran sarma bir kütüphane fonksiyonu bulundurulmamıştır. 
---------------------------------------------------------------------------------------------------------------------------*/

#define _GNU_SOURCE

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <pthread.h>
#include <signal.h>

void exit_sys(const char *msg);
void exit_sys_thread(const char *msg, int err);
void *thread_proc(void *param);
void sigrt_handler(int signo, siginfo_t *info, void *context);

int main(void)    
{
    int result;
    pthread_t tid;
    struct sigaction act;
    union sigval val;
    int i;

    act.sa_sigaction = sigrt_handler;
    sigemptyset(&act.sa_mask);
    act.sa_flags = SA_SIGINFO;

    if (sigaction(SIGRTMIN, &act, NULL) == -1)
        exit_sys("sigaction");

    if ((result = pthread_create(&tid, NULL, thread_proc, NULL)) != 0) 
        exit_sys_thread("pthread_create", result);

    sleep(1);
    
    for (i = 0; i < 10; ++i) {
        val.sival_int = i;
        if ((result = pthread_sigqueue(tid, SIGRTMIN, val)) != 0)
            exit_sys_thread("pthread_sigqueue", result);
    }

    sleep(1);

    if ((result = pthread_cancel(tid)) == -1)
        exit_sys_thread("pthread_cancel", result);

    if ((result = pthread_join(tid, NULL)) != 0)
        exit_sys_thread("pthread_join", result);

    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

void exit_sys_thread(const char *msg, int err)
{
    fprintf(stderr, "%s: %s\n", msg, strerror(err));

    exit(EXIT_FAILURE);
}

void *thread_proc(void *param)
{
    printf("thread1 waiting at pause...\n");
    
    for (;;)
        pause();

    return NULL;
}

void sigrt_handler(int signo, siginfo_t *info, void *context)
{
    printf("SIGRTMIN + 0 occurred with %d code\n", info->si_value.sival_int);
}

/*--------------------------------------------------------------------------------------------------------------------------
    POSIX sistemlerinde hem prosesin ana şalter görevinde olan bir sinyal maskeleme kümesi (signal mask) hem de thread'lerin
    sinyal maskeleme kümesi vardır. Eğer sinyal kill fonksiyonuyla prosese gönderilmişse prosesin sinyal maskeleme kümesi dikkate 
    alınmaktadır. Eğer sinyal pthread_kill ile belli bir thread'e gönderiliyorsa bu durumda da thread'in maskeleme kümesi dikkate alınır. 
    Thread'lerin maskeleme kümeleri aynı zamanda prosese gönderilen sinyalin hangi thread tarafından işletileceği konusunda da dolaylı bir
    etkiye sahiptir. Şöyle ki: Eğer thread ilgili sinyal için bloke edilirse prosese gönderilen bu sinyal artık bu thread tarafından işlenmez.
    Örneğin programcılar prosese gönderilen sinyalin belli bir thread tarafından işlenmesini istiyorlarsa bu durumda tek bir therad'i sinyale
    açıp diğer thread'leri bu sinyale bloke yoluyla kapatabilmektedirler. 

    Aşağıdaki örnekte ikinci thread dışında tüm thread'ler SIGUSR1 sinyaline kapatılmıştır. Bu durumda diğer terminalden prosese SIGUSR1
    sinyali gönderildiğinde bunu iki numaralı thread çalıştıracaktır.
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <pthread.h>
#include <signal.h>

void exit_sys(const char *msg);
void exit_sys_thread(const char *msg, int err);
void *thread_proc1(void *param);
void *thread_proc2(void *param);
void *thread_proc3(void *param);
void sigusr1_handler(int sno);

int main(void)    
{
    int result;
    pthread_t tid1, tid2, tid3;
    struct sigaction act;
    sigset_t sset;

    act.sa_handler = sigusr1_handler;
    sigemptyset(&act.sa_mask);
    act.sa_flags = 0;

    if (sigaction(SIGUSR1, &act, NULL) == -1)
        exit_sys("sigaction");

    if ((result = pthread_create(&tid1, NULL, thread_proc1, NULL)) != 0) 
        exit_sys_thread("pthread_create", result);

    if ((result = pthread_create(&tid2, NULL, thread_proc2, NULL)) != 0) 
        exit_sys_thread("pthread_create", result);

    if ((result = pthread_create(&tid3, NULL, thread_proc3, NULL)) != 0) 
        exit_sys_thread("pthread_create", result);

    sigemptyset(&sset);
    sigaddset(&sset, SIGUSR1);

    if ((result = pthread_sigmask(SIG_BLOCK, &sset, NULL)) != 0)
        exit_sys_thread("pthread_sigmask", result);

    if ((result = pthread_join(tid1, NULL)) != 0)
        exit_sys_thread("pthread_join", result);

    if ((result = pthread_join(tid2, NULL)) != 0)
        exit_sys_thread("pthread_join", result);

    if ((result = pthread_join(tid3, NULL)) != 0)
        exit_sys_thread("pthread_join", result);

    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

void exit_sys_thread(const char *msg, int err)
{
    fprintf(stderr, "%s: %s\n", msg, strerror(err));
    exit(EXIT_FAILURE);
}

void *thread_proc1(void *param)
{
    sigset_t sset;
    int result;
    
    sigemptyset(&sset);
    sigaddset(&sset, SIGUSR1);

    if ((result = pthread_sigmask(SIG_BLOCK, &sset, NULL)) != 0)
        exit_sys_thread("pthread_sigmask", result);

    printf("thread1 waiting at pause...\n");
    pause();
    printf("thread1 resuming...\n");

    return NULL;
}

void *thread_proc2(void *param)
{
    printf("thread2 waiting at pause...\n");
    pause();
    printf("thread2 resuming...\n");

    return NULL;
}

void *thread_proc3(void *param)
{
    sigset_t sset;
    int result;
    
    sigemptyset(&sset);
    sigaddset(&sset, SIGUSR1);

    if ((result = pthread_sigmask(SIG_BLOCK, &sset, NULL)) != 0)
        exit_sys_thread("pthread_sigmask", result);

    printf("thread3 waiting at pause...\n");
    pause();
    printf("thread3 resuming...\n");

    return NULL;
}

void sigusr1_handler(int sno)
{
    printf("SIGUSR1 occurred...\n");
}

/*--------------------------------------------------------------------------------------------------------------------------
    Nadiren programcı kritik birtakım işlemler yaparken sinyalleri bloke edip sonra açıp pause ile bekleyebilmektedir. 

    siprocmask(<sinyalleri bloke et>);

    <kritik kod>

    siprocmask(<sinyalleri aç>);
---> Problem var!
    pause();

Programcı sinyalleri açıp pause beklemesini yapmak istediği sırada sinyal prosese gönderilirse henüz akış pause fonksiyona girmeden
sinyal teslim edilebilir. Daha sonra akış pause fonksiyonuna girdiğinde buradan çıkılamamış olabilir. Bu problem atomik bir biçimde
sinyalleri açarak pause yapan bir fonksiyonla çözülebilir. İşte sigsuspend fonksiyonu bunu yapmaktadır. 

Yukarıda açıklanan temayı uygulayan aşağıdaki kodu inceleyiniz. Prosesin sinyal maskelerini açıp pause ile değil sigsuspend 
ile beklenmelidir. 
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <errno.h>
#include <unistd.h>
#include <signal.h>

void exit_sys(const char *msg);
void sigusr1_handler(int sno);

int main(void)    
{
    struct sigaction act;
    sigset_t sset;
    int i;

    act.sa_handler = sigusr1_handler;
    sigemptyset(&act.sa_mask);
    act.sa_flags = 0;

    if (sigaction(SIGUSR1, &act, NULL) == -1)
        exit_sys("sigaction");

    sigfillset(&sset);
    if (sigprocmask(SIG_BLOCK, &sset, NULL) == -1)
        exit_sys("sigprocmask");

    for (i = 0; i < 10; ++i) {
        sleep(1);
        printf("critical region running...\n");
    }

    sigemptyset(&sset);
    if (sigsuspend(&sset) == -1  && errno != EINTR)        /* pause yerine sigsuspend kullanılmalı */
        exit_sys("sigsuspend");

    sigfillset(&sset);
    if (sigprocmask(SIG_UNBLOCK, &sset, NULL) == -1)
        exit_sys("sigprocmask");

    printf("process ends...\n");

    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

void sigusr1_handler(int sno)
{
    printf("SIGUSR1 occurred...\n");
}

/*--------------------------------------------------------------------------------------------------------------------------
    sigwait fonksiyonu programcının belirlediği sinyallerden herhangi biri oluşana kadar bekleme yapar. Eğer programcının belirlemediği
    bir sinyal oluşursa ve sinyal fonksiyonu da set edilmişse fonksiyon çalıştırılır fakat bekleme devam eder. Eğer programcının
    belirlemediği bir sinyal oluşursa fakat bu sinyal için sinyal fonksiyonu set edilmemişse bu durumda default eylem gerçekleşir (muhtemelen 
    prosesin sonlandırılması). Eğer sigwait'te beklerken programcının belirlediği sinyallerden biri oluşursa ve bu sinyal için
    sinyal fonksiyonu set edilmişse sinyal fonksiyonu çağrılmaz ancak bu sinyal için sinyal fonksiyonu set edilmemişse default eylem 
    uygulanır (muhtemelen prosesin sonlandırılması). Eğer sigwait çağrıldığında zaten beklelen sinyallerin bazıları pending durumdaysa sigwait
    hiç bekleme yapmaz. 

    sigwait fonksiyonun sigwaitinfo isimli siginfo_t parametreli versiyonu da vardır. Bu fonksiyon yalnız oluşan sinyalin numarasını değil onun siginfo_t 
    bilgilerini de vermektedir. 

    Aşağıdaki örnekte sigwait fonksiyonunda SIGUSR1 ve SIGUSR2 sinyalleri beklenmektedir. Başka bir sinyal oluşursa proses 
    sonlandırılır. SIGUSR1 ve SIGUSR2 için sinyal fonksiyonu set edilmiştir. Bu durumda bu sinyaller oluşursa sinyal fonksiyonu çağrılmadan
    bekleme sonlandırılır. pause ve sisuspend fonksiyonlarının sinyal fonksiyonun çalışmasına yol açtığını anımsayınız. 
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <signal.h>

void exit_sys(const char *msg);
void sigusr1_handler(int sno);
void sigusr2_handler(int sno);

int main(void)    
{
    struct sigaction act;
    sigset_t sset;
    int result;
    int signo;

    act.sa_handler = sigusr1_handler;
    sigemptyset(&act.sa_mask);
    act.sa_flags = 0;

    if (sigaction(SIGUSR1, &act, NULL) == -1)
        exit_sys("sigaction");

    act.sa_handler = sigusr2_handler;
    if (sigaction(SIGUSR2, &act, NULL) == -1)
        exit_sys("sigaction");

    sigemptyset(&sset);
    sigaddset(&sset, SIGUSR1);

    printf("process waiting for SIGUSR1 signal...\n");

    if ((result = sigwait(&sset, &signo)) != 0) {
        fprintf(stderr, "sigwait: %s\n", strerror(result));
        exit(EXIT_FAILURE);
    }

    if (signo == SIGUSR1)
        printf("sigwait returns due to SIGUSR1\n");
    else 
        printf("sigwait returns due to SIGINT\n");

    printf("process ends...\n");

    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

void sigusr1_handler(int sno)
{
    printf("SIGUSR1 occurred...\n");
}

void sigusr2_handler(int sno)
{
    printf("SIGUSR2 occurred...\n");
}

/*--------------------------------------------------------------------------------------------------------------------------
    sleep fonksiyonu parametresiyle belirtilen saniye kadar thread'i blokede bekletir. Fonksiyon zamandan dolayı sonlanırsa
    0 değerine sinyal dolayısıyla sonlanırsa kalan saniye değerine geri döner. sleep yeniden başlatılabilen (restartable) bir 
    fonksiyon değildir. 

    Aşağıdaki örnekte SIGINT sinyali gelse bile sleep ile 10 saniye civarında bekleme yapılmıştır.
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <signal.h>

void exit_sys(const char *msg);
void sigint_handler(int sno);

int main(void)    
{
    struct sigaction act;
    int t;

    act.sa_handler = sigint_handler;
    sigemptyset(&act.sa_mask);
    act.sa_flags = 0;

    if (sigaction(SIGINT, &act, NULL) == -1)
        exit_sys("sigaction");

    printf("waiting 10 seconds even if SIGINT occurs...\n");

    t = 10;
    while ((t = sleep(t)) != 0)
        ;

    printf("process ends..\n");

    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

void sigint_handler(int sno)
{
    printf("SIGINT occurred...\n");
}

/*--------------------------------------------------------------------------------------------------------------------------
    nanosleep nano saniye (saniyenin m,lyarda biri) çözünürlüğüne sahip bir POSIX bekeleme fonksiyonudur. Fonksiyon timespec
    isimli yapı nesnesini parametre olarak alır. Sinyal oluşursa sonlanır ve kalan zamanı da yine bize timespec biçiminde verir.
    Her ne kadar bu fonksiyon nanosaniye çözünürlüğüne sahipse de işletim sistemleri genellikle bu çöznünürlüğü destekleyememektedir. 
    Bu durumda bekleme tam istenen miktarda gerçekleşmez. Örneğin Linux işletim sistemlerinde sleep kuyruğundaki thread'ler timer
    kesmesinde kontrol edilmektedir. Dolayısıyla genellikle bu çözünürlük 1 milisaniyedir. 
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <time.h>

void exit_sys(const char *msg);

int main(void)    
{
    struct timespec ts;
    
    printf("waiting 3.5 seconds...\n");
    ts.tv_sec = 3;
    ts.tv_nsec = 500000000;

    if (nanosleep(&ts, NULL) == -1)
        exit_sys("nanosleep");

    printf("sleep finished..\n");

    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/*--------------------------------------------------------------------------------------------------------------------------
    Ayrıca POSIX standartlarından 2008'de çıkartılmış olan mikrosaniye çözünürlüğüne sahip bir usleep fonksiyonu da vardır. Bu
    fonksiyon Linux sistemlerinde hala desteklenmektedir. 
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>

void exit_sys(const char *msg);

int main(void)    
{
    printf("waiting 3.5 seconds even if SIGINT occurs...\n");

    if (usleep(3500000) == -1)
        exit_sys("usleep");

    printf("sleep finished..\n");

    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/*--------------------------------------------------------------------------------------------------------------------------
    Amacımız bekleme yapmak değil de zaman ölçmek ise ilk akla gelen POSIX fonksiyonu clock_gettime olmalıdır. Bu fonksiyonun
    birinci parametresi clockid_t türündendir. Hesabın yapılacağı saat cinsini belirtir. Bu parametre CLOCK_REALTIME biçiminde girilirse
    01/01/1970'ten geçen nano saniye sayısı bize verilir. Tabii biz buradan elde ettiğimiz mutlak zamanı C'nin klasik zaman fonksiyonlarına
    sokup dönüştürmeler yapabiliriz. Saat türü olarak CLOCK_MONOTONIC değeri geçilirse belli bir zamandan itibaren geçen göreli zaman elde edilir.
    Linux sistemleri bu durumda boot zamanından itibaren geçen zamanı bize vermektedir. Monononic saat demek "bilgisayarın çalışması sırasında 
    sürekli artan, sistem zamanının değiştirilmesinden etkilenmeyen saat" demektir. Zaman aralığı ölçmek için monotonic saat daha uygundur. 
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <time.h>

void exit_sys(const char *msg);

int main(void)    
{
    struct timespec ts;
    struct tm *pt;

    if (clock_gettime(CLOCK_REALTIME, &ts) == -1)
        exit_sys("clock_gettime");

    printf("Seconds: %ld\n", (long)ts.tv_sec);
    printf("Nanoseconds: %ld\n", (long)ts.tv_nsec);

    puts(ctime(&ts.tv_sec));

    pt = localtime(&ts.tv_sec);
    printf("%02d/%02d/%04d %02d:%02d:%02d\n", pt->tm_mday, pt->tm_mon + 1, pt->tm_year + 1900, pt->tm_hour, pt->tm_min, pt->tm_sec);

    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/*--------------------------------------------------------------------------------------------------------------------------
    Programın iki noktası arasında geçen gerçek zamanı taşınabilir bir biçimde ölçmek için ilk akla gelecek yöntem clock_gettime
    olmalıdır. Tabii benzer başka yöntemler de kullanılabilir. 
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <time.h>

void exit_sys(const char *msg);

int main(void)    
{
    struct timespec ts1, ts2;
    int i;
    double result;

    if (clock_gettime(CLOCK_MONOTONIC, &ts1) == -1)
        exit_sys("clock_gettime");

    for (i = 0; i < 1000000000; ++i)
        ;

    if (clock_gettime(CLOCK_MONOTONIC, &ts2) == -1)
        exit_sys("clock_gettime");
    
    result = (ts2.tv_sec - ts1.tv_sec) * 1000000000.0 + ts2.tv_nsec - ts1.tv_nsec;
    printf("Elapsed time (nonosecands): %.0f\n", result);
    printf("Elapsed time (seconds): %f\n", result / 1000000000.0);

    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/*--------------------------------------------------------------------------------------------------------------------------
    clock isimli standart C fonksiyonu bize zamanı clock_t türünden verir. Ancak geçen zamanın saniye cinsine dönüştürülmesi 
    için CLOCKS_PER_SEC değerine bölünmesi gerekmektedir. Genellikle bu fonksiyonlar işletim sisteminin timer kesmesi ile tick
    sayısını verecek biçimde yazılmışlardır. Bu durumda zaman ölçmenin C genelinde en taşınabilir yolu clock fonksiyonunu
    kullamak olabilir. Ancak genel olarak clock_gettime fonksiyonunun çöznünürlüğünün daha yüksek olduğu varsayılmalıdır. 
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <time.h>

void exit_sys(const char *msg);

int main(void)    
{
    clock_t c1, c2;
    int i;
    double result;

    c1 = clock();

    for (i = 0; i < 1000000000; ++i)
        ;

    c2 = clock();
    
    result = (double)(c2 - c1) / CLOCKS_PER_SEC;
    printf("Elapsed time (seconds): %f\n", result);

    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/*--------------------------------------------------------------------------------------------------------------------------
    clock_gettime fonksiyonundaki duyarlılık clock_getres fonksiyonuyla elde edilebilir. Pek çok işlemcide zamansal nano saniye 
    çözünürlük için özel makine komutları bulunmaktadır. Örneğin x64 işlemcide çalışan sanal makinede bu değer 1 nanosaniye çıkmıştır.  
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <time.h>

void exit_sys(const char *msg);

int main(void)    
{
    struct timespec ts;

    if (clock_getres(CLOCK_REALTIME, &ts) == -1)
        exit_sys("clock_getres");

    printf("%ld second and %ld nano seconds:\n", (long)ts.tv_sec, (long)ts.tv_nsec);

    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/*--------------------------------------------------------------------------------------------------------------------------
    clock_gettime fonksiyonunda clockid_t olarak CLOCK_PROCESS_CPUTIME_ID geçilirse prosesin yalnızca CPU'da harcadığı zamanların
    toplamı verilir. Bu gerçek zamandan daha kısa olacaktır. Eğer proses çok thread'ten oluşuyorsa bu hesaba tüm thread'lerin CPU zamanları toplanır. 
    Fakat clockid_t olarak CLOCK_THREAD_CPUTIME_ID verilirse bu da spesifik bir thread'in (fonksiyonu çağıran) CPU zamanını ölçmekte kullanılır. 
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <time.h>
#include <unistd.h>

void exit_sys(const char *msg);

int main(void)    
{
    struct timespec ts1, ts2;
    int i;
    double result;

    if (clock_gettime(CLOCK_PROCESS_CPUTIME_ID, &ts1) == -1)
        exit_sys("clock_gettime");

    for (i = 0; i < 10; ++i)
        sleep(1);

    if (clock_gettime(CLOCK_PROCESS_CPUTIME_ID, &ts2) == -1)
        exit_sys("clock_gettime");
    
    result = (ts2.tv_sec - ts1.tv_sec) * 1000000000.0 + ts2.tv_nsec - ts1.tv_nsec;
    printf("Elapsed time (nonosecands): %.0f\n", result);
    printf("Elapsed time (seconds): %f\n", result / 1000000000.0);

    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/*--------------------------------------------------------------------------------------------------------------------------
    Başka bir prosese ilişkin clockid_t elde etmek mümkündür. Bu durumda o prosese ilişkin zamansal ölçümler yapılabilir. 
    Bunun için clock_getcpuclockid POSIX fonksiyonu kullanılmaktadır. Eğer spesifik bir thread'e ilişkin clockid_t elde etmek için ise
    pthread_getcpuclockid fonksiyonu kullanılmaktadır.
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    İlgili thread'i duyarlıklı bir biçimde bekletmek için nanosleep fonksiyonu görmüştük. Her ne kadar POSIX standartlarından kaldırılmış
    olsa da  Linux sistemlerinde desteklenen mikrosaniye duyarlıklı bir usleep fonksiyonu da vardı. Klasik sleep fonksiyonu ise eski bir
    fonksiyondu ve saniye duyarlılığına sahipti. İşte nanosleep fonksiyonunun clock_nanosleep isimli biraz daha gelişmiş bir biçimi vardır.
    Fonksiyonun bu versiyonu clockid_t aldığı için daha yeteneklidir.  clock_nanosleep fonksiyonunun nanosleep fonksiyonundan en önemli avantajı
    gerçek bekleme zamanını ölçebilmesidir. Eğer bekleme  nanosleep fonksiyonuyla yapılırsa ve programda sinyal de kullanılıyorsa nanosleep sinyal
    geldiğinde başarısızlıkla sonlandırılacak (errno = EINTR) programcı da kalan süreyi alarak yeniden nanosleep fonksiyonunu çağırıp beklemeye devam edecektir.
    Ancak her sinyal geldiğinde sinyal fonksiyonun çalıştırılması zamanı ekstra bir zaman olarak bekleyemeye eklenecektir. 

    Aşağıdaki örnekte programcı nanosleep kullanarak sinyalli bir ortamda 10 saniye beklemek istemiştir. Ancak SIGINT sinyali oluştuğunda
    bu toplam bekleme gerçek zamana göre fazlalaşacaktır. 
---------------------------------------------------------------------------------------------------------------------------*/

stdio.h>
#include <stdlib.h>
#include <time.h>
#include <errno.h>
#include <signal.h>

void exit_sys(const char *msg);
void sigint_handler(int sno);

int main(void)    
{
    struct sigaction act;
    struct timespec ts, rm;
    struct timespec ts1, ts2;
    double result;

    act.sa_handler = sigint_handler;
    sigemptyset(&act.sa_mask);
    act.sa_flags = 0;

    if (sigaction(SIGINT, &act, NULL) == -1)
        exit_sys("sigaction");

    printf("waiting 10 seconds...\n");
    ts.tv_sec = 10;
    ts.tv_nsec = 0;

    if (clock_gettime(CLOCK_REALTIME, &ts1) == -1)
        exit_sys("clock_gettime");
    
    while (nanosleep(&ts, &rm) == -1 && errno == EINTR)
        ts = rm;

    if (clock_gettime(CLOCK_REALTIME, &ts2) == -1)
        exit_sys("clock_gettime");

    result = (ts2.tv_sec - ts1.tv_sec) * 1000000000.0 + ts2.tv_nsec - ts1.tv_nsec;
    printf("Elapsed time (nonosecands): %.0f\n", result);
    printf("Elapsed time (seconds): %f\n", result / 1000000000.0);

    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

void sigint_handler(int sno)
{
    int i;

   for (i = 0; i < 1000000000; ++i)
        ;
}

/*--------------------------------------------------------------------------------------------------------------------------
    clock_nanosleep fonksiyonun nanosleep fonksiyonundan en önemli avantajı sinyalli ortamda timer türü TIMER_ABSTIME alınarak 
    umulan beklemeyi yapabilmesidir. 
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <time.h>
#include <errno.h>
#include <signal.h>

void exit_sys(const char *msg);
void sigint_handler(int sno);

int main(void)    
{
    struct sigaction act;
    struct timespec ts;
    struct timespec ts1, ts2;
    double elapsed;
    int result;

    act.sa_handler = sigint_handler;
    sigemptyset(&act.sa_mask);
    act.sa_flags = 0;

    if (sigaction(SIGINT, &act, NULL) == -1)
        exit_sys("sigaction");

    if (clock_gettime(CLOCK_REALTIME, &ts) == -1)
        exit_sys("clock_gettime");
        
    ts.tv_sec += 10;

    if (clock_gettime(CLOCK_REALTIME, &ts1) == -1)
        exit_sys("clock_gettime");
    
    while ((result = clock_nanosleep(CLOCK_REALTIME, TIMER_ABSTIME, &ts, NULL)) == EINTR)
        ;

    if (clock_gettime(CLOCK_REALTIME, &ts2) == -1)
        exit_sys("clock_gettime");

    elapsed = (ts2.tv_sec - ts1.tv_sec) * 1000000000.0 + ts2.tv_nsec - ts1.tv_nsec;
    printf("Elapsed time (nonosecands): %.0f\n", elapsed);
    printf("Elapsed time (seconds): %f\n", elapsed / 1000000000.0);

    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

void sigint_handler(int sno)
{
    int i;

    for (i = 0; i < 1000000000; ++i)
        ;
}

/*--------------------------------------------------------------------------------------------------------------------------
    Periyodik bir biçimde iş yapılmasını sağlayan timer'lara İngilizce "interval timer" denilmektedir. POSIX sistemlerinde iki
    interval timer mekanizması vardır. setitimer ile oluşturulan interval timer'ın kullanımı kolaydır. Ancak kullanımı zor olan
    daha yetenekli interval timer mekanizması POSIX standartlarına eklendiği için bu fonksiyon "obsolete" yapılmıştır. setitimer
    fonksiyonunda periyodik işleme başlamak için gereken zaman ile periyot zamanı ayrı ayrı verilir. Yine interval timer'ın
    türleri vardır. Her tür zaman dolduğunda farklı bir sinyalin oluşmasına yol açar. ITIMER_REAL timer'ı SIGALRM sinyaline yol açar ve
    gerçek zamanlı timer'dır. Prosein 3 türden tek farklı farklı tek interval timer'ları vardır. Fonksiyon ikinci kez çağrıldığında eski timer reset edilir.
    Oradaki değerler programcıya verilebilmektedir. Ayrıca getitimer isimli fonksiyon da mevcut interval timer'ın timer değerlerini almak için
    kullanılabilmektedir.

    Aşağıdaki örnekte periyodik işleme 5 saniye sonra başlanıp birer saniye periyorlu işlem yappılmaktadır. 
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <sys/time.h>
#include <unistd.h>
#include <signal.h>

void exit_sys(const char *msg);
void sigalrm_handler(int sno);

int main(void)    
{
    struct itimerval itv;
    struct sigaction act;

    act.sa_handler = sigalrm_handler;
    sigemptyset(&act.sa_mask);
    act.sa_flags = 0;

    if (sigaction(SIGALRM, &act, NULL) == -1)
        exit_sys("sigaction");

    itv.it_interval.tv_sec = 1;
    itv.it_interval.tv_usec = 0;

    itv.it_value.tv_sec = 5;        
    itv.it_value.tv_usec = 0;

    if (setitimer(ITIMER_REAL, &itv, NULL) == -1)
        exit_sys("setitimer");

    for (;;)
        pause();

    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

void sigalrm_handler(int sno)
{
    static int i = 0;

    printf("%d ", i);
    fflush(stdout);

    if (i == 10) {
        printf("\n");
        exit(EXIT_SUCCESS);
    }

    ++i;
}

/*--------------------------------------------------------------------------------------------------------------------------
Periyodik timer (interval timers) yaratmak için yukarıda setitimer fonksiyonunu kullanmıştık. Bu fonksiyon POSIX standartlarında 
artık "obsolete" ilan edilmiştir. Dolayısıyla gelecekte standartlardan kaldırılabilir. Bunun yerine POSIX'e daha yetenekli ama
kullanılması daha zor olan bir grup yeni periyodik timer fonksiyonu eklenmiştir. 

Modern periyodik timer mekanizmasını kullanabilmek için önce timer'ın timer_create fonksiyonu ile yaratılması gerekir. timer cretae fonksiyonu
bizden sigevent türünden bir yapı nesnesinin adresini ister. O yapı nesnesini bizim tanımlayıp içini bizim doldurmamız gerekir. 
sigevent yapısının sigev_notify elemanı periypt bittiğinde bizim nasıl haberdar edileceğimzi belirtir. Eğer bu elemana
SIGEV_SIGNAL değeri girilirse biz sinyal yoluyla haberdar ediliriz. Ancak söz konusu sinyal SIGALRM olmak zorunda değildir. Söz konusu 
sinyalin numarası yapının sigev_signo elemanına girilmelidir. Eğer sigev_notify elemanı SIGEV_THREAD olarak girilirse işletim sistemi
bir thread yaratıp bizim yapının sigev_notify_function elemanıyla belirttiğimiz fonksiyonunu bu thread akışıyla çağırarak bizi haberdar eder. 
Ancak işletim sisteminin tek bir thread'le mi bu işi yapacağı yoksa her çağrım için ayrı bir thread mi kullanacağı sistemden sisteme değişebilmeketdir. 
Bu thread'in yaratılmasındaki thread özellikleri yapının sigev_notify_attributes elemanına girilebilir. Aynı zamanda istenirse oluşan sinyale 
bir değer de iliştirilebilmektedir. Bu değer sigev_value elemanına yerleştirilir ve sigaction ile siginfo_t parametreli sinyal fonksiyonu ile elde edilir. 
timer_create bir timer'ı oluşturur ve onun id'sini fonksiyonun sigev_value timerid parametresine yerleştirir. Bu id sonraki fonksiyonlarda 
kullanılacaktır. 

Timer yaratıldıktan sonra timer'ı kurma işlemi timer_settime fonksiyonuyla yapılmaktadır. Burada yine ilk periyota kadar geçen zaman
ve periyot zamanı belirtilmektedir. 

Timer kullanıldıktan sonra timer_delete fonksiyonuıyla silinir. Yaratılan timer'lar fork işlemi sırasında alt proseste etkinliğini kaybetmektedir. 
Yine exec işlemi yapıldığında timer'lar yok edilmektedir. 

Aşağıdaki örnekte sinyal yoluyla (SIGUSR1) haberdar edilme yöntemi kullanılmıştır. 
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <time.h>
#include <setjmp.h>
#include <unistd.h>
#include <signal.h>

void exit_sys(const char *msg);
void sigusr1_handler(int sno);

jmp_buf g_jb;

int main(void)    
{
    struct sigaction act;
    struct sigevent se;
    timer_t mytimer;
    struct itimerspec tspec;

    act.sa_handler = sigusr1_handler;
    sigemptyset(&act.sa_mask);
    act.sa_flags = 0;

    if (sigaction(SIGUSR1, &act, NULL) == -1)
        exit_sys("sigaction");

    se.sigev_notify = SIGEV_SIGNAL;
    se. sigev_signo = SIGUSR1;
    se.sigev_value.sival_int = 0;

    if (timer_create(CLOCK_REALTIME, &se, &mytimer) == -1)
        exit_sys("timer_create");

    tspec.it_value.tv_sec = 5;
    tspec.it_value.tv_nsec = 0;

    tspec.it_interval.tv_sec = 1;
    tspec.it_interval.tv_nsec = 0;

    if (timer_settime(mytimer, 0, &tspec, NULL) == -1)
        exit_sys("timer_settime");

    if (setjmp(g_jb) == 1) {
        if (timer_delete(mytimer) == -1)
            exit_sys("timer_delete");
        exit(EXIT_SUCCESS);
    }

    for (;;)
        pause();

    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

void sigusr1_handler(int sno)
{
    static int count = 0;

    if (count == 10)
        longjmp(g_jb, 1);

    printf("sigusr1 occurred...\n");

    ++count;
}

/*--------------------------------------------------------------------------------------------------------------------------
    Eğer biz sinyal fonksiyonuna değer de aktarmak istiyorsak bu durumda siginfo_t * parametreli sinyal fonksiyonu set etmeliyiz.
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <time.h>
#include <setjmp.h>
#include <unistd.h>
#include <signal.h>

void exit_sys(const char *msg);
void sigusr1_handler(int sno, siginfo_t *info, void *ucont);

jmp_buf g_jb;

int main(void)    
{
    struct sigaction act;
    struct sigevent se;
    timer_t mytimer;
    struct itimerspec tspec;

    act.sa_sigaction = sigusr1_handler;
    sigemptyset(&act.sa_mask);
    act.sa_flags = SA_SIGINFO;

    if (sigaction(SIGUSR1, &act, NULL) == -1)
        exit_sys("sigaction");

    se.sigev_notify = SIGEV_SIGNAL;
    se.sigev_signo = SIGUSR1;
    se.sigev_value.sival_int = 100;

    if (timer_create(CLOCK_REALTIME, &se, &mytimer) == -1)
        exit_sys("timer_create");

    tspec.it_value.tv_sec = 5;
    tspec.it_value.tv_nsec = 0;

    tspec.it_interval.tv_sec = 1;
    tspec.it_interval.tv_nsec = 0;

    if (timer_settime(mytimer, 0, &tspec, NULL) == -1)
        exit_sys("timer_settime");

    if (setjmp(g_jb) == 1) {
        if (timer_delete(mytimer) == -1)
            exit_sys("timer_delete");
        exit(EXIT_SUCCESS);
    }

    for (;;)
        pause();

    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

void sigusr1_handler(int sno, siginfo_t *info, void *ucontext)
{
     static int count = 0;

    if (count == 10)
        longjmp(g_jb, 1);

    printf("sigusr1 occurred: %d\n", info->si_value.sival_int);

    ++count;
}

/*--------------------------------------------------------------------------------------------------------------------------
    Periyot dolduğunda bir sinyalin oluşması yerine belirlenen bir fonksiyonun çağrılması da sağlanabilir. Bunun için yapının
    sigev_notify elemanı SIGEV_THREAD biçiminde girilmelidir. Çağrılacak fonksiyon da yapının sigev_notify_function elemanına girilir. 
    İşletim sistemi kendisi bir therad yaratıp bizim girdiğimiz fonksiyonu o thread akışının çalıştırmasını sağlamaktadır.   
    Linux bir kere thread yaratıp hep aynı thread'le sinyal fonksiyonu çağırmaktadır. 
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <time.h>
#include <setjmp.h>
#include <unistd.h>
#include <signal.h>

void exit_sys(const char *msg);
void signal_notification_handler(union sigval val);

jmp_buf g_jb;

int main(void)    
{
    struct sigevent se;
    timer_t mytimer;
    struct itimerspec tspec;

    se.sigev_notify = SIGEV_THREAD;
    se.sigev_notify_function = signal_notification_handler;
    se.sigev_notify_attributes = NULL;
    se.sigev_value.sival_int = 100;

    if (timer_create(CLOCK_REALTIME, &se, &mytimer) == -1)
        exit_sys("timer_create");

    tspec.it_value.tv_sec = 5;
    tspec.it_value.tv_nsec = 0;

    tspec.it_interval.tv_sec = 1;
    tspec.it_interval.tv_nsec = 0;

    if (timer_settime(mytimer, 0, &tspec, NULL) == -1)
        exit_sys("timer_settime");

    if (setjmp(g_jb) == 1) {
        if (timer_delete(mytimer) == -1)
            exit_sys("timer_delete");
        exit(EXIT_SUCCESS);
    }

    for (;;)
        pause();

    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

void signal_notification_handler(union sigval val)
{
    static int count = 0;

    if (count == 10)
        longjmp(g_jb, 1);

    printf("signal notification function called: %d\n", val.sival_int);

    ++count;
}

/*--------------------------------------------------------------------------------------------------------------------------
    setitimer fonksiytonu ile her cins timer'dan yalnızca bir tane yaratılabilmektedir. Oysa bu modern timer mekanizmasında
    istenildiği kadar çok timer yaratılabilir. Ayrıca haberdar edilme yönteminin sinyal yoluyla yapılması durumunda girilen sinyal
    numarası realtime bir sinyal numarası olsa bile kuyruklama yapılmamaktadır. Yani örneğin periyot kısa olabilir. Bu süre içerisinde 
    sinyal fonksiyonu sonlanmamış olabilir. Ancak yalnızca 1 tane sinyal pending durumda bekleyecektir. Fakat programcı isterse
    aslında kaç periyodun geçmiş olduğunu timer_getoverrun isimli fonksiyonla istediği zaman alabilir. Bu fonksiyon aynı biçimde
    fonksiyon yoluyla haberdar edilmede de kullanılır. 
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Bir grup prosesin oluşturduğu gruba "proses grubu" denilmektedir. Proses grubu kavramı bir grup prosese sinyal gönderebilmek için
    uydurulmuştur. Gerçekten de kill sistem fonksiyonunun  birinci parametresi olan pid sıfırdan küçük br sayı olarak girilirse 
    abs(pid) numaralı proses grubuna sinyal gönderilmektedir. Bir sinyal bir prosese grubuna gönderilirse o proses grubunun bütün üyeleri olan 
    proseslere gönderilmiş olur. kill fonksiyonun birinci parametresi 0 girilirse bu durumda sinyal kill fonksiyonunu uygulayan prosesin
    proses grubuna gönderilir. Yani proses kendi proses grubuna sinyali göndermektedir. 

    Bir proses grubunun id'si vardır. Bir proses grubunun id'si o proses grubundaki bir prosesin proses id'si ile aynıdır. İşte
    proses id'si proses grup id'sine eşit olan prosese o proses grubunun "proses grup lideri (process group leader)" denilmektedir. 
    Proses grup lideri genellikle proses grubunu yaratan prosestir. for işlemi sırasında alt prosesin proses grubu onu yaratan 
    üst prosesten alınmaktadır. 

    Bir prosesin ilişkin olduğu proses grubunun id'sini alabilmek için getpgrg ya da getpgid POSIX fonksiyonları kullanılır. 

    pid_t getpgrp(void);
    pid_t getpgid(pid_t pid);

    getpgid fonksiyonu herhangi bir prosesin proses grup id'sini almakta kullanılabilir. Bu fonksiyonun parametresi 0 geçilirse 
    fonksiyonu çağıran prosesin proses grup id'si alınmış olur Yani aşağıdaki çağrı eşdeğerdir:

    pgid = getpgrp();
    pgid = getpgid(0);

    Proses grup lideri sonlanmış olsa bile proses grubunun id'si aynı biçimde kalmaya devam eder. Yani işletim sistemi bu durumda 
    prosesin id'sini o proses grubu bu id ile temsil edildiği için başka proses'te kullanmaz. Proses grubu gruptaki son prosesin sonlanması
    ya da grup değiştirmesiyle ömrünü tamamlamaktadır.

    Bir programı kabul üzerinden çalıştırdığımızda kabuk yeni bir proses grubu oluşturur ve çalıştırılan programa ilişkin prosesi
    o proses grubunun proses grup lideri yapar. Aşağıdaki programı çalıştırıp sonucunu inceleyiniz. Yapılan denemeden şöyle bir sonuç elde edilmiştir:

    Parent process id: 9921
    Parent process id of the parent: 1894
    Parent process group id: 9921
    Child process id: 9922
    Parent process id of the child: 9921
    Child process group id: 9921

---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/wait.h>

void exit_sys(const char *msg);

int main(void)    
{
    pid_t pgid;
    pid_t pid;
    
    if ((pid = fork()) == -1)
        exit_sys("fork");

    if (pid != 0) {     /* parent process */
        printf("Parent process id: %ld\n", (long)getpid());
        printf("Parent process id of the parent: %ld\n", (long)getppid());
        pgid = getpgrp();
        printf("Parent process group id: %ld\n", (long)pgid);

        if (waitpid(pid, NULL, 0) == -1)
            exit_sys("waitpid");
    }
    else {      /* child process */
        sleep(1);
        printf("Child process id: %ld\n", (long)getpid());
        printf("Parent process id of the child: %ld\n", (long)getppid());
        pgid = getpgrp();
        printf("Child process group id: %ld\n", (long)pgid);
    }

    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/*--------------------------------------------------------------------------------------------------------------------------
    Yeni bir proses grubu yaratmak için ya da bir prosesin proses grubunu değiştirmek için setpgid POSIX fonksiyonu kullanılmaktadır. 

    int setpgid(pid_t pid, pid_t pgid);

    Fonskiyonun birinci parametresi proses grup id'si değiştirilecek prosesi ikinci parametresi de hedef proses grup id'sini belirtmektedir. 
    Eğer bu iki parametre aynı ise yeni bir proses grubu yaratılır ve bu yeni grubun lideri de buradaki proses olur. Bir proses
    (root olsa bile) ancak kendisinin ya da kendi alt proseslerinin proses grup id'lerini değiştirebilir. Ancak üst proses alt proses 
    exec uyguladıktan sonra onun proses grup id'sini artık değiştirememektedir. setpgid fonksiyonu ile prsoses kendisinin ya da alt proseslerinin
    proses grup id'lerini aynı "oturum (session)" içerisindeki bir proses grup id'si olarak değiştirebilmektedir. 

    Örneğin kabuk çalıştırdığımız programı yeni proses grubunun grup lideri şöyle yapmaktadır: Kabuk önce fork yapar. Üst ya da 
    alt proseste setpgid fonskiyonuyla yeni proses grubunu oluşturp alt prosesin bu grubun lideri olmasını sağlar.
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/wait.h>

void exit_sys(const char *msg);

int main(void)    
{
    pid_t pgid;
    pid_t pid;
    
    if ((pid = fork()) == -1)
        exit_sys("fork");

    if (pid != 0) {     /* parent process */
        printf("Parent process id: %ld\n", (long)getpid());
        printf("Parent process id of the parent: %ld\n", (long)getppid());
        pgid = getpgrp();
        printf("Parent process group id: %ld\n", (long)pgid);

        if (waitpid(pid, NULL, 0) == -1)
            exit_sys("waitpid");
    }
    else {      /* child process */
        sleep(1);
        if (setpgid(getpid(), getpid() /* 0 */ ) == -1)     
            exit_sys("setpgid");

        printf("Child process id: %ld\n", (long)getpid());
        printf("Parent process id of the child: %ld\n", (long)getppid());
        pgid = getpgrp();
        printf("Child process group id: %ld\n", (long)pgid);
    }

    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/*--------------------------------------------------------------------------------------------------------------------------
    Yukarıda da belirtildiği gibi kill POSIX fonksiyonuyla (ya da kill komutuyla) bir proses grubuna sinyal gönderildiğinde
    aslında proses grubundaki tüm proseslere sinyal gönderilmektedir. Bunu aşağıdaki programla test edebilirsiniz. 
    Başka bir terminalden girip önce üst ve alt proseslerin id'lerini aşağıdaki komut ile elde ediniz:

    ps -a -o pid,ppid,pgid,cmd

    Sonra da proses grubuna kill komutuyla SIGTERM sinyalini gönderiniz:

    kill -TERM -<proses grup id>

    Proses grup id'sini eksi değer olarak yazmayı unutmayınız.
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/wait.h>
#include <signal.h>

void exit_sys(const char *msg);
void sigusr1_handler(int sno);

int main(void)    
{
    pid_t pid;
    struct sigaction sa;

    sa.sa_handler = sigusr1_handler;
    sigemptyset(&sa.sa_mask);
    sa.sa_flags = 0;

    if (sigaction(SIGUSR1, &sa, NULL) == -1)
        exit_sys("siagaction");
    
    if ((pid = fork()) == -1)
        exit_sys("fork");

    if (pid != 0) {     /* parent process */
        printf("parent waitint at pause\n");
        pause();
        if (waitpid(pid, NULL, 0) == -1)
            exit_sys("waitpid");
    }
    else {      /* child process */
        printf("child waitint at pause\n");
        pause();
    }

    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

void sigusr1_handler(int sno)
{
    printf("SIGUSR1 occurred in process %ld\n", (long)getpid());
}

/*--------------------------------------------------------------------------------------------------------------------------
    Kabuk ile birden fazla programı boru eşliğinde çalıştırdığımızı düşünelim. Örneğin:

    cat | grep "xxx" 

    Burada kabuk cat ve grep için fork yapar. Bu iki proses kardeştir. Ancak aralarında üstlük-altlık ilişkisi yoktur.
    Kabuk bu iki prosesi aynı gruba sokar ve birinci prosesi de (burada cat) bu grubun grup lideri yapar. Bu komutu bir terminalden 
    çalıştırıp diğer bir terminalde aşağıdaki komutla durumu gözlemleyiniz:

    ps -a -o pid,ppid,pgid,cmd

    İşte bu durumda Ctrl+C ve Ctrl + Delete tuşları SIGINTR ve SIGQUT sinyallarini bu proses grubuna yollayacak böylece buradaki 
    iki proses de (eğer sinyali sinyali işlememişlerse) sonlanacaktır. 
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Oturum (session) arka plan çalışmayı düzene sokmak için uydurulmuş bir kavramdır. Bir oturum proses gruplarından oluşur. 
    Oturumu oluşturan proses gruplarından yalnızca biri "ön plan (foreground)"", diğerlerinin hepsi "arka plan (background)"
    gruplardır. İşte aslında klavye sinyallerini terminal sürücüsü (tty) oturumun ön plan proses grubuna yollamaktadır.

    Kabuk üzerinden bir komut yazıp komutun sonuna & karakteri getirilirse bu & karakteri "bu komutu arka planda çalıştır" anlamına gelir. 
    Böylece kabuk çalıştırılan komutu wait fonksiyonlarıyla beklemez. Yeniden prompt'a düşer. Ancak o komut çalışmaya devam etmektedir. 
    İşte kabuk & ile çalıştırılan prosesleri oturumun arka plan prosesi durumuna getirir. Sonunda & olmadan çalıştırılan prosesler ise ön plan proses 
    grubunu oluşturur. Aslında kabuk da ön plan proses grubunun içerisindedir. Dolayısıyla kabuğun kendisi de aynı oturumdadır. 

    O halde durum özetle şöyledir: Aslında kabuk bir oturum yaratıp kendini oturumun lideri yapmıştır. Sonra kabuk sonu & ile
    biten komutlar için yarattığı proses guplarını oturumun arka plan proses grupları yapar. Sonunda & olmayan komutları da 
    oturumun ön plan proses grubu yapmaktadır. Terminal sürücüsü de SIGINT ve SIGQIUT gibi sinyalleri oturumun ön plan proses grubuna 
    göndermektedir. 

    Oturumların da proses gruplarında olduğu gibi id'leri vardır. Oturumların id'leri oturum içerisindeki bir proses grubunun liderinin 
    id'si ile aynıdır. Oturum terminal sürücüsüyle ilişkili bir kavram olarak uydurulmuştur. Dolayısıyla oturumların bir 
    "ilişkin olduğu terminal (controlling terminal)" vardır. Bu terminal gerçek terminal ise tty terminallerinde biridir. Sahte (Psudo)
    bir terminal ise pts terminallerinden biridir. Pencere yöneticilerinin içerisinde açılan terminaller sahte terminallerdir. Ancak
    işlev olarak gerçek terminallerden bir farkları yoktur. Klavyeden Ctrl+C ve Ctrl+Backspace tuşlarına basıldığında SIGINT ve SIGQUIT
    sinyalleri bu terminal tarafından (aslında terminal sürücüsü tarafından) oturumun ön plan proses grubuna gönderilmektedir. 
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Bir prosesin ilişkin olduğu otum id'si (session id) getsid POSIX fonksiyonula alınmaktadır:

    pid_t getsid(pid_t pid);

    Aşağıdaki programda bir prosesin ve onun alt prosesinin id bilgileri ekrana yazdırılmıştır. Üst ve alt proseslerin aynı session id'ye
    sahip olduğuna onun da bash'in session id'si olduğuna dikkat ediniz.
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/wait.h>

void exit_sys(const char *msg);

int main(void)    
{
    pid_t pgid;
    pid_t pid;
    
    if ((pid = fork()) == -1)
        exit_sys("fork");

    if (pid != 0) {     /* parent process */
        printf("Parent process id: %ld\n", (long)getpid());
        printf("Parent process id of the parent: %ld\n", (long)getppid());
        pgid = getpgrp();
        printf("Parent process group id: %ld\n", (long)pgid);
        printf("Parent process session id: %ld\n", (long)getsid(0));

        if (waitpid(pid, NULL, 0) == -1)
            exit_sys("waitpid");
    }
    else {      /* child process */
        sleep(1);
        if (setpgid(getpid(), getpid() /* 0 */ ) == -1)     
            exit_sys("setpgid");

        printf("Child process id: %ld\n", (long)getpid());
        printf("Parent process id of the child: %ld\n", (long)getppid());
        pgid = getpgrp();
        printf("Child process group id: %ld\n", (long)pgid);
        printf("Child process session id: %ld\n", (long)getsid(0));
    }

    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/*--------------------------------------------------------------------------------------------------------------------------
    Yeni bir oturum (session) yaratmak için setsid fonksiyonu kullanılmaktadır:

    pid_t setsid(void);

    Fonksiyon şunları yapar: 

    - Yeni bir oturum (session) oluşturur
    - Bu oturum içerisinde yeni bir proses grubu oluşturur. 
    - Oluşturulan oturumun ve proses grubunun lideri fonksiyonu çağıran prosestir.

    setsid fonksiyonu tipik olarak kabuk programları tarafından işin başında çağrılmaktadır. Böylece kabuk yeni bir oturumun hem lideri olur
    hem de o oturum içerisinde yaratılmış olan bir proses grubunun lideri olur. O halde bir komut uygulanmamış durumdaki kabuk ortamında bir oturum 
    ve bir de proses grubu vardır. Kabuk bu ikisinin de lideri durumundadır. Sonra kabukta sonu & ile bitmeyen bir komut çalıştırıldığında kabuk
    bu komuta ilişkin proses için yeni bir proses grubu yaratır ve bu grubu oturumun ön plan proses grubu yapar. 

    setsid fonksiyonunu çağıran proses eğer zaten bir proses grubunun grup lideri ise fonksiyon başarısız olmaktadır. Örneğin 
    biz kabultan çalıştırdığımız bir programda setsid çağrısı yaparsak başarısız oluruz. 
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>

void exit_sys(const char *msg);

int main(void)    
{
    if (setsid() == -1)     /* function possibly will fail! */
        exit_sys("setsid");

    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/*--------------------------------------------------------------------------------------------------------------------------
    Eğer yeni bir oturum yaratılmak isteniyorsa programın nasıl çalıştırılacağı bilnmediğine göre önce fork uygulayıp alt proseste 
    setsid uygulamak gerekir. 
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>

void exit_sys(const char *msg);

int main(void)    
{
    pid_t pid;

    if ((pid = fork()) == -1)
        exit_sys("fork");

    if (pid != 0)
        exit(EXIT_SUCCESS);

    if (setsid() == -1)     /* function possibly will fail! */
        exit_sys("setsid");

    printf("Ok, i am session leader of the new session!\n");

    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/*--------------------------------------------------------------------------------------------------------------------------
    Oturum  lideri open fonksiyonuyla O_NOCTTY bayrağı kullanılmadan bir terminal aygıt sürücüsünü açtığında artık o terminal
    oturumun ilişkin olduğu terminal (controlling terminal) durumuna gelir. Eğer terminal o anda başka bir oturumun terminaliyse oradan kopartılmaktadır.
    open işlemini yapan prosese ise "terminali kontrol eden proses (controlling proscess)" denilmektedir. Normal olarak kabuk programı (bash)
    terminali kontrol eden proses (controlling process) durumundadır. Dosyaların betimleyicileri üst prosesten alt prosese aktarıldığına göre
    bu terminal betimleyicisi her proses de gözükecektir. Buna "ilgili prosese ilişkin terminal (process controlling terminal)" denilmektedir. 
    Anımsanacağı gibi aslında 0 numaralı betimleyici terminal aygıt sürücüsünün (controlling terminal) O_RDONLY modunda açılmasıyla,
    1 numaralı betimleyici aynı aygıt sürücünün O_WRONLY moduyla açılmasıyla ve stderr de 1 numaralı betimleyinin dup yapılmasıyla oluşturulmaktadır.
    Yani aslında 0, 1 ve 2 betimleyiciler aynı dosyaya ilişkindir. Buna terminal ya da bu bağlamda "controlling terminal" denilmektedir. 
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Oturumdaki ön plan proses grubunun hangisi olduğu tcgetpgrp POSIX fonksiyonuyla elde edilebilir. Oturumun ön plan proses grubu da 
    tcsetpgrp POSIX fonksiyonula değiştirilebilir. 

    pid_t tcgetpgrp(int fildes);
    int tcsetpgrp(int fildes, pid_t pgid_id);
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Oturumun arka plan bir plan prosesi, prosesin ilşkin olduğu terminalden (controlling terminal) okuma yapmak isterse terminal 
    sürücüsü o arka plan prosesin içinde bulunduğu proses grubuna SIGTTIN sinyalini göndermektedir. 
    Bu sinyalin defaul durumu prosesin durdurulmasıdır. Bu biçimde durdurulmuş olan prosesler SIGCONT sinyali ile yeniden çalıştırılmak istenebilirler. 
    Ancak yeniden okuma yapılırsa yine proses durdurulur. Bu tür prosesler kabuk üzerinden fg komutuyla ön plana çekilebilir. 
    Bu durumda kabuk önce prosesin proses grubunu ön plan proses grubu yapar sonra da onu SOGCONT sinyali ile uyandırır. 

    Aşağıdaki programı komut satırında sonuna & gerirerek çalıştırınız. Program 10 saniye sonra stdin dosyasından okuma yapmaya
    çalışacak ve bu nedenden dolayı SIGTTIN sinyali gönderilerek durdurulacaktır. Prosesin durdurulmuş olduğunu ps -l komutu ile ya da 
    ps -o stat,cmd komutuyla gözleyiniz
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>

void exit_sys(const char *msg);

int main(void)    
{
    sleep(10);
    fgets(s, 100, stdin);
    puts(s);

    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/*--------------------------------------------------------------------------------------------------------------------------
    Arka plan proses grubundaki proseses SIGTTIN sinyalini işleyebilir. Bu durumda eğer yeniden başlatılabilir olmayan bir sistem fonksiyonu
    içerisinde bulunuluyorsa bu sistem fonksiyonu EINTR hata koduyla geri döner. 

    Aşağıda programı sonuna & getirerek çalıştırıp log dosyasını inceleyiniz.
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <errno.h>
#include <unistd.h>
#include <signal.h>

void exit_sys(const char *msg);
void sigttin_handler(int sno);

FILE *g_f;

int main(void)    
{
    char s[100];
    struct sigaction sa;

    if ((g_f = fopen("log.txt", "w")) == NULL) 
        exit_sys("fopen");

    sa.sa_handler = sigttin_handler;
    sigemptyset(&sa.sa_mask);
    sa.sa_flags = 0;

    if (sigaction(SIGTTIN, &sa, NULL) == -1)
        exit_sys("sigaction");
    
    sleep(10);
    if (fgets(s, 100, stdin) == NULL && errno == EINTR)
        fprintf(g_f, "gets terminated by signal!..\n");
    puts(s);

    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

void sigttin_handler(int sno)
{
    fprintf(g_f, "SIGTTIN occurred!..\n");
}

/*--------------------------------------------------------------------------------------------------------------------------
    Arka plan proses grubundaki bir prosesin ilişkin terminale (controlling terminal) bir şeyler yazmaya çalışması da uygun değildir. 
    Bu durumda da terminal sürücüsü prosesin ilişkin olduğu arka plan proses grubuna SIGTTOU sinyalini göndermektedir. Bu sinyalin default 
    eylemi yine prosesin durdurulmasıdır.  Ancak bu sinyalin aygıt sürücüsü tarafından arka plan proses grubuna gönderilmesi için Linux'ta terminalin TOSTOP modunda 
    olması gerekir. Eğer terminal bu modda değilse proses durdurulmaz ancak yazılanlar da kaybolur. 

    Aşağıdaki programı sonuna & koyarak çalıştırmayı deneyiniz
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>

int main(void)    
{    
    sleep(10);
 
    printf("test\n");

    sleep(10);

    return 0;
}

/*--------------------------------------------------------------------------------------------------------------------------
    Bir prosesin durdurulması çizelgeden çıkartılıp bloke edilmesi anlamına gelir. Ancak bunun normal bir blokeden farkı vardır. 
    Bloke olma bir nedene dayalıdır. O neden ortadan kalkınca (ya da sağlanınca) bloke sonlanır. Ancak prosesin durudulması 
    herhangi bir olayı beklemek biçiminde bi bloke değildir. Durdurulmuş prosesler SIGCONT sinyali ile yeniden normal yaşamlarına 
    dönerler. Prosesi durdurmak için ona SIGSTOP sinyaliin gönderilmesi gerekir. SIGSTOP sinyali için sinyal fonksiyonu set edilemez ve 
    bu sinyal ignore da edilemez. Bu anlamda SIGSTOP sinyali SIGKILL sinyaline benzemektedir. SIGSTOP sinyaline benzer diğer bir sinyale de
    SIGTSTP sinyali denilmektedir. Bu sinyal terminal sürücüsü tarafından klavyeden Ctrl + Z tuşuna basıldığında ön plan porses 
    grubuna gönderilmektedir. Bu sinyalin de -ismi üzer,nde- default eylemi proseslerin durdurulmasıdır. Ancak SIGTSTP sinyali 
    ignore edilebilir ya da bu sinyal için sinyal fonksiyonu set edilebilir. (SIGSTOP sinyaliin ignore edilemediğini ve bunun için
    bir sinyal fonksiyonu set edilemediğine dikkat ediniz.)


    Aşağıdaki programı çalıştırıp Ctrl + Z tuşlarına basmayı deneyiniz.
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <errno.h>
#include <unistd.h>
#include <signal.h>

void exit_sys(const char *msg);
void sigtstop_handler(int sno);

int main(void)    
{
    int i;
    struct sigaction sa;
    
    sa.sa_handler = sigtstop_handler;
    sigemptyset(&sa.sa_mask);
    sa.sa_flags = 0;

    if (sigaction(SIGTSTP, &sa, NULL) == -1)
        exit_sys("sigaction");
    
    for (i = 0;; ++i) {
        printf("%d\n", i);
        sleep(1);
    }

    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

void sigtstop_handler(int sno)
{
    printf("SIGTSTOP occurred!..\n");
}
    
/*--------------------------------------------------------------------------------------------------------------------------
    read ve write fonksiyonları POSIX standartlarına göre sistem genelinde atomiktir. Yani örneğin iki proses dosyanın aynı bölgesine
    write ile yazma yaparsa kesinlikle iç içe geçme olmaz.Ya onun ya da diğerinin yazdıkları gözükür. Benzer biçimde bir proses
    dosyanın belli bir bölümüne yazma yaparken aynı anda balka bir proses aynı bölgeden okumak yapmak isterse okuyan bozuk bir şeyi okumaz.
    Ya önceki durumu okur ya da diğerinin tüm yazdıklarını okur. 

    Ancak VTYS (Veritabanı Yönetim Sistemleri) gibi programlar birden fazla read ya da write ile ilişkili okuma ve yazma yapabilmektedir. 
    Farklı read ve write çağrıları tabii ki atomik değildir. Örneğin bir proses data dosyasına bir yazdıktan sonra ona ilişkin bazı bilgileri
    indeks dosyasına yazıyor olabilir. Başka bir proses de aynı işlemi yapıyor olabilir. Burada iç içe geçme olabilir. 
    O halde bu gibi ayrık okuma ve yazmaları eğer gerekiyorsa senkronize etmek gerekir. Senkronizasyon için bir mutex kullanmak
    iyi bir tek nik değildir. Çünkü bütünsel bir kilitlemeye yol açar. Halbuki dosya işlemlerinde yalnızca çakışan offset aralıkları için 
    kilitleme yapılırsa performs artar. İşte bu nedenle zamanla UNIX türevi sistemlere "dosya kilitleme (file locking)" mekanizmaları eklenmiştir. 

    Dosya kilitleme bütünsel olarak ya da offset temelinde bölgesel olarak (kayıtsal olarak) yapılabilmektedir. Genel olarak bütünsel kilitleme
    çoğu kez kötü bir tekniktir.
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Dosyayı bütünsel kilitlemek için flock fonksiyonu kullanılabilir. Bu fonksiyon bir POSIX fonksiyonu değildir. Ancak Linux
    dahil olmak üzere pek çok UNIX türevi sistemde bulunmaktadır. 

    int flock(int fd, int operation);

    Fonksiyonun birinci parametresi kilitlenecek dosyaya ilişkin betimleyicidir. İkincisi parametresi kilitleme biçimidir. 
    Bu biçim şunlardan birisi olabilir:

    LOCK_SH: Okuma için kilidi alma
    LOCK_EX: Yazma için kilidi alma
    LOCK_UN: Kilidi bırakma

    İstanirse bunlardan birinin yanıs sıra LOCK_NB bayrağı da eklenebilir. Tıpkı okuma yazma kilitlerinde olduğu gibi birbirleriyle
    çelişen kilitleme blokeye yol açmaktadır. 

    Bu biçimdeki kilitler alt prosese de fork işlemi sırasında geçirilmektedir. Eğer kilit hiç açılmazsa kilidin ilişkin olduğu
    dosya ilişkin son betimleyici kapatıldığında kilit otomatik olarak açılır. 

    Dosyayı bütünsel kilitlemek yerine proseslerarası çalışan bir senkronizasyon nesnesiyle benzer bir etki yaratılabilir. Ancak toplamda
    böyle bir senkronizasyon nesnesi oluşturmanın klod maliyeti flock fonksiyonundan çok daha fazla olmaktadır. 

    Dosya hangi modda açılırsa açılsın flock ile kilitleme yapılabilmektedir. 

---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Offset temelinde kilitlemede fcntl fonksiyonu kullanılmaktadır. Anımsanacağı gibi bu fonksiyon açılmış dosyaların birtakım
    özelliklerini değiştirmek için de kullanılmaktaydı. Fonksiyonun prototipi şöyledir:

    
    int fcntl(int fd, int cmd, ... );

    Offset temelinde kilitleme için kilitlenecek dosyayı temsil eden bir dosya betimleyicisi kullanılır (Birinci parametre). 
    Fonksiyonun parametresine F_SETLK, F_SETLKW ya da F_GETLK değerlerinden biri girilir. Üçüncü paramtresine ise her zaman
    flock isimli bir yapı nesnesinin adresi yerleştirilmelidir. Bu yapı şöyledir:

    struct flock {
        short l_type;    
        short l_whence;  
        off_t l_start;   
        off_t l_len;     
        pid_t l_pid;     
    };

    Bu yapı nesnesinin elemanları pid dışında programcı tarafından doldurulur. l_type elemanı kilitlmenin cinsini belirtir. 
    Bu elemana F_RDLCK, F_WRLCK, F_UNLCK değerlerinden biri girilmelidir. Yapının l_whence elemanı offset için orijini belirtmektedir. 
    Bu elemana da SEEK_SET, SEEK_CUR ya da SEEK_END değerleri girilmelidir. l_start kilitlenecek bölgenin başlangıç offset'ini
    l_len ise uzunluğunu belirtmektedir. l_pid F_GETLK komutu tarafından doldulmaktadır. 

    l_len değeri 0 ise bu l_start değerinden itibaren dosyanın sonuna ve ötesine kadar kilitleme anlamına gelmektedir. (Bu durumda
    örneğin lseek ile dosya göstericisi EOF ötesine konumlandırılsa bile kilit geçerli olmaktadır.)

    F_SETLK blokesiz F_SETLKW blokeli kilitleme yapmaktadır. Kilitlenmek istenen alan daha önce kilitlenmiş olan başka
    alanları kapsıyor ya da kesişiyor olabilir. Bu duurmda çelişme tüm kapsanan ve kesişen alanlar dikkate alınarak belirlenmektedir.

    F_SETLK ile kilitlemek isteyen proses eğer bu alan başka bir proses tarafından çelişki yaratacak biçimde kilitlenmişse fcntl -1
    değerine geri döner ve errno EACCESS ya da EAGAIN değeriyle set edilir. F_SETLKW zaten bu durumda bloke olmaktadır. 
    F_GETLK komutu için de programcının flock nesnesini oluşturmuş olması gerekir. Bu durumda fcntl bu alanın isteğe bağlı biçimde
    kilitlenip kilitlenmeyeceğini bize söyler. Yani bu durumda fcntl kilitleme yapmaz ama sanki yapacakmış gibi duruma bakar. 
    Eğer çelişki yoksa fcntl yalnızca yapının type elemanını F_UNLCK haline getirir. Eğer çelişki varsa bu çelişkiye yol açan kilit
    bilgilerini yapı nesnesinin içerisine doldurur. Fakat o alan birden fazla proses tarafından farklı biçimde kilitlenmişse bu durumda
    fcntl bu kilitlerin herhangi birinin bilgisini bize verecektir. 

    fcntl ile offset temelindeki kilitler fork işlemi sırasında alt prosese aktarılmazlar. Yani üst prosesin kilitlemiş olduğu alanlar
    alt proses tarafından da kilitlenmiş gibi olmazlar. exec işlemleri sırasında offset temelindeki kilitlemeler varlığını devam ettirmektedir. 
    Bir proses sonlandığında ya da o i-node elemanına ilişkin tüm betimleyiciler kapatıldığında prosesin ilgili dosyadaki kilitleri serbest bırakılır. 

    Prosesin dosyaya F_WRLCK koyabilmesi için dosyanın yazma modunda, F_RDLCK koyabilmesi için ise dosyanın okuma modunda 
    açılmış olması gerekir. 

    Aşağıdaki program offset temelinde kayıt kilitlemeyi betimlemek için yazılmıştır. Program çalıştırıldığında bir komut satırına düşülecek
    ve komut satırında şu komutlar verilecektir. 

    <fcntl command code> <lock type> <starting offset> <length>

    Programı kilitlemede kullanılacak dosyanın yol ifadesini komut satırı argümanı biçiminde vererek çalıştırınız. Örneğin:

    ./rlock test.txt

    Tabii vereceğiniz dosyanın boş olmaması gerekir. Örnek komutlar şöyledir:

    Örneğin:

    CSD (32567): F_SETLK F_WRLCK 0 64
    CSD (32767): F_SETLK F_UNLCK 0 64

    Command kodlar şunlardır: F_SETLK, F_SETLKW, F_GETLK

    lock türleri de şunlardır: F_RDLCK, F_WRLCK, F_UNLCK
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <errno.h>
#include <fcntl.h>
#include <unistd.h>

#define MAX_CMDLINE     4096
#define MAX_ARGS        64

void parse_cmd(void);
int get_cmd(struct flock *fl);
void disp_flock(const struct flock *fl);
void exit_sys(const char *msg);

char g_cmd[MAX_CMDLINE];
int g_count;
char *g_args[MAX_ARGS];

int main(int argc, char *argv[])    
{
    int fd;
    pid_t pid;
    char *str;
    struct flock fl;
    int fcntl_cmd;

    if (argc != 2) {
        fprintf(stderr, "wrong number of arguments!..\n");
        exit(EXIT_FAILURE);
    }

    pid = getpid();

    if ((fd = open(argv[1], O_RDWR)) == -1)
        exit_sys("open");

    for (;;) {
        printf("CSD (%ld)>", (long)pid), fflush(stdout);
        fgets(g_cmd, MAX_CMDLINE, stdin);
        if ((str = strchr(g_cmd, '\n')) != NULL)
            *str = '\0';
        parse_cmd();
        if (g_count == 0)
            continue;
        if (g_count == 1 && !strcmp(g_args[0], "quit"))
            break;
        if (g_count != 4) {
            printf("invalid command!\n");
            continue;
        }

        if ((fcntl_cmd = get_cmd(&fl)) == -1) {
            printf("invalid command!\n");
            continue;
        }

        if (fcntl(fd, fcntl_cmd, &fl) == -1)
            if (errno == EACCES || errno == EAGAIN)
                printf("Locked failed!..\n");
            else
                exit_sys("fcntl");
        if (fcntl_cmd == F_GETLK) 
            disp_flock(&fl);
    }

    close(fd);

    return 0;
}

void parse_cmd(void)
{    
    char *str;

    g_count = 0;    
    for (str = strtok(g_cmd, " \t"); str != NULL; str = strtok(NULL, " \t")) 
        g_args[g_count++] = str;
}

int get_cmd(struct flock *fl)
{
    int cmd, type;
    
    if (!strcmp(g_args[0], "F_SETLK"))
        cmd = F_SETLK;
    else if (!strcmp(g_args[0], "F_SETLKW"))
        cmd = F_SETLKW;    
    else if (!strcmp(g_args[0], "F_GETLK"))
        cmd = F_GETLK;
    else 
        return -1;

    if (!strcmp(g_args[1], "F_RDLCK"))
        type = F_RDLCK;
    else if (!strcmp(g_args[1], "F_WRLCK"))
        type = F_WRLCK;    
    else if (!strcmp(g_args[1], "F_UNLCK"))
        type = F_UNLCK;
    else 
        return -1;     

    fl->l_type = type;
    fl->l_whence = SEEK_SET;
    fl->l_start = (off_t)strtol(g_args[2], NULL, 10);
    fl->l_len = (off_t)strtol(g_args[3], NULL, 10);

    return cmd;
}

void disp_flock(const struct flock *fl)
{
    switch (fl->l_type) {
        case F_RDLCK:
            printf("Read Lock\n");
            break;
        case F_WRLCK:
            printf("Write Lock\n");
            break;
        case F_UNLCK:
            printf("Unlocked (can be locked)\n");
    }

    printf("Whence: %d\n", fl->l_whence);
    printf("Start: %ld\n", (long)fl->l_start);
    printf("Length: %ld\n", (long)fl->l_len);
    if (fl->l_type != F_UNLCK)
        printf("Process Id: %ld\n", (long)fl->l_pid);
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/*--------------------------------------------------------------------------------------------------------------------------
    Eğer çok sayıda lock işlemi yapılacaksa fcntl çağrısını yapan bir satma fonksiyon kullanılabilir. 
---------------------------------------------------------------------------------------------------------------------------*/

int setlock_wrapper(int fd, int type, int whence, off_t start, off_t len)
{
    struct flock fl;

    fl.l_type = type;
    fl.l_whence = whence;
    fl.l_start = start;
    fl.l_len = len;

    return fcntl(fd, F_SETLK, &fl);
}

int getlock_wrapper(int fd, int type, int whence, off_t start, off_t len)
{
    if (fcntl(fd, F_GETLK, &fl) == -1)
        return -1;

    return fl.l_type;
}

/*--------------------------------------------------------------------------------------------------------------------------
    
    Yukarıdaki sarma fonksiyonarın bir benzeri POSIX standartlarında lockf (flock ile karıştırmayınız) ismiyle bulunmaktadır. 
    
    int lockf(int fildes, int function, off_t size);

    Bu fonksiyon her zaman dosya göstericisinin gösterdiği yerden itibaren size kadar byte'ı kilitler. size değeri negatif olabilir. 
    İkinci parametre olan function şunlardan biri olabilir:

    F_ULOCK
    F_LOCK
    F_TLOCK
    F_TEST

    F_ULOCK "unlock" anlamındadır. F_LOCK kilitleme yapmaya çalışır. Eğer çelişkili bir durum varsa blokeye yol açar. F_TLOCK
    ise çelişki durumda bloke oluşturmayıp -1 ile geri döner. errno değeri de yine EACCES ya da EAGAIN değeri ile set edilir.
    F_TEST kilitleme yapmaz ancak durumu test eder. Eğer test çelişkili ise fonksiyon -1'e geri döüp errno değerini EACCES ya da
    EAGAIN değerine set etmektedir. 

---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------

Biz yukarıda "tavsiye niteliğinde (advisory)" kilitleme yaptık. Burada "tavsiye niteliğinde (advisory)" demekle şu anlatılmak
istenmektedir: Bir proses fcntl (ya da lockf ya da flock ile) kilitleme yaptığında aslında başka bir proses isterse read ve write 
fonksiyonlarıyla istediği zaman okuma yazma yapabilmektedir. Yani read ve write fonksiyonları ilgili alanın kilitli olup olmadığına 
bakmamaktadır. Tabii programcı tüm proseslerin kodlarını kendisi yazdığı için (ya da bir protokol eşliğinde başkaları da yazmış olabilir)
her zaman okuma yazma işlemlerinde öncelikle kilide bakçak biçimde bir strateji izler. İşte kilitlemenin diğer bir türüne de 
"zorlamalı kilitleme (mandatory locking)" denilmektedir. Artık bu kilitleme biçiminde başka bir proses kilitlenmiş alanı çelişki 
durumunda istede de read ve write ile okuyup yazamamaktadır. 

Zorlamalı kilitleme  POSIX standartların bulunmamaktadır. POSIZ standartları fcntl fonksiyonun açıklamasında bunun gerekçelerini
belirtmiştir. Bazı işletim sistemleri bunu hiç desteklememektedir. Linux 2.4 çekirdeği ile birlikte zorlamalı dosya kilitlemesini destekler
hale gelmiştir. Zorlamalı kilitleme için aslında fcntl fonksiyonunda ek bir şey yapılmaz. Linux'ta zorlamalı kilitleme için şu koşullarrın sağlanmış
olması gerekmektedir:

1) Dosyanın içinde bulunduğu dosya sisteminin -o mand ile mount edilmiş olması gerekir. (remount -o mand,remount <device> <mount point))
2) İlgili dosyanın setg-group id bayrağı set edilip x hakkı varsa reset edilmelidir. (chmod <dosya> g+s g-x)

Zorlamalı kilitlemede çekirdek her read/write işleminde kilide denk gelinmiş mi diye kontroller yapmaktadır. Bu da çalışmayı yavaşlatmaktadır. 
Ayrıca zorlamalı kilitleme kötüyekullanıma da açıktır.  

Aşağıda zorlamalı kilitlemeyi test etmek için iki program verilmiştir. Programlardan ilki belli bir dosyanın belli bir yerinden
n byte okuma yazma yapar. Örneğin:

./mlocktest test.txt r 0 64 
./mlocktest test.txt w 30 50 

Yazma sırasında hep 0'lar yazılır. 

Diğer program yukarıdaki rlock.c programıdır.

Bu denemeyi yapmadan önce şu işlemleri uygulayınız:

sudo mount -o remount,mand /dev/sda2 /
chmod g+s-x test.txt

Sonra programları farklı terminallerde dosya ismi vererek (burada test.txt) çalıştırınız.
---------------------------------------------------------------------------------------------------------------------------*/

/* mlocktest.c */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <fcntl.h>
#include <unistd.h>

void exit_sys(const char *msg);

/* ./mlocktest <dosya ismi> <r/w> <offset> <uzunluk> */

int main(int argc, char *argv[])    
{
    int fd;
    int operation;
    off_t offset;
    off_t len;
    char *buf;
    ssize_t result;

    if (argc != 5) {
        fprintf(stderr, "wrong number of arguments!..\n");
        exit(EXIT_FAILURE);
    }

    if (strcmp(argv[2], "r") && strcmp(argv[2], "w")) {
        fprintf(stderr, "invalid operation!\n");
        exit(EXIT_FAILURE);
    }

    offset = (off_t)strtol(argv[3], NULL, 10);
    len = (off_t)strtol(argv[4], NULL, 10);

    if ((buf = (char *)calloc(len, 1)) == NULL) {
        fprintf(stderr, "cannot allocate memory!..\n");
        exit(EXIT_FAILURE);
    }

    if ((fd = open(argv[1], argv[2][0] == 'r' ? O_RDONLY : O_WRONLY)) == -1)
        exit_sys("open");

    lseek(fd, 0, offset);
    if (argv[2][0] == 'r') {
        if ((result = read(fd, buf, len)) == -1)
            exit_sys("read");
        printf("%ld bytes read\n", (long)result);
    }
    else {
        if ((result = write(fd, buf, len)) == -1)
            exit_sys("write");
        printf("%ld bytes written\n", (long)result);
    }

    free(buf);
    close(fd);

    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/* rlock.c */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <errno.h>
#include <fcntl.h>
#include <unistd.h>

#define MAX_CMDLINE     4096
#define MAX_ARGS        64

void parse_cmd(void);
int get_cmd(struct flock *fl);
void disp_flock(const struct flock *fl);
void exit_sys(const char *msg);

char g_cmd[MAX_CMDLINE];
int g_count;
char *g_args[MAX_ARGS];

int main(int argc, char *argv[])    
{
    int fd;
    pid_t pid;
    char *str;
    struct flock fl;
    int fcntl_cmd;

    if (argc != 2) {
        fprintf(stderr, "wrong number of arguments!..\n");
        exit(EXIT_FAILURE);
    }

    pid = getpid();

    if ((fd = open(argv[1], O_RDWR)) == -1)
        exit_sys("open");

    for (;;) {
        printf("CSD (%ld)>", (long)pid), fflush(stdout);
        fgets(g_cmd, MAX_CMDLINE, stdin);
        if ((str = strchr(g_cmd, '\n')) != NULL)
            *str = '\0';
        parse_cmd();
        if (g_count == 0)
            continue;
        if (g_count == 1 && !strcmp(g_args[0], "quit"))
            break;
        if (g_count != 4) {
            printf("invalid command!\n");
            continue;
        }

        if ((fcntl_cmd = get_cmd(&fl)) == -1) {
            printf("invalid command!\n");
            continue;
        }

        if (fcntl(fd, fcntl_cmd, &fl) == -1)
            if (errno == EACCES || errno == EAGAIN)
                printf("Locked failed!..\n");
            else
                exit_sys("fcntl");
        if (fcntl_cmd == F_GETLK) 
            disp_flock(&fl);
    }

    close(fd);

    return 0;
}

void parse_cmd(void)
{    
    char *str;

    g_count = 0;    
    for (str = strtok(g_cmd, " \t"); str != NULL; str = strtok(NULL, " \t")) 
        g_args[g_count++] = str;
}

int get_cmd(struct flock *fl)
{
    int cmd, type;
    
    if (!strcmp(g_args[0], "F_SETLK"))
        cmd = F_SETLK;
    else if (!strcmp(g_args[0], "F_SETLKW"))
        cmd = F_SETLKW;    
    else if (!strcmp(g_args[0], "F_GETLK"))
        cmd = F_GETLK;
    else 
        return -1;

    if (!strcmp(g_args[1], "F_RDLCK"))
        type = F_RDLCK;
    else if (!strcmp(g_args[1], "F_WRLCK"))
        type = F_WRLCK;    
    else if (!strcmp(g_args[1], "F_UNLCK"))
        type = F_UNLCK;
    else 
        return -1;     

    fl->l_type = type;
    fl->l_whence = SEEK_SET;
    fl->l_start = (off_t)strtol(g_args[2], NULL, 10);
    fl->l_len = (off_t)strtol(g_args[3], NULL, 10);

    return cmd;
}

void disp_flock(const struct flock *fl)
{
    switch (fl->l_type) {
        case F_RDLCK:
            printf("Read Lock\n");
            break;
        case F_WRLCK:
            printf("Write Lock\n");
            break;
        case F_UNLCK:
            printf("Unlocked (can be locked)\n");
    }

    printf("Whence: %d\n", fl->l_whence);
    printf("Start: %ld\n", (long)fl->l_start);
    printf("Length: %ld\n", (long)fl->l_len);
    if (fl->l_type != F_UNLCK)
        printf("Process Id: %ld\n", (long)fl->l_pid);
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

int setlock_wrapper(int fd, int type, int whence, off_t start, off_t len)
{
    struct flock fl;

    fl.l_type = type;
    fl.l_whence = whence;
    fl.l_start = start;
    fl.l_len = len;

    return fcntl(fd, F_SETLK, &fl);
}

int getlock_wrapper(int fd, int type, int whence, off_t start, off_t len)
{
    if (fcntl(fd, F_GETLK, &fl) == -1)
        return -1;

    return fl.l_type;
}

/*--------------------------------------------------------------------------------------------------------------------------
    Linux sistemlerinde sistemdeki tüm kilitler /proc/locks isimli dosyay çekirdek tarafından yazılmaktadır. Örneğin:

1: POSIX  ADVISORY  WRITE 3515 08:02:393260 0 63
2: POSIX  ADVISORY  READ  2339 08:02:786493 128 128
3: POSIX  ADVISORY  READ  2339 08:02:786491 1073741826 1073742335
4: FLOCK  ADVISORY  WRITE 770 00:17:614 0 EOF

Burada birinci sütun kilidin  flock fonksiyonuyla mı yoksa fcntl fonksiyonuyla mı oluşturulduğunu belirtir. İkinci sütun
kilidin isteğe bağlı mı yoksa zorlamalı mı olduğunu belirtmektedir. Üçcüncü sütun kilidin yazmayı mı okumayı mı kilitlediğini 
belirtmektedir. Sonraki sütun kilitleyen prosesin id'sini sonraki sütun ise kilitlenmişl dosyanın dosya sistemindek, aygıt
numarasını ve i-node numarasını bel,irtmektedir. Nihayet son sütun kilitlemein offset aralığını belirtmektedir.
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    POSIX sistemlerinde ileri IO işlemleri 4 bölüme ayrılarak incelenebilir:

    1) Multiplexed IO: Bir grup betimleyici izlemeye alınır. Bu betimleyicilerde ilgilenilen olay (read/write/error)  yoksa blokede
    beklenir. Ta ki bu betimleyicilerden en az birinde ilgilenilen olay gerçekleşene kadar. Multiplexed IO için select ve poll POSIX
    fonksiyonları kullanılmaktadır. Ancak Linux epoll isimli daha yetenekli bir fonksiyona da sahiptir.

    2) Signal Driven IO: Burada belli betimleyiciler izlemeye alınır. Ancak blokede beklenmez. Bu betimleyicilerde olay gerçekleştiğinde
    SIGIO isimli sinyal oluşur. Programcı da bu sinyal oluşturuğunda blokeye maruz kalmadan read/write yapılabilir.

    3) Asenkron IO: Burada read/write işlemleri başlatılır. Ancak bir bloke oluşmaz. Arka planda çekirdek tarafından okuma ve yazma
    bir yandan yapılır. Ancak aktarım bittiğinde programcı haberdar edilir. Bunun signal driven IO'dan farkı şudur: Signal driven IO'da
    aktarım yapılmamaktadır. Yalnızca okuma yazma yaılırsa bloke olunmayacağı prosese söylenmektedir. Halbuki asenkron IO'da okuma ve yazma
    işlemi bloke çözülüdüğünde arka planda gerçekleştirilmekte ve yalnızca işlemin bittiğ haber verilmektedir. 

    4) Scatter-Gather IO: Burada okuma birden fazla adrese yazma ise birden fazla adresten kaynağa yapılmaktadır. 
---------------------------------------------------------------------------------------------------------------------------*/


/*--------------------------------------------------------------------------------------------------------------------------
    Multiplexed IO blokeye yol açabilecek aynı anda birden fazla dosya betimleyici ile işlem yapmayı anlatan bir IO terimidir. 
    Multiplexed IO için select, pselect, poll ve epoll fonksiyonları kullanılmaktadır. 
    
    select fonksiyonu ilk kez BSD sistemlerinde denenmiştir. Sonra POSIX standartlarına sokulmuştur. Fonksiyonun prototipi şöyledir:

    int select(int nfds, fd_set *readfds, fd_set *writefds, fd_set *errorfds, struct timeval *timeout);

    Fonksiyonun birinci parametresi ilgilenilecek betimleyicilerin en büyük değerini almaktadır. En yüksek betimleyici numarası FD_SETSIZE
    ile belirtilmiştir. Bu parametre doğrudan FD_SETSIZE (1024) olarak girilebilir. Ancak bu parametrenin uygun girilmesi bir hız kazancı
    sağlayabilmektedir. Fonksiyn parametrelerindeki fd_set türü bir bit dizisi belirtmektedir. Bu bit dizisinin belli bitini 1 yağmak için
    FD_SET, belli bitini 0 yapmak için FD_CLR, tüm bitlerini sıfır yapmak için FD_ZERO, belli bitini test etmek için ise FD_ISSET makroları
    kullanılmaktadır. Biz fonksiyona üç tane fd_set nesnesi veririz. Bunlardan ilki "okuma", ikincici "yazma" üçüncüsü "error" kontrolü yaptırmak
    içindir. Fonksiyon son parametresi "zaman aşımı" belirtmektedir. Bu parametreler için NULL adres girilebilir. Zaman aşımı için NULL adres
    girilirse zaman aşımının kullanılmayacağı anlaşılır. Eğer zaman aşımı için yapının her iki elemanı 0'da girilebilir. Budurumda select fonksiyonu
    hemen testini yapar ve geri döner. 

    select fonksiyonu okuma takibi için tipik olarak şöyle kullanılır: Progrtamcı okuma izlemesi yapılacak betimleyicilerin numaralarına ilişkin bitleri
    bir fd_set içerisinde set eder. Bunu fonksiyonun ikinci parametresine verir. Fonksiyon da yalnızca 1 olan bitlere ilişkin betimleyicileri 
    izleyecektir. Programcı bu betimleyicilerden okuma yapılamayacak durumda ise (yani okuma girişiminde bloke oluşacak durumda ise) select blokede 
    akışı bekletir. En az bir betimleyicide okuma eylemi yapılabilecek durumdaysa bloke çözülür. Fonksiyon hangi betimleyicilerde okuma işleminin yapılabileceğini
    yine bizim ona verdiğimiz fd_set nesnesinin ilgili 1 yaparak bize iletmektedir. Yani bizim fonksiyona verdiğimiz fd_set nesnesi fonksiyon geri döndüğünde
    artık bozlmuş durumdadır yani hangi betimleyicilerin okumaya elvirişli olduğunu gösterecek biçimde değiştirilmiş durumdadır. Buradaki aynı çalışma
    biçimi "yazma" ve "error" işlemi için de aynı biçimde söz konusudur. Programcı aynı zamanda isterse üç ayrı fd_set nesnesini de fonksiyona verebilir. 

    select fonksiyou başarısızlık durumunda -1 değerine geri döner. Eğer hiçbir betimleyicide olay gerçekleşmemiş ancak zaman aşımı dolmuşsa 0 değerine geri döner.
    Eğer en az bir betimleyicide ilgili olay gerçekleşmişse toplam olay gerçekleşen betimleyici sayısına geri döner. (Aynı betimleyici örneğn hen okuma hem de yazma
    için izleniyorsa ve bu betimleyicide hem okuma hem de yazma olayı gerçekleşmişse bu değer 2 artırılmaktadır.)

    select fonksiyonun normal disk dosyaları için kullanılması anlamsızdır. Uzun süre beklemeye yol açabilecek terminal gibi, boru gibi, soket gibi aygıtlar için
    kullanılmalıdır. Normal olarak select ile bekelenecek betimleyicilere ilişkin kaynaklar "blokeli" modda açılmalıdırlar. 

    Aşağıdaki örnekte 0 numaralı betimleyici select ile izlenmiştir. Bu betimleyici terminal sürücüne ilişkindir. Kullanıcı bir yazı girip ENTER
    tuşuna bastığıda terminal sürücüsü select fonksiyonun blokesini çözecektir. 
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/select.h>

void exit_sys(const char *msg);

int main(int argc, char *argv[])    
{
    fd_set rset;
    int result;
    char buf[1024 + 1];
    ssize_t n;

    FD_ZERO(&rset);
    FD_SET(0, &rset);

    if ((result = select(1, &rset, NULL, NULL, NULL)) == -1)
        exit_sys("select");

    printf("result = %d\n", result);
    if ((n = read(0, buf, 1024)) == -1)
        exit_sys("read");
    buf[n] = '\0';
    printf("%s", buf);
    
    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/*--------------------------------------------------------------------------------------------------------------------------
    Yukarıdaki programa 5 saniyelik bir zaman aşımı ekleyelim.
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/select.h>

void exit_sys(const char *msg);

int main(int argc, char *argv[])    
{
    fd_set rset;
    int result;
    char buf[1024 + 1];
    ssize_t n;
    struct timeval tv;

    FD_ZERO(&rset);
    FD_SET(0, &rset);

    tv.tv_sec = 5;
    tv.tv_usec = 0;

    if ((result = select(1, &rset, NULL, NULL, &tv)) == -1)
        exit_sys("select");

    if (result == 0)
        printf("Timeout!\n");
    else {
        printf("result = %d\n", result);
        if ((n = read(0, buf, 1024)) == -1)
            exit_sys("read");
        buf[n] = '\0';
        printf("%s", buf);
    }
    
    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/*--------------------------------------------------------------------------------------------------------------------------
    POSIX standartları zaman aşımı için verdiğimiz timeval yapı nesnesinin fonksiyon tarafından güncellenip güncellenmeyeceğini
    isteğe bağlı olarak sisteme bırakmıştır. Linux'ta select sonlanmadan önce bu yapıya kalan zaman miktarı yerleştirilir. 
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/select.h>

void exit_sys(const char *msg);

int main(int argc, char *argv[])    
{
    fd_set rset;
    int result;
    char buf[1024 + 1];
    ssize_t n;
    struct timeval tv;

    FD_ZERO(&rset);
    FD_SET(0, &rset);

    tv.tv_sec = 10;
    tv.tv_usec = 0;

    if ((result = select(1, &rset, NULL, NULL, &tv)) == -1)
        exit_sys("select");

    if (result == 0)
        printf("Timeout!\n");
    else {
        printf("result = %d\n", result);
        if ((n = read(0, buf, 1024)) == -1)
            exit_sys("read");
        buf[n] = '\0';
        printf("%s", buf);
        printf("Remaining time: %ld.%03ld\n", (long)tv.tv_sec, (long)tv.tv_usec / 1000);
    }
    
    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/*--------------------------------------------------------------------------------------------------------------------------
    select ile birden fazla betimleyiciyi izlerken bloke çözüldüğünde programcının hangi betimleyiciler dolayısıyla blokenin 
    çözüldüğünü belirlemesi gerekir. Bunun için FD_ISSET makrosu ile izlenen tüm betimleyiciler kontrol edilmelidir. Aslında
    bu kontrol yapılırken 0'dan FD_SETSIZE değerine kadar bile bir döngü kullanılabilir. Naısl olsa izlenmeyen tüm betimleyicilerin 
    bitleri 0 olacaktır. Tabii programcı döngüyü kısalmak için eğer betimleyicilerin numaralarını bir yerde saklamışsa yalnızca onu da sorgulayabilir.

    Aşağıdaki  birden fazla isimli borundan okuma yapmaya çalışan bir örnek bulunömaktadır. Boruların isimleri komut satırı
    argümanlarıyla verilmektedir. Bu isimli borular açılıp bunların betimleyicileri bir dizide saklanmıştır. select'in blokesi 
    çözüldüğünde hangi borularda okuma eyleminin yapılabileceği FD_ISSET le kontrol edilmiştir. Yazan taraf boruyu kapattığında
    bu da bir okuma eylemi gibi select'in blokesini çözer. Ancak bu durumda borudan 0 byte okunacaktır. Aşağıdaki uygulama için 
    önce isimli borular yaratıp farklı terminallerden bu boruları cat ile aşağıdaki gibi açınız.

    cat > boru ismi
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <fcntl.h>
#include <unistd.h>
#include <sys/select.h>

#define MAX_ARGS        32
#define BUFFER_SIZE     1024

void exit_sys(const char *msg);

int main(int argc, char *argv[])    
{
    int fds[MAX_ARGS];
    int i;
    fd_set rset, rset_o;
    char buf[BUFFER_SIZE + 1];
    ssize_t result;
    int maxfds, nfds;

    if (argc == 1) {
        fprintf(stderr, "too few arguments!..\n");
        exit(EXIT_FAILURE);
    }

    printf("waiting at open...\n");

    maxfds = 0;  
    nfds = 0;  
    FD_ZERO(&rset_o);
    for (i = 0; i < argc - 1; ++i) {
        if ((fds[i] = open(argv[i + 1], O_RDONLY)) == -1) 
            exit_sys("open");
        FD_SET(fds[i], &rset_o);
        if (fds[i] > maxfds)
            maxfds = fds[i];
        ++nfds;
    }
    printf("waiting at select...\n");
    for (;;) {
        rset = rset_o;
        if (select(maxfds + 1, &rset, NULL, NULL, NULL) == -1)
            exit_sys("select");
        for (i = 0; i < argc - 1; ++i)
            if (FD_ISSET(fds[i], &rset)) {
                if ((result = read(fds[i], buf, BUFFER_SIZE)) == -1)
                    exit_sys("read");
                if (!result) {
                    printf("pipe closing...\n");
                    FD_CLR(fds[i], &rset_o);
                    close(fds[i]);
                    --nfds;
                    if (!nfds)
                       goto EXIT;
                }

                buf[result] = '\0';
                printf("%s", buf);
            }
    }
EXIT:  
    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/*--------------------------------------------------------------------------------------------------------------------------
    Aşağıdaki örnekte ise boruların betimleyicileri bir dizide toplanmaıştır. 
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <fcntl.h>
#include <unistd.h>
#include <sys/select.h>

#define MAX_ARGS        32
#define BUFFER_SIZE     1024

void exit_sys(const char *msg);

int main(int argc, char *argv[])    
{
    int fd;
    fd_set rset, rset_o;
    char buf[BUFFER_SIZE + 1];
    ssize_t result;
    int maxfds, nfds;
    int i;

    if (argc == 1) {
        fprintf(stderr, "too few arguments!..\n");
        exit(EXIT_FAILURE);
    }

    printf("waiting at open...\n");

    maxfds = 0;  
    nfds = 0;  
    FD_ZERO(&rset_o);
    for (i = 0; i < argc - 1; ++i) {
        if ((fd = open(argv[i + 1], O_RDONLY)) == -1) 
            exit_sys("open");
        FD_SET(fd, &rset_o);
        if (fd > maxfds)
            maxfds = fd;
        ++nfds;
    }
    printf("waiting at select...\n");
    for (;;) {
        rset = rset_o;
        if (select(maxfds + 1, &rset, NULL, NULL, NULL) == -1)
            exit_sys("select");
        for (i = 0; i <= maxfds; ++i)
            if (FD_ISSET(i, &rset)) {
                if ((result = read(i, buf, BUFFER_SIZE)) == -1)
                    exit_sys("read");
                if (!result) {
                    printf("pipe closing...\n");
                    FD_CLR(i, &rset_o);
                    close(i);
                    --nfds;
                    if (!nfds)
                       goto EXIT;
                }

                buf[result] = '\0';
                printf("%s", buf);
            }
    }
EXIT:  
    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/*--------------------------------------------------------------------------------------------------------------------------
pselect fonksiyonu select fonksiyonun biraz daha gelişmiş bir versiyonudur. Prototipi şöyledir:
    
int pselect(int nfds, fd_set *readfds, fd_set *writefds, fd_set *errorfds, const struct timespec *timeout, const sigset_t *restrict sigmask);

Fonksiyonun select fonklsiyonundan yalnızca üç farkı vardır. Diğer bütün davranışı aynıdır. 

1) Zaman aşımı için timeval yapısı değil timespec yapısı kullanılmıştır. Bu da nanosaniye çözünürlük anlamına gelmektedir.
2) Fonksiyon bir "signal set" parametresine sahiptir. Biz istersek fonksiyon çalışana kadar belli sinyallerin bloke edilmesini sağlayabiliriz. 
Tabii bu parametreyi NULL da geçebiliriz. Fonksiyon sonlandığında otomatik olarak bu sinyaller prosesin sinyal mask kümesinden çıkarılmaktadır.
3) pselect fonksiyonunun zaman aşımı parametresi const biçimdedir. Yani fonksiyon tarafından günellenmemektedir. 

select ve pselect fonksiyonları eğer bloke edilmemişse ilgili sinyal oluştuğunda -1 ile geri döner ve errno EINTR ile set edilir. 
Bu fonksiyonlar "restartable" yapılamazlar.

---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    poll fonksiyonu amaç bakımından select fonksiyonuna çok benzemektedir. select ve poll aynı işi yapan farklı arayüzler biçiminde
    düşünülebilir. Eskiden select BSD sistemlerinde, poll ise AT&T UNIX sistemlerinde kullanılıyordu. Tabii uzun süredir bu iki
    fonksiyon da POSIX standartlarında bulunmaktadır. 

    int poll(struct pollfd fds[], nfds_t nfds, int timeout);

    poll fonksiyonu ilgilenilen betimleyicileri ve olayları tek tek bir yapı dizisi biçiminde bizden ister. Yani biz bir yapı dizisi
    oluşturup onun içini doldururuz. Sonra bu yapı dizisinin adresini poll fonksiyonuna veriririz. poll fonksiyonu da select fonksiyonunda
    olduğu gibi bu olayları blokede izler. Bu betimleyicilerden herhangi birinde bir olay olduğunda blokeyi çözer. Programcı da girdiği 
    diziyi kontrol ederek hangi olayşarın olduğunu anlayıp uygun işlemleri yaapar. Fonksiyonun timeout parametresi -1 girilirse zaman aşımı 
    ortadan kaldırılmaktadır. Bu parametre 0 girilirse fonksiyon betimleyicilerin durumlarına hemen bak��������p geri döner. Sıfır dışı değer
    milisaniye cinsinden zaman aşımı belirtmektedir. poll fonksiyonu başarısızlık durumunda -1 değerine, zaman aşımından dolayı sonlanmalarda 0 
    değerine ve normal sonlanmalarda ise olay gerçekleşen betimleyici sayısına geri dönmektedir. 

    poll ile izlenecek en önemli iki olay (events) POLLIN ve POLLOUT olaylarıdır. poll fonksiyonunun bize verdiği olaylar (revents) 
    ise tipik olarak şunlardan oluşmaktadır: POLLIN, POLLOUT, POLLERR, POLLHUP. POLLHUP boru, soket gibi aygıtlar kapatıldığında oluşur. 
    POLLERR ise borularda okuyan taraf botuyu kapattığında soketlerde ise soket kapatıldığında oluşmaktadır.
   
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <poll.h>

void exit_sys(const char *msg);

int main(int argc, char *argv[])    
{
    struct pollfd pfds[1];
    int result;
    char buf[1024 + 1];
    ssize_t n;

    pfds[0].fd = 0;
    pfds[0].events = POLLIN;

    if ((result = poll(pfds, 1, -1)) == -1)
        exit_sys("poll");

    printf("%d event(s) occurred\n", result);

    if (pfds[0].revents & POLLIN) {
        if ((n = read(0, buf, 1024)) == -1)
            exit_sys("read");
        buf[n] = '\0';
        printf("%s", buf);
    }

    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/*--------------------------------------------------------------------------------------------------------------------------
    Aşağıdaki programda birden fazla isimli boru ile poll fonksiyonu kullanılarak multiplexed IO işlemi yapılmıştır. 
    Programı çalıştırırken komut satırı argümanı olarak boru isimlerini giriniz. Girdiğiniz boruları  başka terminallerden
    cat > boru ismi komutu ile açınız. 
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <fcntl.h>
#include <unistd.h>
#include <poll.h>

#define MAX_ARGS        32
#define BUFFER_SIZE     1024

void exit_sys(const char *msg);

int main(int argc, char *argv[])    
{
    int i;
    int fd;
    char buf[BUFFER_SIZE + 1];
    int result;
    ssize_t n;
    int nfds;
    struct pollfd pfds[MAX_ARGS];

    if (argc == 1) {
        fprintf(stderr, "too few arguments!..\n");
        exit(EXIT_FAILURE);
    }

    printf("waiting at open...\n");

    nfds = 0;
    for (i = 0; i < argc - 1; ++i) {
        if ((fd = open(argv[i + 1], O_RDONLY)) == -1) 
            exit_sys("open");
        pfds[i].fd = fd;
        pfds[i].events = POLLIN;       
        ++nfds;
    }

    printf("waiting at poll...\n");
    for (;;) {
        if ((result = poll(pfds, nfds, -1)) == -1)
            exit_sys("poll");
        for (i = 0; i < nfds; ++i) {
            if (pfds[i].revents & POLLIN) {
                if ((n = read(pfds[i].fd, buf, BUFFER_SIZE)) == -1)
                    exit_sys("read");
                buf[n] = '\0';
                printf("%s", buf);
            }   
            else if if (pfds[i].revents & POLLHUP) {
                close(pfds[i].fd);
                --nfds;
                if (!nfds)
                    goto EXIT;

            }     
        }
    }
EXIT:  
    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/*--------------------------------------------------------------------------------------------------------------------------
    select fonksiyonunun sinyal blokesi yapan pselect biçiminde bir versiyonu vardı. İşte poll fonksiyonun da Linux sistemlerinde
    sinyal blokesi yapan ppoll isimli bir versiyonu vardır. Ancak pselect POSIX standartlarında bulunduğu halde ppoll bulunmamaktadır. 
    ppoll Linux'a özgüdür:

    int ppoll(struct pollfd *fds, nfds_t nfds, struct timespec *timeout_ts, const sigset_t *sigmask);
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    select ve poll fonksiyonları bazı sistemlerde yüksek performansla çalışabilmektedir. Ancak Linux'ta bu fonksiyonların izlediği 
    betimleyici sayısı arttıkça fonksiyonlar önemli bir yavaşlama içerisine girmektedir. Yani maalesef Linux sistemlerinde select ve poll
    fonksiyonları iyi biçimde ölçeklendirilmemiştir. İşte Linux'ta daha iyi ölçeklendirilmiş epoll isimli bir sistem fonksiyonu bulundurulmuştur. 
    Yüksek performans isteyen server programlar Linux'ta epoll sistemini tercih etmektedir. Tabii epoll POSIX standartlarında mevcut değildir. 
    Yalnızca Linux sistemlerinde bulunmaktadır. epoll sistemi şöyle kullanılmaktadır:

    1) Programcı önce epoll_create isimli fonksiyonla bir betimleyici elde eder. Bu etimleyicinin IO olaylarının izleneceği betimleyici ile
    bir ilgisi yoktur. Bu betimleyici diğer fonksiyonlara bir handle gibi geçirilmektedir:

    int epoll_create(int size);

    Fonksiyonun parametresi kaç betimleyiinin izlenileceğine yönelik bir ip ucu değeri alır. Programcı burada verdiği değerden daha fazla
    betimleyiciyi izleyebilir. Daha sonra bu parametre tasarımcıları rahatsız etmiş ve epoll_create1 isimli fonksiyonla kaldırılmıştır.

     int epoll_create1(int flags);

     Buradaki flags şimdilik yalnızca FD_CLOEXEC değerini ya da 0 değerini alabilmektedir. Fonksiyonların geri dönüş değeri
     başarı durumunda handle görevind eolan bir betimleyicidir. 

     2) Artık programcı izleyeceği betimleyicileri epoll sistemine epoll_ctl fonksiyonuyla ekler. Örneğin programcı 5 boru betimleyicisini
     izleyecekse bu 5 betimleiyici için de ayrı ayrı epoll_ctl çağrısı yapmalıdır. 

     int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event);

     Fonksiyonun birinci parametresi epoll_create ya da epoll_create1 fonksiyonundan elde edilen handle değeridir. İkinci parametre
     EPOLL_CTL_ADD, EPOLL_CTL_MOD, EPOLL_CTL_DEL değerlerinden birini alır. EPOLL_CTL_ADD ekleme için, EPOLL_CTL_DEL çıkarma için ve
     EPOLL_CTL_MOD mevcut eklenmiş betimleyicide izleme değişikliği yapmak için kullanılmaktadır. Üçücncü parametre izlenecek betimleyiciyi
     belirtir. Son parametre izlenecek olayı belirtmektedir. sturct epoll_event yapısı şöyle bildirilmiştir:

     struct epoll_event {
        uint32_t   events;      
        epoll_data_t data;        
     };

    Yapının events elemanı tıpkı poll fonksiyonunda olduğu gibi EPOLLIN, EPOLLOUT değerlerini almaktadır. Geri döndürülen
    olay da yine EPOLLIN, EPOLLOUT, EPOLLERR ve EPOLLHUP gibi olaylardır. Yapının data elemanı aslında çekirdek tarafından saklanıp
    epoll_wait fonksiyonu yoluyla bize geri verilmektedir. Bu eleman bir birlik biçiminde bildirilmiştir:

    typedef union epoll_data {
        void        *ptr;
        int          fd;
        uint32_t     u32;
        uint64_t     u64;
    } epoll_data_t;

    select ve poll fonksiyonları "düzey tetiklemeli (level triggered)" çalışmaktadır. epoll fonksiyonu da default durumda düzey tetiklemeli 
    çalışır. Ancak events parametresine bit or işlemi ile EPOLLET eklenirse o betimleyici için "kenar tetiklemeli (edge triggered)" mod kullanılır. 
    Düzey tetiklemeli mod demek (select, poll daki durum ve epoll'daki default durum) bir okuma ya da yazma olayı açılıp bloke çözüldüğünde
    programcı eğer okuma ya da yazma yapmayıp yeniden bu fonksiyonları çağrırsa bekleme yapılmayacak demektir. Yani örneğin biz select ya poll ile
    stdin dosyasını izliyorsak ve klavyeden bir giriş yapıldıysa bu fonksiyonlar blokeyi çözer. Fakat biz read ile okuma yapmazsak ve yeniden select ve poll
    fonksiyonlarını çağırırsak artık bloke oluşmaz. Halbuki kenar tetiklemeli modda biz okuma yapmasak bile yeni okuma eylemi oluşana kadar yine
     blokede kalırız.

    3) Asıl bekleme ve izleme işlemi epoll_wait fonksiyonu tarafından yapılmaktadır. Bu fonksiyon poll select ve poll fonksiyonu gibi 
    bloke oluşturur ve arka planda betimleyicileri izler. 

     int epoll_wait(int epfd, struct epoll_event *events, int maxevents, int timeout);

     Fonksiyonun birinci parametresi epoll_create ya da epoll_create1 fonksiyonundan elde edilmiş olan handle değeridir. İkinci 
     parametre oluşan olayların depolanacağı yapı dizisininadresidir. Biz bu yapının events elemanından oluşan olayın ne olduğunu 
     anlarız. Yapının data elemanı epoll_ctl sırasında verdiğimiz değeri belirtir. Bizim en azından epoll_ctl fonksiyonund ilgili 
     betimleyiciyi bu data elemanında girmiş olmamız gerekir. Fonksiyonun üçünccü paranetresi ikinci parametresiyle belirtilen dizinin 
     uzunluğudur. (Normal olarak bu dizinin eklenmiş olan betimleyici sayısı kadar olması gerekir. Ancak buradaki değer toplam izlenecek betimleyici
     asyısından az olabilir. Bu parametre tek en fazla hamlede kaç betimleyici hakkında bilgi verileceğini belirtmektedir.) Son parametre yine milisaniye cinsinden
     zaman aşımını belirtir. -1 değeri zaman aşımının kullanılmayacağını, 0 değeri hemen bakıp çıkılacağını belirtmektedir. Fonksiyon 
     başarı durumunda diziye doldurduğu eleman sayısı ile başarısızlık durumda -1 ile geri döner. Fonksiyon 0 değeri ile geri dönerse
     sonlanmanın zaman aşımından dolayı oluştuğu anlaşılır.

    Sistemin kapatılması için eopll_create ya da epoll_create1 ile elde edilen betimleyici kapatılabilir. 
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/epoll.h>

void exit_sys(const char *msg);

int main(int argc, char *argv[])    
{
    int epfd;
    struct epoll_event epe;
    struct epoll_event epe_out[1];
    int result;
    char buf[1024 + 1];
    ssize_t n;

    if ((epfd = epoll_create(1)) == -1)
        exit_sys("epoll_create");

    epe.events = EPOLLIN;
    epe.data.fd = STDIN_FILENO;
    if (epoll_ctl(epfd, EPOLL_CTL_ADD, STDIN_FILENO, &epe) == -1)
        exit_sys("epoll_ctl");

    printf("waiting stdin...\n");

    if ((result = epoll_wait(epfd, epe_out, 1, -1)) == -1)
        exit_sys("epoll_wait");

    if (epe_out[0].events & EPOLLIN) {
        if ((n = read(epe_out[0].data.fd, buf, 1024)) == -1)
            exit_sys("read");
        buf[n] = '\0';
        printf("%d event(s) occurred...\n", result);
        printf("%s", buf);
    }
    
    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/*--------------------------------------------------------------------------------------------------------------------------
    epoll sisteminde izlemek istediğimiz betimleyicileri ekledikten sonra bunları çıkarmamız gerekmez. Bu betimelyicilere 
    ilişkin dosyalar kapatıldığında zaten  ilgili betimleyici izlemeden otomatik olarak çıkartılmaktadır. 

    Aşağıdaki örnekte yine bu kez epoll sistemi ile isimli borularda multiplexed io uygulaması yapılmıştır. Yine bu programı
    komut satırı argümanı olarak isimli boruların yoli fadelerini vererek çalıştırınız. Diğer terminallerden boruları yazma 
    modunda cat > boru ismi biçiminde açınız. 
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <fcntl.h>
#include <unistd.h>
#include <sys/epoll.h>

#define MAX_ARGS        32
#define BUFFER_SIZE     1024

void exit_sys(const char *msg);

int main(int argc, char *argv[])    
{
    int epfd;
    struct epoll_event epe;
    struct epoll_event *epe_outs;
    int fd;
    char buf[BUFFER_SIZE + 1];
    int result;
    ssize_t n;
    int nfds;
    int i;

    if (argc == 1) {
        fprintf(stderr, "too few arguments!..\n");
        exit(EXIT_FAILURE);
    }

    if ((epfd = epoll_create(2)) == -1)
        exit_sys("epoll_create");

    printf("waiting at open...\n");

    nfds = 0;
    for (i = 0; i < argc - 1; ++i) {
        if ((fd = open(argv[i + 1], O_RDONLY)) == -1) 
            exit_sys("open");
        epe.events = EPOLLIN;
        epe.data.fd = fd;
        if (epoll_ctl(epfd, EPOLL_CTL_ADD, fd, &epe) == -1)
            exit_sys("epoll_ctl");
        ++nfds;
    }

    if ((epe_outs = (struct epoll_event *)malloc(nfds * sizeof(struct epoll_event))) == NULL)
        exit_sys("malloc");

    printf("waiting at epoll...\n");
    for (;;) {
        if ((result = epoll_wait(epfd, epe_outs, nfds, -1)) == -1)
            exit_sys("epoll_wait");
        for (i = 0; i < nfds; ++i) {
            if (epe_outs[i].events & EPOLLIN) {
                if ((n = read(epe_outs[i].data.fd, buf, BUFFER_SIZE)) == -1)
                    exit_sys("read");
                buf[n] = '\0';
                printf("%s", buf);
            }   
            else if (epe_outs[i].events & EPOLLHUP) {
                close(epe_outs[i].data.fd);
                --nfds;
                if (!nfds)
                    goto EXIT;
}     
        }
    }
EXIT:  
    free(epe_outs);

    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/*--------------------------------------------------------------------------------------------------------------------------
    Linux sistemlerinde epoll özel bir ihtimamla hazırlanmıştır. Bu nedenle epoll sistemi Linux'ta select ve poll fonksiyonlarından 
    oldukça hızlı çalışmaktadır. Pekiyi neden? Çünkü Linux çekirdeği dosya nesnesinin içerisinde bu işlem için alan ayırmıştır. 
    Biz bir betimleyiciyi izleme listesine epoll_ctl ile eklediğimizde çekirdek hemen onu ilgili bağlı listelere eklemektedir. 
    Sonra bu betimleyicide olay gerçekleştiğinde zaten bu betimleyiciyi zaten gerçekleşen olay listesine almaktadır. Yani sonuçta
    aslında betimleyicilerin çekirdek tarafından izlenmesine, gözden geçirilmesine gerek kalmamaktadır. İzlenen betimleyicilerin artması durumunda
    zaman kaybı "The Linux Programming Interface" kitabında 1365'inci sayfada verilmiştir:

    Number of descriptors monitored (N)     poll() CPU time (seconds)       select() CPU time (seconds)     epoll CPU time (seconds)
            10                                  0.61                                0.73                            0.41
            100                                 2.9                                 3.0                             0.42
            1000                                35                                  35                              0.53
            10000                               990                                 930                             0.66
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Signal Driven IO işleminde belli bir betimleyicide olay oluştupunda SIGIO isimli sinyal oluşturulmaktadır. Böylee programcı 
    bu oluştuğunda okuma/yazma işlemini yapabilmektedir. Ancak bu model Pgüncel POSIZ standartlarında bulunmamaktadır. Linux bu 
    modeli desteklemektedir. Bunun için sırasıyla şunlar yapılmalıdır:

    1) Betimleyici open fonksiyonuyla açılır.
    2) SIGIO sinyali için sinyal fonksiyonu set edilir. 
    3) Betimleyici üzerinde F_SETOWN komut koduyla fcntl uygulanır. Üçüncü parametreye sinyalin gönderileceği prosesin 
    ya da proses grubunun id'si girilmelidir. (Tabii genellikle programcı kendi prosesinin id'sini girer.)
    4) Betimleyici blokesiz moda sokulur ve aynı zamanda O_SYNC bayrağı da set edilir. Bu işlem fcntl fonksiyonunda F_SETFL komut 
    koduyla yapılabilmektedir. 

    fcntl(fd, F_SETFL, fcntl(fd, F_GETFL) | O_NONBLOCK | O_ASYNC);

    O_ASYNC byrağı POSIX standartlarında bulunmamaktadır. 

    Bu yöntemde ilgilenilen olay (yani read mi write mı) gizlice open fonksiyonundaki açış modunda belirtilmektedir. Yani örneğin 
    biz open fonksiyonunda dosyayı O_RDONLY modunda açarsak yalnızca okuma ilgilendiğimiz, O_WRONLY modunda açarsak yalnızca yazma ile ilgilendiğimiz,
    O_RDWR modunda açarsak hem okuma hem de yazma ile ilgilendiğimiz sonucu çıkar.

    5) Artık normal akışa devam eder. İlgilenilen olay gerçekleştiğinde sinyal oluşturulmaktadır.

    Signal driven IO "kenar tetiklemeli (edge triggered)" bir yöntemdir. Blokesiz okuma/yazma yapılabilecek bir durumda (örneğin okuma 
    durumunda boruya okunacak birşeyler gelmesi gibi) sinyal oluşur. Ancak okuma/yazma yapılmasa bile yeni bir benzer durum oluştuğunda
    yeniden sinyal oluşur. (Örneğin boruya bilgi geldiğinde sinyal oluşur. Biz borudan okuma yapmasak bile yeniden boruya bilgi gelirse
    yine sinyal oluşur. Halbuki select, poll böyle değildir. Anımsanacağı gibi epoll'da bu durum ayarlanabilemktedir.)

    Aşağıdaki programda yine borular komut satırı argümanlarıyla verilmektedir. Borular üzerinde okuma işlemi söz konusu olduğunda
    SIGIO sinyali oluşacaktır. Okuma işlemi sinyal içerisinde değil dışarıda yapılmıştır. Ancak sinyal fonksiyonunda bir bayrak set
    edilmiştir. Yazan taraf boruyu kapattığında da yine SIGIO sinyali oluşmaktadır. Tabii bu durumda yine read fonksiyonu blokeye 
    yol açmadan 0 ile geri dönecektir. Örnekte bekleme işleminin sigprocmask ve sigsuspend ile yapıldığına dikat ediniz. Bu tür 
    durumlarda pause kullanmak -puase öncesinde son bir sinyal gelirse- sorunlara yol açma potansiyelindedir. 

    Aslında istenirse sinyal fonksiyonu içerisinde hangi betimleyicide olay olduğu anlaşılabilir. Ama bunun için sigaction
    fonksiyounda flags parametresinin SA_SIGINFIO biçiminde geçilip siginfo_t parametreli sinyal fonksiyonun set edilmesi sağlanmalıdır. 
    Bu siginfot yapısında Linux'ta (POSIX'te yok) si_fd elemanı SIGIO oluşmasına yol açan dosya betimleyicisini bulundurmaktadır.

---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <errno.h>
#include <fcntl.h>
#include <unistd.h>
#include <signal.h>

#define MAX_ARGS        32
#define BUFFER_SIZE     1024

void sigio_handler(int sno);
void exit_sys(const char *msg);

int g_flag;

int main(int argc, char *argv[])    
{
    int nfds, nfds_open;
    int fds[MAX_ARGS];
    struct sigaction sa;
    sigset_t sm, osm;
    int i;
    ssize_t n;
    char buf[BUFFER_SIZE];
   
    if (argc == 1) {
        fprintf(stderr, "too few arguments!..\n");
        exit(EXIT_FAILURE);
    }

    sa.sa_handler = sigio_handler;
    sigemptyset(&sa.sa_mask);
    sa.sa_flags = SA_RESTART;

    if (sigaction(SIGIO, &sa, NULL) == -1)
        exit_sys("sigaction");

    nfds = 0;
    for (i = 0; i < argc - 1; ++i) {
        if ((fds[i] = open(argv[i + 1], O_RDONLY)) == -1) 
            exit_sys("open");
        if (fcntl(fds[i], F_SETOWN, getpid()) == -1)
            exit_sys("fcntl");
        if (fcntl(fds[i], F_SETFL, fcntl(fds[i], F_GETFL) | O_ASYNC|O_NONBLOCK) == -1)
            exit_sys("fcntl");
        ++nfds;
    }

    sigemptyset(&sm);
    sigaddset(&sm, SIGIO);
    if (sigprocmask(SIG_BLOCK, &sm, &osm) == -1)
        exit_sys("sigprocmask");

    nfds_open = nfds;
    printf("waiting at sigsuspend...\n");
    for (;;) {
        sigsuspend(&osm);
        if (g_flag) {
            for (i = 0; i < nfds; ++i) {
                if (fds[i] == -1)
                    continue;
                if ((n = read(fds[i], buf, BUFFER_SIZE)) == -1) {
                    if (errno == EAGAIN)
                        continue;
                    exit_sys("read");
                }
                if (n == 0) {
                    close(fds[i]);
                    fds[i] = -1;
                    --nfds_open;
                    if (nfds_open == 0)
                        goto EXIT;
                    continue;
                }
                buf[n] = '\0';
                printf("%s", buf);
            }
            
            g_flag = 0;
        }
    }

EXIT:
    return 0;
}

void sigio_handler(int sno)
{
    g_flag = 1;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/*--------------------------------------------------------------------------------------------------------------------------
    İleri Modellerinden biri de "Asenkron IO Modelidir". Bu modelde okuma/yazma gibi işlemler başlatılır ancak akış devam eder.
    İşlemler bittiğinde durum programcıya bir sinyal ya da fonksiyon çağrısı ile bildirilir. İşlemler tipik olarak şöyle
    yürütülmektedir. 

    1) Önce struct aiocb isimli bir yapı türünden nesne tanımlayıp içinin doldurulması gerekir. Yapı şu biçimdedir:

    struct aiocb {
        int             aio_fildes;     
        off_t           aio_offset;     
        volatile void  *aio_buf;       
        size_t          aio_nbytes;    
        int             aio_reqprio;    
        struct sigevent aio_sigevent;   
        int             aio_lio_opcode; 
    };

    Yapının aio_fildes elemanına okuma/yazma yapılmak istenen dosyaya ilişkin dosya betimleyicisi yerleştirilir. Asenkon okuma/yazma
    işlemleri dosya göstericisinin gösterdiği yerden itibaren yapılmamaktadır. Okuma/yazmanın dosyanın neresinden yapılacağı yapının 
    aio_offset elemanında belirtilir. (Eğer yazma durumu söz konusuysa ve dosya O_APPEND modda açıldıysa bu durumda aio_offset elemanının
    değeri dikkate alınmaz. Her yazılan dosyaya eklenir.) Yapının aio_buf elemanı transfer yapılacağı bellek adresini belirtir. Bu adresteki
    dizinin işlem sonlanana kadar yaşıyor durumda olması gerekmektedir. Yapının aio_nbytes elemanı okunacak ya da yazılacak byte miktarını
    belirtmektedir. Tabii burada belirtilen byte miktarı aslında aio_buf dizisinin uzunluğunu belirtmektedir. Yoksa bildirimde bulunulacak byte sayısını
    belirtmez. Yani örneğin asenkron biçimde bir borudan 100 byte okumak istesek bize "işlem bitti" bildirimi 100 byte okuduktan sonra gelmek 
    zorunda değildir. Daha az miktarda okuma olayı gerçekleşmişse de "işlem bitti bildirimi" yapılır. Tabii hiçbir zaman burada belirtilen 
    byte miktarından fazla okuma yazma yapılmayacaktır. Yapının aio_reprio elemanı ise okuma/yazma için bir öncelik derecesi belirtmektedir. 
    Yani bu değer yapılacak transferin önceliğine ilişkin bir ip ucu belirtir. Ancak işletim sisteminin bu ipucunu kullanıp kullanmayacağı 
    isteğe bağlı bırakılmıştır. Bu eleman 0 geçilebilir. Yapının aio_sigevent elemanı işlem bittiğinde yapılacak bildirim hakkında bilgileri 
    barındırmaktadır. Bu sigevent yapısını daha önce görmüştük. Şöyleydi:

      struct sigevent {
           int          sigev_notify; 
           int          sigev_signo;  
           union sigval sigev_value;  
           void       (*sigev_notify_function) (union sigval);
           void        *sigev_notify_attributes;
       };

    Bu yapının sigev_notify elemanı bildirimin türünü belirtir. Bu tür SIGEV_NONE, SIGEV_SIGNAL, SIGEV_THREAD biçiminde olabilir. 
    Yapının sigev_signo elemanı ise eğer sinyal yoluyla bildirimde bulunulacaksa sinyalin numrasını belirtmektedir. Yapının sigev_value
    elemanı sinyal fonksiyonuna ya d athread fonksiyonuna gönderilecek kulanıcı tanımlı bilgiyi temsil etmektedir. Yapının sigev_notify_function
    elemanı eğer bildirim thread yoluyla yapılacaksa işletim sistemi tarafından yaratılan thread'in çağıracağı fonksiyonu 
    belirtmektedir. Yapının sigev_notify_attributes elemanı ise yaratılacak thread'in özelliklerini belirtir. Bu parametre NULL geçilebilir. 
    
    2) Şimdi okuma ya da yazma olayını aio_read ya da aio_write fonksiyonuyla başlatmak gerekir. Artık akış bu fonksiyonlarda bloke olmayacak
    fakat işlem bitince bize bildirimde bulunulacaktır. 

    int aio_read(struct aiocb *aiocbp);
    int aio_write(struct aiocb *aiocbp);

    Fonksiyonlar başarı durumunda 0 başarısızlık durumunbda -1 değerine geri dönmektedir. İşlemlerin devam ettiğine yani henüz sonlanmadığına
    dikkat ediniz. Bu fonksiyonlara verdiğimiz aiocb yapılarının işlem tamamlanana kadar yaşıyor olması gerekir. Yani fonksiyon bizim verdiğimiz
    aicb yapısını çalışırken kullanıyor olabilir. 

    3) Anımsanacağı gibi biz aiocb yapısının aio_nbytes elemanına maksimum okuma/yazma miktarını vermiştik. Halbuki bundan daha az okuma/yazma
    yapılması mümkündür. Pekiyi bize bildirimde bulunulduğunda ne kadar miktarda bilginin okunmuş ya da yazılmış olduğunu nasıl anlayacağız?
    İşte bunun için aio_result isimli fonksiyon kullanılmaktadır:

    ssize_t aio_return(struct aiocb *aiocbp);

    Fonksiyon başarı durumunda transfer edilen byte sayısına başarısızlık durumunda -1'e geri dönmektedir. Eğer bildirim gelmeden
    bu fonksion çağrılırsa geri dönüş değeri anlamlı olmayabilir. aio_read ve aio_write fonksiyonları sinyal güvenli değildir ancak
    aio-Return ve aio_error fonksiyonları sinyal güvenlidir. 

    Aşağıdaki programda stdin dosyasından asenkron bir biçimde okuma yapımıştır. Her aio_read için okuma yeniden başlatılmış ve
    bildirim olarak SIGSUR1 sinyali seçilmiştir. Ana program beklemeyi pause ile değil sigprocmask ve sigsuspend fonksiyonları ile 
    yapmaktadır. Sinyal fonksiyonunda yalnızca bir bayrak set edilmiş asıl işlem dışarıda yapılmıştır. Sinyal fonksiyonun içerisinde
    aio_return yapılabilir (abii bunun için aiocb yapı nesnesinin global alınması gerekir) ancak maalesef işlemin devam ettirilmesi 
    için aio_read yapılamaz. Çünkü aiored sinyal güvenli değildir. (Tabii bildirim olarak sinyal yerine thread yöntemi kullanılırsa
    artık thread fonksiyonun içerisinde yeniden aio_read işlemi yapılabilmektedir.)
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <signal.h>
#include <aio.h>

void sigusr1_handler(int sno);
void exit_sys(const char *msg);

char g_buf[1024 + 1];
int g_flag;

int main(void)    
{
    struct aiocb cb;
    struct sigaction sa;
    ssize_t size;
    sigset_t sm, osm;

    sa.sa_handler = sigusr1_handler;
    sigemptyset(&sa.sa_mask);
    sa.sa_flags = 0;

    if (sigaction(SIGUSR1, &sa, NULL) == -1)
        exit_sys("siagaction");

    cb.aio_fildes = 0;       /* stdin */
    cb.aio_offset = 0;       /* stdin ve pipe için 0 vermek gerekir */
    cb.aio_nbytes = 1024;
    cb.aio_buf = g_buf;
    cb.aio_reqprio = 0;
    cb.aio_sigevent.sigev_notify = SIGEV_SIGNAL;
    cb.aio_sigevent.sigev_signo = SIGUSR1;
    cb.aio_sigevent.sigev_value.sival_int = 0;

    sigemptyset(&sm);
    sigaddset(&sm, SIGUSR1);

    if (sigprocmask(SIG_BLOCK, &sm, &osm) == -1)
        exit_sys("sigprocmask");

    if (aio_read(&cb) == -1) 
        exit_sys("aio_read");

    for (;;) {
        sigsuspend(&osm);
                        
        if (g_flag) {
            if ((size = aio_return(&cb)) == -1)
                exit_sys("aio_return");
            g_buf[size] = '\0';
            if (!strcmp(g_buf, "quit\n"))
                break;
            printf("%s", g_buf);
            g_flag = 0;
            if (aio_read(&cb) == -1) 
                exit_sys("aio_read");
        }
    }

    return 0;
}

void sigusr1_handler(int sno)
{
    g_flag = 1;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/*--------------------------------------------------------------------------------------------------------------------------
    Yukarıdaki örnekte bekleme işlemi bir senkronizasyon sorunuı oluşmasın diye sigprocmask ve sigsuspend fonksiyonları yardımıyla
    yapılmıştır. Aslında bunun yerine istenirse aio_suspend isimli fonlsiyondan da faydalanılabilir. 

    int aio_suspend(const struct aiocb *const list[], int nent, const struct timespec *timeout);

    Fonksiyonun birinci paramtresi beklenecek asenkron olayara ilişkin aiocb yapılarının bulunduğu dizinin adresini almaktadır. 
    Yani fonksiyon aslında birden fazla olayı bekleyebilmektedir. İkinci parametre birinci parametredeki dizinin uzunluğunu belirtir. 
    Son parametre zaman aşımı belirtmektedir. NULL geçilirse zaman aşımı kullanılmaz. Fonksiyon başarı durumunda 0, başarısılık durumunda
    (yani zaman aşımı ya da sinyal oluşma durumunda) -1'e geri dönmektedir. Geri dönüş değerinin kontrol edilmesine genellikle gerek olmaz. 
    aio_suspend fonksiyonu eğer başlatılan io olayı sona ermişse hiç bloke oluşturmamaktadır. (Halbuki örneğin pause fonksiyonu yalnızca sinyal
    oluştuğunda geri dönmektedir.)

    Şimdi yukarıdaki programı sigprocmask ve sigsuspend yerine aio_suspend ile yeniden deneyelim.
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <signal.h>
#include <aio.h>

void sigusr1_handler(int sno);
void exit_sys(const char *msg);

char g_buf[1024 + 1];
int g_flag;

int main(void)    
{
    struct aiocb cb;
    const struct aiocb *pcb;
    struct sigaction sa;
    ssize_t size;

    sa.sa_handler = sigusr1_handler;
    sigemptyset(&sa.sa_mask);
    sa.sa_flags = 0;

    if (sigaction(SIGUSR1, &sa, NULL) == -1)
        exit_sys("siagaction");

    cb.aio_fildes = 0;       /* stdin */
    cb.aio_offset = 0;       /* stdin ve pipe için 0 vermek gerekir */
    cb.aio_nbytes = 1024;
    cb.aio_buf = g_buf;
    cb.aio_reqprio = 0;
    cb.aio_sigevent.sigev_notify = SIGEV_SIGNAL;
    cb.aio_sigevent.sigev_signo = SIGUSR1;
    cb.aio_sigevent.sigev_value.sival_int = 0;

    if (aio_read(&cb) == -1) 
        exit_sys("aio_read");

    pcb = &cb;
    for (;;) {
        aio_suspend(&pcb, 1, NULL);
                        
        if (g_flag) {
            if ((size = aio_return(&cb)) == -1)
                exit_sys("aio_return");
            g_buf[size] = '\0';
            if (!strcmp(g_buf, "quit\n"))
                break;
            printf("%s", g_buf);
            g_flag = 0;
            if (aio_read(&cb) == -1) 
                exit_sys("aio_read");     
        }
    }

    return 0;
}

void sigusr1_handler(int sno)
{
    g_flag = 1;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/*--------------------------------------------------------------------------------------------------------------------------
    aio_read ya da aio_write fonksiyonlarınde belirtilen işlem bittiğinde istenirse sigevent yapısı yoluyla bildirim biçimi
    SIGEV_THREAD seçilebilir. Bu durumda işlem bittiğinde işletim sistemi tarafından bir thread yaratılacak ve o thread akışı tarafından
    belirlenen fonksiyon çağrılacaktır. İşlemlerin devam ettirilmesi bu thread fonksiyonu tarafından yapılabilir. 

    Aşağıdaki örnekte program komut argümanlarıyla fifo dosyalarının yol ifadelerini almaktadır. Bunları asenkron io yöntemiyle okumaktadır. 
    Her io olayı bittiğinde belirlenen fonksiyon çağrılmış ve okunan bilgiler ekrana yazdırılmıştır. Bu programda struct aiocb yapısınun
    ve transfer alanının (buffer'ın) bir yapıda tutulduğuna dikkat ediniz. Bu teknik bu tür durumlarda sık kullanılmaktadır. 
    Çünkü bazen (özellikle soket uygulamalarında) programcı tampon alanda biriktirme yapıp birikmiş olan bilgiyi işleme sokmak isteyebilir. 
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <fcntl.h>
#include <unistd.h>
#include <aio.h>

#define MAX_ARGS        32
#define BUFFER_SIZE     102

void read_completion_proc(union sigval val);
void exit_sys(const char *msg);

typedef struct  {
    struct aiocb cb;
    char buf[BUFFER_SIZE + 1];
} IOCB_BUF;

int main(int argc, char *argv[])    
{
    int nfds;
    int fds[MAX_ARGS];
    IOCB_BUF *cbbufs[MAX_ARGS];
    int i;
       
    if (argc == 1) {
        fprintf(stderr, "too few arguments!..\n");
        exit(EXIT_FAILURE);
    }

    printf("waiting for pipe to be opened...\n");
    nfds = 0;
    for (i = 0; i < argc - 1; ++i) {
        if ((fds[i] = open(argv[i + 1], O_RDONLY)) == -1) 
            exit_sys("open");
        
        if ((cbbufs[i] = (IOCB_BUF *)calloc(1, sizeof(IOCB_BUF))) == NULL)
            exit_sys("calloc");
        
        cbbufs[i]->cb.aio_fildes = fds[i];
        cbbufs[i]->cb.aio_offset = 0;
        cbbufs[i]->cb.aio_buf = cbbufs[i]->buf;
        cbbufs[i]->cb.aio_nbytes = BUFFER_SIZE;
        cbbufs[i]->cb.aio_reqprio = 0;
        cbbufs[i]->cb.aio_sigevent.sigev_notify = SIGEV_THREAD;
        cbbufs[i]->cb.aio_sigevent.sigev_value.sival_ptr = cbbufs[i];
        cbbufs[i]->cb.aio_sigevent.sigev_notify_function = read_completion_proc;

        if (aio_read(&cbbufs[i]->cb) == -1)
            exit_sys("aio_read");

        ++nfds;
    }
    
    printf("waiting at getchar...\n");
    getchar();

    for (i = 0; i < nfds; ++i) {
        close(cbbufs[i]->cb.aio_fildes);
        free(cbbufs[i]);
    }

    return 0;
}

void read_completion_proc(union sigval val)
{
    IOCB_BUF *cbbuf = (IOCB_BUF *)val.sival_ptr;
    ssize_t n;

    if ((n = aio_return(&cbbuf->cb)) == -1)
        exit_sys("aio_return");

    if (n == 0) {
        printf("closing pipe...\n");
        return;
    }

    cbbuf->buf[n] = '\0';
    printf("%s", cbbuf->buf);

    if (aio_read(&cbbuf->cb) == -1)
        exit_sys("aio_read");
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/*--------------------------------------------------------------------------------------------------------------------------
    Yukarıdaki program şöyle de düzenlenebilirdi
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <fcntl.h>
#include <unistd.h>
#include <aio.h>

#define MAX_ARGS        32
#define BUFFER_SIZE     102

void read_completion_proc(union sigval val);
void exit_sys(const char *msg);

typedef struct  {
    struct aiocb cb;
    char buf[BUFFER_SIZE + 1];
} IOCB_BUF;

int main(int argc, char *argv[])    
{
    int fds[MAX_ARGS];
    IOCB_BUF *cbbuf;
    int i;
       
    if (argc == 1) {
        fprintf(stderr, "too few arguments!..\n");
        exit(EXIT_FAILURE);
    }

    printf("waiting for pipe to be opened...\n");
    for (i = 0; i < argc - 1; ++i) {
        if ((fds[i] = open(argv[i + 1], O_RDONLY)) == -1) 
            exit_sys("open");
        
        if ((cbbuf = (IOCB_BUF *)calloc(1, sizeof(IOCB_BUF))) == NULL)
            exit_sys("malloc");
        
        cbbuf->cb.aio_fildes = fds[i];
        cbbuf->cb.aio_offset = 0;
        cbbuf->cb.aio_buf = cbbuf->buf;
        cbbuf->cb.aio_nbytes = BUFFER_SIZE;
        cbbuf->cb.aio_reqprio = 0;
        cbbuf->cb.aio_sigevent.sigev_notify = SIGEV_THREAD;
        cbbuf->cb.aio_sigevent.sigev_value.sival_ptr = cbbuf;
        cbbuf->cb.aio_sigevent.sigev_notify_function = read_completion_proc;

        if (aio_read(&cbbuf->cb) == -1)
            exit_sys("aio_read");
    }
    
    printf("waiting at getchar...\n");
   
    getchar();

    return 0;
}

void read_completion_proc(union sigval val)
{
    IOCB_BUF *cbbuf = (IOCB_BUF *)val.sival_ptr;
    ssize_t n;

    if ((n = aio_return(&cbbuf->cb)) == -1)
        exit_sys("aio_return");

    if (n == 0) {
        close(cbbuf->cb.aio_fildes);
        free(cbbuf);
        return;
    }

    cbbuf->buf[n] = '\0';
    printf("%s", cbbuf->buf);

    if (aio_read(&cbbuf->cb) == -1)
        exit_sys("aio_read");
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/*--------------------------------------------------------------------------------------------------------------------------
    Bu tür uygulamalarda (aslında multiplexed io da böyle) programcı önce biriktirme yapıp sonra belli bir tampon dolduğunda 
    biriktirdiklerini işleme sokmak isteyebilir. Bu tür isteklerle özellikle soket uygulamalarda çok karşılaşılmaktadır. 
    Aşağıda bu biçimde biriktirerek işleme sokmaya yönelik bir örnek verilmiştir
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <fcntl.h>
#include <unistd.h>
#include <aio.h>

#define MAX_ARGS        32
#define MSG_SIZE        10

void read_completion_proc(union sigval val);
void exit_sys(const char *msg);

typedef struct  {
    struct aiocb cb;
    char buf[MSG_SIZE + 1];
    size_t index;
    size_t left;
} IOCB_BUF;

int main(int argc, char *argv[])    
{
    int fds[MAX_ARGS];
    IOCB_BUF *cbbuf;
    int i;
       
    if (argc == 1) {
        fprintf(stderr, "too few arguments!..\n");
        exit(EXIT_FAILURE);
    }

    printf("waiting for pipe to be opened...\n");
    for (i = 0; i < argc - 1; ++i) {
        if ((fds[i] = open(argv[i + 1], O_RDONLY)) == -1) 
            exit_sys("open");
        
        if ((cbbuf = (IOCB_BUF *)calloc(1, sizeof(IOCB_BUF))) == NULL)
            exit_sys("malloc");
        
        cbbuf->index = 0;
        cbbuf->left = MSG_SIZE;
        cbbuf->cb.aio_fildes = fds[i];
        cbbuf->cb.aio_offset = 0;
        cbbuf->cb.aio_buf = cbbuf->buf;
        cbbuf->cb.aio_nbytes = MSG_SIZE;
        cbbuf->cb.aio_reqprio = 0;
        cbbuf->cb.aio_sigevent.sigev_notify = SIGEV_THREAD;
        cbbuf->cb.aio_sigevent.sigev_value.sival_ptr = cbbuf;
        cbbuf->cb.aio_sigevent.sigev_notify_function = read_completion_proc;

        if (aio_read(&cbbuf->cb) == -1)
            exit_sys("aio_read");
    }
    
    printf("waiting at getchar...\n");
   
    getchar();

    return 0;
}

void read_completion_proc(union sigval val)
{
    IOCB_BUF *cbbuf = (IOCB_BUF *)val.sival_ptr;
    ssize_t n;

    if ((n = aio_return(&cbbuf->cb)) == -1)
        exit_sys("aio_return");

    if (n == 0) {
        close(cbbuf->cb.aio_fildes);
        free(cbbuf);
        return;
    }

    cbbuf->index += n;
    cbbuf->left -= n;
   
    if (cbbuf->left == 0) {
        cbbuf->buf[MSG_SIZE] = '\0';
        printf("Buffer filled: %s\n", cbbuf->buf);
        cbbuf->index = 0;
        cbbuf->left = MSG_SIZE;
    }
    
    cbbuf->cb.aio_nbytes = cbbuf->left;
    cbbuf->cb.aio_buf = cbbuf->buf + cbbuf->index;   
    if (aio_read(&cbbuf->cb) == -1)
            exit_sys("aio_read");
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/*--------------------------------------------------------------------------------------------------------------------------
    aio_error isimli fonksiyon herhangi bir durumda başlatılan işlemin akibeti konusunda bilgi almak için kullanılabilir. 
    
    int aio_error(const struct aiocb *aiocbp);

    Fonksiyonun geri dönüş değeri bu asenkron işlemin o anda ne durumda olduğu hakkında bize bilgi verir. Eğer fonksiyon 
    EINPROGRESS değerine geri dönerse işlemin hala devam ettiği anlamı çıkar. Geri dönüş değeri ECANCELED ise bu durumda 
    işlem aio_cancel fonksiyonuyla iptal edilmiştir. Fonksiyon errno değerini set etmez. Geri dönüş değeri diğer pozitif değerlerden birisi
    ise hata ile ilgili başka bir errno değerini belirtir. Fonksiyon işlem başarılı bir biçimde işlem bitmişse 0
    değerine geri döner. 
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    aio_cancel fonksiyonu ise başlatılmış olan bir işlemi iptal etmek için kullanılmaktadır. 

    
    int aio_cancel(int fd, struct aiocb *aiocbp);

    Fonksiyonun birinci parametresi iptal edilecek betimleyiciyi beelirtir. Eğer iocb NULL geçilirse bu betimleyiciye lişkin 
    bütün asenkron işlemler iptal edilmektedir.         

    Fonksiyon AIO_CANCELED değerine geri dönerse iptal başarılıdır. AIO_NOTCANCELED değerine geri dönerse işlem aktif biçimde 
    devam etmekte olduğu için iptal başarısızdır. AIO_ALLDONE değeri ise işlemin zaten bittiğini belirtir. Fonksiyon başarıszlık 
    durumunda -1 değerine geri döner. 
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Pek çok uygulamada değişik adreslerdeki bilgilerin peşi sıraya dosyaya yazılması ya da ters olarak okunması gerekebilmektedir. 
    Örneğin bir kaydı temsil eden aşağıdaki üç bilginin birbiri ardına dosyaya yazılmak istendiğini düşünelim:

    int record_len;
    char record[RECORD_SIZE];
    int record_no;

    Bu bilgilerin dosyaya yazılması için normal olarak üç ayrı write işlemi yapmak gerekir:

    if (write(fd, &record_len, sizeof(int)) != sizeof(int)) {
        ...
    }

    if (write(fd, record, RECORD_SIZE) != RECORD_SIZE) {
        ...
    }

    if (write(fd, &record_no, sizeof(int)) != sizeof(int)) {
        ...
    }

    üç write işlemi göreli bir zaman kaybı oluşturabilmektedir. Tabii zaman kaybı uygulamaların ancak çok azında önem oluşturur.
    Buradaki zaman kaybının en önemli nedeni her write çağrısının kernel mode'a geöçiş yapmasıdır. Eğer bu zaman kaybını aşağı çekmek
    istiyorsak ilk gelen yöntem önce bu bilgileri başka bir tampona kopyalayıp tek bir write işlemi yapmaktır:

    char buf[BUFSIZE];

    memcpy(buf, &recordlen, sizeof(int));
    memcpy(buf + sizeof(int), record, BUFSIZE);
    memcpy(buf + sizeof(int) + BUFIZE, &record_no, sizeof(int));

    if (write(fd, buf, 2 * sizeof(int) + BUFSIZE) != 2 * sizeof(int) + BUFSIZE) {
        ....
    }

    Bu işlem üç ayrı write işlemine göre oldukça hızlıdır. işte readv ve writev isimli fonksiyonlar farklı adreslerdeki bilgileri 
    yukarıdakine benzer biçimde dosyaya yazıp dosyadan okumaktadır. Bu işlemlere İngilizce "scatter/gather IO" denilmektedir. readv ve 
    writev fonksşyonlarınınj prototipleri şöyledir:

    ssize_t readv(int fildes, const struct iovec *iov, int iovcnt); 
    ssize_t writev(int fildes, const struct iovec *iov, int iovcnt);

    Fonskiyonların birinci parametreleri okuma ya da yazma işlemiin yapılacağı dosya betimleyicisini, ikinci parametreleri kullanılacak
    tampon uzunluğun belirtildiği yapı dizisinin adresini, üçüncü parametresi de bu dizinin uzunluğunu belirtir. Programcı struct iovec
    türünden bir yapı dizisi oluşturuğ onun içini doldurmalıdır.   Geri dönüş değeri başarısızlık durumunda -1, diğer durumlarda okunan yazılan 
    byte miktarıdır. Okuma ve yazma işlemleri tek parça haline atomik biçimde yapılmaktadır. iovec yapısı şöyle bildirilmiştir:

    struct iovec {
        void  *iov_base;    
        size_t iov_len;     
    };

    Aşağıdaki programda üç ayrı adresteki yazılar peşi sıra tek bir writev çağrısı ile dosyaya yazdırılmıştır.
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <fcntl.h>
#include <sys/stat.h>
#include <unistd.h>
#include <sys/uio.h>

#define BUFFER_SIZE      10

void exit_sys(const char *msg);

int main(void)    
{
    int fd;
    char *buf1[BUFFER_SIZE];
    char *buf2[BUFFER_SIZE];
    char *buf3[BUFFER_SIZE];
    struct iovec vec[3];

    if ((fd = open("test.dat", O_WRONLY|O_CREAT|O_TRUNC, S_IRUSR|S_IWUSR|S_IRGRP|S_IROTH)) == -1)
        exit_sys("open");

    memset(buf1, 'a', BUFFER_SIZE);
    memset(buf2, 'b', BUFFER_SIZE);
    memset(buf3, 'c', BUFFER_SIZE);

    vec[0].iov_base = buf1;
    vec[0].iov_len = BUFFER_SIZE;

    vec[1].iov_base = buf2;
    vec[1].iov_len = BUFFER_SIZE;

    vec[2].iov_base = buf3;
    vec[2].iov_len = BUFFER_SIZE;

    if (writev(fd, vec, 3) == -1)
        exit_sys("writev");

    close(fd);

    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/*--------------------------------------------------------------------------------------------------------------------------
    Aşağıdaki programda da readv kullanılarak yukarıdaki işlemin tersi yapılmıştır
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <fcntl.h>
#include <unistd.h>
#include <sys/uio.h>

#define BUFFER_SIZE      10

void exit_sys(const char *msg);

int main(void)    
{
    int fd;
    char *buf1[BUFFER_SIZE];
    char *buf2[BUFFER_SIZE];
    char *buf3[BUFFER_SIZE];
    struct iovec vec[3];

    if ((fd = open("test.dat", O_RDONLY)) == -1)
        exit_sys("open");

    vec[0].iov_base = buf1;
    vec[0].iov_len = BUFFER_SIZE;

    vec[1].iov_base = buf2;
    vec[1].iov_len = BUFFER_SIZE;

    vec[2].iov_base = buf3;
    vec[2].iov_len = BUFFER_SIZE;

    if (readv(fd, vec, 3) == -1)
        exit_sys("writev");

    write(1, buf1, BUFFER_SIZE);
    write(1, buf2, BUFFER_SIZE);
    write(1, buf3, BUFFER_SIZE);

    close(fd);

    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/*--------------------------------------------------------------------------------------------------------------------------
    Arka planda sessiz sedasız çalışan bir kullanıcı arayüzü olmayan, kullanıcılarla etkileşmeyen programlara Windows dünyasında
    "service" UNIX/Linux dünyasında "daemon" denilmektedir. Servisler ya da daemon'lar tipik olarak boo sırasında çlışmaya başlatılırlar
    ve yine tipik olarak makine rebbot edilene kadar çalışmaya devam ederler. Tabii böyle bir zorunluluk yoktur. Servis ya da "daemon"
    kernel mod bir kavram değildir. Yani servisler ve daemon'lar genellikle "user mode"da yazılırlar. UNIX/Linux dünyasında geleneksel 
    olarak "daemon"lar xxxxxd biçiminde sonuna 'd' harfi getirilerek isimlendirilmektedir. Çekirdeğe ilişkin bazı thread'ler de servis
    benzeri işlemler yaptıkları için bunlar da çoğu kez sonu 'd' ile bitecek ancak başı da 'k' ile başlayacak biçimde isimlendirilmiştir. 
    Bu kernel daemon'ların bizim şu andaki konumuz olan daemnon'larla hiçbir ilgisi yoktur. Yalnızca işlev bakımından bir benzerlikleri vardır. 
    UNIX/Linux dünyasında daemon dendiğinde akla tabii ki "server programlar" gelir. Örneğin ftp server programının ismi "ftpd" biçiminde 
    olabilir. Ya da örneğin HTTP server programının ismi "httpd" biçiminde olabilir. 

    daemon'lar genellikle arka planda önemli işlemler yaptıkları için "root (process id 0)" hakkıyla (yani sudo ile) çalıştırılırlar. Daemon programlar
    pek çok modern UNIX/Linux sisteminde init paketleri içerisindeki özel utility'ler tarafından başlaıtlıp, surdurulup sonlandırılmaktadır.
    Yani ilgili dağıtımın bu dameon'ları idare etmek için özel komutları bulunabilmektedir. Linux sistemlerinde init prosesi ve diğer proseslerin
    kodları ve boot süreci ile ilgili utility'ler "init paketleri" denilen ve farklı proje grupları tarafından oluşturulmuştur. Ve tipik olarak
    bugüne kadar yaygın 3 init paketi kullanılmıştır:

    1) sysvinit: Klasik System5'teki işlevleri yapan init paketi. Linux uzun bir süre bu paketi kullanmıştır.
    2) Upstart: 2006 yılında oluşturulmuştur ve 2010'ların ortalarına kadar (bazı dağtımlarda hala) kullanılmaya devam edilmiştir.
    3) systemd: 2010 yılında oluşturulmuştur ve son yıllarda pek çok Linux dağıtımında kullanılmaya başlanmıştır.

    Bir daemon programın yazılması tipik olarak şu aşamalardan geçilerek yapılmaktadır:

    1) Deamon programlar bir dosya açmak istediklerinde tam olarak belirlenen haklarla bunu yapmalıdırlar. Bu nedenle bu proseslerin
    umask değerlerinin 0 yapılması uygun olur.

    2) Bir prosesin deamon etkisi yaratması için terminalle bir bağlantısının kalmaması gerekir. Bu maalesef 0, 1, 2 numaralı terminal
    betimleyicilerinin kapatılmasıyla sağlanamaz. Bunu sağlamanın en temel yolu setsid fonksiyonunu çağırmaktır. Anımsanacağı gibi
    setsid fonksiyonu yeni bir oturum (session) ve yeni bir proses grubu oluşturup lgili prosesi bu proses grubunun ve oturumun lideri 
    yapmaktadır. Ayrıca setsid fonksiyonu prosesin terminal ilişkisini (controlling terminal) de ortadan kaldırmaktadır. Ancak setsid uygulayabilmek
    için prosesin herhangi bir proses grup lideri olmaması gerekir. Aksi takdirde setsid fonksiyonu başarısız olmaktadır. Anımsanacağı gibi 
    kabuk programlar çalıştırdıkları programlar için bir proses grubu yaratıp o programı da proses grup lideri yapıyordu. İşte proses grup
    lideri olmaktan kurtulmak için bir kez fork yapıp üst prosesi sonlandırabiliriz. Aynı zamanda bu işlem kabuk programının hemen komut 
    satırına yeniden düşmesine yol açacaktır. O halde 2'inci aşamada fork işlemi yapılıp üst proses sonlandırılmalıdır. Bilindiği gibi 
    terminale bağlı programları kabukta  çalıştırdığımızda yeniden komut satırına düşsek bile kabuk programları kapatıldığında bu programlar 
    da sonlandırılmaktadır. Yani örneğin biz terminal ilişkisini kesmezsek bir kez fork yapıp alt proses arka planda çalışır gibi olur ancak 
    bu durumda terminal kapatıldığında o alt proses de sanlandırılır.  

    3) Artık alt proses setsid fonksiyonunu uygulayarak yeni bir oturum yaratır ve terminal ilişkisini keser. Terminal ilişkisinin kesilmesi
    ile artık terminal kapatılsa bile programımız çalışmaya devam eder. Tabii setsid ile terminal bağlantısının kesilmiş olması programın
    terminale bir şey yazamayacağı anlamına gelmez. Hala 0, 1, 2 numaralı betimleyiciler açıktır. Terminal açık olduğu sürece oraya yazma
    yapılabilir. 

    4) Daemon programların çalışma dizinlerinin (current working directory) sağlam bir dizin olması tavsiye eidlir. Aksi takdirde 
    o dizin silinirse arka plan bu programların çalışmaları bozulur. Bu nedenle daemon programların çoğu kök dizini (silinemeyeceği için) 
    çalışma dizini yapmaktadır. Tabii bu zorunlu değildir. Bunun yerine varlığı garanti edilmiş olan herhangi bir dizin de çalışma 
    dizini yapılabilir. 

    5) Daemon programın o ana kadar açılmış olan tüm betimleyicileri kapatması uygun olur. Örneğin 0, 1, 2 numaralı betimleyiciler
    ilgili terminale ilişkindir ve artık o terminal kapatılmış ya da kapatılacak olabilir. Program kendini daemon yaptığı 
    sırada açmış olduğu diğer dosyaları da kapatmalıdır. Bunu sağlamanın basit bir yolu prosesin toplam dosya betimleyici tablosunun 
    uzunluğunu elde edip her bir betimleyici için close işlemi uygulamaktır. Çünkü maalesef biz açık betimleyicileri pratik bir 
    biçimde tespit edememekteyiz. Zaten kapalı bir betimleyiciye close uygulanırsa close başarısz olur ancak program çökmez. 
    Prosesin toplam betimleyici sayısı sysconf çağrısında _SC_OPEN_MAX argümanıyla ya da getrlimit fonksiyonunda RLIMIT_NOFILE 
    argümanıyla elde edilebilir. İki fonksiyon da aynı değeri vermektedir. 
 
    6) Zorunlu olmamakla birlikte ilk üç betimleyiciyi /dev/null aygıtına yönlendirmek iyi bir fikirdir. Çünkü bir biçimde bazı 
    fonksiyonlar bu betimleyicileri kullanıyor olabilirler. Anımsanacağı gibi /dev/null aygıtına yazılanlar kaybolmaktadır. Bu aygıttan
    okume yapılmak istendiğinde ise EOF etkisi oluşur.

    Pekiyi daemon'lar ne yaparlar? İşte daemon2lar arka planda genellikle sürekli bir biçimde birtakım işler yapmaktadır. Bu anlamda
    en tipik daemon örnekleri "server" programlardır. Örneğin http server aslında httpd isimli bir daemon'dan ibarettir. Bunun gibi
    UNIX/Linux sistemlerinde genellikle boot zamanında devreye giren onlarca daemon program vardır. Örneğin belli amanlarda belli işlerin 
    yapılması için kullanılan cron utility'si aslında bir daemon olarak çalışmaktadır. 

    Aşağıda bir prosesi daemon haline getiren bir fonksiyon örneği verilmiştir. Bu fonksiyon main fonksiyonun çağrılmış böylece proses
    daemon haline getirilmiştir. 

---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <fcntl.h>
#include <sys/stat.h>
#include <unistd.h>

void make_daemon(void)
{
    pid_t pid;
    int maxfd;
    int fd;
    int i;

    umask(0);

    if ((pid = fork()) == -1) {
        perror("fork");
        exit(EXIT_FAILURE);
    }
        
    if (pid != 0)
        exit(EXIT_SUCCESS);

    if (setsid() == -1) {
        perror("setsid");
        exit(EXIT_FAILURE);
    }

    if (chdir("/") == -1) 
        exit(EXIT_FAILURE);
        
    maxfd = sysconf(_SC_OPEN_MAX);
    for (i = 0; i < maxfd; ++i)
        close(i);

    if ((fd = open("/dev/null", O_RDWR)) == -1)
        _exit(EXIT_FAILURE);

    if (dup(fd) == -1 || dup(fd) == -1)
        _exit(EXIT_FAILURE);
}

int main(void)    
{
    make_daemon();

    /* daemon kodu, muhtemelen bir server program */


    return 0;
}

/*--------------------------------------------------------------------------------------------------------------------------

    Pekiyi mademki daemon programların terminal ilişkileri yoktur, o zaman bu programlar dış dünyaya nasıl bildirimde bulunacaklardır?
    İlk akla gelen yöntem önceden belirlenmiş bazı dosyalara yazmak olabilir. Ancak her daemon'ın kendi belirlediği dosyalara yazması 
    karışık bir durum oluşturabilmektedir. Bazı daemon'lar çok uzun süre çalışırlar bu da onların yazdıkları log'ların çok büyümesine yol açar. 
    UNIX türevi sistemlerde daha genel ve merkezi bir log mekanizması düşünülmüştür. Bu mekanizma sayesinde farklı daemon'lar aynı log dosyasına 
    bildirimleri yazarlar. Böylece hem daha güvenli hem daha makul bir loglama sistemi oluşturulmuş olur. 

    Merkezi loglama için üç temel POSIX fonksiyonu kullanılmaktadır: openlog, syslog ve closelog fonksiyonları. Log oluşturmadan önce openlog fonksiyonu
    çağrılırak bazı belirlemeler yapılır. Fonksiyonun prototipi şöyledir:

    void openlog(const char *ident, int logopt, int facility);

    Fonksiyonun birinci parametresi log mesajlarında görüntülenecek program ismini belirtmektedir. Genellikle programcılar bu parametre için
    program ismini argüman olarak verirler. Linux sistemlerinde bu parametreye NULL geçilebilmektedir. Bu durumda sanki bu parametre için
    program ismi yazılmış gibi işlem yapılır. Ancak POSIX standartlarında NULL geçme durumu belirtilmemiştir. İkinci parametre aşağıdaki 
    sembolik sabitlerin bit or işlemine sokulmasıyla oluşturulabilir:

    LOG_PID
    LOG_CONS
    LOG_NDELAY
    LOG_ODELAY
    LOG_NOWAIT
    
    Burada LOG_PID log mesajında prosesin proses id'sinin de bulundurulacağını belirtir. LOG_CONS log mesajlarının aynı zamanda default consola (/dev/console)
    da yazılacağını belirtmektedir. Bu parametre için argüman 0 olarak da girilebilir. Fonksiyonun üçüncü parametresi log mesajını yollayan prosesin kim olduğu
    hakkında temel bir bilgi vermek için düşünülmüştür. Bu parametre LOG_USER olarak girilebilir. LOG_USER bir user proses tarafından bu loglamanın yapıldığını 
    belirtmektedir. LOG_KERN mesajın kernel tarafından gönderildiğini belirtir. LOG_DAEMON mesajın bir sistem daemon programı tarafındanm gönderildiğini 
    belirtmektedir. LOG_LOCAL0'dan LOG_LOCAL7'ye akadarki sembolik sabitler özel log kaynaklarını belirtmektedir. Fonksiyon başarısız olamamaktadır. bu nedenle
    geri dönüş değeri void yapılmıştır. Bu parametre de 0 geçilebilir. Bu durumda LOLOCAL0 anlaşılır. 

    syslog fonksiyonu asıl log işlemini yapan fonksiyondur. Aslında syslog için işin başında openlog çağrısının yapılmasına da gerek yoktur. Bu durumda
    default belirlemeler kullanılmaktadır. Fonskiyonun parametrik yapısı şöyledir:

    void syslog(int priority, const char *format, ...);

    Fonksiyonun birinci parametresi mesajın öncelik derecesini (yani önemini) belirtir. Diğer paraetreler tamamen printf fonksiyonundaki gibidir. 
    Öncelik değerleir şunlardır:

    LOG_EMERG
    LOG_ALERT
    LOG_CRIT
    LOG_ERR
    LOG_WARNING
    LOG_NOTICE
    LOG_INFO
    LOG_DEBUG

    En çok kullanılanlar error mesajları için LOG_ERR, uyarı mesajları için LOG_WARNING ve genel bilgilendirme mesajları için LOG_INFO 
    değerleridir. syslog için openlog çağrılmak zorunda olmadığından syslog fonksiyonun birinci parametresi ile istenirse openlog fonksiyonunun
    üçüncü parametresi kombine edilebilir. 

    Nihayet eğer proses bitmeden log sistemi prosese kapatılmak isteniyorsa closelog fonksiyonu çağrılmalıdır:

    void closelog(void);

    Aşağıda log fonksiyonlarının kullanımına ilişkin bir örnek verilmiştir

---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <syslog.h>

void exit_sys(const char *msg);

int main(void)    
{
    int i;

    openlog("sample", LOG_PID, LOG_LOCAL0);

    for (i = 0; i < 10; ++i)
        syslog(LOG_INFO, "This is a test: %d\n", i);

    closelog();
    
    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/*--------------------------------------------------------------------------------------------------------------------------
    Tabii log sistemi aslında tipik olarak daemon programlar ve aygıt sürücüler tarafından kullanılmaktadır. Aşağıda
    bu sistemi kullanan bir daemon örneği görüyorsunuz. Bu program çalışırken tail /var/log/syslog komutu ile syslog isimli
    log dosyasının sonuna bakabilirsiniz. 
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <fcntl.h>
#include <sys/stat.h>
#include <unistd.h>
#include <syslog.h>

void make_daemon(void)
{
    pid_t pid;
    int maxfd;
    int fd;
    int i;

    umask(0);

    if ((pid = fork()) == -1) {
        perror("fork");
        exit(EXIT_FAILURE);
    }
        
    if (pid != 0)
        exit(EXIT_SUCCESS);

    if (setsid() == -1) {
        perror("setsid");
        exit(EXIT_FAILURE);
    }

    if (chdir("/") == -1) 
        exit(EXIT_FAILURE);
        
    maxfd = sysconf(_SC_OPEN_MAX);
    for (i = 0; i < maxfd; ++i)
        close(i);

    if ((fd = open("/dev/null", O_RDWR)) == -1)
        exit(EXIT_FAILURE);

    if (dup(fd) == -1 || dup(fd) == -1)
        exit(EXIT_FAILURE);
}

int main(void)    
{
    int i;

    make_daemon();

    openlog("sampled", LOG_PID, LOG_LOCAL0);

    for (i = 0; i < 100; ++i) {
        syslog(LOG_INFO, "daemon running: %d\n", i);
        sleep(1);
    }

    closelog();

    return 0;
}

/*--------------------------------------------------------------------------------------------------------------------------
    Pekiyi syslog log mesajlarını nereye yazmaktadır? Aslında log mesajlarını syslog fonksiyonun kendisi yazmaz. Log mesajlarının yazdırılması 
    için özel bir daemon prosesten faydalanılmaktadır. Bu proses eskiden syslogd ismindeydi, daha sonra bunun biraz daha gelişmiş versiyonu olan
    rsyslogd prosesi kullanılmaya başlandı. Kursun yapıldığı zamanlarda Linux sistemlerinde yaygın olarak rsyslogd isimli daemon kullanılmaktadır. 

    syslogd ya da rsyslogd aslında diğer proseslerden proseslerarası haberleşmeyle yazdırılacak log mesajlarını almaktadır. Tipik olarak syslog fonksiyonu
    /dev/log isimli soket dosyasını (datagram UNIX domain soket) kullanarak mesajları syslogd ya da rsyslogd daemon'ına göndermektedir. (Yani aslında syslogd ya da
    rsyslogd datagram server görevi de yapmaktadır). Kernel'ın kendisi de (örneğin printk fonksiyonunda) aslında neticede bu syslogd ya da rsyslogd daemon'ına 
    /dev/log soketi yoluyla datagram mesaj göndererek log mesajlarını yazdırmaktadır. Uzak bağlantı söz konusu olduğunda syslogd ya da rsyslogd datagram mesajları
    UDP/IP 514 numaralı porttan almaktadır. İşte aslında log mesajlarının hangi dosyalara yazılacağına syslogd ya da rsyslogd daemon'ları karar vermektedir. 
    Bu daemon'lar çalışmaya başladıklarında default durumda /etc/syslog.conf ya da /etc/rsyslog.conf dosyalarına bakmaktadır. İşte bu daemon'ların hangi dosyalara
    yazacağı bu konfigürasyon dosyalarında sistem yöneticisi tarafından belirlenebilmektedir. Ancak bu dosyada da belirleme yapılmamışsa default olarak
    pek çok mesaj grubu (error, warning, info) /var/log/syslog dosyasına yazılmaktadır. O halde programcı bu mesajlar için bu dosyaya başvurmalıdır. 

    Log dosyalarını incelemek için pek çok utility bulunmaktadır. Örneğin lnav, glogg ksystemlog gibi. systemd init paketi içerisindeki
    servis programaları olan systemctl ve journalctl fonksiyonu ile de servis temelinde görüntüleme yapılabilmektedir. 

---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Yukarıda da belirtildiği gibi pek çok daemon aslında sistem boot edilirken çalıştırılmakta ve sistem kapatılana kadar çalışır durumda kalmaktadır. 
    Fakat bazı daemon'lar ise gerektiğinde çalıştırılıp, gerekmediğinde durdurulabilmektedir. İşte UNIX/Linux sistemlerinde bu çalıştırma, 
    durdurma gibi falliyetler için daha yüksek seviyeli araçlar bulundurulmaktadır. Bu araçlar init prosesinin paketinde yer alırlar. 
    Tarihsel süreç içerisinde Linux sistemlerinde boot sonrası işlemlerden ve servis işlemlerinden sorumlu üç önemli init paketi geliştirilmiştir:

    systemVinit (klasik)
    upstart
    systemd

    Kursun yapıldığı zaman diliminde ağırlıklı biçimde init paketi olarak systemd paketi kullanılmaktadır. Sisteminizde hangi init 
    paketinin kullanıldığını anlamak için birkaç yol söz konusu olabilir:

    ls -l /sbin/init
    cat /proc/1/status

    systemd init paketinin servis yönetici programı systemctl isimli programdır. Bu program yoluyla daemon işlemleri yapabilmek için öncelikle
    bir .service uzantılı dosyasının oluşturulması gerekir. Bu programın çalıştırabileceği servislere "unit" denilmektedir. .service uzantılı
    dosyada da unit bildirimleri bulunur. Sonra bu dosyanın /etc/systemd/system dizinine kopyalanması gerekmektedir. Ondan sonra asıl daemon programının da
    /usr/local/bin ya da /usr/bin içerisine çekilmesi uygundur. (Tabii burada bazı seçenkler söz konusudur. Ancak biz tipik durumları ele alıyoruz. Ayrıntılı bilgi 
    için systemd dokümantasyonuna bakınız.) Artık şu komutlar uygulanarak servis yönetilebilir:

    systemctl start <daemon ismi> (daemon'ı çalıştırır)
    systemctl stop <daemon ismi> (daemon'ı durdurur)
    systemctl restart <daemon ismi> (durdurup yeniden başlatır)
    systemctl show <daemon ismi> (daemon'ın durumunu gösterir)
    systemctl enable <service dosyasının ismi> (boot zamanında devreye sokmak için)
    systemctl disable <service dosyasının ismi> (boot zamanında devreden çıkarmak için)

    systemd için tipik bir .service uzantılı dosyanın içeriği şöyledir:
    
    [Unit]
    Description=Example Unit
    [Service]
    Type=forking
    ExecStart=/usr/bin/sampled
    [Install]
    WantedBy=multi-user.target

    Daemon'lar işleme başlamadan önce çeşitli parametrik bilgileri bazı konfigürasyon dosyalarından (genellikle bunların uzantıları .conf olur) okuyabilmektedir. 
    Sistem yöneticisi de bu dosyalarda değişiklik yapıp daemon'ı restart edebilmektedir. 
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Farklı makinelerin prosesleri arasında haberleşme (yani ağ altında haberleşme) daha çetrefil bir haberleşme biçimidir. 
    Çünkü burada ilgili işletim sisteminin dışında pek çok belirlemelerin önceden yapılmış olması gerekir. İşte ağ haberleşmesinde 
    önceden belirlenmiş kurallar topluluğuna "protokol" denilmektedir. Ağ haberleşmesi için tarihsel süreç içerisinde pek çok 
    protokol gerçekletirilmiştir. Bunların bazıları büyük şirketlerin kontrolü altındadır. Ancak açık bir protkol olan
    IP protokol ailesi günümüzde hemen her zaman tercih edilen protokol ailesidir. 

    Protokol ailesi (protocol family) denildiğinde birbirleriyle ilişkili bir grup protokol anlaşılır. Ailenin pek çok protokolü 
    başka protokollerin üzerine konumlandırılmıitır. Böylece protokol aileleri katmanlı (layered) bir yapıya sahip olmuştur. 
    Üst seviye bir protokol alt seviye protokolün zaten var olduğu fikriyle o alt seviye protokol kullanılarak oluşturulur. 

    ISO Bir protokol ailesinde katmanlı olarak hangi tarzda protokollerin bulundurulabileceğine yönelik OSI (Open System Interconnection) 
    isimli bir referans dokümanı oluşturmuştur. Bunlara OSI katmanları denilmektedir. OSI'nin 7 katmanı vardır. Aşağıdaki yukarıya
    bunlar şöyledir: Phsical Layer, Data Link Link Layer, Network Layer, Transport Layer, Session Layer, Presentation Layer, Application Layer. 
    En aşağı seviyeli elektriksel tanımlamaların yapıldığı katmana "fiziksel katman" denilmektedir. (Örneğin kabloların, konnektörlerin özellikleri vs.)
    Veri Bağlantı Katmanı artık bilgisayarlar arasında fiziksel bir adreslemenin yapıldığı ve bilgilerin paketlere ayrılarak gönderilip alındığı
    bir ortam tanımlarlar. Örneğin bugün kullandığımız Ethernet kartları MAC adresi denilen dünya genelinde tek olan adresler yoluyla paket paket (packet switching)
    bilginin gönderilip alınmasını sağlar. Bu yüzden Ethernet protokolü "veri bağlantı katmanına ilişkindir." Ağ Katmanı (Netword layer) artık "inernetworking" yapmak
    için gerekli kuralları tanımlar. "Internetworking" terimi network'lerden oluşan network'ler anlamına gelir. Tipik olarak internetworking yapmak için
    yerel ağlar (local area networks) "router" denilen aygıtlarla birbirine bağlanmaktadır. Ağ katmanında artık fiziksel bir adresleme değil, mantıksal adresleme
    sistemi kullanılmaktadır. Ayrıca bilgilerin paketlere ayrılarak router'lardan dolaşııp hedefe varması için rotalama mekanizması da bu katmanda tanımlanmaktadır. 
    Yani elimizde yalnızca network katmanı varrsa bi yalnızca "internetworking" ortamında belli bir kaynaktan hedefe bir paket yollayabiliriz. Transport katmanları
    network katmanlarının üzerindedir. Transpot katmanında artık kaynak ile hedef arasında bir bağlantı oluşturulabilmekte ve veri aktarımı daha güvenli 
    olarak yapılabilmektedir. Aynı zamanda transport kavramı "multiplex" bir kaynak hedef yapısı da oluşturmaktadır. Bu sayede hedefe bilgiler oradaki spesifik bir
    programa gönderilebilmektedir. Oturrum katmanı pek çok ailede yoktur. Görevi oturum açma kapama gibi yüksek seviyeli bazı belirlemeleri yapmaktır. Presentation
    katmanı verilerin sıkıştırılması, şifrelenemesi gibi tanımlamalar içermektedir. Nihayet bu protokolü kullanan bütün programlar aslında uygulama katmanını oluşturmaktadır.
    Yani ağ ortamında haberleşen her program zaten kendi içerisinde açık ya da gizli bir protokol oluşturmuş durumdadır. 

    IP ailesi neden bu kadar popüler olmuştur? Bunun en büyük nedeni 1983 yılında hepimizin katıldığı Internet'in (I'nin büyük yazıldığına dikkat ediniz)
    bu aileyi kullanmaya başlamasındadır. Böylece IP ailesini kullanarak yazdığımız programlar hem aynı bilgisayarda hem yerel ağımızdaki bilgisayarlarda hem de
    Internet'te çalışabilmektedir. Aynı zamanda IP ailesinin açık bir (yani bir şirketin malı değil) protokol olması da cazibeyi çok artırmıştır. 

    IP ailesi 70'li yıllarda Vint Cerf ve Bob Kahn tarafından geliştirilmiştir. IP ismi Internet Protocol'den gelmektedir. Burada internet "internetworking" 
    anlamında kullanılmıştır. 

    Bugün hepmizin bağlandığı büyük ağa da "Internet" denilmektedir. Bu ağ ilk kez 1969 yılında Amerika'da Amerikan Savunma Bakanlığının bir soğuk savaş
    projesi biçiminde başlatıldı. O zamana kadar yalnızca yerel ağlar vardı. 1969 yoılında ilk kez bir "WAN (Wide Area Network)" oluşturuldu. 
    Bu proje Amerikan savunma bakanlığının DARPA isimli araştırma kurumu tarafından başlatılmıştır ve ARPA.NET ismi verilmiştir. Daha bu ağa Amerika'daki
    çeşitli devlet kurumları ve üniversiteler katıldı. Sonra ağ Avrupa'ya sıçradı. 1983 yılında bu ağ NCP protokolünden IP protokol ailesine geçiş yaptı.
    Bundan sonra artık APRA.NET ismi yerine "Internet" ismi kullanılmaya başlandı. 

    IP prtokol ailesi 4 katmanlı bir ailedir. Fiziksel ve Veri Bağlantı Katmanı bir arada düşünülebilir. Bugün bunlar Ethernet ve Wireless protokolleri
    biçiminde pratikte kullanılmaktadır. IP ailesinin ağ katmanı aileye ismini veren IP protokolünden oluşmaktadır. Transport katmanı ise TCP ve UDP 
    protokollerinden oluşur. Nihayet TCP üzerine oturtulmuş olan HTTP, TELNET, SSH, POP3, IMAP gibi pek çok protokol ailenin uygulama katmanını oluşturmaktadır. 

    IP protokolü tek başına kullanılırsa ancak bir paket gönderip alma işini yapar. Bu nedenle bu protokolün tek başına kullanılması çok seyrektir. 
    Uygulamada genellikle trasport katmanına ilişkin TCP ve UDP ptotokolleri kullanılmaktadır. 

    TCP "stream tabanlı", UDP "datagram (paket) tabanlı" bir protokoldür. Stream tabanlı demek tamamen boru haberleşmesinde olduğu gibi gönderen tarafın
     bilgilerinin bir kuyruk sistemi eşliğinde alıcıda organize edilmesi ve alıcının istediği kadar byte'ı parça parça okuyabilmesi demektir. Datagram tabanlı
     demek tamamen mesaj kuyruklarında olduğu gibi bilginin paket paket iletilmesi demektir. Yani datagram haberleşmede alıcı taraf gönderen tarafın
     tüm paketini tek hamlede almak zorundadır. 

     TCP bağlantılı (connection-oriented) UDP bağlantısız (connectionless) bir protokoldür. Buradaki bağlantı IP paketleriyle yapılan
     mantıksal bir bağlantıdır. Bağlantı sırasında gönderici ve alıcı birbirlerini tanır ve haberleşme boyunca konuşabilirler. Oysa
     UDP'de alıcı onun hiç bilmediği bir kullanıcıdan bilgi alabilmektedir. UDP'de gönderen ve alan arasında bir kayıt turulmaz. 

     TCP güvenilir (reliable) UDP (güvenilir) olmayan (unreliable) bir protokoldür. TCP'de mantıksal bir bağlantı oluşturulduğu için 
     yolda kaybolan paketlerin telafi edilmesi mümkündür. Alıcı taraf gönderenin bilgilerini eksiksiz ve bozulmadan aldığını 
     bilir. 

    IP protokol ailesinde ağa bağlı olan birimlere "host" denilmektedir. Host bir bilgisayar olmak zorunda değildir. İşte bu protokolde
    her host'un mantıksal bir adresi vardır. Bu adrese IP adresi denilmektedir. IP adresi IPV4'te 4 byte uzunlukta, IPV6'da 16 byte 
    uzunluktadır. Ancak bir host'ta farklı programlar farklı host'larla haberleşiyor olabilir. İşte aynı host'a gönderilen IP paketlerinin
    o host'ta ayrıştırılması için "protokol port numarası" diye içsel bir numara uydurulmuştur. Port numarası bir şirketin içerisinde çalışanların
    dahili numarası gibi düşünülebilir. Port numaraları IPV4'te 2 byte'la, IPV6'da 4 byte'la ifade edilmektedir. İlk 1024 port numarası IP 
    ailesinin uygulama katmanındaki protokoller için ayrılmıştır. Bunlara "well known ports" denilmektedir. Bu nedenle prograöcıların port numaralarını
    1024'ten büyük olacak biçimde almaları gerekir. Bu udurmda TCP ve UDP'de bilgiler belirli bir IP adresindeki host'un belirli bir portuna gönderilir. 
    Gönderilen bu bilgiler de o portla ilgilenen programlar tarafından alınmaktadır. 

    IP haberleşmesi (yani paketlerin, oluşturulması, gönderilmesi alınması vs.) işletim sistemlerinin çekirdekleri tarafından yapılmaktadır. 
    Tabii User mod programlar için sistem çağrılarını yapana API fonksiyonlarına ve kütüphanelerine gereksinim vardır. İşte bunların en yaygın
    kullanılanı "soket kütüphanesi" denilen kütüphanedir. Bu kütüphane ilk kez 1983 yılında 4.2BSD'de gerçekleştirilmiştir ve pek çok UNIX türevi
    sistem bu kütüphaneyi aynı biçimde benimsemiştir. Microsoft'un Windows sistemleri de bu APı kütüpahanesini desteklemektedir. Bu kütüphaneye "Winsock"
    ya da "WSA (Windows Socket API)" denilmektedir. Microsoft'un Winsock kütüphanesinde hem BSD fonksiyonları orijinal haliyle bulunmakta hem de 
    başı WSAXXX ile başlayan Wibndows'a özgü fonksiyonlar bulunmaktadır. 
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Bir TCP/IP uygulmasında server ve client olmak üzere iki ayrı program yazılır. Server program şu fonksiyonlar çağrılarak oluşturulmaktadır:

    socket, bind, listen, accept, read/write/recv/send, shutdown, close

    socket fonksiyonu bir handle alanı yaratır ve bize bir dosya betimleyicisi verir. Biz diğer fonksiyonlarda soket dediğimiz bu 
    betimleyiciyi kullanırız. Fonksiyonun prototipi şöyledir:

    #include <sys/socket.h>

    int socket(int domain, int type, int protocol);

    Fonksiyonun birinci parametresi kullanılacak protokol ailesini belirtir. Bu parametre AF_XXX biçimindeki sembolik sabitlerden biri
    olarak girilir. IPV4 için bu parametreye AF_INET, IPV6 için AF_INET6 girilmelidir. UNIX protokolü için AF_UNIX kullanılır. İkinci 
    parametre kullanılacak protokolün stream mi datagram mı ya da başka bir türden mi olduğunu belirtir. Stream soketler için SOCK_STREAM, 
    datagram soketler için SOCK_DGRAM kullanılmalıdır. Ancak başka soket türleri de vardır. Üçüncü parametre transport katmanındaki protokolü belirtmektedir. 
    Ancak zaten ikinci parametreden transport protokolü anlaşılıyorsa üçüncü parametre 0 geçilebilir. Örneğin IP ailesinde üçüncü parametreye
    gerek duyulmamaktadır. Çünkü SOCK_STREAM zaten TCP'yi SOCK_DGRAM ise UDP'yi anlatmaktadır. Fakat yine de bu parametreye istenirse IP ailesi 
    için IPPRO_TCP ya da IPPROTO_UDP girilebilir. (Bu sembolik sabitler <netinet/in.h> içerisindedir.) Fonksiyon başarılıysa soket betimleyicisine
    başarısızsa -1 değerine geri döner ve errno uygun biçimde set edilir. 

    Server program soketi yarattıktan sonra onu bağlamalıdır (bind etmelidir). bind işlemi sırasında server'ın hangi portu dinleyeceği
    ve hangi network arayüzünden (kartından) gelen bağlantı isteklerini kabul edeceği belirlenir. 

    #include <sys/socket.h>

    int bind(int sockfd, const struct sockaddr *addr, socklen_t addrlen);

    Fonksiyonun birinci parametresi yaratılmış olan soket betimleyicisini alır. İkinci parametre her ne kadar sockaddr isimli 
    yapı türündense de aslında her protokol için ayrı bir yapı adresini almaktadır. Yani sockaddr yapısı genelliği (void gösterici gibi)
    temsil etmek için kullanılmıştır. IPV4 için kullanılacak yapı sockaddr_in IPV6 için sockaddr_in6 ve örneğin Unix domain soketler için ise 
    sockaddr_un biçiminde olmalıdır. Üçüncü parametre ikinci parametredeki yapının uzunluğu olarak girilmelidir. 

    sockaddr_in yapısı <netinet/in.h> dosyası içerisinde aşağıdaki gibi bildirilmiştir:

    struct sockaddr_in {
        sa_family_t     sin_family;   
        in_port_t       sin_port;     
        struct in_addr  sin_addr;     
    };

    Yapının sin_family elemanına protokol ailesini belirten AF_XXX değeri girilmelidir. Bu eleman tipik olarak short biçimde bildirilmiştir. 
    Yapının sin_port elemanı in_port_t  türündendir ve bu tür uint16_t olarak typedef edilmiştir. Bu eleman server'ın dinleyeceği
    port numarasını belirtir. Yapının sin_addr elemanı IP numarası belirten bir elemandır. Bu eleman in_addr isimli bir yapı türündendir. 
    Bu yapı da şöyle bildirilmiştir:

    struct in_addr {
        in_addr_t  s_addr;
    };

    in_addr_t 4 byte'lık işaretsiz tamsayı türünü (uint32_t)  belirtmektedir. Böylece s_addr 4 byte'lık IP adresini temsil eder.

    IP ailesinde tüm sayısal değerler BIG ENDIAN formatıyla belirtilmek zorundadır. Bu ailede "network byte ordering" denildiğinde
    BIG ENDIAN anlaşılır. Oysa makinelerin belli bir bölümü (örneğin INTEL ve default ARM) LITTLE ENDIAN kullanmaktadır. İşte 
    elimzdeki makinenin endian'lığı ne olursa olsun onu BIG ENDIAN'a dönüştüren htons (host to network byte ordering short) ve
    htonl (host to network byte ordering long) isimli iki fonksiyon vardır. Bu işlemlerin tersini yapan ntohs ve ntohl fonksiyonları 
    da bulunmaktadır. IP adresi olarak INADDR_ANY özel bir değerdir ve "tüm network kartlarından gelen bağlantı isteklerini kubul et"
    anlamına gelir. Bu durumda sockaddr_in yapısı tipik olarak şöyle doldurulabilir:

    struct sockaddr_in sinaddr;

    sinaddr.sin_family = AF_INET;
    sinaddr.sin_port = htons(SERVER_PORT);
    sinaddr.sin_addr.s_addr = htonl(INADDR_ANY);
    
    server bind işleminden sonra soketi aktif dinleme konumuna sokmak için listen fonkiyonunu çağırmalıdır. Fonksiyonun prototipi şöyledir:

    int listen(int socket, int backlog);

    Fonksiyonun birinci parametresi soketin handle değeri, ikinci parametresi kuyruk uzunluğunu belirtir. listen işlemi blokeye 
    yol açmamaktadır. İşletim sistemi listen işleminden sonra ilgili porta gelen bağlantı isteklerini uygulama için bir kuyruk sisteminde 
    biriktirir. accept fonksiyonu bu kuyruğa bakmaktadır. Kuyruk uzunluğunu yüksek tutmak meeşgul server'larda bağlantı isteklerinin kaçırılmamasını
    sağlayabilir. Linux'ta default durumda verilebilecek en yüksek değer 128'dir. Ancak /proc/sys/net/core/somaxconn dosyasındaki
    değer yükseltilebilir. Fonksiyon başarı durumunda 0 değerine başarısızlık durumunda -1 değerine geri döner. Bu fonksiyon işletim 
    sisteminin "firewall mekanizması" tarafından denetlenmektedir. 

    Nihayet asıl bağlantı accept fonksiyonuyla sağlanmaktadır. accept fonksiyonu bağlantı kuyruğuna bakar. Eğer orada bir bağlantı isteği varsa
    onu alır ve hemen geri döner. Eğer oarada bir bağlantı isteği yoksa default durumda blokede bekler. Fonksiyonun prototipi şöyledir:

    int accept(int socket, struct sockaddr *address, socklen_t *address_len);

    Fonskiyonun birinci parametresi soketin dosya betimleyicisini almaktadır. İkinci parametre bağlanılan client'a ilişkin bilgilerin
    yerleştirileceği yapının adresini almaktadır. Tabii bu yapı yine protokole göre değişebilen bir yapıdır. Örneğin IPV4 için bu yapı
    yine sockaddr_in olmalıdır. Bu yapının içinden biz bağlanılan clien'ın ip adresini, kaynak port numarasını alabiliriz. 
    Bu bilgiler yine BIG ENDIAN formattadır. accpry fonksiyonu baaşarı durumunda client ile konuşma işinde kullanılacak soket değerine
    (soket dosya betimleyicisine) başarıszlık durumunda 0 değerine geri dönmektedir. 

    Server programın listen ve accept işlemlerini yapmak için kullandığı sokete "pasif soket" ya da "dinleme soketi" denilmektedir. 
    Bu pasif soket başka bir amaçla kullanılamaz. Client'larla konuşmak için accept fonksiyonun verdiği soketler kullanılır. 

    Aşağıda accept işlemine kadar tipik bir server örneği verilmiştir. Bu program dinlenecekprot numarasını komut satırı argümanıyla almaktadır.

---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>

void exit_sys(const char *msg);

int main(int argc, char *argv[])
{
    int sock, sock_client;
    struct sockaddr_in sinaddr, sinaddr_client;
    socklen_t sinaddr_len;
    in_port_t port;

    if (argc != 2) {
        fprintf(stderr, "wrong number of arguments!..\n");
        exit(EXIT_FAILURE);
    }

    port = (in_port_t)strtoul(argv[1], NULL, 10);

    if ((sock = socket(AF_INET, SOCK_STREAM, 0)) == -1)
        exit_sys("socket");

    sinaddr.sin_family = AF_INET;
    sinaddr.sin_port = htons(port);
    sinaddr.sin_addr.s_addr = htonl(INADDR_ANY);

    if (bind(sock, (struct sockaddr *)&sinaddr, sizeof(sinaddr)) == -1)
        exit_sys("bind");

    if (listen(sock, 8) == -1)
        exit_sys("listen");


    printf("Waiting for connection...\n");
    
    sinaddr_len = sizeof(sinaddr_client);
    if ((sock_client = accept(sock, (struct sockaddr *)&sinaddr_client, &sinaddr_len)) == -1)
        exit_sys("accept");

    printf("Connected: %s : %u\n", inet_ntoa(sinaddr_client.sin_addr), (unsigned)ntohs(sinaddr_client.sin_port));    
  
    /* other stuff */    

    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/*--------------------------------------------------------------------------------------------------------------------------

    Client program tipik olarak şu aşamalardan geçerek yazılmaktadır: socket, bind (optional), gethostbyname (optional), connect, 
    read/write/recv/send, shutdown, close.

    Client program yine socket fonksiyonuyla bir soket yaratır. İsterse bu soketi bind eder. Client bind işlemi yapmak zorunda değildir. 
    Ancak client'ın server'a belirli bir kaynak porttan bağlanması isteniyorsa client bu kaynak portu belirlemek için bind işlemi yapmalıdır. 
    Eğer client bind işlemi yapmazsa işletim sistemi belli bir aralıkta boş bir kaynak port numarasını tahsis eder. Client program server'ın
    ip adresini ve port numarasını bilerek ona bağlanacaktır. Ancak IP adresleri akılda zor tutulduğu için IP adreslerine isimler karşı düşürülmüştür.
    Pratikte daha çok bu isimler kullanılmaktadır. connect fonksiyonun prototipi şöyledir:

    int connect(int socket, const struct sockaddr *address, socklen_t address_len);

    Fonksiyonun birinci parametresi soket betimleyicisi alır. İkinci parametre yine IPV4 için sockaddr_in IPV6 için sockaddr_in6 türünden
    bir yapının adresini alır. Böylece IPV4 için programcı bir sockaddr_in yapısı alıp bağlanacağı server'ın ip adresini ve port numarasını
    bu yapıya yerleştirir. Fonksiyonun son parametresi ikinci parametredeki nesnenin byte uzunluğunu almaktadır. Fonksiyon başarı durumunda 0, 
    başarısızlık durumunda -1 değerine geri dönmektedir. 

    IP adreslerinin sockaddr_in yapısına BIG ENDIAN (network byte ordering) biçiminde girilmesi gerektiğini anımsayınız. Bu durumda örneğin
    a.b.c.d biçimindeki bir IP adresi htonl(a << 24 | b << 16 | c << 8 | d) biçiminde oluşturulabilir. Ancak bunun yerine bu dönüşümü yapana
    inet_addr isimli bir fonksiyon bulundurulmuştur. Bu fonksiyon "a.b.c.d" biçiminde yazısal olarak verilen IP adresini parse ederek BIG ENDIAN
    formata dönüştürmektedir. Eğer noktalıformdaki (dotted decimal form) IP adresi yazlış girilmişse fonksiyon INADDR_NONE değerine geri dönmektedir. 
    Bu işlemin tersini yapan inet_ntoa isimli bir fonksiyon vardır. Bu iki fonksiyon IPV4'te kullanılabilmektedir. Daha sonraları IPV6'da da kullanılabilecek
    biçimde yeni fonksiyonlar inet_pton ve inet_aton fonksiyonlarıdır. 

    Genellikle client programlar server'ın IP adresini ya da host ismini (domain ismini) alarak çalışacak biçimde yazılırlar. İşte programcının 
    girilen değerin öncelikle "noktalı desimal formda (dotted decimal form)" olup olmadığını kontrol etmesi gerekir. Zaten inet_addr fonksiyonu bu kontrolü 
    yapabilmektedir. O halde girilen yazı öncer inet_addr fonksiyonuna sokulmalı eğer oradan INADDR_NONE değeri elde ediliyorsa artık girilen yazının ip adresi 
    olmadığı anlaşılır. İşte host isimlerinin IP adreslerine dönüştürülmesi için IP protokol ailesinde "DNS protokolü" denilen özel bir protokol bulunmaktadır. 
    İsimlerin IP adres karşılıkları "Doman Name Server" denilen özel server'larda tutulur. Client program bu server'lara danışarak ismi IP numarasına
    dönüştürür. Bu işlem için IPV4'te gethostbyname isimli fonksiyon kullanılıyordu. Daha sonra IPV6'yı da kapsayacak biçimde getnameinfo ve getaddrinfo 
    fonksiyonları oluşturudu. gethostbyname fonksiyonun prototipi şöyledir:

     struct hostent *gethostbyname(const char *name);

    Fonksiyon parametre olarak host ismini alır, ve  hostent isimli bir yapı adresine geri döner. hostent yapısı şöyledir:

    struct hostent {
        char  *h_name;            
        char **h_aliases;         
        int    h_addrtype;        
        int    h_length;          
        char **h_addr_list;       
    };
    
    Bit host ismine karşı birden fazla IP adresi olabileceği gibi, bir IP adresine karşı da birden fazla host ismi olabilmektedir. Yapının 
    h_addr_list elemanı her biri 4 char'dan oluşan dört elemanlı dizilerin adreslerini tutmaktadır. Bunlar host ismine karşı gelen IP adresleridir. 
    Bu cgösterici dizisinin sonunda NULL adres vardır. 

    Aşağıdaki programda anlatılan yere kadar bir client program iskeleti verilmiştir. Program komut satırı argümanı olarak server'ın
    ip adresini (ya da host ismini) ve port numarasını alır ve server'a TCP ile bağlanır. 

---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <netdb.h>

void exit_sys(const char *msg);

int main(int argc, char *argv[])
{
    int sock;
    struct sockaddr_in sinaddr;
    struct hostent *hent;
    in_port_t port;

    if (argc != 3) {
        fprintf(stderr, "wrong number of arguments!..\n");
        exit(EXIT_FAILURE);
    }

    port = (in_port_t)strtol(argv[2], NULL, 10);

    if ((sock = socket(AF_INET, SOCK_STREAM, 0)) == -1)
        exit_sys("socket");

    sinaddr.sin_family = AF_INET;
    sinaddr.sin_port = htons(port);
    
    if ((sinaddr.sin_addr.s_addr = inet_addr(argv[1])) == INADDR_NONE) {
        if ((hent = gethostbyname(argv[1])) == NULL) 
            exit_sys("gethostbyname");
        memcpy(&sinaddr.sin_addr.s_addr, hent->h_addr_list[0], hent->h_length);
    }

    if (connect(sock, (struct sockaddr *)&sinaddr, sizeof(sinaddr)) == -1) 
        exit_sys("connect");

    printf("Connected...\n");

   /* other stuff */   
    
    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/*--------------------------------------------------------------------------------------------------------------------------
    Client taraf soketi yarattıktan sonra kaynak port numarasının belli bir değerde olmasını sağlayabilir. Bunun için client
    tarafın da bind işlemi uygulaması gerekir. Aşağıdaki örnekte client taraf 5051 numaralı port'a bind işlemi yapmıştır.
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <netdb.h>

void exit_sys(const char *msg);

int main(int argc, char *argv[])
{
    int sock;
    struct sockaddr_in sinaddr;
    struct hostent *hent;
    in_port_t port;

    if (argc != 3) {
        fprintf(stderr, "wrong number of arguments!..\n");
        exit(EXIT_FAILURE);
    }

    port = (in_port_t)strtol(argv[2], NULL, 10);

    if ((sock = socket(AF_INET, SOCK_STREAM, 0)) == -1)
        exit_sys("socket");

    sinaddr.sin_family = AF_INET;
    sinaddr.sin_port = htons(5051);
    sinaddr.sin_addr.s_addr = htonl(INADDR_ANY);

    if (bind(sock, (struct sockaddr *)&sinaddr, sizeof(sinaddr)) == -1)
        exit_sys("bind");

    sinaddr.sin_family = AF_INET;
    sinaddr.sin_port = htons(port);
    
    if ((sinaddr.sin_addr.s_addr = inet_addr(argv[1])) == INADDR_NONE) {
        if ((hent = gethostbyname(argv[1])) == NULL) 
            exit_sys("gethostbyname");
        memcpy(&sinaddr.sin_addr.s_addr, hent->h_addr_list[0], hent->h_length);
    }

    if (connect(sock, (struct sockaddr *)&sinaddr, sizeof(sinaddr)) == -1) 
        exit_sys("connect");

    printf("Connected...\n");

    /* other stuff */
       
    
    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/*--------------------------------------------------------------------------------------------------------------------------
    Bağlantı sağlandıktan sonra artık iki taraf da birbirlerine bilgi gönderip alabilirler (full duplex). Bilgi gönderip alma
    aslında bir tamponlama (bufffering) mekanizmasıyla gerçekleştirilmektedir. Her iki tarafta da işletim sistemleri "gönderme tamponu (send buffer)"
    ve "alma tamponu (receive buffer)" isminde iki tampon bulundurur. Biz bir soketle karşı tarafa bilgi göndermek istediğimizde aslında göndermek
    istediğimiz bilgiler önce kendi bilgisayarımızın "gönderme taponuna (send buffer)" yazılmaktadır. Bu gönderme tamponuna yazılan bilgiler 
    işletim sistemi tarafından TCP ve dolayısıyla IP paketlerine dönüştürülüp uygun bir zamanda gerçekten gönderilmektedir. Benzer biçimde
    aslında bilgisayarımıza gelen paketler kesme (interrupt) mekanizması yoluyla işletim sistemi tarafından "alma tamponuna (receive buffer)" yerleştirilmektedir. 
    Biz soketten okuma yapmak istediğimizde bu tampona yerleştirilmiş olanları okuruz. Pekiyi alma tamponu dolarsa ve biz hiç okuma yapmazsak
    ne olur? İşte TCP protokolü (ama IP değil) akış kontrolüne (flow control) sahiptir. Akış kontrolü tampon taşmasını engellemek için iki tarafın 
    konuşarak birbirlerini gerektiğinde durdurması anlamına gelmektedir. 

    TCP'de soket arayüzünü kullanarak bilgi göndermek için write ya da send fonksiyonları kullanılmaktadır. send fonksiyonunun write fonksiyonundan
    fazla bir flags parametresi vardır.

    ssize_t write(int fd, const char *buf, size_t size);
    ssize_t send(int fd, const void *buffer, size_t size, int flags);

    Soketten bilgi okumak için ise read ya da recv fonksiyonları kullanılmaktadır. Yine aslında recv fonksiyonu read fonksiyonundan farklı
    olarak bir flags parametresine sahiptir:

     ssize_t read(int fd, void *buf, size_t count);
     ssize_t recv(int fd, void *buf, size_t len, int flags);

    send fonksiyonunun flags parametresi 0 geçilirse, recv fonksiyonunun da flags parametresi 0 geçilirse bunların write ve read'ten 
    hiçbir farklılığı kalmamaktadır. 

    write ya da send fonksiyonu ile bilgi gönderilirken aslında bilgi "gönderme tamponuna yazılıp" hemen bu fonksiyonlar geri dönerler. write ya da send 
    fonksiyonları POSIX standartlarına göre normal olarak tüm bilgi gönderme tamponuna yazılana kadar blokeye yol açmaktadır. Örneğin biz bu fonksiyonlarla 
    100 byte göndermek isteyelim ancak gönderme tamponunda 90 byte'lık yer kalmış olsun. Bu durumda write ya da send fonksiyonları bu 100 byte'ın tamamı yazılana 
    kadar blokeye yol açmaktadır. (send fonksiyonunun bu davranışı Windows sistemlerinde değişiklik gösterebilmektedir. Bu sistemlerde send fonksiyonu bilginin 
    tamamı tampona aktarılana kadar blokeye yol açmak zorunda değildir. Bu sistemlerde send fonksiyonu yazabildiği kadar byte'ı tampona yazıp yazabildiği 
    byte sayısına geri dönebilmektedir.)
    
    read ya da recv fonksiyonları "alma tamponuna" bakmaktadır. Bu tampon tamamen boş ise bunlar blokeli modda (default durum) en az 1 byte okuyana 
    kadar blokede beklerler. Ancak eğer tamponda en az 1 byte'lık bilgi varsa bu fonksiyonlar blokeye yol açmazlar, okuyabildikleri kadar byte'ı 
    okuyarak okuyabildikleri byte sayısına geri dönerler.

    TCP/IP haberleşmede önemli bir durum vardır: Bir tarafın tek bir write/send ile gönderdiği bilgiyi diğer taraf tek bir read/recv ile okuyamayabilir. 
    Çünkü write/send yapan taraf bu bilgileri önce gönderme tamponuna yerleştirir. Buradaki bilgiler işletim sistemi tarafından farklı IP paketleri ile
    iletilebilr. Bunun sonucunda alıcı taraf bunları parça parça alabilir. 
---------------------------------------------------------------------------------------------------------------------------*/

/* server.c */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>

#define BUFFER_SIZE     1024

char *revstr(char *str);
void exit_sys(const char *msg);

int main(int argc, char *argv[])
{
    int sock, sock_client;
    struct sockaddr_in sinaddr, sinaddr_client;
    socklen_t sinaddr_len;
    in_port_t port;
    ssize_t result;
    char buf[BUFFER_SIZE + 1];

    if (argc != 2) {
        fprintf(stderr, "wrong number of arguments!..\n");
        exit(EXIT_FAILURE);
    }

    port = (in_port_t)strtoul(argv[1], NULL, 10);

    if ((sock = socket(AF_INET, SOCK_STREAM, 0)) == -1)
        exit_sys("socket");

    sinaddr.sin_family = AF_INET;
    sinaddr.sin_port = htons(port);
    sinaddr.sin_addr.s_addr = htonl(INADDR_ANY);

    if (bind(sock, (struct sockaddr *)&sinaddr, sizeof(sinaddr)) == -1)
        exit_sys("bind");

    if (listen(sock, 8) == -1)
        exit_sys("listen");

    printf("Waiting for connection...\n");
    
    sinaddr_len = sizeof(sinaddr_client);
    if ((sock_client = accept(sock, (struct sockaddr *)&sinaddr_client, &sinaddr_len)) == -1)
        exit_sys("accept");

    printf("Connected: %s : %u\n", inet_ntoa(sinaddr_client.sin_addr), (unsigned)ntohs(sinaddr_client.sin_port));    
  
    for (;;)  {
        if ((result = recv(sock_client, buf, BUFFER_SIZE, 0)) == -1)
            exit_sys("recv");
        if (result == 0)
            break;
        buf[result] = '\0';
        if (!strcmp(buf, "quit"))
            break;
        printf("%ld bytes received from %s (%u): %s\n", (long)result, inet_ntoa(sinaddr_client.sin_addr), 
                    (unsigned)ntohs(sinaddr_client.sin_port), buf);
        revstr(buf);
        if (send(sock_client, buf, strlen(buf), 0) == -1)
            exit_sys("send");
   }
   
   /* Other stuff */
    
    return 0;
}

char *revstr(char *str)
{
    size_t i, k;
    char temp;

    for (i = 0; str[i] != '\0'; ++i)
        ;
    
    for (--i, k = 0;  k < i; ++k, --i) {
        temp = str[k];
        str[k] = str[i];
        str[i] = temp;
    }

    return str;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/* client.c */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <netdb.h>

#define BUFFER_SIZE        1024

void exit_sys(const char *msg);

int main(int argc, char *argv[])
{
    int sock;
    struct sockaddr_in sinaddr;
    struct hostent *hent;
    in_port_t port;
    char buf[BUFFER_SIZE];
    char *str;
    ssize_t result;
    
    if (argc != 3) {
        fprintf(stderr, "wrong number of arguments!..\n");
        exit(EXIT_FAILURE);
    }

    port = (in_port_t)strtol(argv[2], NULL, 10);

    if ((sock = socket(AF_INET, SOCK_STREAM, 0)) == -1)
        exit_sys("socket");

    sinaddr.sin_family = AF_INET;
    sinaddr.sin_port = htons(port);
    
    if ((sinaddr.sin_addr.s_addr = inet_addr(argv[1])) == INADDR_NONE) {
        if ((hent = gethostbyname(argv[1])) == NULL) 
            exit_sys("gethostbyname");
        memcpy(&sinaddr.sin_addr.s_addr, hent->h_addr_list[0], hent->h_length);
    }

    if (connect(sock, (struct sockaddr *)&sinaddr, sizeof(sinaddr)) == -1) 
        exit_sys("connect");

    printf("Connected...\n");

    for (;;) {
        printf("Yazı giriniz:");
        fgets(buf, BUFFER_SIZE, stdin);
        if ((str = strchr(buf, '\n')) != NULL)
            *str = '\0';
        if ((send(sock, buf, strlen(buf), 0)) == -1)
            exit_sys("send");
        if (!strcmp(buf, "quit"))
            break;

        if ((result = recv(sock, buf, BUFFER_SIZE, 0)) == -1)
            exit_sys("recv");
        if (result == 0)
            break;
        buf[result] = '\0';
        printf("%ld bytes received from %s (%u): %s\n", (long)result, inet_ntoa(sinaddr.sin_addr), 
                    (unsigned)ntohs(sinaddr.sin_port), buf);
    }

    /* Other stuff */

    
    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/*--------------------------------------------------------------------------------------------------------------------------
    Haberleşmenin sonunda TCP soketi nasıl kapatılmalıdır? Mademki soketler UNIX/Linux sistemlerinde birer dosya betimleyicisi gibidir
    o halde soketi kapatma işlemi close ile yapılmaktadır. Tabii yine close işlemi yapılmazsa işletim sistemi proses normal ya da
    sinyal gibi nedenlerle sonlandığında otomatik close işlemini yapar. Soket betimleyicileri de dup işlemine sokulabilir. Bu durumda
    close işlemi soket nesnesinin yok edileceği anlamına gelmez. Benzer biçimde fork işlemi sırasında da betimleyicilerin 
    çiftlendiğine dikkat ediniz. 

    Aktif soketlerin doğrudan close ile kapatılması iyi bir teknik değildir. Bu soketler önce shutdown ile haberleşmeden kesilmeli sonra close 
    işlemi uygulanmalıdır. Bu biçimde soketlerin kapatılmasına İngilizce "graceful close (zarif kapatma)" denilmektedir. Pekiyi shutdown
    fonksiyonu ne yapmaktadır ve neden gerekmektedir? close işlemi ile bir soket kapatıldığında işletim sistemi sokete ilişkin tüm veri yapılarını
    ve bağlantı bilgilerini siler. Örneğin biz karşı tarafa send ile bir şey gönderdikten hemen sonraki satırda close yaparsak artık 
    send ile gönderdiklerimizin karşı tarafa ulaşacağının hiçbir garantisi yoktur. Çünkü anımsanacağı gibi send aslında "gönderme tamponuna"
    bilgiyi yazıp geri dönmektedir. Hemen arkasından close işlemi uygulandığında artık bu sokete ilişkin gönderme ve alma tamponları da 
    yok edileceğinden tamponda gönderilmeyi bekleyen bilgiler hiç gönderilmeyebilecektir. İşte shutdown fonksiyonun üç işlevi vardır:

    1) Haberleşmeyi TCP çerçevesinde el sıkışarak sonlandırmak. 
    2) Göndeme tamponuna yazılan bilgilerin gönderildiğine emin olmak.
    3) Okuma ya da yazma işlemini sonlandırıp diğer işleme devam edebilmek. 

    shutdown fonksiyonun prototipi şöyledir:

    int shutdown(int socket, int how);

    Fonksiyonun birinci parametresi sonlandırılacak soketin betimleyicisini, ikinci parametresi biçimini belirtmektedir İkinci parametre
    şunlardan biri olarak girilebilir:

    SHUT_RD: Bu işlemden sonra artık soketten okuma yapılamaz. Fakat sokete yazma yapılabilir. Bu seçenek pek kullanılmamaktadır. 
    SHUR_WR: Burada artık shutdown daha önce gönderme tamponuna yazılmış olan byte'ların gönderilmesine kadar bloke oluşturabilir. 
    Bu işlemden sonra artık sokete yazma yapılamaz ancak okuma işlemi devam ettirilebilir. 
    SHUT_RDWR: En çok kullanılan seçenektir. Burada da artık shutdown daha önce gönderme tamponuna yazılmış olan byte'ların gönderilmesine 
    kadar bloke oluşturabilir. Artık bundan sonra soketten okuma ya da yazma yapılamamaktadır. shutdown başarı durumunda 0 değerine, başarısızlık durumunda -1
    değerine geri dönmektedir. 

    O halde aktif bir soketin kapatılması tipik olarak şöyle yapılmaktadır:

    shutdown(sock, SHUT_RDWR);
    close(sock);

    Karşı taraf soketi (peer socket) shutdown ile SHUT_WR ya da SHUT_RDWR ile sonlandrımışsa artık biz o soketten okuma yaptığımızda read ya da 
    recv fonksiyonları 0 ile geri döner. Benzer biçimde karşı taraf doğurdan soketi close ile katapmışsa yine biz recv işleminden 0 elde ederiz. 
    Karşı tarafın soketi kapatıp kapatmadığı tipik olarak recv fonksiyonunda anlaşılabilmektedir. Ancak karşı taraf soketi kapattıktan sonra biz sokete
    write ya da send ile bir şeyler yazmak istersek default durumda UNIX/Linux sistemlerinde SIGPIPE sinyali oluşmaktadır. Programcı send fonksiyonun 
    flags parametresine MSG_NOSIGNAL değerini girerse bu durumda send başarısız olmakta ve errno EPIPE değeri ile set edilmektedir. 
    Karşı taraf soketi kapatmamış ancak bağlantı kopmuş olabilir. Bu durumda send ve recv fonksiyonları -1 ile geri döner.

    Yukarıdaki programlara zarif kapatma özelliğini de ekleyebiliriz.
---------------------------------------------------------------------------------------------------------------------------*/

/* server.c */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>

#define BUFFER_SIZE     1024

char *revstr(char *str);
void exit_sys(const char *msg);

int main(int argc, char *argv[])
{
    int sock, sock_client;
    struct sockaddr_in sinaddr, sinaddr_client;
    socklen_t sinaddr_len;
    in_port_t port;
    ssize_t result;
    char buf[BUFFER_SIZE + 1];

    if (argc != 2) {
        fprintf(stderr, "wrong number of arguments!..\n");
        exit(EXIT_FAILURE);
    }

    port = (in_port_t)strtoul(argv[1], NULL, 10);

    if ((sock = socket(AF_INET, SOCK_STREAM, 0)) == -1)
        exit_sys("socket");

    sinaddr.sin_family = AF_INET;
    sinaddr.sin_port = htons(port);
    sinaddr.sin_addr.s_addr = htonl(INADDR_ANY);

    if (bind(sock, (struct sockaddr *)&sinaddr, sizeof(sinaddr)) == -1)
        exit_sys("bind");

    if (listen(sock, 8) == -1)
        exit_sys("listen");

    printf("Waiting for connection...\n");
    
    sinaddr_len = sizeof(sinaddr_client);
    if ((sock_client = accept(sock, (struct sockaddr *)&sinaddr_client, &sinaddr_len)) == -1)
        exit_sys("accept");

    printf("Connected: %s : %u\n", inet_ntoa(sinaddr_client.sin_addr), (unsigned)ntohs(sinaddr_client.sin_port));    
  
    for (;;)  {
        if ((result = recv(sock_client, buf, BUFFER_SIZE, 0)) == -1)
            exit_sys("recv");
        if (result == 0)
            break;
        buf[result] = '\0';
        if (!strcmp(buf, "quit"))
            break;
        printf("%ld bytes received from %s (%u): %s\n", (long)result, inet_ntoa(sinaddr_client.sin_addr), 
                    (unsigned)ntohs(sinaddr_client.sin_port), buf);
        revstr(buf);
        if (send(sock_client, buf, strlen(buf), 0) == -1)
            exit_sys("send");
    }
   
    shutdown(sock_client, SHUT_RDWR);
    close(sock_client);
    close(sock);
    
    return 0;
}

char *revstr(char *str)
{
    size_t i, k;
    char temp;

    for (i = 0; str[i] != '\0'; ++i)
        ;
    
    for (--i, k = 0;  k < i; ++k, --i) {
        temp = str[k];
        str[k] = str[i];
        str[i] = temp;
    }

    return str;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/* client.c */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <netdb.h>

#define BUFFER_SIZE        1024

void exit_sys(const char *msg);

int main(int argc, char *argv[])
{
    int sock;
    struct sockaddr_in sinaddr;
    struct hostent *hent;
    in_port_t port;
    char buf[BUFFER_SIZE];
    char *str;
    ssize_t result;
    
    if (argc != 3) {
        fprintf(stderr, "wrong number of arguments!..\n");
        exit(EXIT_FAILURE);
    }

    port = (in_port_t)strtol(argv[2], NULL, 10);

    if ((sock = socket(AF_INET, SOCK_STREAM, 0)) == -1)
        exit_sys("socket");

    sinaddr.sin_family = AF_INET;
    sinaddr.sin_port = htons(port);
    
    if ((sinaddr.sin_addr.s_addr = inet_addr(argv[1])) == INADDR_NONE) {
        if ((hent = gethostbyname(argv[1])) == NULL) 
            exit_sys("gethostbyname");
        memcpy(&sinaddr.sin_addr.s_addr, hent->h_addr_list[0], hent->h_length);
    }

    if (connect(sock, (struct sockaddr *)&sinaddr, sizeof(sinaddr)) == -1) 
        exit_sys("connect");

    printf("Connected...\n");

    for (;;) {
        printf("Yazı giriniz:");
        fgets(buf, BUFFER_SIZE, stdin);
        if ((str = strchr(buf, '\n')) != NULL)
            *str = '\0';
        if ((send(sock, buf, strlen(buf), 0)) == -1)
            exit_sys("send");
        if (!strcmp(buf, "quit"))
            break;

        if ((result = recv(sock, buf, BUFFER_SIZE, 0)) == -1)
            exit_sys("recv");
        if (result == 0)
            break;
        buf[result] = '\0';
        printf("%ld bytes received from %s (%u): %s\n", (long)result, inet_ntoa(sinaddr.sin_addr), 
                    (unsigned)ntohs(sinaddr.sin_port), buf);
    }

    shutdown(sock, SHUT_RDWR);
    close(sock);
    
    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/*--------------------------------------------------------------------------------------------------------------------------
    Windows sistemlerindeki soket kütüphanesine "Winsock" denilmektedir. Şu anda bu kütüphanenin 2'inci versiyonu kullanımaktadır. 
    Winsosk fonksiyonları "UNIX/Linux uyumlu" fonksiyonlar ve Windows'a özgü fonksiyonlar olmak üzere iki biçimde kullanılabilmektedir. 
    Ancak Winsock'un UNIX/Linux uyumlu fonksiyonlarında da birtakım değişiklikler söz konusudur. Bir UNIX/Linux ortamında yazılmış
    soket uygulamasının Windows sistemlerine aktarılması için şu düzeltmelerin yapılması gerekir:

    1) POSIX'in soket sistemine ilişkin tüm başlık dosyaları kaldırılır. Onun yerine <winsok2.h> dosyası include edilir. 
    2) xxx_t'li typedef türleri silinir  ve onların yerine (dokümanlara da bakabilirsiniz) int, short, unsigned int, unsigned short
    türleri kullanılır. 
    3) Windows'ta soket sisteminin ilklendirilmesi için WSAStartup fonksiyonu işin başında çağrılır ve işin sonunda da bu işlem
    WSACleanup fonksiyonuyla geri alınır. 
    4) Windows'ta dosya betimleyicisi kavramı yoktur. (Onun yerine "handle" kavramı vardır.) Dolayısıyla soket türü de int değil,
    SOCKET isimli bir typedef türüdür.
    5) shutdown fonksiyonun ikinci parametresi SD_RECEIVE, SD_SEND ve SD_BOTH biçimindedir. 
    6) close fonksiyonu yerine closesoket ile soket kapatılır. 
    7) Windows'ta soket fonksiyonları başarısızlık durumunda -1 değerine geri dönmezler. socket fonksiyonu başarısızlık durumunda
    INVALID_SOCKET değerine, diğerleri ise SOCKET_ERROR değerine geri dönmektedir. 
    8) Visual Studiko IDE'sinde default durumda "deprecated" durumlar "error"e yükseltilmiştir. Bunlar için bir sembolik sabit define edilebilmektedir. Ancak
    proje ayarlarından "sdl check" disable edilebilir. Benzer biçimde proje ayarlarından "Unicode" "not set" yapılmalıdır. 
    9) Projenin linker ayarlarından Input/Additional Dependencies edit alanına Winsock kütüphanesi olan "Ws2_32.lib" import kütüphanesi eklenir. 

    Yukarıdaki programların Winsock'a dönüştürülmüş biçimleri aşağıda verilmiştir.
---------------------------------------------------------------------------------------------------------------------------*/

/* server.c */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <WinSock2.h>

#define BUFFER_SIZE     1024

char* revstr(char* str);
void exit_sys(LPCSTR lpszMsg, int status, DWORD dwLastError);

int main(int argc, char* argv[])
{
    SOCKET sock, sock_client;
    struct sockaddr_in sinaddr, sinaddr_client;
    int sinaddr_len;
    unsigned short port;
    int result;
    char buf[BUFFER_SIZE + 1];
    WSADATA wsadata;

    if ((result = WSAStartup(MAKEWORD(2, 2), &wsadata)) != 0)
        exit_sys("WSAStartup", EXIT_FAILURE, result);

    if (argc != 2) {
        fprintf(stderr, "wrong number of arguments!..\n");
        exit(EXIT_FAILURE);
    }

    port = (unsigned short)strtoul(argv[1], NULL, 10);

    if ((sock = socket(AF_INET, SOCK_STREAM, 0)) == INVALID_SOCKET)
        exit_sys("socket", EXIT_FAILURE, WSAGetLastError());

    sinaddr.sin_family = AF_INET;
    sinaddr.sin_port = htons(port);
    sinaddr.sin_addr.s_addr = htonl(INADDR_ANY);

    if (bind(sock, (struct sockaddr*)&sinaddr, sizeof(sinaddr)) == SOCKET_ERROR)
        exit_sys("bind", EXIT_FAILURE, WSAGetLastError());

    if (listen(sock, 8) == -1)
        exit_sys("listen", EXIT_FAILURE, WSAGetLastError());

    printf("Waiting for connection...\n");

    sinaddr_len = sizeof(sinaddr_client);
    if ((sock_client = accept(sock, (struct sockaddr*)&sinaddr_client, &sinaddr_len)) == SOCKET_ERROR)
        exit_sys("accept", EXIT_FAILURE, WSAGetLastError());

    printf("Connected: %s : %u\n", inet_ntoa(sinaddr_client.sin_addr), (unsigned)ntohs(sinaddr_client.sin_port));

    for (;;) {
        if ((result = recv(sock_client, buf, BUFFER_SIZE, 0)) == -1)
            exit_sys("recv", EXIT_FAILURE, WSAGetLastError());
        if (result == 0)
            break;
        buf[result] = '\0';
        if (!strcmp(buf, "quit"))
            break;
        printf("%ld bytes received from %s (%u): %s\n", (long)result, inet_ntoa(sinaddr_client.sin_addr),
            (unsigned)ntohs(sinaddr_client.sin_port), buf);
        revstr(buf);
        if (send(sock_client, buf, strlen(buf), 0) == -1)
            exit_sys("send", EXIT_FAILURE, WSAGetLastError());
    }

    shutdown(sock_client, SD_BOTH);
    closesocket(sock_client);
    closesocket(sock);

    WSACleanup();

    return 0;
}

char *revstr(char* str)
{
    size_t i, k;
    char temp;

    for (i = 0; str[i] != '\0'; ++i)
        ;

    for (--i, k = 0; k < i; ++k, --i) {
        temp = str[k];
        str[k] = str[i];
        str[i] = temp;
    }

    return str;
}

void exit_sys(LPCSTR lpszMsg, int status, DWORD dwLastError)
{
    LPTSTR lpszErr;

    if (FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM, NULL, dwLastError,
        MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), (LPTSTR)&lpszErr, 0, NULL)) {
        fprintf(stderr, "%s: %s", lpszMsg, lpszErr);
        LocalFree(lpszErr);
    }

    exit(status);
}

/* client.c */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <WinSock2.h>

#define BUFFER_SIZE        1024

void exit_sys(LPCSTR lpszMsg, int status, DWORD dwLastError);

int main(int argc, char* argv[])
{
    SOCKET sock;
    WSADATA wsadata;
    struct sockaddr_in sinaddr;
    struct hostent* hent;
    unsigned short port;
    char buf[BUFFER_SIZE];
    char *str;
    int result;

    if (argc != 3) {
        fprintf(stderr, "wrong number of arguments!..\n");
        exit(EXIT_FAILURE);
    }

    port = (unsigned short)strtol(argv[2], NULL, 10);

    if ((result = WSAStartup(MAKEWORD(2, 2), &wsadata)) != 0)
        exit_sys("WSAStartup", EXIT_FAILURE, result);

    if ((sock = socket(AF_INET, SOCK_STREAM, 0)) == INVALID_SOCKET)
        exit_sys("socket", EXIT_FAILURE, WSAGetLastError());

    sinaddr.sin_family = AF_INET;
    sinaddr.sin_port = htons(port);

    if ((sinaddr.sin_addr.s_addr = inet_addr(argv[1])) == INADDR_NONE) {
        if ((hent = gethostbyname(argv[1])) == NULL)
            exit_sys("gethostbyname", EXIT_FAILURE, WSAGetLastError());
        memcpy(&sinaddr.sin_addr.s_addr, hent->h_addr_list[0], hent->h_length);
    }

    if (connect(sock, (struct sockaddr*)&sinaddr, sizeof(sinaddr)) == SOCKET_ERROR)
        exit_sys("connect", EXIT_FAILURE, WSAGetLastError());

    printf("Connected...\n");

    for (;;) {
        printf("Yazı giriniz:");
        fgets(buf, BUFFER_SIZE, stdin);
        if ((str = strchr(buf, '\n')) != NULL)
            *str = '\0';
        if ((send(sock, buf, strlen(buf), 0)) == SOCKET_ERROR)
            exit_sys("send", EXIT_FAILURE, WSAGetLastError());
        if (!strcmp(buf, "quit"))
            break;

        if ((result = recv(sock, buf, BUFFER_SIZE, 0)) == SOCKET_ERROR)
            exit_sys("recv", EXIT_FAILURE, WSAGetLastError());
        if (result == 0)
            break;
        buf[result] = '\0';
        printf("%ld bytes received from %s (%u): %s\n", (long)result, inet_ntoa(sinaddr.sin_addr),
            (unsigned)ntohs(sinaddr.sin_port), buf);
    }

    shutdown(sock, SD_BOTH);
    closesocket(sock);

    WSACleanup();

    return 0;
}

void exit_sys(LPCSTR lpszMsg, int status, DWORD dwLastError)
{
    LPTSTR lpszErr;

    if (FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM, NULL, dwLastError,
        MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), (LPTSTR)&lpszErr, 0, NULL)) {
        fprintf(stderr, "%s: %s", lpszMsg, lpszErr);
        LocalFree(lpszErr);
    }

    exit(status);
}

/*--------------------------------------------------------------------------------------------------------------------------
    Daha önce write/send ve read/recv fonksiyonlarının davranışları hakkında temel bazı şeyler şöylemiştik. Şimdi biraz ayyrıntılandıralım. 
    POSIX standartlarına göre send fonksiyonu blokeli modda bloke garantisi vermektedir. Yani örneğin gönderme tamponunda 10 byte'lık boş bir
    alan varsa fakat biz write/send ile 100 byte göndermeye çalışıyorsak blokeli modda send bu 100 byte'ın tamamını tampona yazana kadar 
    blokede bekler. Böylece send genel olarak bizim yazmak istediğimiz byte miktarına geri dönmektedir. Ancak bu davranış eskiden tam böyle değildi.
    Windows sistemlerinde de tam böyle değildir. Windows sistemlerinde send fonksiyonu eğer gönderme tamponu tüm gönderilecek bilgiyi alamayacak
    biçimde doluysa send blokeye yol açmayabilmektedir. Böylece Windows sistemlerinde send talep edilenden daha düşük bir değerle 
    geri dönebilmektedir. Blokesiz modda POSIX standartlarına göre send fonksiyonu yine kısmi yazıma izin vermemektedir. Örneğin göönderme 
    tamponunda yine 10 byte boşluk olsun. Biz de blokesiz modda 100 byte göndermek isteyelim. Bu durumda send tüm bilgileri tampona yazamayacaksa
    hiçbirini yazmaz ve -1 ile geri döner. errono EAGAIN değeri ile set edilir. 

    read/recv fonksiyonları daha önceden belirtildiği gibi blokeli modda eğer alma tamponu tamamen boş ise blokeye yol açmaktadır. Alma 
    tamponunda en az 1 byte varsa read/recv bloke oluşturmaz olanı okur ve geri döner. Blokesiz modda write/recv tampon boşsa bile blokeye 
    yol açmamaktadır. Bu durumda bu fonksiyonlar -1 ile geri dönerler ve errno EAGAIN değeriyşe set edilir. 

    Yukarıda da belirtildiği gibi karşı taraf shutdown uygulamışsa ya da soketi kapatmışsa read/recv 0 ile geri döner. Başka diğer
    hatalarda (örneğin bağlantı kopması) bu fonksiyonlar başarısz olup -1 ile geri dönerler. 
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Zamanla bazı klasik soket fonksiyonları yerine onların işlevini yapabilecek daha yetenekli fonksiyonlar oluşturulmuştur. 
    Eski fonksiyonlar IPV4 zamanlarında tasarlanmıştı. IPV6 için bunların bazılarının farklı isimli biçimleri devreye sokuldu.
    En sonunda hem IPV4'te hem de IPV6 da çalışacak daha yetenekli fonksiyonlar tasarlandı. Programlarınızda bunları kullanmanız
    artık daha uygun olabilir. 

    inet_ntoa fonksiyonu bilindiği gibi noktalı desimal formattaki IP adresini 4 byte'lık IPV4 formuna dönüştürüyordu.
    İşte bu fonksiyonun inet_ptop isimli IPV6'yı da kapsayan gelişmiş biçimi vardır:

    const char *inet_ntop(int af, const void *src, char *dst, socklen_t size);
    
    Fonksiyonun birinci parametresi AF_INET (IPV4) ya da AF_INET& (IPV6) olarak girilmelidir. İkinci parametre nümerik IPV4 ya da IPV6
    adresinin bulunduğu adresi belirtmektedir. Fonksiyon yazısal noktalı desimal formatı üçüncü parametresiyle belirtilen
    adrese yerleştirir. Son parametre üçüncü parametredeki dizinin uzunluğunu belirtir. Bu parametre INET_ADDRSTRLEN ya da INET6_ADDRSTRLEN
    biçiminde girilebilir. Fonksiyon başarı durumunda üçüncü parametreyle belirtilen adrese başarısızlık durumunda NULLL adrese
    geri döner.Örneğin:

    char ntopbuf[INET_ADDRSTRLEN];
    ...
    printf("Connected: %s : %u\n", inet_ntop(AF_INET, &sinaddr_client.sin_addr, ntopbuf, INET_ADDRSTRLEN), (unsigned)ntohs(sinaddr_client.sin_port));    
  
    inet_ntoa işleminin tersinin inet_addr ile yapıldığını belirtmiştik. İşte inet_addr fonksiyonunun yerine hem IPV4 hem de IPV6 ielk çalışan 
    inet_ptoa fonksiyonu kullanılabilmektedir:

    int inet_pton(int af, const char *src, void *restrict dst);

    Fonksiyonun birinci parametresi yine AF_INET ya da AF_INET6 biçiminde geçilir. İkinci parametre noktalı desimal formatın bulunduğu 
    yazının adresini üçüncü parametre ise nümerik adresin yerleştirileceği adrsi almaktadır. Fonksiyon başarı durumunda 1 değerine, başarısızlık 
    durumundurumunda 0 ya da -1 değerine geri döner. Başarısızlık birinci parametreden kaynaklanıyorsa -1, ikinci parametreden yanaklanıyorsa 0)
    Bu durumda örneğin client programda inet_addr yerine inet_ptoa fonksiyonunu şöyle çağırabilirdik:

    
    if (inet_pton(AF_INET, argv[1], &sinaddr.sin_addr.s_addr) == 0) {
       ...
    }

    IPV6 ile birlikte yeni gelen diğer bir fonksiyon da getaddrinfo isimli fonksiyondur. Bu fonksiyonaslında inet_addr ve gethosybyname
    fonksiyonlarının IPV6'yı da içerecek biçimde genişletilmiş bir biçimidir. Yani getaddrinfo hem noktalı desimal formatı nümerik adrese
    dönüşürür hem de eğer isim söz konusuysa DNS işlemi yaparak ilgili host'un IP adresini elde eder. Maalesef fonksiyon biraz karışık tasarlanmıştır.
    Fonksiyonun prototipi şöyledir:

    int getaddrinfo(const char *node, const char *service, const struct addrinfo *hints, struct addrinfo **res);

    Fonksiyonun birinci parametres, "noktalı desimal formatlı IP adresi" ya da "host ismi"dir. İkinci parametre NULL geçilebilir ya da
    buraya port numarası girilebilir. Ancak bu port numarası girilecekse yazısal girilmelidir. Fonksiyon kendisi bu pro numarasını
    htons yaparak Big Endian formata dönüştürüp bize verecektir. Bu parametre IP ailesinin uygulama katmanına ilişkin spesifik bir protokol
    ismi olarak da girilebilmektedir (Örneğin "http" gibi). Eper bu parametre NULL girilirse bize port olarak 0 verilir. Fonksiyonun üçüncü
    parametresi nasıl bir adres istediğimizi anlatan filtreleme seçeneklerini belirtir. Bu parametre addrinfo isimli bir yapı türündendir. 
    Bu yapının yalnızca ilk dört elemanı programcı tarafından girilebilmektedir. Ancak POSIX standartları bu yapının elemanlarının sıfırlanmasını
    öngörmektedir (sıfırlanmak normal tirler için bit 0, göstericiler için NULL adres). Yapı şöyledir:

    struct addrinfo {
        int              ai_flags;
        int              ai_family;
        int              ai_socktype;
        int              ai_protocol;
        socklen_t        ai_addrlen;
        struct sockaddr *ai_addr;
        char            *ai_canonname;
        struct addrinfo *ai_next;
    };

    Yapının ai_flags elemanı pek çok bayrak değeri alabilmektedir. Bu değer 0 olarak da geçilebilir. Yapının ai_family elemanı AF_INET girilirse 
    host'a ilişkin IPV4 adresleri, AF_INET6 girilirse IPV6 adresleri AF_UNSPEC girilirse hem IPV4 hem de IPV6 adresleri elde edilir. 
    Yapının ai_socktype elemanı 0 girilebilir ya da SOCK_STREAM veya SOCK_DGRAM girilebilir. Fonksiyonun ayrıntılı açıklaması için dokümanlara
    başvurunuz. 

    getaddrinfo fonksiyonun son parametresine bir bağlı listenin ilk elemanını gösteren adres yerleştirilmektedir. Buradaki bağlı listenin
    bağ elemanı sturct addrinfo yapısının ai_next elemanıdır. Bu bağlı listenin boşaltımı freeaddrinfo fonksiyonu tarafından yapılmaktadır. 

    getaddrinfo fonksiyonu başarı durumunda 0 değerine başarısızlık durumunda error koduna geri döner. Bu error kodları klasik errno değerlerinden 
    farklı olduğu için streerror fonksiyonuyla değil gai_strerror fonksiyonuyla yazıya dönüştürülmelidir. 

    getaddrinfo fonksiyonun tersini yapan getnameinfo isminde bir fonksiyon da sonraları soket kütüphanesine eklenmiştir. getnameinfo aslında inet_ntop, 
    getserverbyname (biz görmekdik) fonksiyonlarının bileşimi gibidir. Biz aşağıdaki örnekte bu fonksiyonu kullanmayacağız. 

    int getnameinfo(const struct sockaddr *addr, socklen_t addrlen, char *host, socklen_t hostlen, char *serv, socklen_t servlen, int flags);

    Fonksiyonun birinci parametresi sockaddr_in ya da sockaddr_in6 yapısıdır. İkinci parametre birinci parametredeki yapının uzunluğudur. 
    Fonksiyonun sonraki dört parametresi sırasıyla noktalı hostun yazısal temsilin yerleştirileeği dizinin adresi ve uzunluğu, port numarasına ilişkin 
    yazının (servis ismi) yerleştirileceği dizinin adresi ve uzunluğudur. Son parametre 0 geçilebilir. Maksimum host ismi NI_MAXHOST ile
    maksimum servis ismi ise NI_MAXSERV ile belirtilmiştir. 

    Aşağıda daha önce yazmış olduğumuz server'ın bu yeni fonksiyonlarla yazılmış halini görüyorsunuz. 
---------------------------------------------------------------------------------------------------------------------------*/

/* server.c */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>

#define BUFFER_SIZE     1024

char *revstr(char *str);
void exit_sys(const char *msg);

int main(int argc, char *argv[])
{
    int sock, sock_client;
    struct sockaddr_in sinaddr, sinaddr_client;
    socklen_t sinaddr_len;
    char ntopbuf[INET_ADDRSTRLEN];
    in_port_t port;
    ssize_t result;
    char buf[BUFFER_SIZE + 1];

    if (argc != 2) {
        fprintf(stderr, "wrong number of arguments!..\n");
        exit(EXIT_FAILURE);
    }

    port = (in_port_t)strtoul(argv[1], NULL, 10);

    if ((sock = socket(AF_INET, SOCK_STREAM, 0)) == -1)
        exit_sys("socket");

    sinaddr.sin_family = AF_INET;
    sinaddr.sin_port = htons(port);
    sinaddr.sin_addr.s_addr = htonl(INADDR_ANY);

    if (bind(sock, (struct sockaddr *)&sinaddr, sizeof(sinaddr)) == -1)
        exit_sys("bind");

    if (listen(sock, 8) == -1)
        exit_sys("listen");

    printf("Waiting for connection...\n");
    
    sinaddr_len = sizeof(sinaddr_client);
    if ((sock_client = accept(sock, (struct sockaddr *)&sinaddr_client, &sinaddr_len)) == -1)
        exit_sys("accept");

    printf("Connected: %s : %u\n", inet_ntop(AF_INET, &sinaddr_client.sin_addr, ntopbuf, INET_ADDRSTRLEN), (unsigned)ntohs(sinaddr_client.sin_port));    
  
    for (;;)  {
        if ((result = recv(sock_client, buf, BUFFER_SIZE, 0)) == -1)
            exit_sys("recv");
        if (result == 0)
            break;
        buf[result] = '\0';
        if (!strcmp(buf, "quit"))
            break;
        printf("%ld bytes received from %s (%u): %s\n", (long)result, ntopbuf, (unsigned)ntohs(sinaddr_client.sin_port), buf);
        revstr(buf);
        if (send(sock_client, buf, strlen(buf), 0) == -1)
            exit_sys("send");
    }
   
    shutdown(sock_client, SHUT_RDWR);
    close(sock_client);
    close(sock);
    
    return 0;
}

char *revstr(char *str)
{
    size_t i, k;
    char temp;

    for (i = 0; str[i] != '\0'; ++i)
        ;
    
    for (--i, k = 0;  k < i; ++k, --i) {
        temp = str[k];
        str[k] = str[i];
        str[i] = temp;
    }

    return str;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/* client.c */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <netdb.h>

#define BUFFER_SIZE        1024

void exit_sys(const char *msg);

int main(int argc, char *argv[])
{
    int sock;
    struct addrinfo *ai, *ri;
    struct addrinfo hints = {0};
    char buf[BUFFER_SIZE];
    char *str;
    ssize_t result;
    int sresult;
    
    if (argc != 3) {
        fprintf(stderr, "wrong number of arguments!..\n");
        exit(EXIT_FAILURE);
    }
    
    if ((sock = socket(AF_INET, SOCK_STREAM, 0)) == -1)
        exit_sys("socket");

    hints.ai_family = AF_INET;
    hints.ai_socktype = SOCK_STREAM;

    if ((sresult = getaddrinfo(argv[1], argv[2], &hints, &ai)) != 0) {
        fprintf(stderr, "getaddrinfo: %s\n", gai_strerror(sresult));
        exit(EXIT_FAILURE);
    }

    for (ri = ai; ri != NULL; ri = ri->ai_next) 
        if (connect(sock, ri->ai_addr, ri->ai_addrlen) != -1) 
            break;
        
    if (ri == NULL)
        exit_sys("connect");

    freeaddrinfo(ai);

    printf("Connected...\n");

    for (;;) {
        printf("Yazı giriniz:");
        fgets(buf, BUFFER_SIZE, stdin);
        if ((str = strchr(buf, '\n')) != NULL)
            *str = '\0';
        if ((send(sock, buf, strlen(buf), 0)) == -1)
            exit_sys("send");
        if (!strcmp(buf, "quit"))
            break;

        if ((result = recv(sock, buf, BUFFER_SIZE, 0)) == -1)
            exit_sys("recv");
        if (result == 0)
            break;
        buf[result] = '\0';
        printf("%ld bytes received from %s (%s): %s\n", (long)result, argv[1], argv[2], buf);
    }

    shutdown(sock, SHUT_RDWR);
    close(sock);
    
    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/*--------------------------------------------------------------------------------------------------------------------------
    Tıpkı borularda olduğu gibi çok clieent'lı TCP server programları birden fazla client'tan gelen bilgileri okuyabilmelidir. 
    Budurumda server programın organizasyonu client programlara göre daha zor olmaktadır. Buradaki server problemi yine şöyledir:
    Server bir client için recv yaparken eğer o soketin alma tamponu boşsa bloke oluşur. Bu durumda maalesef diğer client'lardan 
    gelmiş olan bilgileri okuyamaz. İşte bu tür durumlarda tıpkı daha önce borular için yaptığımız "ileri io modelleri" kullanılmalıdır.

    Şüphesiz en basit çok client'lı organizasyon fork organizasyonudur. Şöyle ki bu organizasyonda server her client bağlantısı 
    sağlandığında fork yapar, böylece her client ile aslında ayrı bir proses konuşmuş olur. Şüphesiz her client bağlantısında bir 
    prosesin oluşturulması verimli bir yöntem değildir. Bu öntemi uygularken üst prosesin otomatik zombie engelleme yapması gerekir. 
    Çünkü üst proses hep accept işleminde bloke bekleyeceğine göre alt prosesi zombie'likten kurtaramaz.

    Aşağıda böyle bir fork modeli örneği verilmiştir
---------------------------------------------------------------------------------------------------------------------------*/

/* server.c */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>

#define BUFFER_SIZE     1024

char *revstr(char *str);
void exit_sys(const char *msg);

int main(int argc, char *argv[])
{
    int sock, sock_client;
    struct sockaddr_in sinaddr, sinaddr_client;
    socklen_t sinaddr_len;
    char ntopbuf[INET_ADDRSTRLEN];
    in_port_t port;
    ssize_t result;
    char buf[BUFFER_SIZE + 1];
    pid_t pid;

    if (argc != 2) {
        fprintf(stderr, "wrong number of arguments!..\n");
        exit(EXIT_FAILURE);
    }

    port = (in_port_t)strtoul(argv[1], NULL, 10);

    if ((sock = socket(AF_INET, SOCK_STREAM, 0)) == -1)
        exit_sys("socket");

    sinaddr.sin_family = AF_INET;
    sinaddr.sin_port = htons(port);
    sinaddr.sin_addr.s_addr = htonl(INADDR_ANY);

    if (bind(sock, (struct sockaddr *)&sinaddr, sizeof(sinaddr)) == -1)
        exit_sys("bind");

    if (listen(sock, 8) == -1)
        exit_sys("listen");

    printf("Waiting for connection...\n");
    
    for (;;)  {
        sinaddr_len = sizeof(sinaddr_client);
        if ((sock_client = accept(sock, (struct sockaddr *)&sinaddr_client, &sinaddr_len)) == -1)
            exit_sys("accept");

        printf("Connected: %s : %u\n", inet_ntop(AF_INET, &sinaddr_client.sin_addr, ntopbuf, INET_ADDRSTRLEN), (unsigned)ntohs(sinaddr_client.sin_port));    

        if ((pid = fork()) == -1)
            exit_sys("fork");
        if (pid == 0) {
            for(;;) {
                if ((result = recv(sock_client, buf, BUFFER_SIZE, 0)) == -1)
                    exit_sys("recv");
                if (result == 0)
                    break;
                buf[result] = '\0';
                if (!strcmp(buf, "quit"))
                    break;
                 printf("%ld bytes received from %s (%u): %s\n", (long)result, ntopbuf, (unsigned)ntohs(sinaddr_client.sin_port), buf);
                revstr(buf);
                if (send(sock_client, buf, strlen(buf), 0) == -1)
                    exit_sys("send");
            }
            shutdown(sock_client, SHUT_RDWR);
            close(sock_client);
            exit(EXIT_SUCCESS);
        }
    }
    
    close(sock);
    
    return 0;
}

char *revstr(char *str)
{
    size_t i, k;
    char temp;

    for (i = 0; str[i] != '\0'; ++i)
        ;
    
    for (--i, k = 0;  k < i; ++k, --i) {
        temp = str[k];
        str[k] = str[i];
        str[i] = temp;
    }

    return str;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/* client.c */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <netdb.h>

#define BUFFER_SIZE        1024

void exit_sys(const char *msg);

int main(int argc, char *argv[])
{
    int sock;
    struct addrinfo *ai, *ri;
    struct addrinfo hints = {0};
    char buf[BUFFER_SIZE];
    char *str;
    ssize_t result;
    int sresult;
    
    if (argc != 3) {
        fprintf(stderr, "wrong number of arguments!..\n");
        exit(EXIT_FAILURE);
    }
    
    if ((sock = socket(AF_INET, SOCK_STREAM, 0)) == -1)
        exit_sys("socket");

    hints.ai_family = AF_INET;
    hints.ai_socktype = SOCK_STREAM;

    if ((sresult = getaddrinfo(argv[1], argv[2], &hints, &ai)) != 0) {
        fprintf(stderr, "getaddrinfo: %s\n", gai_strerror(sresult));
        exit(EXIT_FAILURE);
    }

    for (ri = ai; ri != NULL; ri = ri->ai_next) 
        if (connect(sock, ri->ai_addr, ri->ai_addrlen) != -1) 
            break;
    
    if (ri == NULL)
        exit_sys("connect");

    freeaddrinfo(ai);

    printf("Connected...\n");

    for (;;) {
        printf("Yazı giriniz:");
        fgets(buf, BUFFER_SIZE, stdin);
        if ((str = strchr(buf, '\n')) != NULL)
            *str = '\0';
        if ((send(sock, buf, strlen(buf), 0)) == -1)
            exit_sys("send");
        if (!strcmp(buf, "quit"))
            break;

        if ((result = recv(sock, buf, BUFFER_SIZE, 0)) == -1)
            exit_sys("recv");
        if (result == 0)
            break;
        buf[result] = '\0';
        printf("%ld bytes received from %s (%s): %s\n", (long)result, argv[1], argv[2], buf);
    }

    shutdown(sock, SHUT_RDWR);
    close(sock);
    
    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/*--------------------------------------------------------------------------------------------------------------------------
    Yukarıdaki açıkladığımız fork modeli en basit model olmakla birlikte en verimsiz modeldir. Her client bağlantısında 
    bir prosesin yaratılması client sayısı arttıkça sistemde yük oluşturur. Tabii fork modeli az client için uygulanabilecek bir
    modeldir. Ancak burada server client'lara müdahale edemez. Çünkü her server her client için ayrı proses yaratmıştır. 
    İşte fork modeli yerine thread modeli her bakımdan daha etkindir. Bu modelde server her client bağlantısında bir proses değil thread yaratır. 

    Aşağıda thread modeline ilişkin örnek görülmektedir.
---------------------------------------------------------------------------------------------------------------------------*/

/* server.c */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <pthread.h>

typedef struct {
    int sock;
    struct sockaddr_in sinaddr;
    char ntopbuf[INET_ADDRSTRLEN];
} CLIENT_INFO;

#define BUFFER_SIZE     1024

void *client_proc(void *param);
char *revstr(char *str);
void exit_sys(const char *msg);

int main(int argc, char *argv[])
{
    int sock, sock_client;
    struct sockaddr_in sinaddr, sinaddr_client;
    socklen_t sinaddr_len;
    in_port_t port;
    ssize_t result;
    CLIENT_INFO *ci;
    pthread_t tid;

    if (argc != 2) {
        fprintf(stderr, "wrong number of arguments!..\n");
        exit(EXIT_FAILURE);
    }

    port = (in_port_t)strtoul(argv[1], NULL, 10);

    if ((sock = socket(AF_INET, SOCK_STREAM, 0)) == -1)
        exit_sys("socket");

    sinaddr.sin_family = AF_INET;
    sinaddr.sin_port = htons(port);
    sinaddr.sin_addr.s_addr = htonl(INADDR_ANY);

    if (bind(sock, (struct sockaddr *)&sinaddr, sizeof(sinaddr)) == -1)
        exit_sys("bind");

    if (listen(sock, 8) == -1)
        exit_sys("listen");

    printf("Waiting for connection...\n");
    
    for (;;) {
        sinaddr_len = sizeof(sinaddr_client);
        if ((sock_client = accept(sock, (struct sockaddr *)&sinaddr_client, &sinaddr_len)) == -1)
            exit_sys("accept");

        if ((ci = (CLIENT_INFO *)malloc(sizeof(CLIENT_INFO))) == NULL) 
            exit_sys("malloc");

        ci->sock = sock_client;
        ci->sinaddr = sinaddr_client;
        inet_ntop(AF_INET, &sinaddr_client.sin_addr, ci->ntopbuf, INET_ADDRSTRLEN);

        printf("Connected: %s : %u\n", ci->ntopbuf, (unsigned)ntohs(sinaddr_client.sin_port));    
       
        if ((result = pthread_create(&tid, NULL, client_proc, ci)) != 0) {
            fprintf(stderr, "pthread_create: %s\n", strerror(result));
            exit(EXIT_FAILURE);
        }   
        if ((result = pthread_detach(tid)) != 0) {
            fprintf(stderr, "pthread_detach: %s\n", strerror(result));
            exit(EXIT_FAILURE);
        }
    }
   
    close(sock);
    
    return 0;
}

void *client_proc(void *param)
{
    CLIENT_INFO *ci = (CLIENT_INFO *)param;
    char buf[BUFFER_SIZE + 1];
    ssize_t result;

    for (;;)  {
        if ((result = recv(ci->sock, buf, BUFFER_SIZE, 0)) == -1)
            exit_sys("recv");
        if (result == 0)
            break;
        buf[result] = '\0';
        if (!strcmp(buf, "quit"))
            break;
        printf("%ld bytes received from %s (%u): %s\n", (long)result, ci->ntopbuf, (unsigned)ntohs(ci->sinaddr.sin_port), buf);
        revstr(buf);
        if (send(ci->sock, buf, strlen(buf), 0) == -1)
            exit_sys("send");
    }

    shutdown(ci->sock, SHUT_RDWR);
    close(ci->sock);

    free(ci);

    return NULL;
}

char *revstr(char *str)
{
    size_t i, k;
    char temp;

    for (i = 0; str[i] != '\0'; ++i)
        ;
    
    for (--i, k = 0;  k < i; ++k, --i) {
        temp = str[k];
        str[k] = str[i];
        str[i] = temp;
    }

    return str;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/* client.c */

/* server.c */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>

#define BUFFER_SIZE     1024

char *revstr(char *str);
void exit_sys(const char *msg);

int main(int argc, char *argv[])
{
    int sock, sock_client;
    struct sockaddr_in sinaddr, sinaddr_client;
    socklen_t sinaddr_len;
    char ntopbuf[INET_ADDRSTRLEN];
    in_port_t port;
    ssize_t result;
    char buf[BUFFER_SIZE + 1];

    if (argc != 2) {
        fprintf(stderr, "wrong number of arguments!..\n");
        exit(EXIT_FAILURE);
    }

    port = (in_port_t)strtoul(argv[1], NULL, 10);

    if ((sock = socket(AF_INET, SOCK_STREAM, 0)) == -1)
        exit_sys("socket");

    sinaddr.sin_family = AF_INET;
    sinaddr.sin_port = htons(port);
    sinaddr.sin_addr.s_addr = htonl(INADDR_ANY);

    if (bind(sock, (struct sockaddr *)&sinaddr, sizeof(sinaddr)) == -1)
        exit_sys("bind");

    if (listen(sock, 8) == -1)
        exit_sys("listen");

    printf("Waiting for connection...\n");
    
    sinaddr_len = sizeof(sinaddr_client);
    if ((sock_client = accept(sock, (struct sockaddr *)&sinaddr_client, &sinaddr_len)) == -1)
        exit_sys("accept");

    printf("Connected: %s : %u\n", inet_ntop(AF_INET, &sinaddr_client, ntopbuf, INET_ADDRSTRLEN), (unsigned)ntohs(sinaddr_client.sin_port));    
  
    for (;;)  {
        if ((result = recv(sock_client, buf, BUFFER_SIZE, 0)) == -1)
            exit_sys("recv");
        if (result == 0)
            break;
        buf[result] = '\0';
        if (!strcmp(buf, "quit"))
            break;
        printf("Connected: %s : %u\n", inet_ntop(AF_INET, &sinaddr_client, ntopbuf, INET_ADDRSTRLEN), (unsigned)ntohs(sinaddr_client.sin_port));    
        revstr(buf);
        if (send(sock_client, buf, strlen(buf), 0) == -1)
            exit_sys("send");
    }
   
    shutdown(sock_client, SHUT_RDWR);
    close(sock_client);
    close(sock);
    
    return 0;
}

char *revstr(char *str)
{
    size_t i, k;
    char temp;

    for (i = 0; str[i] != '\0'; ++i)
        ;
    
    for (--i, k = 0;  k < i; ++k, --i) {
        temp = str[k];
        str[k] = str[i];
        str[i] = temp;
    }

    return str;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}


/*--------------------------------------------------------------------------------------------------------------------------
    Çok client'lı server soketler için en çok kullanılan modellerden biri "select modeli"dir. Bu model hem UNIX/Linux hem de
    Windows sistemlerine kullanılabilmektedir. Bu model şöyle özetlenebilir:

    1) Önce select fonksiyonunun için "read set" parametresi için içib oş bir fd_set nesnesi yaratılır. 
    2) Dinleme soketi (pasif soket) yaratılır, bind işlemi uygulanır ve bu soket "read set" içerisinde FD_SET ile eklenir. 
    Artık dinleme soketinde bir bağlantı isteği olduğunda sanki  bir okuma durumu oluşmuş gibi select blokesi çözülecektir. 
    Eğer select'in blokesi dinleme soketi yüzünden çözülmüşse o noktada bizin accept işlemini yapmamız gerekir. 
    3) accept işlemiyle bir client ile bağlantı sağlandığında bu client'ın soketi de "read set" içerisine eklenir. Böylece artık
    "read set" içerisinde hem dinleme soketi hem de de client soketler bulunur. 
    4) Program bir döngü içerisinde select fonksiyonun çağrılması biçiminde oluşturulur. select'in blokesi çözüldüğünde hangi sokette
    okuma eyleminin oluştuğuna bakılır. Eğer dinleme soketinde okuma eylemi oluşmuşsa bu noktada yukarıda da belirtildiği gibi accepy yapılmalıdır,
    eğer bir client sokette okuma eylemi oluşmuşsa o client soketten read/recv yapılır. 
    5) Bir client close ya da shutdown uyguladığında bu da select için bir okuma eylemi oluşmuş gibi ele alınır. Bu durumda programcı read/recv 
    yapacak ve buradan eğer 0 değeri elde ederse karşı tarafın soketi kapattıonı anlayacaktır. Artık programcının bu noktada ilgili client soketi kapatıp
    onu "read set" kümesinden çıkartması gerekir. 

    Aşağıda bir select server modeli görülmektedir.
---------------------------------------------------------------------------------------------------------------------------*/

/* server.c */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <sys/select.h>

#define BUFFER_SIZE     1024

char *revstr(char *str);
void exit_sys(const char *msg);

int main(int argc, char *argv[])
{
    int sock, sock_client;
    struct sockaddr_in sinaddr, sinaddr_client;
    socklen_t sinaddr_len;
    char ntopbuf[INET_ADDRSTRLEN];
    in_port_t port;
    ssize_t result;
    char buf[BUFFER_SIZE + 1];
    fd_set rset, tset;
    int maxfd;
    int i;

    if (argc != 2) {
        fprintf(stderr, "wrong number of arguments!..\n");
        exit(EXIT_FAILURE);
    }

    port = (in_port_t)strtoul(argv[1], NULL, 10);
    FD_ZERO(&rset);

    if ((sock = socket(AF_INET, SOCK_STREAM, 0)) == -1)
        exit_sys("socket");

    sinaddr.sin_family = AF_INET;
    sinaddr.sin_port = htons(port);
    sinaddr.sin_addr.s_addr = htonl(INADDR_ANY);

    if (bind(sock, (struct sockaddr *)&sinaddr, sizeof(sinaddr)) == -1)
        exit_sys("bind");

    FD_SET(sock, &rset);
    maxfd = sock;

    if (listen(sock, 8) == -1)
        exit_sys("listen");

    printf("Waiting for connection...\n");
    
    for (;;) {
        tset = rset;
        if (select(maxfd + 1, &tset, NULL, NULL, NULL) == -1)
            exit_sys("select");
        for (i = 0; i <= maxfd; ++i) 
            if (FD_ISSET(i, &tset)) {
                if (i == sock) {
                    sinaddr_len = sizeof(sinaddr_client);
                    if ((sock_client = accept(sock, (struct sockaddr *)&sinaddr_client, &sinaddr_len)) == -1)
                        exit_sys("accept");

                    inet_ntop(AF_INET, &sinaddr_client.sin_addr, ntopbuf, INET_ADDRSTRLEN);
                    printf("Connected: %s : %u\n", ntopbuf, (unsigned)ntohs(sinaddr_client.sin_port));    
                    FD_SET(sock_client, &rset);
                    if (sock_client > maxfd)
                        maxfd = sock_client;
                    continue;
                }
                
                if ((result = recv(i, buf, BUFFER_SIZE, 0)) == -1)
                    exit_sys("recv");
                if (result > 0) {
                    buf[result] = '\0';
                    sinaddr_len = sizeof(sinaddr_client);
                    if (getpeername(i, (struct sockaddr *)&sinaddr_client, &sinaddr_len) == -1)
                        exit_sys("getpeername");

                    inet_ntop(AF_INET, &sinaddr_client.sin_addr, ntopbuf, INET_ADDRSTRLEN);
                    printf("%ld bytes received from %s (%u): %s\n", (long)result, ntopbuf, (unsigned)ntohs(sinaddr_client.sin_port), buf);
                    revstr(buf);
                    if (send(i, buf, strlen(buf), 0) == -1)
                        exit_sys("send");
                }
                else { 
                    shutdown(i, SHUT_RDWR);
                    close(i);
                    FD_CLR(i, &rset);
                }
            }
    }
    
    close(sock);

    return 0;
}

char *revstr(char *str)
{
    size_t i, k;
    char temp;

    for (i = 0; str[i] != '\0'; ++i)
        ;
    
    for (--i, k = 0;  k < i; ++k, --i) {
        temp = str[k];
        str[k] = str[i];
        str[i] = temp;
    }

    return str;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/* client.c */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <netdb.h>

#define BUFFER_SIZE        1024

void exit_sys(const char *msg);

int main(int argc, char *argv[])
{
    int sock;
    struct addrinfo *ai, *ri;
    struct addrinfo hints = {0};
    char buf[BUFFER_SIZE];
    char *str;
    ssize_t result;
    int sresult;
    
    if (argc != 3) {
        fprintf(stderr, "wrong number of arguments!..\n");
        exit(EXIT_FAILURE);
    }
    
    if ((sock = socket(AF_INET, SOCK_STREAM, 0)) == -1)
        exit_sys("socket");

    hints.ai_family = AF_INET;
    hints.ai_socktype = SOCK_STREAM;

    if ((sresult = getaddrinfo(argv[1], argv[2], &hints, &ai)) != 0) {
        fprintf(stderr, "getaddrinfo: %s\n", gai_strerror(sresult));
        exit(EXIT_FAILURE);
    }

    for (ri = ai; ri != NULL; ri = ri->ai_next) 
        if (connect(sock, ri->ai_addr, ri->ai_addrlen) != -1) 
            break;
    
    if (ri == NULL)
        exit_sys("connect");

    freeaddrinfo(ai);

    printf("Connected...\n");

    for (;;) {
        printf("Yazı giriniz:");
        fgets(buf, BUFFER_SIZE, stdin);
        if ((str = strchr(buf, '\n')) != NULL)
            *str = '\0';
         if (!strcmp(buf, "quit"))
            break;

        if ((send(sock, buf, strlen(buf), 0)) == -1)
            exit_sys("send");
       
        if ((result = recv(sock, buf, BUFFER_SIZE, 0)) == -1)
            exit_sys("recv");
        if (result == 0)
            break;
        buf[result] = '\0';
        printf("%ld bytes received from %s (%s): %s\n", (long)result, argv[1], argv[2], buf);
    }

    shutdown(sock, SHUT_RDWR);
    close(sock);
    
    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/*--------------------------------------------------------------------------------------------------------------------------
    Yukarıdaki programda daha önce görmedğimiz getpeername isimli bir fonksiyon kullanılmıştır. Bu fonksiyon bağlı bir soketi
    parametre olarak alır ve karşı tarafın ip adresini ve port numarasını bize sockaddr_in ya da sockaddr_in6 biçiminde verir. 
    Tabii aslında server bağlantıyı yaptığında karşı tarafın bilgisini zaten accept fonksiyonunda almaktadır. B bilgi saklanarak 
    kullanılabilir. Ancak bu bilgi saklanmamışsa istenildiği zaman getpeername fonksiyonuyla alınabilmektedir. Fonksiyonun
    prototipi şöyledir:

    int getpeername(int sockfd, struct sockaddr *addr, socklen_t *addrlen);

    Fonksiyonun birinci parametresi soket betimleyicisidir. İkinci parametre duruma göre  bilgilerin yerleştirileceği ssockaddr_in ya da
    sockaddr_in6 yapı nesnesinin adresini alır. Son parametre ikinci parametredeki yapının uzunluğudur. Eğer buraya az bir uzunluk girilirse 
    kırma yapılır ve gerçek uzunluk verdiğimiz adresteki nesneye yerleştirilir. fonksiyon başarı durumunda 0 değerine başarısızlık durumunda -1 
    değerine geri dönmektedir. 

    getppername fonksiyonunun ters işlemini getsockname fonksiyonu yapmaktadır. Bu fonksiyon kendi bağlı soketimizin ip adresini ve 
    port numarasını elde etmek için kullanılır. Genellikle bı fonksiyona gereksinim duyulmamaktadır. 

    int getsockname(int sockfd, struct sockaddr *addr, socklen_t *addrlen);
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    poll modeli tamamen select modeline benzemektedir. Zaten poll fonksiyonu select fonksiyonunun değişik arayüzlü bir benzeri gibidir. 
    Her ne kadar select ve poll aynı işlevlere sahip olsalar da poll fonksiyonun arayüzünün select fonksiyonundan daha iyi olduğu söylenebilir. 
    Örneğin select fonksiyonunda maxsimum betimleyici sayısı FD_SETSIZE kadardır ve bu taşınabilir biçimde artırılamamaktadır. Oysa
    poll arayüzünde böyle bir kısıt yoktur. Yine pek çok sistemde select ve poll birbirlerine çok yakın performans göstermektedir. 
    Fakat poll fonksiyonunun az daha iyi performanlı olma eğilimi vardır. poll modeli de kısaca şu adımlardan geçilerek 
    uygulanır. 

    1) Önce poll fonksiyonu için struct pollfd türünden uygun genişlikte bir dizi yaratılır. (Tabii programcı isterse dinamik dizi de kullanabilir)
    2) Dinleme soketi (pasif soket) yaratılır, bind işlemi uygulanır ve bu soket, POLLIN koduyla diziye eklenir. Şimdi dizinin sktif eleman 1'dir.
    Artık dinleme soketinde bir bağlantı isteği olduğunda sanki  POLLIN işlemi sağlanmış gibi select blokesi çözülecektir. poll fonksiyonunda dinleme soketine
    bağlantı isteği geldiğinde POLLIN olayı gerçekleşir. Eğer poll fonksiyonunun blokesi dinleme soketi yüzünden çözülmüşse o noktada bizin accept işlemini 
    yapmamız gerekir. 
    3) accept işlemiyle bir client ile bağlantı sağlandığında bu client'ın soketi ve POLLIN olayı da dizinin sonuna eklenir. Böylece dizinin aktif eleman sayısı
    gittikçe artacaktır. Dizinin içerisinde hem dinleme soketinin hem de client soketlerin olduğuna dikkat ediniz.  
    4) Program bir döngü içerisinde poll fonksiyonun çağrılması biçiminde oluşturulur. poll'un blokesi çözüldüğünde hangi sokette
    POLLIN eyleminin oluştuğuna bakılır. Eğer dinleme soketinde POLLIN eylemi oluşmuşsa bu noktada yukarıda da belirtildiği gibi accept yapılmalıdır,
    eğer bir client sokette POLLIN eylemi oluşmuşsa o client soketten read/recv yapılır. 
    5) Bir client close ya da shutdown uyguladığında bu da poll için bir POLLIN eylemi oluşturur. Bu durumda programcı read/recv 
    yapacak ve buradan eğer 0 değerini elde ederse karşı tarafın soketi kapattığını anlayacaktır. Artık programcının bu noktada ilgili client soketi kapatıp
    onu diziden çıkartması gerekir. 

    Aşağıda bir poll server modeli görülmektedir.
---------------------------------------------------------------------------------------------------------------------------*/

/* server.c */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <poll.h>

#define BUFFER_SIZE     1024
#define MAX_CLIENT      1024

char *revstr(char *str);
void exit_sys(const char *msg);

int main(int argc, char *argv[])
{
    int sock, sock_client;
    struct sockaddr_in sinaddr, sinaddr_client;
    socklen_t sinaddr_len;
    char ntopbuf[INET_ADDRSTRLEN];
    in_port_t port;
    ssize_t result;
    char buf[BUFFER_SIZE + 1];
    struct pollfd pfds[MAX_CLIENT];
    int npfds;
    int i;

    if (argc != 2) {
        fprintf(stderr, "wrong number of arguments!..\n");
        exit(EXIT_FAILURE);
    }

    port = (in_port_t)strtoul(argv[1], NULL, 10);

    if ((sock = socket(AF_INET, SOCK_STREAM, 0)) == -1)
        exit_sys("socket");

    sinaddr.sin_family = AF_INET;
    sinaddr.sin_port = htons(port);
    sinaddr.sin_addr.s_addr = htonl(INADDR_ANY);

    if (bind(sock, (struct sockaddr *)&sinaddr, sizeof(sinaddr)) == -1)
        exit_sys("bind");

    npfds = 1;
    pfds[0].fd = sock;
    pfds[0].events = POLLIN;
    
    if (listen(sock, 8) == -1)
        exit_sys("listen");

    printf("Waiting for connection...\n");
    
    for (;;) {
        if (poll(pfds, npfds, -1) == -1)
            exit_sys("poll");
        for (i = 0; i < npfds; ++i) 
            if (pfds[i].revents & POLLIN) {
                if (pfds[i].fd == sock) {
                    sinaddr_len = sizeof(sinaddr_client);
                    if ((sock_client = accept(sock, (struct sockaddr *)&sinaddr_client, &sinaddr_len)) == -1)
                        exit_sys("accept");

                    inet_ntop(AF_INET, &sinaddr_client.sin_addr, ntopbuf, INET_ADDRSTRLEN);
                    printf("Connected: %s : %u\n", ntopbuf, (unsigned)ntohs(sinaddr_client.sin_port));    
                    
                    pfds[npfds].fd = sock_client;
                    pfds[npfds].events = POLLIN;
                    ++npfds;
                    continue;
                }
                
                if ((result = recv(pfds[i].fd, buf, BUFFER_SIZE, 0)) == -1)
                    exit_sys("recv");
                if (result > 0) {
                    buf[result] = '\0';
                    sinaddr_len = sizeof(sinaddr_client);

                    if (getpeername(pfds[i].fd, (struct sockaddr *)&sinaddr_client, &sinaddr_len) == -1)
                        exit_sys("getpeername");
                    inet_ntop(AF_INET, &sinaddr_client.sin_addr, ntopbuf, INET_ADDRSTRLEN);
                    printf("%ld bytes received from %s (%u): %s\n", (long)result, ntopbuf, (unsigned)ntohs(sinaddr_client.sin_port), buf);
                    revstr(buf);
                    if (send(pfds[i].fd, buf, strlen(buf), 0) == -1)
                        exit_sys("send");
                }
                else { 
                    shutdown(pfds[i].fd, SHUT_RDWR);
                    close(pfds[i].fd);
                    pfds[i] = pfds[npfds - 1];
                    --npfds;
                }
            }
    }
    
    close(sock);

    return 0;
}

char *revstr(char *str)
{
    size_t i, k;
    char temp;

    for (i = 0; str[i] != '\0'; ++i)
        ;
    
    for (--i, k = 0;  k < i; ++k, --i) {
        temp = str[k];
        str[k] = str[i];
        str[i] = temp;
    }

    return str;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/* client.c */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <netdb.h>

#define BUFFER_SIZE        1024

void exit_sys(const char *msg);

int main(int argc, char *argv[])
{
    int sock;
    struct addrinfo *ai, *ri;
    struct addrinfo hints = {0};
    char buf[BUFFER_SIZE];
    char *str;
    ssize_t result;
    int sresult;
    
    if (argc != 3) {
        fprintf(stderr, "wrong number of arguments!..\n");
        exit(EXIT_FAILURE);
    }
    
    if ((sock = socket(AF_INET, SOCK_STREAM, 0)) == -1)
        exit_sys("socket");

    hints.ai_family = AF_INET;
    hints.ai_socktype = SOCK_STREAM;

    if ((sresult = getaddrinfo(argv[1], argv[2], &hints, &ai)) != 0) {
        fprintf(stderr, "getaddrinfo: %s\n", gai_strerror(sresult));
        exit(EXIT_FAILURE);
    }

    for (ri = ai; ri != NULL; ri = ri->ai_next) 
        if (connect(sock, ri->ai_addr, ri->ai_addrlen) != -1) 
            break;
    
    if (ri == NULL)
        exit_sys("connect");

    freeaddrinfo(ai);

    printf("Connected...\n");

    for (;;) {
        printf("Yazı giriniz:");
        fgets(buf, BUFFER_SIZE, stdin);
        if ((str = strchr(buf, '\n')) != NULL)
            *str = '\0';
         if (!strcmp(buf, "quit"))
            break;

        if ((send(sock, buf, strlen(buf), 0)) == -1)
            exit_sys("send");
       
        if ((result = recv(sock, buf, BUFFER_SIZE, 0)) == -1)
            exit_sys("recv");
        if (result == 0)
            break;
        buf[result] = '\0';
        printf("%ld bytes received from %s (%s): %s\n", (long)result, argv[1], argv[2], buf);
    }

    shutdown(sock, SHUT_RDWR);
    close(sock);
    
    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/*--------------------------------------------------------------------------------------------------------------------------
    Anımsanacağı gibi poll yönteminin Linux sistemlerinde epoll isimli bir benzeri vardı. Linux sistemlerinde en iyi performansı 
    bu epoll modeli vermektedir. Bu modelde önce epoll_create ile bir epoll nesnesi yaratılır. Sonra dinleme soketi  epoll_ctll fonksiyonu ile 
    ilgi listesine eklenir. Tıpkı poll modelinde olduğu gibi dinleme soketine bir bağlantı isteği geldiğinde, herhangi bir sokete
    okunacak bir bilgi geldiğinde ya da bir soket shutdown ya da close fonksiyonuyla kapatıldığında EPOLLIN olayı gerçekleşmektedir. 
    İşte programcı döngü içerisinde epoll_wait fonksiyonu ile beklemer. Sonra hangi sokette olay gerçekleşmişse gereğini yapar. 

    epoll modeli Linux'a özgüdür diğer UNIX türevi sistemlerde yoktur. 

    Aşağıda epoll modelini uygulayan bir "level triggered" server örneği verilmiştir.
---------------------------------------------------------------------------------------------------------------------------*/

/* server.c */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <sys/epoll.h>

#define BUFFER_SIZE     1024
#define MAX_CLIENT      1024

char *revstr(char *str);
void exit_sys(const char *msg);

int main(int argc, char *argv[])
{
    int sock, sock_client;
    int epfd;
    struct sockaddr_in sinaddr, sinaddr_client;
    socklen_t sinaddr_len;
    char ntopbuf[INET_ADDRSTRLEN];
    in_port_t port;
    ssize_t result;
    char buf[BUFFER_SIZE + 1];
    int nepes;
    int rnepes;
    int i;
    struct epoll_event epe;
    struct epoll_event epes[MAX_CLIENT];

    if (argc != 2) {
        fprintf(stderr, "wrong number of arguments!..\n");
        exit(EXIT_FAILURE);
    }

    port = (in_port_t)strtoul(argv[1], NULL, 10);

    if ((epfd = epoll_create(1024)) == -1)
        exit_sys("epoll_create");

    if ((sock = socket(AF_INET, SOCK_STREAM, 0)) == -1)
        exit_sys("socket");

    sinaddr.sin_family = AF_INET;
    sinaddr.sin_port = htons(port);
    sinaddr.sin_addr.s_addr = htonl(INADDR_ANY);

    if (bind(sock, (struct sockaddr *)&sinaddr, sizeof(sinaddr)) == -1)
        exit_sys("bind");

    nepes = 1;
    epe.events = EPOLLIN;
    epe.data.fd = sock;
    if (epoll_ctl(epfd, EPOLL_CTL_ADD, sock, &epe) == -1)
        exit_sys("epoll_ctl");
    
    if (listen(sock, 8) == -1)
        exit_sys("listen");

    printf("Waiting for connection...\n");
    
    for (;;) {
        if ((rnepes = epoll_wait(epfd, epes, nepes, -1)) == -1)
            exit_sys("epoll");
        for (i = 0; i < rnepes; ++i) 
            if (epes[i].events & EPOLLIN) {
                if (epes[i].data.fd == sock) {
                    sinaddr_len = sizeof(sinaddr_client);
                    if ((sock_client = accept(sock, (struct sockaddr *)&sinaddr_client, &sinaddr_len)) == -1)
                        exit_sys("accept");

                    inet_ntop(AF_INET, &sinaddr_client.sin_addr, ntopbuf, INET_ADDRSTRLEN);
                                        
                    epe.events = EPOLLIN;
                    epe.data.fd = sock_client;
                    if (epoll_ctl(epfd, EPOLL_CTL_ADD, sock_client, &epe) == -1)
                        exit_sys("epoll_ctl");
                    ++nepes;
                    
                    printf("New client Connected: %s : %u, total descriptor interested: %d\n", ntopbuf, (unsigned)ntohs(sinaddr_client.sin_port), nepes);    

                    continue;
                }
                
                if ((result = recv(epes[i].data.fd, buf, BUFFER_SIZE, 0)) == -1)
                    exit_sys("recv");
                if (result > 0) {
                    buf[result] = '\0';
                    sinaddr_len = sizeof(sinaddr_client);

                    if (getpeername(epes[i].data.fd, (struct sockaddr *)&sinaddr_client, &sinaddr_len) == -1)
                        exit_sys("getpeername");
                    inet_ntop(AF_INET, &sinaddr_client.sin_addr, ntopbuf, INET_ADDRSTRLEN);
                    printf("%ld bytes received from %s (%u): %s\n", (long)result, ntopbuf, (unsigned)ntohs(sinaddr_client.sin_port), buf);
                    revstr(buf);
                    if (send(epes[i].data.fd, buf, strlen(buf), 0) == -1)
                        exit_sys("send");
                }
                else { 
                    shutdown(epes[i].data.fd, SHUT_RDWR);
                    close(epes[i].data.fd);
                      
                    --nepes;
                    printf("Client connection ended, total descriptors interested: %d\n", nepes);
                }
            }
    }
    
    close(sock);
    close(epfd);

    return 0;
}

char *revstr(char *str)
{
    size_t i, k;
    char temp;

    for (i = 0; str[i] != '\0'; ++i)
        ;
    
    for (--i, k = 0;  k < i; ++k, --i) {
        temp = str[k];
        str[k] = str[i];
        str[i] = temp;
    }

    return str;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/*--------------------------------------------------------------------------------------------------------------------------
    Daha önceden de epoll IO modelinin hem düzey tetiklemeli (default) hem de kenar tetiklemeli modda çalışabildiğini belirtmiştik.
    Düzey tetiklemeli mod aslında select ve poll modelinin modudur. Düzey tetiklemeli modda eğer "read/recv yapıldığında bloke oluşmayacak
    bir durum varsa" select, poll ve epoll_wait hemen geri döner. Böylece bu modda biz gelen bilgilerin hepsini okumalıyız. Aksi takdirde
    sürekli bloke çözülecektir ve bu da sonsuz döngü oluşturabilecektir. Ancak bazı uygulamalarda gelen bilginin hepsinin okunması istenmeyebilir. 
    Örneğin programcı gelen bilgi belli bir büyüklüğe ulaşınca onu kendi tamponuna taşımak isteyebilir.  Bu durumda düzey tetiklemeli çalışma uygulanamaz.
    Kenar tetiklemeli modda "yeni bilginin gelip gelmediğine" bakılmaktadır. Yani network tamponunda yeni bilginin olmasıyla değil yeni bir 
    gelmesiyle bloke çözülmektedir. (Başka bir deyişle bir epoll_wait işleminden sonra ancak yeni bir bilgi gelmişse tetikleme oluşur.)

    Düzey tetiklemeli IO modellerinde bir bilgi geldiğinde o bilgi okunup işleme sokulurken başka bir bilginin gelmesi durumunda 
    bu yeni gelen bilgi ikinci turda ancak ele alınabilmektedir. Buradaki zaman kaybını engellemek için soketi blokesiz moda sokup döngü içerisinde 
    okuma yapmak uygun bir yöntem olabilmektedir. Örneğin:

    nepes = epoll(......);

    for (i = 0; i < nepes; ++i) {
        if (epes[i].events & EPOLLIN) {
            for (;;)  {
                result = recv(....);
                if (result == -1) {
                    if (errno = EAGAIN)
                        break;
                    exit_sys("recv");
                }
                ....
            }
        }
    }

    Bu yöntemde sokete bilgi gelmişse ele alınırken yeni bir bilginin gelmesi durumunda bu yeni gelen bilgi ikinci tura bırakılmadan
    hemen işlenebilmektedir. Bazı performans kritik durumlarda bu yöntem tercih edilebilmektedir. Ancak bu yöntem için de soketin blokesiz moda 
    sokulması gerekir. Soket accept ile edildiğinde default blokeli moddadır. Soketi blokesiz moda sokmak fcntl fonksiyonuyla yapılabilir. 
    Ancak nonblocking olarak döngüsel okumalarda sorunlardan biri belli bir client'tan çok fazla ve sürekli bilgi geldiğinde bu döngüde çok fazla zaman
    geçirilmesi ve bunun sonucunda da diğer soketlerle ilgilenilememesi olmaktadır. Programcı böyle bir sorunu belli bir limit 
    koyarak çözebilir. 

    Kenar tetiklemeli modda eğer programcı her yeni tetiklemede önceden gelmiş olan tüm bilgileri okumayı garanti etmek istiyorsa ya blokeli
    modda read/recv fonksiyonunda talep ettiğinden daha az değerin okunmuş olmasına bakmalı ya da yukarıdaki gibi blokesiz modda bir döngü 
    içerisinde EAGAIN durumu oluşana kadar read/recv uygulamalıdır.

    Epoll yönteminde genel olarak kenar tetiklemeli modun düzey tetiklemeli moddan daha verimli olduğu görülmüştür. Kenar tetiklemeli modda
    yeni bir bilgi geldiğinde tetiklemenin yapılması çok sayıda betimleyici ile çalışılırken etkin artışına yol açmaktadır.() Bunun en önemli
    nedenlerinden biri çekirdek kodlarının dha az betimleyiciye bakıyor olmasındandır.)
    
    Yukarıdaki programı mantıksal olarak kenar tetiklemeli ve döngüsel biçime aşağıdaki gibi sokabiliriz.

---------------------------------------------------------------------------------------------------------------------------*/

/* server.c */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <errno.h>
#include <fcntl.h>
#include <unistd.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <sys/epoll.h>

#define BUFFER_SIZE     1024
#define MAX_CLIENT      1024

char *revstr(char *str);
void exit_sys(const char *msg);

int main(int argc, char *argv[])
{
    int sock, sock_client;
    int epfd;
    struct sockaddr_in sinaddr, sinaddr_client;
    socklen_t sinaddr_len;
    char ntopbuf[INET_ADDRSTRLEN];
    in_port_t port;
    ssize_t result;
    char buf[BUFFER_SIZE + 1];
    int nepes;
    int rnepes;
    int i;
    struct epoll_event epe;
    struct epoll_event epes[MAX_CLIENT];


    if (argc != 2) {
        fprintf(stderr, "wrong number of arguments!..\n");
        exit(EXIT_FAILURE);
    }

    port = (in_port_t)strtoul(argv[1], NULL, 10);

    if ((epfd = epoll_create(1024)) == -1)
        exit_sys("epoll_create");

    if ((sock = socket(AF_INET, SOCK_STREAM, 0)) == -1)
        exit_sys("socket");

    sinaddr.sin_family = AF_INET;
    sinaddr.sin_port = htons(port);
    sinaddr.sin_addr.s_addr = htonl(INADDR_ANY);

    if (bind(sock, (struct sockaddr *)&sinaddr, sizeof(sinaddr)) == -1)
        exit_sys("bind");

    nepes = 1;
    epe.events = EPOLLIN|EPOLLET;
    epe.data.fd = sock;
    if (epoll_ctl(epfd, EPOLL_CTL_ADD, sock, &epe) == -1)
        exit_sys("epoll_ctl");
    
    if (listen(sock, 8) == -1)
        exit_sys("listen");

    printf("Waiting for connection...\n");
    
    for (;;) {
        if ((rnepes = epoll_wait(epfd, epes, nepes, -1)) == -1)
            exit_sys("epoll");
        for (i = 0; i < rnepes; ++i) 
            if (epes[i].events & EPOLLIN) {
                if (epes[i].data.fd == sock) {
                    sinaddr_len = sizeof(sinaddr_client);
                    if ((sock_client = accept(sock, (struct sockaddr *)&sinaddr_client, &sinaddr_len)) == -1)
                        exit_sys("accept");
                    if (fcntl(sock_client, F_SETFL, fcntl(sock_client, F_GETFL) | O_NONBLOCK) == -1)
                        exit_sys("fcntl");

                    inet_ntop(AF_INET, &sinaddr_client.sin_addr, ntopbuf, INET_ADDRSTRLEN);
                                        
                    epe.events = EPOLLIN|EPOLLET;
                    epe.data.fd = sock_client;
                    if (epoll_ctl(epfd, EPOLL_CTL_ADD, sock_client, &epe) == -1)
                        exit_sys("epoll_ctl");
                    ++nepes;
                    
                    printf("New client Connected: %s : %u, total descriptor interested: %d\n", ntopbuf, (unsigned)ntohs(sinaddr_client.sin_port), nepes);    

                    continue;
                }

                for (;;) {
                    if ((result = recv(epes[i].data.fd, buf, BUFFER_SIZE, 0)) == -1) {
                        if (errno == EAGAIN)
                            break;
                        exit_sys("recv");
                    }
                        
                    if (result > 0) {
                        buf[result] = '\0';
                        sinaddr_len = sizeof(sinaddr_client);

                        if (getpeername(epes[i].data.fd, (struct sockaddr *)&sinaddr_client, &sinaddr_len) == -1)
                            exit_sys("getpeername");
                        inet_ntop(AF_INET, &sinaddr_client.sin_addr, ntopbuf, INET_ADDRSTRLEN);
                        printf("%ld bytes received from %s (%u): %s\n", (long)result, ntopbuf, (unsigned)ntohs(sinaddr_client.sin_port), buf);
                        revstr(buf);
                        if (send(epes[i].data.fd, buf, strlen(buf), 0) == -1)
                            exit_sys("send");
                    }
                    else { 
                        shutdown(epes[i].data.fd, SHUT_RDWR);
                        close(epes[i].data.fd);
                        
                        --nepes;
                        printf("Client connection ended, total descriptors interested: %d\n", nepes);
                        break;  
                    }
                }
            }
    }
    
    close(sock);
    close(epfd);

    return 0;
}

char *revstr(char *str)
{
    size_t i, k;
    char temp;

    for (i = 0; str[i] != '\0'; ++i)
        ;
    
    for (--i, k = 0;  k < i; ++k, --i) {
        temp = str[k];
        str[k] = str[i];
        str[i] = temp;
    }

    return str;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/*--------------------------------------------------------------------------------------------------------------------------
    Nihayet soket uygulamalarında asenkron IO modeli de uygulanabilmektedir. Ancak bu modelim soketlerde taşınabilirlik bakımından bazı
    sorunları vardır. POSIX standartları bu modelin soketlerde kullanımı konusunda gerekli olan bazı gri noktaları açıklamamıştır. 
    Dolayısıyla asenkron model soketlerde kullanılırken taşınabilirlik sorunları oluşabilmektedir. Linux sistemlerinde bu model epoll modelinden
    daha yavaş olma eğilimindedir. 

    Bu modelde daha önce yaptığımız gibi her betimleyci için bir AIO Kontrol Blok oluşturulur ve sonra okuma işlemi aio_read ile başlatılır.
    İşlem bittiğinde sistem bize bir sinyal ya da thread yoluyla bunu bildirmektedir. Biz de orada yeniden aio_read yaparak işlemi devam ettiririz. 
    
    Bu yöntemde dinleme soketi üzeirnde asenkron işlem yapılamamaktadır. Yani yalnızca accept ile elde edilen soket üzerinde asenkron işlemler
    yapılabilmektedir. 
---------------------------------------------------------------------------------------------------------------------------*/

/* server.c */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <aio.h>

#define BUFFER_SIZE     1024
#define MAX_CLIENT      1024

typedef struct  {
    struct aiocb cb;
    char buf[BUFFER_SIZE + 1];
    char peer_name[INET_ADDRSTRLEN];
    in_port_t peer_port;
} IOCB_BUF;

void read_completion_proc(union sigval val);
char *revstr(char *str);
void exit_sys(const char *msg);

int main(int argc, char *argv[])
{
    int sock, sock_client;
    struct sockaddr_in sinaddr, sinaddr_client;
    socklen_t sinaddr_len;
    in_port_t port;
    IOCB_BUF *aiobuf;

    if (argc != 2) {
        fprintf(stderr, "wrong number of arguments!..\n");
        exit(EXIT_FAILURE);
    }

    port = (in_port_t)strtoul(argv[1], NULL, 10);

    if ((sock = socket(AF_INET, SOCK_STREAM, 0)) == -1)
        exit_sys("socket");

    sinaddr.sin_family = AF_INET;
    sinaddr.sin_port = htons(port);
    sinaddr.sin_addr.s_addr = htonl(INADDR_ANY);

    if (bind(sock, (struct sockaddr *)&sinaddr, sizeof(sinaddr)) == -1)
        exit_sys("bind");
    
    if (listen(sock, 8) == -1)
        exit_sys("listen");

    printf("Waiting for connection...\n");
    
    for (;;) {
        if ((sock_client = accept(sock, (struct sockaddr *)&sinaddr_client, &sinaddr_len)) == -1)
            exit_sys("accept");
        
        if ((aiobuf = (IOCB_BUF *)calloc(1, sizeof(IOCB_BUF))) == NULL)
            exit_sys("calloc");
        
        inet_ntop(AF_INET, &sinaddr_client.sin_addr, aiobuf->peer_name, INET_ADDRSTRLEN);
        aiobuf->peer_port = htons(sinaddr_client.sin_port);
        
        printf("New client Connected: %s : %u\n", aiobuf->peer_name, (unsigned)aiobuf->peer_port);    

        aiobuf->cb.aio_fildes = sock_client;
        aiobuf->cb.aio_offset = 0;
        aiobuf->cb.aio_buf = aiobuf->buf;
        aiobuf->cb.aio_nbytes = BUFFER_SIZE;
        aiobuf->cb.aio_reqprio = 0;
        aiobuf->cb.aio_sigevent.sigev_notify = SIGEV_THREAD;
        aiobuf->cb.aio_sigevent.sigev_value.sival_ptr = aiobuf;
        aiobuf->cb.aio_sigevent.sigev_notify_function = read_completion_proc;

        if (aio_read(&aiobuf->cb) == -1)
            exit_sys("aio_read");
    }
    
    close(sock);

    return 0;
}

void read_completion_proc(union sigval val)
{
    IOCB_BUF *aiobuf = (IOCB_BUF *)val.sival_ptr;
    ssize_t n;

    if ((n = aio_return(&aiobuf->cb)) == -1)
        exit_sys("aio_return");

    if (n == 0) {
        shutdown(aiobuf->cb.aio_fildes, SHUT_RDWR);
        close(aiobuf->cb.aio_fildes);
        free(aiobuf);
        return;
    }

    aiobuf->buf[n] = '\0';
    printf("%ld bytes received from %s (%u): %s\n", (long)n, aiobuf->peer_name, (unsigned)aiobuf->peer_port, (char *)aiobuf->cb.aio_buf);
    revstr(aiobuf->buf);
    if (send(aiobuf->cb.aio_fildes, (void *)aiobuf->cb.aio_buf, strlen(aiobuf->buf), 0) == -1)
        exit_sys("send");

    if (aio_read(&aiobuf->cb) == -1)
        exit_sys("aio_read");
}

char *revstr(char *str)
{
    size_t i, k;
    char temp;

    for (i = 0; str[i] != '\0'; ++i)
        ;
    
    for (--i, k = 0;  k < i; ++k, --i) {
        temp = str[k];
        str[k] = str[i];
        str[i] = temp;
    }

    return str;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/* client.c */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <netdb.h>

#define BUFFER_SIZE        1024

void exit_sys(const char *msg);

int main(int argc, char *argv[])
{
    int sock;
    struct addrinfo *ai, *ri;
    struct addrinfo hints = {0};
    char buf[BUFFER_SIZE];
    char *str;
    ssize_t result;
    int sresult;
    
    if (argc != 3) {
        fprintf(stderr, "wrong number of arguments!..\n");
        exit(EXIT_FAILURE);
    }
    
    if ((sock = socket(AF_INET, SOCK_STREAM, 0)) == -1)
        exit_sys("socket");

    hints.ai_family = AF_INET;
    hints.ai_socktype = SOCK_STREAM;

    if ((sresult = getaddrinfo(argv[1], argv[2], &hints, &ai)) != 0) {
        fprintf(stderr, "getaddrinfo: %s\n", gai_strerror(sresult));
        exit(EXIT_FAILURE);
    }

    for (ri = ai; ri != NULL; ri = ri->ai_next) 
        if (connect(sock, ri->ai_addr, ri->ai_addrlen) != -1) 
            break;
    
    if (ri == NULL)
        exit_sys("connect");

    freeaddrinfo(ai);

    printf("Connected...\n");

    for (;;) {
        printf("Yazı giriniz:");
        fgets(buf, BUFFER_SIZE, stdin);
        if ((str = strchr(buf, '\n')) != NULL)
            *str = '\0';
         if (!strcmp(buf, "quit"))
            break;

        if ((send(sock, buf, strlen(buf), 0)) == -1)
            exit_sys("send");
       
        if ((result = recv(sock, buf, BUFFER_SIZE, 0)) == -1)
            exit_sys("recv");
        if (result == 0)
            break;
        buf[result] = '\0';
        printf("%ld bytes received from %s (%s): %s\n", (long)result, argv[1], argv[2], buf);
    }

    shutdown(sock, SHUT_RDWR);
    close(sock);
    
    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/*--------------------------------------------------------------------------------------------------------------------------
    UDP (User Datagram Protocol) bağlantılı olmayan bir protokoldür. Dolayısıyla bir taraf bir tarafa hiç bağlanmadan onun IP
    adresini ve port numarasını bilerek UDP paketlerini gönderebilir. Gönderen taraf alan tarafın paketi alıp almadığını bilmez. 
    Bir akış kontrolü yoktur. Dolayısıyla alan taraf bilgi kaçırabilir. UDP tabii ki TCP'ye göre daha hızlıdır. Zaten TCP bir bakıma
    UDP'nin organize edilmiş bağlantılı biçimidir. 

    UDP bağlantılı olmadığı için burada "client" ve "server" terimleri tam oturmamaktadır. Ancak yine de genellikle bilgiyi gönderen tarafa
    "client" alan tarafa "server" denilmektedir. UDP özellikle periyodik kısa bilgilerin gönderildiği ve alındığı durumlarda tercih edilmektedir.
    UDP haberleşmesinde bilgi alan tarafın (server) bilgi kaçırabilmesi söz konusu olabileceğinden dolayı böyle kaçırmalarda sistemde önemli bir
    aksamanın olmaması gerekir. Örneğin birtakım makineler belli periyotlarda server'a "ben çalışıyorum" demek için periyodik UDP paketleri yollayabilir. 
    Server da hangi makinenin çalıştığını anlayabilir. Bir araba simülatörü arabanın durumunu UDP paketleriyle dış dünyaya verebilir. Ya da örneğin 
    bir görüntü aktarımı UDP paketleriyle yapılabilir. Bir UDP paketi 64K gibi bir sınıra sahiptir. Büyük verilerin UDP ile gönderilmesi için programcının
    paketlere kendisinin manuel numara vermesi gerekebilir. Zaten TCP protokolü bu şekilde bir numaralandırmayı kendi içerisinde yapmaktadır. UDP haberleşmesinin
    önemli bir farkı da "broadcasting" işlemidir. Yerel ağda belli bir makine tüm host'lara UDP paketini gönderebilir. TCP'de böyle bir broadcasting mekanizması 
    yoktur. 

    UDP server programın tasarımı şöyledir:

    1) Server socket fonksiyonuyla soketi SOCK_DGRAM parametresiyle yaratır.
    2) Soketi bind fonksiyonuyla bağlar.
    3) recvfrom fonksiyonuyla gelen paketleri alır ve işler
    4) Haberleşme bitince soketi close ile kapatır. 

    UDP Client Programın tasarımı da şöyledir:

    1) Client socket fonksiyonuyla soketi SOCK_DGRAM parametresiyle yaratır.
    2) Client isteğe bağlı olarak soketi bind fonksiyonuyla bağlayabilir.
    3) Client server'ın host isminden hareketle server'ın IP adresini gethostbyname ya da getaddrinfo fonksiyonuyla elde edebilir.
    4) Client sendto fonksiyonuyla UDP paketlerini gönderir. 
    5) Haberleşme birince client close fonksiyonuyla soketi kapatır. 

    recvfrom fonksiyonu UDP paketini okumak için kullanılmaktadır. Fonksiyonun prototipi şöyledir:

    ssize_t recvfrom(int socket, void *buffer, size_t length, int flags, struct sockaddr *address, socklen_t *address_len);

    Fonksiyonun birinci parametresi bind edilen soketi belirtir. ikinci parametre alınacak bilginin yerleştirileceğin adresi belirtir. Üçüncü parametre
    ikinci parametredeki dizinin uzunluğunu belirtir. Eğer buradaki değer değer UDP paketindeki gönderilmiş olan byte sayısından daha az ise kırpılarak 
    diziye yerleştirme yapımaktadır. flgas parametresi birkaç seçeneğe sahiptir. 0 girilebilir. fonksionun dördüncü parametresi UDP paketin gönderen tarafın 
    IP adresinin ve port numarasının yerleştirileceği sockaddr_in yapısının adresini alır. Son parametre ise bu yapının uzunluğunu tutan int nesnenin adresini almaktadır. 
    Eğer bu değer küçük girilirse fonksiyon asıl değeri buraya yerleştirmektedir. Fonksiyon başarı durumunda UDP paketinideki byte sayısına, başarıszlık durumunda
    -1 değerine geri dönmektedir. 

    sendto fonksiyonu da şöyledir:

    ssize_t sendto(int socket, const void *message, size_t length, int flags, const struct sockaddr *dest_addr, socklen_t dest_len);

    Fonksiyonun parametreleri recfrom da olduğu gibidir. Ancak buffer yönü terstir. Fonksiyon blokeli modda UDP paketinin tamamı network tamponuna
    yazılana kadar blokeye yol açmaktadır. Başarı durumunda network tamponuna yazılan byte sayısına başarısızlık durumunda -1'e geri dönmektedir. 


    Aşağıda örnek bir UDP-Server ve Client_program verilmiştir.
---------------------------------------------------------------------------------------------------------------------------*/

/* udp-server.c */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>

#define BUFFER_SIZE     4096

char *revstr(char *str);
void exit_sys(const char *msg);

int main(int argc, char *argv[])
{
    int sock;
    struct sockaddr_in sinaddr, sinaddr_client;
    socklen_t sinaddr_len;
    char ntopbuf[INET_ADDRSTRLEN];
    in_port_t port;
    ssize_t result;
    char buf[BUFFER_SIZE + 1];

    if (argc != 2) {
        fprintf(stderr, "wrong number of arguments!..\n");
        exit(EXIT_FAILURE);
    }

    port = (in_port_t)strtoul(argv[1], NULL, 10);

    if ((sock = socket(AF_INET, SOCK_DGRAM, 0)) == -1)
        exit_sys("socket");

    sinaddr.sin_family = AF_INET;
    sinaddr.sin_port = htons(port);
    sinaddr.sin_addr.s_addr = htonl(INADDR_ANY);

    if (bind(sock, (struct sockaddr *)&sinaddr, sizeof(sinaddr)) == -1)
        exit_sys("bind");

    printf("Waiting for client data...\n");
        
    for (;;)  {
        sinaddr_len = sizeof(sinaddr_client);
        if ((result = recvfrom(sock, buf, BUFFER_SIZE, 0, (struct sockaddr *)&sinaddr_client, &sinaddr_len)) == -1)
            exit_sys("recvfrom");
        
        buf[result] = '\0';
        inet_ntop(AF_INET, &sinaddr_client.sin_addr, ntopbuf, INET_ADDRSTRLEN);
        printf("%ld bytes received from %s (%u): %s\n", (long)result, ntopbuf, (unsigned)ntohs(sinaddr_client.sin_port), buf);

        revstr(buf);
        if (sendto(sock, buf, strlen(buf), 0,(struct sockaddr *)&sinaddr_client, sizeof(struct sockaddr)) == -1)
            exit_sys("sendto");
    }
  
    close(sock);
    
    return 0;
}

char *revstr(char *str)
{
    size_t i, k;
    char temp;

    for (i = 0; str[i] != '\0'; ++i)
        ;
    
    for (--i, k = 0;  k < i; ++k, --i) {
        temp = str[k];
        str[k] = str[i];
        str[i] = temp;
    }

    return str;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/* udp-client.c */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <netdb.h>

#define BUFFER_SIZE        4096

void exit_sys(const char *msg);

int main(int argc, char *argv[])
{
    int sock;
    struct addrinfo *ai;
    struct addrinfo hints = {0};
    struct sockaddr_in sinaddr;
    int sinaddr_len;
    char buf[BUFFER_SIZE];
    char ntopbuf[INET_ADDRSTRLEN];
    char *str;
    ssize_t result;
    int sresult;
    
    if (argc != 3) {
        fprintf(stderr, "wrong number of arguments!..\n");
        exit(EXIT_FAILURE);
    }
    
    if ((sock = socket(AF_INET, SOCK_DGRAM, 0)) == -1)
        exit_sys("socket");

    hints.ai_family = AF_INET;
    hints.ai_socktype = SOCK_DGRAM;

    if ((sresult = getaddrinfo(argv[1], argv[2], &hints, &ai)) != 0) {
        fprintf(stderr, "getaddrinfo: %s\n", gai_strerror(sresult));
        exit(EXIT_FAILURE);
    }

    for (;;) {
        printf("Yazı giriniz:");
        fgets(buf, BUFFER_SIZE, stdin);
        if ((str = strchr(buf, '\n')) != NULL)
            *str = '\0';
         if (!strcmp(buf, "quit"))
            break;

        if (sendto(sock, buf, strlen(buf), 0, ai->ai_addr, sizeof(struct sockaddr)) == -1)
            exit_sys("sendto");

        sinaddr_len = sizeof(sinaddr);
        if ((result = recvfrom(sock, buf, BUFFER_SIZE, 0, (struct sockaddr *)&sinaddr, &sinaddr_len)) == -1)
            exit_sys("recvfrom");

        buf[result] = '\0';
        inet_ntop(AF_INET, &sinaddr.sin_addr, ntopbuf, INET_ADDRSTRLEN);
        printf("%ld bytes received from %s (%u): %s\n", (long)result, ntopbuf, (unsigned)ntohs(sinaddr.sin_port), buf);
    }

    freeaddrinfo(ai);
    close(sock);
    
    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/*--------------------------------------------------------------------------------------------------------------------------
    Server uygulamalarında server'ın bir client'tan gelen isteği yerine getirmesi bir zaman kaybı oluşturabilmektedir. Server bir
    client ile uğraşırken diğer client'ların istekleri mecburen bekletilir. İşte bu durumu en aza indirmek için select, poll, epoll 
    modellerinde server bir client'ın isteğini bir thread ile yerine getirebilir. Böylece birden fazla client'a aynı anda hizmet verebilecektir. 
    Örneğin select modelinde bu işlem şöyle yapılabilir:

    for (;;) {
        select(.....);
        if (<belli bir sokete bilgi geldi>) {
            <thread oluştur ve işlemi thread'e devret>
        }
    }

    Tabii burada küçük bir işlem için yeni bir thread'in yaratılıp yok edilmesi etkin bir yöntem değildir. Çünkü bilindiği gibi
    thread'lerin yaratılıp yok edilmeleri de dikkate değer bir zaman kaybı oluşturmaktadır. İşte bu tür durumlarda "thread havuzları (thread pools)"
    kullanılabilir. Thread havuzlarında zaten belli bir miktar thread yaratılmış ve bekler durumda (suspend durumda) tutulmaktadır. Böylece vlient'tan gelen
    isteğin bu thread'lerden biri tarafından gerçekleştirilmesi uygun olur. Tabii havuzda ne kadar thread'in bekletileceği neselesi vardır. Eğer genel amaçlı
    bir thread havuzu yazılacaksa havuzda bekletilecek thread dinamik bir biçimde belirlenebilir. (Yani çok fazla gereksinim olduğunda havuzu büyütmek, 
    gereksinim azaldığında küçültmek gibi.) Daha önceden de belirttiğimiz gibi UNIX/Linux sistemlerinde standart bir thread havuzu mekanizaması yoktur. 
    Halbuki örneğin Windows sistemlerinde işletim sistemi tarafından sunulan threda havuz mekanizması bulunmaktadır. Bu durumda UNIX/Linux sistemlerinde 
    başkaları tarafından yazılmış thread havuzları kullanılabilir ya da uygulamaya yönelik basit bir havuz mekanizması oluşturulabilir. 

---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    recv ve send fonksiyonlarının read ve write fonksiyonlarından tek farkı flags parametresidir. Biz yukarıdaki örneklerde bu parametreyi 0
    geçtik. Dolayısıyla yukarıdaki örneklerde kullandığımız recv ve send fonksiyonlarının read ve write fonksiyonlarından hiçbir farkı yoktur. 
    Pekiyi bu flag değerleri neler olabilir? İşte POSIX standartlarında recv fonksiyonundaki flag değerleri şunlardan biri ya da birden fazlası olabilir:

    MSG_PEEK: Bu seçenekte bilgi reive tamponundan alınır ama oradan silinmez. (Belki de programcı mesaj uygunsa okumak istemektedir.)
    MSG_OOB: Outof-band data (urgent data) denilen okumalar için kullanılmaktadır.
    MSG_WAITALL: Bu seçenkte n byte okunmak istendiğinde bu n byte kesin olarak okunana kadar blokede beklenir. Fakat bu durumda bir sinyal geldiğinde
    yine recv -1 ile geri döner ve errno EINTR ile set edilir. 

    send fonksiyonundaki POSIX bayrakları da şunlardır:

    MSG_EOR: Soket türü SOCK_SEQPACKET ise kaydı sonlandırmakta kullanılır.
    MSG_OOB: Outof-band data gönderimi için kullanılmaktadır. 
    MSG_NOSIGNAL: Normal olarak send ya da write işlemi yapılırken karşı taraf soketi kapatmışsa bu fonksiyonların çağrıldığı tarafta
    SIGPIPE sinyali oluşmaktadır. Bu bayrak kullanılırsa SIGPIPE sinyali oluşmaz send -1 ile geri döner ve errno EPIPE değeri ile set edilir. 

    Linux POSIX'in bayraklarından daha fazlasını bulundurmaktadır. Örneğin recv ve send işleminde MSG_DONTWAIT bir çağrımlık "nonblocking" etki 
    yaratmaktadır. Yani recv sırasında network tamponunda hiç bilgi yoksa recv bloke olmaz, -1 ile geri döner errno EAGAIN değeri ile set edilir. 
    send işlemi sırasında da network tamponu dolu ise send bloke olmaz -1 ile geri döner errno EAGAIN değeri ile set edilir. 

---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Client server uygulamaların çoğunda client server'a isteğini yazısal biçimde iletmektedir. Fakat istek binary biçimde de 
    iletilebilir. bu durumda server'ın soketten belli bir miktar okuaybilecek biçimde orhganize edilmesi gerekir. Bazen client
    önce server'a okunacak mesajın uzunluğunu gönderir. Sonra da mesajın kendisi gönderir. Bu yöntem text ya da binary tabanlı yapılabilmektedir. 
    Bu durumda programcının belli bir miktar okuyana kadar biriktirme yapması gerekir. Garantili n byte okumak için recv fonksiyonu MSG_WAITALL
    bayrağı ile kullanılabilir. Ancak bu da sıkıntılıdır. Çünkü select, poll, ya da asenkron io modellerinde n byte okuyana kadar bloke oluşturmak
    tasarıma terstir. Bu tür durumlarda daha önce borularda yaptığımız gibi "index, left" mekanizmasını kullanabiliriz. 

    Aşağıda her defasında BUFFER_SIZE (10) byte bilginin hepsi okunduğunda onları işleme soken bir epoll modelli server örneği
    verilmiştir. 

---------------------------------------------------------------------------------------------------------------------------*/

/* server.c */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <sys/epoll.h>

#define BUFFER_SIZE     10
#define MAX_CLIENT      1024

typedef struct {
    int fd;
    char buf[BUFFER_SIZE + 1];
    ssize_t index;
    ssize_t left;
} CLIENT_INFO;

char *revstr(char *str);
void exit_sys(const char *msg);

int main(int argc, char *argv[])
{
    int sock, sock_client;
    int epfd;
    struct sockaddr_in sinaddr, sinaddr_client;
    socklen_t sinaddr_len;
    char ntopbuf[INET_ADDRSTRLEN];
    in_port_t port;
    ssize_t result;
    int nepes;
    int rnepes;
    int i;
    struct epoll_event epe;
    struct epoll_event epes[MAX_CLIENT];
    CLIENT_INFO *ci;

    if (argc != 2) {
        fprintf(stderr, "wrong number of arguments!..\n");
        exit(EXIT_FAILURE);
    }

    port = (in_port_t)strtoul(argv[1], NULL, 10);

    if ((epfd = epoll_create(1024)) == -1)
        exit_sys("epoll_create");

    if ((sock = socket(AF_INET, SOCK_STREAM, 0)) == -1)
        exit_sys("socket");

    sinaddr.sin_family = AF_INET;
    sinaddr.sin_port = htons(port);
    sinaddr.sin_addr.s_addr = htonl(INADDR_ANY);

    if (bind(sock, (struct sockaddr *)&sinaddr, sizeof(sinaddr)) == -1)
        exit_sys("bind");

    nepes = 1;
    epe.events = EPOLLIN;
    epe.data.fd = sock;
    if (epoll_ctl(epfd, EPOLL_CTL_ADD, sock, &epe) == -1)
        exit_sys("epoll_ctl");
    
    if (listen(sock, 8) == -1)
        exit_sys("listen");

    printf("Waiting for connection...\n");
    
    for (;;) {
        if ((rnepes = epoll_wait(epfd, epes, nepes, -1)) == -1)
            exit_sys("epoll");
        for (i = 0; i < rnepes; ++i) 
            if (epes[i].events & EPOLLIN) {
                if (epes[i].data.fd == sock) {
                    sinaddr_len = sizeof(sinaddr_client);
                    if ((sock_client = accept(sock, (struct sockaddr *)&sinaddr_client, &sinaddr_len)) == -1)
                        exit_sys("accept");

                    inet_ntop(AF_INET, &sinaddr_client.sin_addr, ntopbuf, INET_ADDRSTRLEN);


                    if ((ci = (CLIENT_INFO *)malloc(sizeof(CLIENT_INFO))) == NULL)
                        exit_sys("malloc");
                        
                    ci->fd = sock_client;
                    ci->index = 0;
                    ci->left = BUFFER_SIZE;
                    epe.events = EPOLLIN;
                    epe.data.ptr = ci;

                    if (epoll_ctl(epfd, EPOLL_CTL_ADD, sock_client, &epe) == -1)
                        exit_sys("epoll_ctl");
                    ++nepes;
                    
                    printf("New client Connected: %s : %u, total descriptor interested: %d\n", ntopbuf, (unsigned)ntohs(sinaddr_client.sin_port), nepes);    

                    continue;
                }
                
                ci = (CLIENT_INFO *)epes[i].data.ptr;
                if ((result = recv(ci->fd, ci->buf + ci->index, ci->left, 0)) == -1)
                    exit_sys("recv");
                if (result > 0) {
                    ci->index += result;
                    ci->left -= result;
                    if (ci->left == 0) {
                        ci->buf[ci->index] = '\0';
                        sinaddr_len = sizeof(sinaddr_client);

                        if (getpeername(ci->fd, (struct sockaddr *)&sinaddr_client, &sinaddr_len) == -1)
                            exit_sys("getpeername");
                        inet_ntop(AF_INET, &sinaddr_client.sin_addr, ntopbuf, INET_ADDRSTRLEN);
                        printf("%ld bytes received from %s (%u): %s\n", (long)ci->index, ntopbuf, (unsigned)ntohs(sinaddr_client.sin_port), ci->buf);
                        ci->index = 0;
                        ci->left = BUFFER_SIZE;
                    }
                }
                else { 
                    shutdown(ci->fd, SHUT_RDWR);
                    close(ci->fd);
                    --nepes;
                    free(ci);
                    printf("Client connection ended, total descriptors interested: %d\n", nepes);
                }
            }
    }
    
    close(sock);
    close(epfd);

    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/* client.c */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <netdb.h>

#define BUFFER_SIZE        1024

void exit_sys(const char *msg);

int main(int argc, char *argv[])
{
    int sock;
    struct addrinfo *ai, *ri;
    struct addrinfo hints = {0};
    char buf[BUFFER_SIZE];
    char *str;
    int result;
    
    if (argc != 3) {
        fprintf(stderr, "wrong number of arguments!..\n");
        exit(EXIT_FAILURE);
    }
    
    if ((sock = socket(AF_INET, SOCK_STREAM, 0)) == -1)
        exit_sys("socket");

    hints.ai_family = AF_INET;
    hints.ai_socktype = SOCK_STREAM;

    if ((result = getaddrinfo(argv[1], argv[2], &hints, &ai)) != 0) {
        fprintf(stderr, "getaddrinfo: %s\n", gai_strerror(result));
        exit(EXIT_FAILURE);
    }

    for (ri = ai; ri != NULL; ri = ri->ai_next) 
        if (connect(sock, ri->ai_addr, ri->ai_addrlen) != -1) 
            break;
    
    if (ri == NULL)
        exit_sys("connect");

    freeaddrinfo(ai);

    printf("Connected...\n");

    for (;;) {
        printf("Yazı giriniz:");
        fgets(buf, BUFFER_SIZE, stdin);
        if ((str = strchr(buf, '\n')) != NULL)
            *str = '\0';
         if (!strcmp(buf, "quit"))
            break;

        if ((send(sock, buf, strlen(buf), 0)) == -1)
            exit_sys("send");
    }

    shutdown(sock, SHUT_RDWR);
    close(sock);
    
    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/*--------------------------------------------------------------------------------------------------------------------------
    Aşağıda biriktirmeli işlem yapan server'ın select ile gerçekleştirimi görülmektedir.
---------------------------------------------------------------------------------------------------------------------------*/

/* server.c */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <sys/select.h>

#define BUFFER_SIZE     10
#define MAX_CLIENT      1024

char *revstr(char *str);
void exit_sys(const char *msg);

typedef struct {
    int fd;
    char buf[BUFFER_SIZE + 1];
    ssize_t index;
    ssize_t left;
} CLIENT_INFO;

int main(int argc, char *argv[])
{
    int sock, sock_client;
    struct sockaddr_in sinaddr, sinaddr_client;
    socklen_t sinaddr_len;
    char ntopbuf[INET_ADDRSTRLEN];
    in_port_t port;
    ssize_t result;
    fd_set rset, tset;
    CLIENT_INFO clients[MAX_CLIENT];
    int maxfd;
    int nclients = 0;
    int i;

    if (argc != 2) {
        fprintf(stderr, "wrong number of arguments!..\n");
        exit(EXIT_FAILURE);
    }

    port = (in_port_t)strtoul(argv[1], NULL, 10);
    FD_ZERO(&rset);

    if ((sock = socket(AF_INET, SOCK_STREAM, 0)) == -1)
        exit_sys("socket");

    sinaddr.sin_family = AF_INET;
    sinaddr.sin_port = htons(port);
    sinaddr.sin_addr.s_addr = htonl(INADDR_ANY);

    if (bind(sock, (struct sockaddr *)&sinaddr, sizeof(sinaddr)) == -1)
        exit_sys("bind");

    FD_SET(sock, &rset);
    maxfd = sock;

    if (listen(sock, 8) == -1)
        exit_sys("listen");

    printf("Waiting for connection...\n");
    
    for (;;) {
        tset = rset;
        if (select(maxfd + 1, &tset, NULL, NULL, NULL) == -1)
            exit_sys("select");

         if (FD_ISSET(sock, &tset)) {
            sinaddr_len = sizeof(sinaddr_client);
            if ((sock_client = accept(sock, (struct sockaddr *)&sinaddr_client, &sinaddr_len)) == -1)
                exit_sys("accept");

            clients[nclients].fd = sock_client;
            clients[nclients].index = 0;
            clients[nclients].left = BUFFER_SIZE;
            ++nclients;

            inet_ntop(AF_INET, &sinaddr_client.sin_addr, ntopbuf, INET_ADDRSTRLEN);
            printf("Connected: %s : %u\n", ntopbuf, (unsigned)ntohs(sinaddr_client.sin_port));    
            FD_SET(sock_client, &rset);
            if (sock_client > maxfd)
                maxfd = sock_client;
        }

        for (i = 0; i < nclients; ++i) 
            if (FD_ISSET(clients[i].fd, &tset)) {
                if ((result = recv(clients[i].fd, clients[i].buf + clients[i].index, clients[i].left, 0)) == -1)
                    exit_sys("recv");
                if (result > 0) {
                    clients[i].index += result;
                    clients[i].left -= result;
                    if (clients[i].left == 0) {
                        clients[i].buf[clients[i].index] = '\0';
                        sinaddr_len = sizeof(sinaddr_client);
                        if (getpeername(clients[i].fd, (struct sockaddr *)&sinaddr_client, &sinaddr_len) == -1)
                            exit_sys("getpeername");

                        inet_ntop(AF_INET, &sinaddr_client.sin_addr, ntopbuf, INET_ADDRSTRLEN);
                        printf("%ld bytes received from %s (%u): %s\n", (long)clients[i].index, ntopbuf, (unsigned)ntohs(sinaddr_client.sin_port), clients[i].buf);

                        clients[i].index = 0;
                        clients[i].left = BUFFER_SIZE;
                    }
        
                }
                else { 
                    shutdown(clients[i].fd, SHUT_RDWR);
                    close(clients[i].fd);
                    FD_CLR(clients[i].fd, &rset);
                    clients[i] = clients[nclients - 1];
                    --nclients;
                }
            }
    }
    
    close(sock);

    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/* client.c */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <netdb.h>

#define BUFFER_SIZE        1024

void exit_sys(const char *msg);

int main(int argc, char *argv[])
{
    int sock;
    struct addrinfo *ai, *ri;
    struct addrinfo hints = {0};
    char buf[BUFFER_SIZE];
    char *str;
    int result;
    
    if (argc != 3) {
        fprintf(stderr, "wrong number of arguments!..\n");
        exit(EXIT_FAILURE);
    }
    
    if ((sock = socket(AF_INET, SOCK_STREAM, 0)) == -1)
        exit_sys("socket");

    hints.ai_family = AF_INET;
    hints.ai_socktype = SOCK_STREAM;

    if ((result = getaddrinfo(argv[1], argv[2], &hints, &ai)) != 0) {
        fprintf(stderr, "getaddrinfo: %s\n", gai_strerror(result));
        exit(EXIT_FAILURE);
    }

    for (ri = ai; ri != NULL; ri = ri->ai_next) 
        if (connect(sock, ri->ai_addr, ri->ai_addrlen) != -1) 
            break;
    
    if (ri == NULL)
        exit_sys("connect");

    freeaddrinfo(ai);

    printf("Connected...\n");

    for (;;) {
        printf("Yazı giriniz:");
        fgets(buf, BUFFER_SIZE, stdin);
        if ((str = strchr(buf, '\n')) != NULL)
            *str = '\0';
         if (!strcmp(buf, "quit"))
            break;

        if ((send(sock, buf, strlen(buf), 0)) == -1)
            exit_sys("send");
    }

    shutdown(sock, SHUT_RDWR);
    close(sock);
    
    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/*--------------------------------------------------------------------------------------------------------------------------
    Bir tarafın diğer tarafa bir dosyanın içeriğini göndermesi (dosya aktarımı) sık rastlanan durumlardandır. Bunun şüphesiz klasik gerçekleştirim
    biçimi dosyadan blok blok okuma yapıp onları soketten yollamak ve benzer biçimde bir döngü içerisinde recv fonksiyonuyla alarak dosyaya yazmak olabilir. 
    Linux sistemlerinde (başka bazı sistemlerde de var) bu işlem için sendfile isimli bir sistem fonksiyonu bulundurulmuştur. Fonksiyonu prototipi şöyledir:

    ssize_t sendfile(int out_fd, int in_fd, off_t *offset, size_t count);

    Fonskiyonun birinci parametresi soket betimleyicisini almaktadır. İkinci parametre normal bir dosya betimleyicisidir. Fonksiyonun üçüncü parametresi
    aktarımın başlatılacağı offset değerini belirtmektedir. Bu parametre NULL geçilirse aktarım ikinci parametreyle belirtilen dosyanın başından itibaren yapılır. 
    Fonksiyon sonlandıktan sonra dosya göstericisinin yeni değeri bu adrese yerleştirilmektedir. Bu parametre NULL da geçilebilir. Bu durumda kopyalama ikinci parametreyle
    belirtilen dosyanın başından itibaren yapılır. Eğer bu offset parametresi NULL geçilmediyse ikinci parametreyle belirtilen dosyaya ilişkin dosya göstericisinin 
    değeri değiştirilmez ama bu parametre NULL geçilmişse bu dosyaya ilişkin dosya göstericisinin değeir değiştirilir. Son parametre kaç byte transfer edileceğidir. 
    Fonksiyon başarı durumunda aktarılan byte sayına başarısızlık durumunda -1 değerine geri döner. Bu fonksiyon sayesinde hiç user düzeyinde tampon kullanmadan tek bir hamlede
    bir dosyanın içeriğini soketten karşı tarafa gönderebiliriz. Fonksiyon başarı durumunda tampona yazılmış olan byte sayısıyla başarısızlık durumunda -1 değeri ile geri döner

    sendfile fonksiyonun POSIX standartlarında bulunmadığına Linux'a özgü olduğuna dikkat ediniz. 

    sendfile sistem fonksiyonu kernel 2.6.33'e kadar yalnızca dosyadan sokete kopyalama yapmak için kullanılıyordu. Bu versiyondan sonra fonksiyon herhangi iki betimleyici 
    arasında çalışabilir hale getirilmiştir. copy_file_range fonksiyonu ise halen yalnızca normal dosyalar için çalışabilmektedir. 

---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    TCP/IP client server uygulamaların önemli bir bölümünde mesajlaşma text tabanlı yapılmaktadır. Yani client server'a isteğini 
    bir yazı göndererek iletir, server da client'a yanıtı bir yazı biçiminde verir. Gerçekten de IP ailesinin TELNET, SSH, HTTP, 
    POP3, IMAP gibi protokolleri hep yazısal işlem yapmaktadır. Bir satır bilginin gönderilmesinde hiçbir problem yoktur. Ancak bir
    satırlık bilginin etkin bir biçimde alınabilmesi için bir algoritma kullanmak gerekir. Çünkü karakterlerin tek tek read ya da
    recv ile okunması yavaş bir seçenektir. Aşağıda her çağrıldığında soketten bir satır okuyan örnek bir fonksiyon verilmiştir. 
---------------------------------------------------------------------------------------------------------------------------*/

int sock_readline(int sock, char *buf, size_t len)
{
	char *bufx = buf;
	static char *bp;
	static ssize_t count = 0;
	static char b[2048];
	
    if (len <= 2)
        return -1;
        
	while (--len > 0) {
		if (--count <= 0) {
			if ((count = recv(sock, b, sizeof(b), 0)) == -1)
                return -1;
	        if (count == 0)
                return 0;
		    bp = b;
		}
		*buf++ = *bp++;
		if (buf[-1] == '\n' && buf[-2] == '\r') {
			*buf = '\0';
            break;
		}
	}

	return buf - bufx;
}

/*--------------------------------------------------------------------------------------------------------------------------
    IP ailesinin uygulama katmanındaki Telnet, SSH, HTTP, POP3, SMTP gibi protokoller yukarıda belirtildiği gibi hep yazısal işlem yapmaktadır. 
    Örneğin POP3 (Post Office Version 3) protokolü kabaca şöyledir:

    1) Client server'a (POP3 server) 110 numaralı porttan (POP3 için well known port) bağlanır. Bağlanma başarılı ise 
    Server Client'a "+OK <mesaj>\r\n" biçiminde bir satır yollar. 

    2) Bundan sonra client "USER <user name>\r\n" komutu ile mail adresini iletir. (Örneğin test@csystem.org). Server eğer bu işlem 
    başarılıysa "+OK\r\n" yazısını gönderir. 

    3) Client bundan sonra "PASS <password>\r\n" yazısını server'a göndererek password'ü iletmiş olur. Eğer password başarılı ise server
    "+OK Logged in.\r\n" yazısını balarısız ise "-ERR [AUTH] Authentication failed.\r\n" yazısını göndermektedir. 

    4) Şimdi client posta kutusundaki postalar hakkında "LIST\r\n" komutu ile bilgileri elde eder. Bu komuta karşı server birden fazla
    satırdan oluşan şöyle bir vermektedir:

    1 8088
    2 1568
    3 3962
    .

    Son satırın '.' ile bittiğine dikkat ediniz. 

    5) Client herhangi bir postayı "RETR <no>\r\n" ile elde edebilir. Buna karşı server e-postanın içeriğini birden fazla satır biçiminde yollayacaktır. 
    E-posta düz text ya da genellikle HTML olarak gönderilmiş olabilir. e-posta'ın içeriğinde MIME Type zaten belirtilemktedir. Bu konuda POP3 ve MIME 
    dokğmanlarına başvurabilirsiniz. 

    Bu protokolde server'ın olumlu yanıtlarında "+OK ...." olumlusuz yanıtlarında "-ERR ...." biçiminde satırlar gönderilmektedir. 

    6) Nihayet client işini bitirdikten sonra server'a "QUIT\t\n" komutunu gönderir. Server'da soketi kapatır. Client da sketin kapatılmış olduğunu anlar
    ve işini sonlandırır. 

    Aşağıda POP3 işlemi yapan TELNET benzeri bir program örneği verilmiştir. Programda bir thread sğrekli server'dan gelen satırları blokeli biçimde okumaktadır. 

---------------------------------------------------------------------------------------------------------------------------*/

/* pop3cient.c */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <errno.h>
#include <pthread.h>
#include <signal.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <netdb.h>

#define BUFFER_SIZE        1024

void *thread_proc(void *param);
int sock_readline(int sock, char *buf, size_t len);
void sigusr1_handler(int sno);
void exit_sys(const char *msg);

typedef struct {
    int sock;
    pthread_t tid;
} THREAD_PARAM;

int main(int argc, char *argv[])
{
    int sock;
    struct addrinfo *ai, *ri;
    struct addrinfo hints = {0};
    char buf[BUFFER_SIZE + 1];
    char *str;
    int result;
    pthread_t tid;
    struct sigaction sa;
    THREAD_PARAM *tp;
    
    if (argc != 3) {
        fprintf(stderr, "wrong number of arguments!..\n");
        exit(EXIT_FAILURE);
    }

    sa.sa_handler = sigusr1_handler;
    sa.sa_flags = 0;
    sigemptyset(&sa.sa_mask);
    
    if (sigaction(SIGUSR1, &sa, NULL) == -1)
        exit_sys("sigaction");

    if ((sock = socket(AF_INET, SOCK_STREAM, 0)) == -1)
        exit_sys("socket");

    hints.ai_family = AF_INET;
    hints.ai_socktype = SOCK_STREAM;

    if ((result = getaddrinfo(argv[1], argv[2], &hints, &ai)) != 0) {
        fprintf(stderr, "getaddrinfo: %s\n", gai_strerror(result));
        exit(EXIT_FAILURE);
    }

    for (ri = ai; ri != NULL; ri = ri->ai_next) 
        if (connect(sock, ri->ai_addr, ri->ai_addrlen) != -1) 
            break;
    
    if (ri == NULL)
        exit_sys("connect");

    freeaddrinfo(ai);

    if ((tp = malloc(sizeof(THREAD_PARAM))) == NULL)
        exit_sys("malloc");
    tp->sock = sock;
    tp->tid = pthread_self();
    if ((result = pthread_create(&tid, NULL, thread_proc, tp) != 0)) {
        fprintf(stderr, "pthread_create: %s\n", strerror(result));
        exit(EXIT_FAILURE);
    }

    for (;;) {
        if (fgets(buf, BUFFER_SIZE, stdin) == NULL)
            break;
        if (errno == EINTR)
            break;
        if ((str = strchr(buf, '\n')) != NULL)
            *str = '\0';
        if (!strcmp(buf, "quit"))
            break;

        strcat(buf, "\r\n");

        if (send(sock, buf, strlen(buf), 0) == -1)
            exit_sys("send");
    }

    shutdown(sock, SHUT_RDWR);
    close(sock);
    
    return 0;
}

void *thread_proc(void *param)
{
    char buf[BUFFER_SIZE + 1];
    THREAD_PARAM *tp = (THREAD_PARAM *)param;
    int result;

    for (;;) {
        if ((result = sock_readline(tp->sock, buf, BUFFER_SIZE)) == -1)
            exit_sys("sock_readline");
        if (!result)
            break;

        printf("%s", buf);
    }
  
    if ((result = pthread_kill(tp->tid, SIGUSR1)) != 0) {
        fprintf(stderr, "pthread_create: %s\n", strerror(result));
        exit(EXIT_FAILURE);
    }
        
    return NULL;
}

int sock_readline(int sock, char *buf, size_t len)
{
	char *bufx = buf;
	static char *bp;
	static ssize_t count = 0;
	static char b[2048];
	
    if (len <= 2)
        return -1;
        
	while (--len > 0) {
		if (--count <= 0) {
			if ((count = recv(sock, b, sizeof(b), 0)) == -1)
                return -1;
	        if (count == 0)
                return 0;
		    bp = b;
		}
		*buf++ = *bp++;
		if (buf[-1] == '\n' && buf[-2] == '\r') {
			*buf = '\0';
            break;
		}
	}

	return buf - bufx;
}

void sigusr1_handler(int sno)
{
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/*--------------------------------------------------------------------------------------------------------------------------
    Aslında POP3'te olduğu gibi pek çok protokol her komuta en az 1 satır yanıt vermektedir. Eğer server komuta karşı bir satırdan daha fazla
    bir yanıt veriyorsa genellikle bu ilk satırda ya da son satırda açığa vurulmaktadır. Örneğin POP3 protokolünde LIST komutu birden fazla
    satırlık bilgi gönderebilemektedir. Ancak son satır özellikle protokolde '.' biçiminde tutulmuştur. Böylece client programı yazan programcı
    bu '.' satırını gördüğünde satır okuma işlemini bitirilebilmektedir. Benzer biçimde POP3 protokolünde RETR komutunun birinci satırında e-postanın
    kaç byte'lık bir bilgi içerdiği belirtilmektedir. Böylece POP3 client programını yazam programcı bu sayıyı alarak tam o kadar byte okuyabilir. 
    Diğer diğer protokollerdeki mantıkta aslında çok benzerdir. 

    Aşağıdaki program yukarıdaki programın thread'siz dolayısıyla daha uygun bir versiyondur. Bu programda POP3 komutlarındaki yanıta da bakılarak
    porttan uygun miktarda okumalar yapılmıştır. 
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <ctype.h>
#include <string.h>
#include <unistd.h>
#include <errno.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <netdb.h>

#define BUFFER_SIZE        1024

void proc_list(int sock);
void proc_retr(int sock);
void getcmd(const char *buf, char *cmd);
int sock_readline(int sock, char *buf, size_t len);
void exit_sys(const char *msg);

int main(int argc, char *argv[])
{
    int sock;
    struct addrinfo *ai, *ri;
    struct addrinfo hints = {0};
    char bufsend[BUFFER_SIZE + 1];
    char bufrecv[BUFFER_SIZE + 1];
    char *str;
    ssize_t result;
    char cmd[BUFFER_SIZE];
    
    if (argc != 3) {
        fprintf(stderr, "wrong number of arguments!..\n");
        exit(EXIT_FAILURE);
    }
   
    if ((sock = socket(AF_INET, SOCK_STREAM, 0)) == -1)
        exit_sys("socket");

    hints.ai_family = AF_INET;
    hints.ai_socktype = SOCK_STREAM;

    if ((result = getaddrinfo(argv[1], argv[2], &hints, &ai)) != 0) {
        fprintf(stderr, "getaddrinfo: %s\n", gai_strerror(result));
        exit(EXIT_FAILURE);
    }

    for (ri = ai; ri != NULL; ri = ri->ai_next) 
        if (connect(sock, ri->ai_addr, ri->ai_addrlen) != -1) 
            break;
    
    if (ri == NULL)
        exit_sys("connect");

    freeaddrinfo(ai);

    if (sock_readline(sock, bufrecv, BUFFER_SIZE) == -1)
        exit_sys("sock_readline");
    printf("%s", bufrecv);
        
    for (;;) {  
        printf(">");
        fflush(stdout);
        if (fgets(bufsend, BUFFER_SIZE, stdin) == NULL)
            break;
        if ((str = strchr(bufsend, '\n')) != NULL)
            *str = '\0';
                
        strcat(bufsend, "\r\n");

        if (send(sock, bufsend, strlen(bufsend), 0) == -1)
            exit_sys("send");

        getcmd(bufsend, cmd);
        if (!strcmp(cmd, "LIST")) 
            proc_list(sock);
        else if (!strcmp(cmd, "RETR"))
            proc_retr(sock);
        else {
            if ((result = sock_readline(sock, bufrecv, BUFFER_SIZE)) == -1)
                    exit_sys("sock_readline");
                if (result == 0)
                    break;
            printf("%s", bufrecv);
            if (!strcmp(cmd, "QUIT"))
                break;
        }
    }

    shutdown(sock, SHUT_RDWR);
    close(sock);
    
    return 0;
}

void proc_list(int sock)
{
    ssize_t result;
    char bufrecv[BUFFER_SIZE];
    
    do {
        if ((result = sock_readline(sock, bufrecv, BUFFER_SIZE)) == -1)
            exit_sys("sock_readline");
        if (result == 0)
            break;
        printf("%s", bufrecv);
    } while (*bufrecv != '.');
}

void proc_retr(int sock)
{
    ssize_t result;
    char bufrecv[BUFFER_SIZE + 1];
    ssize_t n;
    int i, ch;

    for (i = 0;; ++i) {
        if ((result = recv(sock, &ch, 1, 0)) == -1)
            exit_sys("sock_readline");
        if (result == 0)
            return;
        if ((bufrecv[i] = ch) == '\n')
            break;
    } 
    bufrecv[i] = '\0';

    printf("%s", bufrecv);
    n = (ssize_t)strtol(bufrecv + 3, NULL, 10);
    printf("%ld\n", n);

    while (n > 0) {
        if ((result = recv(sock, bufrecv, BUFFER_SIZE, 0)) == -1)
            exit_sys("recv");
        if (result == 0)
            break;
        bufrecv[result] = '\0';
        printf("%s", bufrecv);
        fflush(stdout);
        n -= result;
    }
}

void getcmd(const char *buf, char *cmd)
{
    int i;

    for (i = 0; buf[i] != '\0' && !isspace(buf[i]); ++i)
        cmd[i] = buf[i];
    cmd[i] = '\0';
}

int sock_readline(int sock, char *buf, size_t len)
{
	char *bufx = buf;
	static char *bp;
	static ssize_t count = 0;
	static char b[2048];
	
    if (len <= 2)
        return -1;
        
    while (--len > 0) {
		if (--count <= 0) {
			if ((count = recv(sock, b, sizeof(b), 0)) == -1)
                return -1;
	        if (count == 0)
                return 0;
		    bp = b;
		}
		*buf++ = *bp++;
		if (buf[-1] == '\n' && buf[-2] == '\r') {
			*buf = '\0';
            break;
		}
	}

	return buf - bufx;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/*--------------------------------------------------------------------------------------------------------------------------
    Soketler yaratıldıktan sonra onların bazı özellikleri setsockopt isimli fonksiyonla değiştirilebilir ve getsockopt isimli fonksiyonla
    da alınabilir. setsockopt fonksiyonunun prototipi şyledir:

    int setsockopt(int socket, int level, int option_name, const void *option_value, socklen_t option_len);

    Fonksiyonun birinci parametresi özelliği değiştirilecek soketi belirtir. ikinci parametresi değişimin hangi düzeyde yapılacağını belirten bir
    sembolik sabit olarak girilir. Soket düzeyi için her zaman SOL_SOCKET girilmelidir. Üçüncü parametre hangi özelliğin değiştirileceğini belirtmektedir. 
    Dördüncü parametre değiştirilecek özelliğin değerinin bulunduğu nesnenin adresini almaktadır. Son parametre dördüncü parametredeki nesnenin uzunluğunu belirtmektedir. 
    Fonksiyon başarı durumunda 0, başarısızlık durumunda -1 değerine geri döner. 

    Soket seçeneğini elde etmek için de getsockopt fonksiyonu kullanılmaktadır:

    int getsockopt(int socket, int level, int option_name, void *restrict option_value, socklen_t *restrict option_len);

    Parametreler setsockopt'ta olduğu gibidir. Yalnızca dördüncü parametrenin yönü değişiktir. 

    Tipik soket seçenekleri (üçüncü parametre) şunlardan biri olabilir:

    SO_ACCEPTCONN
    SO_BROADCAST
    SO_DEBUG
    SO_DONTROUTE
    SO_ERROR
    SO_KEEPALIVE
    SO_LINGER
    SO_OOBINLINE
    SO_RCVBUF
    SO_RCVLOWAT
    SO_RCVTIMEO
    SO_REUSEADDR
    SO_SNDBUF
    SO_SNDLOWAT
    SO_SNDTIMEO
    SO_TYPE

    Burada bizim için şimdilik önemli olan birkaç seçenek vardır: SO_BROADCAST, SO_OOBLINE, SO_SNDBUF, SO_RECVBUF, SO_REUSEADDR.

    Örneğin:

    int buflen;
    int optsize = sizeof(int)
    ...
    if (getsockopt(sock_client, SOL_SOCKET, SO_RCVBUF, &buflen, &optsize) == -1)
        exit_sys("getsockopt");

---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    SO_REUSEADDR seçeneği belli bir port için bind işlemi yapmış bir server'ın sonlanması sonucunda bu server'ın yeniden çalıştırılıp
    aynı portu bind edebilmesi için kullanılmaktadır. Bir portu bind eden server, bir client ile bağlandıktan sonra çökerse, ya da her hangi
    bir biçimde sonlanırsa işletim sistemleri o portun yeniden belli bir süre bind edilmesini engellemektedir. Bunun nedeni eski çalışan server ile
    yeni çalışacak olan server'ın göndereceği ve alacağı paketlerin karışabilme olasılığıdır. Eski paketlerin ağda maksimum bir geçerlilik süresi vardır. 
    İşletim sistemi de bunun iki katı kadar bir süre (2 dakika civarı, neden iki katı olduğu protokolün aşağı seviyeli çalışması ile ilgilidir) bu protun yeniden
    bind edilmesini engellemktedir. İşte eğer bu soket seçeneği kullanılırsa artık sonlanan ya da çöken bir server hemen yeniden çalıiştırıldığında
    bind işlemi sırasında "Address already in use" biçiminde bir hata ile karşılaşılmayacaktır. Örneğin:
    
    int sockapt = 1;
    ...
    if (setsockopt(sock, SOL_SOCKET, SO_REUSEADDR, &sockopt, sizeof(sockopt)) == -1)
       exit_sys("setsockopt");

    SO_REUSEADDR seçeneğini set etmek için int bir nesne alıp onun içerisine sıfır dışı bir değer yerleştirip, onun adresini setsockopt fonksiyonunun dördünceü
    parametresine girmek gerekir. Bu nesneye 0 girip fonksiyonu çağırırsak bu özelliği kapatmış oluruz. Fonksiyonun dördüncü parametresine adresi girilecek nesnenin
    seçeneğe göree değişebileceğine dikkat ediniz. 

    SO_REUSEADDR bayrağı daha önce başka bir program tarafındna bind edilmiş soketin ikinci kez diğer bir program tarafından bind edilmesi için kullanılmamaktadır. 
    Eğer böyle bir ihtiyaç varsa (nadiren olabilir) Linux'ta (fakat POSIX'te değil) SO_REUSEPORT soket seçeneği kullanılmalıdır. Bu soket seçeneği benzer biçimde 
    Windows sistemlerinde SO_EXCLUSIVEADDRUSE biçimindedir. 

    Aşağıdaki server programını client ile bağlandıktan sonra
    Ctrl+C ile sonlandırınız. Sonra yeniden çalıştırmaya çalışınız. SO_REUSEADDR seçeneği kullanıldığından dolayı bir sorun ile karşılaşılmayacaktır. 
    Daha sonra server programdan o kısmı silerek yeniden denemeyi yapınız.
---------------------------------------------------------------------------------------------------------------------------*/

/* server.c */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>

#define BUFFER_SIZE     1024

void exit_sys(const char *msg);

int main(int argc, char *argv[])
{
    int sock, sock_client;
    struct sockaddr_in sinaddr, sinaddr_client;
    socklen_t sinaddr_len;
    char ntopbuf[INET_ADDRSTRLEN];
    in_port_t port;
    ssize_t result;
    char buf[BUFFER_SIZE + 1];
    int sockopt = 1;

    if (argc != 2) {
        fprintf(stderr, "wrong number of arguments!..\n");
        exit(EXIT_FAILURE);
    }

    port = (in_port_t)strtoul(argv[1], NULL, 10);

    if ((sock = socket(AF_INET, SOCK_STREAM, 0)) == -1)
        exit_sys("socket");

    if (setsockopt(sock, SOL_SOCKET, SO_REUSEADDR, &sockopt, sizeof(sockopt)) == -1)
        exit_sys("setsockopt");

    sinaddr.sin_family = AF_INET;
    sinaddr.sin_port = htons(port);
    sinaddr.sin_addr.s_addr = htonl(INADDR_ANY);

    if (bind(sock, (struct sockaddr *)&sinaddr, sizeof(sinaddr)) == -1)
        exit_sys("bind");

    if (listen(sock, 8) == -1)
        exit_sys("listen");

    printf("Waiting for connection...\n");
    
    sinaddr_len = sizeof(sinaddr_client);
    if ((sock_client = accept(sock, (struct sockaddr *)&sinaddr_client, &sinaddr_len)) == -1)
        exit_sys("accept");

    printf("Connected: %s : %u\n", inet_ntop(AF_INET, &sinaddr_client, ntopbuf, INET_ADDRSTRLEN), (unsigned)ntohs(sinaddr_client.sin_port));    

    for (;;)  {
        if ((result = recv(sock_client, buf, BUFFER_SIZE, 0)) == -1)
            exit_sys("recv");
        if (result == 0)
            break;
        buf[result] = '\0';
        if (!strcmp(buf, "quit"))
            break;
        printf("%ld bytes received from %s (%u): %s\n", (long)result, ntopbuf, (unsigned)ntohs(sinaddr_client.sin_port), buf);
    }
   
    shutdown(sock_client, SHUT_RDWR);
    close(sock_client);
    close(sock);
    
    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/* client.c */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <netdb.h>

#define BUFFER_SIZE        1024

void exit_sys(const char *msg);

int main(int argc, char *argv[])
{
    int sock;
    struct addrinfo *ai, *ri;
    struct addrinfo hints = {0};
    char buf[BUFFER_SIZE];
    char *str;
    int result;
    
    if (argc != 3) {
        fprintf(stderr, "wrong number of arguments!..\n");
        exit(EXIT_FAILURE);
    }
    
    if ((sock = socket(AF_INET, SOCK_STREAM, 0)) == -1)
        exit_sys("socket");

    hints.ai_family = AF_INET;
    hints.ai_socktype = SOCK_STREAM;

    if ((result = getaddrinfo(argv[1], argv[2], &hints, &ai)) != 0) {
        fprintf(stderr, "getaddrinfo: %s\n", gai_strerror(result));
        exit(EXIT_FAILURE);
    }

    for (ri = ai; ri != NULL; ri = ri->ai_next) 
        if (connect(sock, ri->ai_addr, ri->ai_addrlen) != -1) 
            break;
    
    if (ri == NULL)
        exit_sys("connect");

    freeaddrinfo(ai);

    printf("Connected...\n");

    for (;;) {
        printf("Yazı giriniz:");
        fgets(buf, BUFFER_SIZE, stdin);
        if ((str = strchr(buf, '\n')) != NULL)
            *str = '\0';
         if (!strcmp(buf, "quit"))
            break;

        if ((send(sock, buf, strlen(buf), 0)) == -1)
            exit_sys("send");
    }

    shutdown(sock, SHUT_RDWR);
    close(sock);
    
    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/*--------------------------------------------------------------------------------------------------------------------------
    OOB (Out-Of_Band) Data bazı stream protokollerinde olan bir özelliktir. Örneğin TCP protokolü bunu 1 byte olarak desteklemektedir. 
    OOB Verisine TCP'de "Acil (Urgent)" veri de denilmektedir. Bunun amacı OOB verisinin normal stream sırasında değil daha önce gönderilenlerin
    -eğer hedef host'ta henüz ele alınmamışlarsa- önünde ele alınabilmesidir. Yani biz TCP'de birtakım verileri gönderdikten sonra OOB verisini gönderirsek
    bu veri önce göndermiş olduklarımızdan daha önde işleme sokulabilir. Böylece uygulamalarda önce gönderilen birtakım işlemlerin iptal edilmesi gibi 
    gerekçelerle kullanılabilmektedir. 

    OOB verisini gönderebilmek için send fonksiyonunun flags parametresine MSG_OOB girmek gerekir. Tabii TCP yalnızca 1 byte uzunlğunda
    OOB verisinin gönderilmesine izin vermektedir. Bu durumda eğer send ile birden fazla byte MSG_OOB bayrağı ile gönderilmek istenirse gönderilenlerin
    yalnızca son byte'ı OOB olarak gönderilir. 

    Normal olarak OOB verisi recv fonksiyonunda MSG_OOB bayrağı ile alınır. Ancak bu bayrak kullanılarak recv çağrıldığında eğer bir OOB verisi 
    sırada yoksa recv başarısız olmaktadır. recv fonksiyonun MSG_OOB bayraklı çağrısında başarılı olabilmesi için o anda bir OOB verisinin gelmiş olması gerekir. 
    Pekiyi OOB verisinin geldiğini nasıl anlarız? İşte tipik yöntem SIGURG sinyaliin kullanılmasıdır. Çünkü sokete bir OOB verisi geldiğinde işletim sistemi 
    SIGURG sinyali oluşturabilmektedir. Bu sinyalin default durumu IGNORE biçimindedir. (Yani eğer set edilmemişse sanki sinyal oluşmamış gibi davranılır.)
    Fakat default olarak OOB verisi geldiğinde sinyal oluşmamaktadır. Bunu mümkün hale getirmek için soket üzerinde fcntl fonksiyonu ile F_SETOWN komut kodunu 
    kullanarak set işlemi yapmak gerekir. fcntl fonksiyonun son parametresi bu durumda sinyalin gönderileceği prosesin id değeri olarak girilmelidir. 
    Eğer bu parametre negatif bir proses grup id'si oalrak girilirse bu durumda işletim sistemi tüm proses grubuna sinyal göndermektedir. Örneğin:

    if (fcntl(sock_client, F_SETOWN, getpid()) == -1)
        exit_sys("fcntl");

    Aşağıdaki server programda bir OOB verisi geldiğinde SIGURG sinyali oluşturulmaktadır. Bu sinyalin içerisinde recv fonksiyonu MSG_OOB bayrağı 
    ile çağrılmıştır. OOB verisinin okunması için MSG_OOB bayrağı gerekir, ancak OOB verisinin olmadığı bir duurmda bu bayrak kullanılırsa recv başarısız olur.
    O halde SIGURG sinyali geldiğinde recv MSG_OOB ile çağrılmalıdır. Bu durumda TCP'de her zaman yalnızca 1 byte okunabilmektedir. Ayrıca server programda 
    SIGURG sinyali set edilirken sigaction yapısının flags parametresinin SA_RESTART biçimind egeçildiğine dikkat ediniz. Bu recv üzerinde beklerken oluşabilecek 
    SIGURG sinyalinden sonra recv'in otomatik yeniden başlatılması için kullanılmıştır. 

    Aşağıdaki client programda başı "u" harfi ile başlayan yazılar MSG_OOB bayrağı kullanılarak gönderilmiştir. Bu durumda yalnızca son byte'ın OOB verisi
    olacağını anımsayınız. OOB verileri her zaman mümkünse diğer verilerden önce ele alınmaktadır. 

---------------------------------------------------------------------------------------------------------------------------*/

/* oobserver.c */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <fcntl.h>
#include <unistd.h>
#include <signal.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>

#define BUFFER_SIZE     1024

void sigurg_handler(int sno);
void exit_sys(const char *msg);

int sock_client;

int main(int argc, char *argv[])
{
    int sock;
    struct sockaddr_in sinaddr, sinaddr_client;
    socklen_t sinaddr_len;
    char ntopbuf[INET_ADDRSTRLEN];
    in_port_t port;
    ssize_t result;
    char buf[BUFFER_SIZE + 1];
    struct sigaction sa;

    if (argc != 2) {
        fprintf(stderr, "wrong number of arguments!..\n");
        exit(EXIT_FAILURE);
    }

    sa.sa_handler = sigurg_handler;
    sa.sa_flags = SA_RESTART;
    sigemptyset(&sa.sa_mask);

    if (sigaction(SIGURG, &sa, NULL) == -1)
        exit_sys("sigaction");

    port = (in_port_t)strtoul(argv[1], NULL, 10);

    if ((sock = socket(AF_INET, SOCK_STREAM, 0)) == -1)
        exit_sys("socket");

    sinaddr.sin_family = AF_INET;
    sinaddr.sin_port = htons(port);
    sinaddr.sin_addr.s_addr = htonl(INADDR_ANY);

    if (bind(sock, (struct sockaddr *)&sinaddr, sizeof(sinaddr)) == -1)
        exit_sys("bind");

    if (listen(sock, 8) == -1)
        exit_sys("listen");

    printf("Waiting for connection...\n");
    
    sinaddr_len = sizeof(sinaddr_client);
    if ((sock_client = accept(sock, (struct sockaddr *)&sinaddr_client, &sinaddr_len)) == -1)
        exit_sys("accept");

    if (fcntl(sock_client, F_SETOWN, getpid()) == -1)
            exit_sys("fcntl");

    printf("Connected: %s : %u\n", inet_ntop(AF_INET, &sinaddr_client, ntopbuf, INET_ADDRSTRLEN), (unsigned)ntohs(sinaddr_client.sin_port));    
  
    for (;;)  {
        if ((result = recv(sock_client, buf, BUFFER_SIZE, 0)) == -1)    
            exit_sys("recv");
        if (result == 0)
            break;
        buf[result] = '\0';
        if (!strcmp(buf, "quit"))
            break;
        printf("%ld bytes received from %s (%u): %s\n", (long)result, ntopbuf, (unsigned)ntohs(sinaddr_client.sin_port), buf);
   }
   
    shutdown(sock_client, SHUT_RDWR);
    close(sock_client);
    close(sock);
    
    return 0;
}

void sigurg_handler(int sno)
{
    char oob;

    if (recv(sock_client, &oob, 1, MSG_OOB) == -1)
        exit_sys("recv");

    printf("OOB Data received: %c\n", oob);
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/* oobclient.c */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <netdb.h>

#define BUFFER_SIZE        1024

void exit_sys(const char *msg);

int main(int argc, char *argv[])
{
    int sock;
    struct addrinfo *ai, *ri;
    struct addrinfo hints = {0};
    char buf[BUFFER_SIZE];
    char *str;
    int result;
    
    if (argc != 3) {
        fprintf(stderr, "wrong number of arguments!..\n");
        exit(EXIT_FAILURE);
    }
    
    if ((sock = socket(AF_INET, SOCK_STREAM, 0)) == -1)
        exit_sys("socket");

    hints.ai_family = AF_INET;
    hints.ai_socktype = SOCK_STREAM;

    if ((result = getaddrinfo(argv[1], argv[2], &hints, &ai)) != 0) {
        fprintf(stderr, "getaddrinfo: %s\n", gai_strerror(result));
        exit(EXIT_FAILURE);
    }

    for (ri = ai; ri != NULL; ri = ri->ai_next) 
        if (connect(sock, ri->ai_addr, ri->ai_addrlen) != -1) 
            break;
    
    if (ri == NULL)
        exit_sys("connect");

    freeaddrinfo(ai);

    printf("Connected...\n");

    for (;;) {
        printf("Yazı giriniz:");
        fgets(buf, BUFFER_SIZE, stdin);
        if ((str = strchr(buf, '\n')) != NULL)
            *str = '\0';
         if (!strcmp(buf, "quit"))
            break;

        if ((send(sock, buf, strlen(buf), buf[0] == 'u' ? MSG_OOB : 0)) == -1)
            exit_sys("send");
    }

    shutdown(sock, SHUT_RDWR);
    close(sock);
    
    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/*--------------------------------------------------------------------------------------------------------------------------
    OOB verisi geldiğinde select fonksiyonu "sokette bir işlem oluştu" biçiminde geri dönmektedir. Ancak oluşan işlem "exceptional"
    kabul edilmektedir. Yani select fonksiyonunda dördüncü parametredeki bayraklara set işlemi yapmamız gerekir. Benzer biçimde OOB geldiğinde
    poll fonksiyonu da POLLPRI bayrağını set etmektedir. 

    Aşağıdaki örnekte OOB verisi select fonksiyonu ile tespit edilmiştir.
---------------------------------------------------------------------------------------------------------------------------*/

/* oobserver.c */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <fcntl.h>
#include <unistd.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <sys/select.h>

#define BUFFER_SIZE     1024

void exit_sys(const char *msg);

int main(int argc, char *argv[])
{
    int sock, sock_client;
    struct sockaddr_in sinaddr, sinaddr_client;
    socklen_t sinaddr_len;
    char ntopbuf[INET_ADDRSTRLEN];
    in_port_t port;
    ssize_t result;
    char buf[BUFFER_SIZE + 1];
    fd_set rset, trset, eset, teset;
    char oob;
    
    if (argc != 2) {
        fprintf(stderr, "wrong number of arguments!..\n");
        exit(EXIT_FAILURE);
    }
    
    port = (in_port_t)strtoul(argv[1], NULL, 10);

    if ((sock = socket(AF_INET, SOCK_STREAM, 0)) == -1)
        exit_sys("socket");

    sinaddr.sin_family = AF_INET;
    sinaddr.sin_port = htons(port);
    sinaddr.sin_addr.s_addr = htonl(INADDR_ANY);

    if (bind(sock, (struct sockaddr *)&sinaddr, sizeof(sinaddr)) == -1)
        exit_sys("bind");

    if (listen(sock, 8) == -1)
        exit_sys("listen");

    printf("Waiting for connection...\n");
    
    sinaddr_len = sizeof(sinaddr_client);
    if ((sock_client = accept(sock, (struct sockaddr *)&sinaddr_client, &sinaddr_len)) == -1)
        exit_sys("accept");

    printf("Connected: %s : %u\n", inet_ntop(AF_INET, &sinaddr_client, ntopbuf, INET_ADDRSTRLEN), (unsigned)ntohs(sinaddr_client.sin_port));    
  
    FD_ZERO(&eset);
    FD_ZERO(&teset);

    FD_SET(sock_client, &rset);
    FD_SET(sock_client, &eset);

    for (;;)  {
        trset = rset;
        teset = eset;
        if (select(sock_client + 1, &trset, NULL, &teset, NULL) == -1)
            exit_sys("select");

        if (FD_ISSET(sock_client, &trset)) {
            if ((result = recv(sock_client, buf, BUFFER_SIZE, 0)) == -1)    
                exit_sys("recv");
            if (result == 0)
                break;
            buf[result] = '\0';
            if (!strcmp(buf, "quit"))
                break;
            printf("%ld bytes received from %s (%u): %s\n", (long)result, ntopbuf, (unsigned)ntohs(sinaddr_client.sin_port), buf);
        }
        if (FD_ISSET(sock_client, &teset)) {
            if ((result = recv(sock_client, &oob, 1, MSG_OOB)) == -1)    
                exit_sys("recv");
            printf("OOB Data received: %c\n", oob);
        }
    }
   
    shutdown(sock_client, SHUT_RDWR);
    close(sock_client);
    close(sock);
    
    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/* oobclient.c */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <netdb.h>

#define BUFFER_SIZE        1024

void exit_sys(const char *msg);

int main(int argc, char *argv[])
{
    int sock;
    struct addrinfo *ai, *ri;
    struct addrinfo hints = {0};
    char buf[BUFFER_SIZE];
    char *str;
    int result;
    
    if (argc != 3) {
        fprintf(stderr, "wrong number of arguments!..\n");
        exit(EXIT_FAILURE);
    }
    
    if ((sock = socket(AF_INET, SOCK_STREAM, 0)) == -1)
        exit_sys("socket");

    hints.ai_family = AF_INET;
    hints.ai_socktype = SOCK_STREAM;

    if ((result = getaddrinfo(argv[1], argv[2], &hints, &ai)) != 0) {
        fprintf(stderr, "getaddrinfo: %s\n", gai_strerror(result));
        exit(EXIT_FAILURE);
    }

    for (ri = ai; ri != NULL; ri = ri->ai_next) 
        if (connect(sock, ri->ai_addr, ri->ai_addrlen) != -1) 
            break;
    
    if (ri == NULL)
        exit_sys("connect");

    freeaddrinfo(ai);

    printf("Connected...\n");

    for (;;) {
        printf("Yazı giriniz:");
        fgets(buf, BUFFER_SIZE, stdin);
        if ((str = strchr(buf, '\n')) != NULL)
            *str = '\0';
         if (!strcmp(buf, "quit"))
            break;

        if ((send(sock, buf, strlen(buf), buf[0] == 'u' ? MSG_OOB : 0)) == -1)
            exit_sys("send");
    }

    shutdown(sock, SHUT_RDWR);
    close(sock);
    
    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/*--------------------------------------------------------------------------------------------------------------------------
    UNIX Domain soketler aynı makinenin prosesleri arasında haberleşmeler için kullanılabilmektedir. Bu bakımdan bu soketler
    IP ailesini kullanan soketlerden farklıdır. Unix domain soket yaratabilmek için socket fonksiyonun birinci parametresi 
    AF_UNIX geçilmelidir. Unix domain soketlerin TCP/IP ya da UDP/IP soketlerle bir ilgisi yoktur. Bu soketler UNIX/Linux sistemlerinde
    oldukça etkin bir biçimde gerçekleştirilmektedir. Dolayısıyla aynı makinenin prosesleri arasında haberleşmede borulara, mesaj kuyruklarına, 
    paylaşılan bellek alanlarına bir seçenek olarak kullanılabilmektedir. Hatta bazı UNIX türevi sistemlerde (ama Linux'ta böyle değil) aslında 
    çekirdek tarafından önce bu protokol gerçekleştirilip daha sonra boru mekanizması bu protokol kullanılarak gerçekleştirilmektedir. Böylece örneğin aynı makinedeki
    iki prosesin haberleşmesi için UNIX domain soketler TCP/IP ve UDP/IP soketlerine göre çok daha hızlı çalışmaktadır. Aynı makine üzerinde çok client'lı uygulamalar için
    UNIX domain soketler boru haberleşmesine göre organizasyonel avantaj bakımından da tercih edilebilmektedir. 

    UNIX domain soketlerin kullanımı en çok boru kullanımına benzemektedir. Ancak Unix domain soketlerin borulara olan bir üstünlüğü 
    "full duplex" haberleşme sunmasıdır. Bilindiği gibi borular "half duplex" bir haberleşme sunmaktadır. Ancak genel olarak boru 
    haberleşmeleri UNIX domain soket haberleşmelere göre daha hızlı olma eğilimindedir.

    UNIX domain soketler kullanım olarak daha önce görmüş olduğumuz TCP/IP ve UDP/IP soketlerine çok benzemektedir. Yani işlemler
    sanki TCP/IP ya da UDP/IP client server program yazılıyormuş gibi yapılır. Başka bir deyişle UNIX domain soketlerinde client ve 
    server programların genel yazım adımları TCP/IP ve UDP/IP ile aynıdır. 

    UNIX domain soketlerde client'ın server'a bağlanması için gereken adres bir dosya ismi yani yol ifadesi biçimindedir. Kullanılacak yapı
    sockaddr_in değil sockaddr_un yapısıdır. Bu yapı <sys/un.h> dosyası içerisinde  bildirilmiştir ve en azından şu elemanlara 
    sahip olmak zorundadır:

     struct sockaddr_un {
        sa_family_t sun_family;               
        char sun_path[108];            
     };

     Yapının sun_family elemanı AF_UNIX biçiminde, sun_path elemanı da soketi temsil eden dosyanın yol ifadesi biçiminde girilmelidir. Burada yol ifadesi
     verilen dosya bind işlemi tarafından yaratılmaktadır. Yaratılan bu dosyanın türü "ls -l komutunda" "(s)ocket" biçiminde görüntülenmektedir. 
     Eğer bu dosya zaten varsa bind fonksiyonu başarısız olur. Dolayısıyla bu dosyanın varsa silinmesi gerekmektedir. O halde client ve server programlar 
     işin başında bir isim altında anlaşmalıdır. sockaddr_un yapısı kullanılmadan önce sıfırlanmalıdır. bind tarafından yaratılan bu soket dosyaları 
     normal bir dosya değildir. Yani open fonksiyonuyla açılamamaktadır. 

    Aşağıda stream tabanlı örnek bir UNIX domain uygulaması verilmiştir. Bu örnekte client yalnızca bilgi göndermekte server ise bilgiyi alıp yazdırmaktadır. 
---------------------------------------------------------------------------------------------------------------------------*/

/* uds-server.c */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <errno.h>
#include <unistd.h>
#include <sys/socket.h>
#include <sys/un.h>

#define BUFFER_SIZE     1024

char *revstr(char *str);
void exit_sys(const char *msg);

int main(int argc, char *argv[])
{
    int sock, sock_client;
    socklen_t sunaddr_len;
    struct sockaddr_un sunaddr, sunaddr_client;
    ssize_t result;
    char buf[BUFFER_SIZE + 1];
    
    if (argc != 2) {
        fprintf(stderr, "wrong number of arguments!..\n");
        exit(EXIT_FAILURE);
    }

    if ((sock = socket(AF_UNIX, SOCK_STREAM, 0)) == -1)
        exit_sys("socket");
    
    memset(&sunaddr, 0, sizeof(sunaddr));
    sunaddr.sun_family = AF_UNIX;
    strcpy(sunaddr.sun_path, argv[1]);

    if (remove(argv[1]) == -1 && errno != ENOENT)
        exit_sys("remove");

    if (bind(sock, (struct sockaddr *)&sunaddr, sizeof(sunaddr)) == -1)
        exit_sys("bind");

    if (listen(sock, 8) == -1)
        exit_sys("listen");

    printf("Waiting for connection...\n");
    
    sunaddr_len = sizeof(sunaddr_client);
    if ((sock_client = accept(sock, (struct sockaddr *)&sunaddr_client, &sunaddr_len)) == -1)
        exit_sys("accept");

    printf("Connected: %s\n", sunaddr_client.sun_path);
            
    for(;;) {
        if ((result = recv(sock_client, buf, BUFFER_SIZE, 0)) == -1)
            exit_sys("recv");
        if (result == 0)
            break;
        buf[result] = '\0';
        if (!strcmp(buf, "quit"))
            break;
        printf("%ld bytes received: %s\n", (long)result, buf);
        
        revstr(buf);
        if (send(sock_client, buf, strlen(buf), 0) == -1)
            exit_sys("send");
    }

    close(sock_client);
    close(sock);
    
    return 0;
}

char *revstr(char *str)
{
    size_t i, k;
    char temp;

    for (i = 0; str[i] != '\0'; ++i)
        ;
    
    for (--i, k = 0;  k < i; ++k, --i) {
        temp = str[k];
        str[k] = str[i];
        str[i] = temp;
    }

    return str;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/* uds-client.c */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/socket.h>
#include <sys/un.h>

#define BUFFER_SIZE        1024

void exit_sys(const char *msg);

int main(int argc, char *argv[])
{
    int sock;
    struct sockaddr_un sunaddr;
    char buf[BUFFER_SIZE];
    char *str;
    ssize_t result;
    int sresult;
    
    if (argc != 2) {
        fprintf(stderr, "wrong number of arguments!..\n");
        exit(EXIT_FAILURE);
    }
    
    if ((sock = socket(AF_UNIX, SOCK_STREAM, 0)) == -1)
        exit_sys("socket");
    
    memset(&sunaddr, 0, sizeof(sunaddr));
    sunaddr.sun_family = AF_UNIX;
    strcpy(sunaddr.sun_path, argv[1]);

    if (connect(sock, (struct sockaddr *)&sunaddr, sizeof(sunaddr)) == -1)
        exit_sys("socket");
    
    for (;;) {
        printf("Yazı giriniz:");
        fgets(buf, BUFFER_SIZE, stdin);
        if ((str = strchr(buf, '\n')) != NULL)
            *str = '\0';
        if ((send(sock, buf, strlen(buf), 0)) == -1)
            exit_sys("send");
        if (!strcmp(buf, "quit"))
            break;

        if ((result = recv(sock, buf, BUFFER_SIZE, 0)) == -1)
            exit_sys("recv");
        if (result == 0)
            break;
        buf[result] = '\0';
        printf("%ld bytes received: %s\n", (long)result, buf);
    }

    close(sock);
    
    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/*--------------------------------------------------------------------------------------------------------------------------
    Stream tabanlı UNIX domain soketlerde server accept uyguladığında client'a ilişkin sockaddr_un yapısında ne almaktadır?
    Aslında bu protokolde bir port kavramı olmadığına göre server'ın bağlantıdan bir bilgi elde etmeyecektir. Fakat yine de 
    client program da bind uygulayıp ondan sonra sokete bağlanabilir. Bu durumda server client bağlantısından sonra sockaddr_un
    yapısından client'ın bind ettiği soket dosyanın yol ifadesini elde eder. 

    Multi client UNIX domain soket uygulamalarında  tamamen TCP/IP'de yapmış olduğumuz server modellerinin aynıları kullanılabilmektedir. 
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    UNIX domain soketlerde datagram haberleşme de yapılabilir. Bu haberleşme mesaj kuyruklarına bir seçenektir.  UNIX domain 
    soket datagram haberleşmede gönderilen datagram'ların aynı sırada alınması garanti edilmiştir. Yani gönderim UDP/IP'de olduğu gibi 
    güvensiz değil güvenlidir. 

    Aşağıda UNIX domain soketler kullanılarak bir datagram haberleşme örneği verilmektedir. Burada server hiç bağlantı sağlamadan herhani bir
    client'tan paketi alır, oradaki yazıyı ters çevirip ona geri gönderir. Hem client hem de server ayrı ayrı iki dosya ismi ile bind işlemi paymaktadırlar. 
    Server program komut satırı argümanı olarak kendi bind edeceği soket dosyasının yol ifadesini, client program ise hem kendi bind edeceği soket dosyasının
    yol ifadesini hem de server soketin yol ifadesini almaktadır. 
---------------------------------------------------------------------------------------------------------------------------*/

/* uds-dg-server.c */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <errno.h>
#include <unistd.h>
#include <sys/socket.h>
#include <sys/un.h>

#define BUFFER_SIZE     4096

char *revstr(char *str);
void exit_sys(const char *msg);

int main(int argc, char *argv[])
{
    int sock;
    struct sockaddr_un sunaddr, sunaddr_client;
    socklen_t sunaddr_len;
    ssize_t result;
    char buf[BUFFER_SIZE + 1];

    if (argc != 2) {
        fprintf(stderr, "wrong number of arguments!..\n");
        exit(EXIT_FAILURE);
    }

    if ((sock = socket(AF_UNIX, SOCK_DGRAM, 0)) == -1)
        exit_sys("socket");

    memset(&sunaddr, 0, sizeof(sunaddr));
    sunaddr.sun_family = AF_UNIX;
    strcpy(sunaddr.sun_path, argv[1]);

    if (remove(argv[1]) == -1 && errno != ENOENT)
        exit_sys("remove");

    if (bind(sock, (struct sockaddr *)&sunaddr, sizeof(sunaddr)) == -1)
        exit_sys("bind");

    printf("Waiting for client data...\n");
        
    for (;;)  {
        sunaddr_len = sizeof(sunaddr_client);
        if ((result = recvfrom(sock, buf, BUFFER_SIZE, 0, (struct sockaddr *)&sunaddr_client, &sunaddr_len)) == -1)
            exit_sys("recvfrom");
        
        buf[result] = '\0';
        printf("%ld bytes received from %s: %s\n", (long)result, sunaddr_client.sun_path, buf);

        revstr(buf);
        if (sendto(sock, buf, strlen(buf), 0, (struct sockaddr *)&sunaddr_client, sizeof(struct sockaddr)) == -1)
            exit_sys("sendto");
    }
  
    close(sock);
    
    return 0;
}

char *revstr(char *str)
{
    size_t i, k;
    char temp;

    for (i = 0; str[i] != '\0'; ++i)
        ;
    
    for (--i, k = 0;  k < i; ++k, --i) {
        temp = str[k];
        str[k] = str[i];
        str[i] = temp;
    }

    return str;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/* uds-dg-client.c */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <errno.h>
#include <unistd.h>
#include <sys/socket.h>
#include <sys/un.h>

#define BUFFER_SIZE        4096

void exit_sys(const char *msg);

int main(int argc, char *argv[])
{
    int sock;
    struct sockaddr_un sunaddr, sunaddr_server;
    socklen_t sunaddr_len;
    char buf[BUFFER_SIZE];
    char *str;
    ssize_t result;
    
    if (argc != 3) {
        fprintf(stderr, "wrong number of arguments!..\n");
        exit(EXIT_FAILURE);
    }
    
    if ((sock = socket(AF_UNIX, SOCK_DGRAM, 0)) == -1)
        exit_sys("socket");

    memset(&sunaddr, 0, sizeof(sunaddr));
    sunaddr.sun_family = AF_UNIX;
    strcpy(sunaddr.sun_path, argv[1]);

    if (remove(argv[1]) == -1 && errno != ENOENT)
        exit_sys("remove");

    if (bind(sock, (struct sockaddr *)&sunaddr, sizeof(sunaddr)) == -1)
        exit_sys("bind");

    memset(&sunaddr_server, 0, sizeof(sunaddr));
    sunaddr_server.sun_family = AF_UNIX;
    strcpy(sunaddr_server.sun_path, argv[2]);

    for (;;) {
        printf("Yazı giriniz:");
        fgets(buf, BUFFER_SIZE, stdin);
        if ((str = strchr(buf, '\n')) != NULL)
            *str = '\0';
         if (!strcmp(buf, "quit"))
            break;

        if (sendto(sock, buf, strlen(buf), 0, (struct sockaddr *)&sunaddr_server, sizeof(sunaddr_server)) == -1)
            exit_sys("sendto");

        sunaddr_len = sizeof(sunaddr_server);
        if ((result = recvfrom(sock, buf, BUFFER_SIZE, 0, (struct sockaddr *)&sunaddr_server, &sunaddr_len)) == -1)
            exit_sys("recvfrom");

        buf[result] = '\0';
        printf("%ld bytes received from %s: %s\n", (long)result, sunaddr_server.sun_path, buf);
    }
    
    close(sock);
    
    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/*--------------------------------------------------------------------------------------------------------------------------
    UNIX domain soketler "isimsiz boru haberleşmesine" benzer biçimde de kullanılabilmektedir. Anımsanacağı gibi isimsiz boru hanerleşmesinde
    yalnızca üst alt prosesler arası haberleşme yapılabilmekteydi. pipe fonksiyonu bize iki betimleyici veriyordu. Biz de 
    fork işlemi ile bu betimleyicileri alt prosese geçiriyorduk. Burada da benzer bir model uygulanmaktadır. 

    İsimsiz (unbound) soket yaratımı socketpair isimli fonksiyonuyla yapılmaktadır. Fonksiyonun prototipi şöyledir:

    int socketpair(int domain, int type, int protocol, int sv[2]);

    Fonksiyonun birinci parametresi protokol ailesinin ismini alır. Her ne kadar fonksiyon genel olsa da pek çok işletim sistemi 
    bu fonksiyonu yalnızca UNIX domain soketler için gerçekleştirmektedir. (Gerçekten de üst ve alt prosesler arasında UNIX domain soketler
    varken örneğin TCP/IP soketleriyle haberleşmenin zarardan başka bir faydası olmayacaktır.) Fonksiyonun ikinci parametresi kullanılacak 
    soketin türünü belirtir. Bu parametre yine SOCK_STREAM ya da SOCK_DGRAM biiminde girilmelidir. Üçüncü parametre kulalhılacak transport
    katmanını belirtmektedir. Bu parametre 0 olarak geçilebilir. Son parametre bir çift soket betimleyicisinin yerleştirileceği iki elemanlı
    int türden dizinin başlangıç adresini almaktadır. Fonksiyon başarı durumunda 0 değerine, başarısızlık durumunda -1 değerine geri dönmektedir. 

    socketpair fonksiyonu SOCK_STREAM soketler için zaten bağlantı sağlanmış iki soketi bize vermektedir. Yani bu fonksiyon çağrıldıktan sonra
    listen, accept, connect gibi fonksiyonların çağrılması gereksizdir. 

    Pekiyi isimsiz borularla socketpair fonksiyonuyla oluşturulan isimsiz UNIX domain soketler arasında ne fark vardır?
    Aslında bu iki kullanım benzer etkilere sahiptir. Ancak en önemli farklılık UNIX domain soketlerin çift yönlü (full duplex)
    bir haberleşme sağlamasıdır. Ayrıca isimsiz mesaj kuyrukları olmadığına dikkat ediniz. Halbuki isimsiz UNIX domain soketler sanki isimsiz
    mesaj kuyrukları gibi de kullanılabilmektedir. 

    Aşağıdaki programda tıpkı isimsiz boru haberleşmesinde olduğu gibi üst ve alt prosesler birbirileri arasında isimsiz UNIX domain
    soketler yoluyla haberleşmektedir. Buradaki soketlerin çift yönlü haberleşmeye olanak verdiğini anımsayınız. 
---------------------------------------------------------------------------------------------------------------------------*/

/* uds-socketpair.c */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/wait.h>
#include <sys/socket.h>

#define BUFFER_SIZE     1024

char *revstr(char *str);
void exit_sys(const char *msg);

int main(void)
{
    int socks[2];
    char buf[BUFFER_SIZE + 1];
    char *str;
    ssize_t result;
    pid_t pid;

    if (socketpair(AF_UNIX, SOCK_STREAM, 0, socks) == -1)
        exit_sys("socketpair");

    if ((pid = fork()) == -1)
        exit_sys("fork");

    if (pid != 0) {     /* parent */
        close(socks[1]);

        for (;;) {
            if ((result = recv(socks[0], buf, BUFFER_SIZE, 0)) == -1)
                exit_sys("recv");
            if (result == 0)
                break;
            buf[result] = '\0';
            if (!strcmp(buf, "quit"))
                break;
            revstr(buf);
            if (send(socks[0], buf, strlen(buf), 0) == -1)
                exit_sys("send");
        }

        if (waitpid(pid, NULL, 0) == -1)
            exit_sys("waitpid");

        close(socks[0]);

        exit(EXIT_SUCCESS);
    }
    else {              /* child */
        close(socks[0]);
        for (;;) {
            printf("Yazı giriniz:");
            fgets(buf, BUFFER_SIZE, stdin);
            if ((str = strchr(buf, '\n')) != NULL)
                *str = '\0';
            if ((send(socks[1], buf, strlen(buf), 0)) == -1)
                exit_sys("send");
            if (!strcmp(buf, "quit"))
                break;
            if ((result = recv(socks[1], buf, BUFFER_SIZE, 0)) == -1)
                exit_sys("recv");
            if (result == 0)
                break;
            buf[result] = '\0';
            printf("%ld bytes received: %s\n", (long)result, buf);
        }
        close(socks[1]);
        exit(EXIT_SUCCESS);
    }
  
    return 0;
}

char *revstr(char *str)
{
    size_t i, k;
    char temp;

    for (i = 0; str[i] != '\0'; ++i)
        ;
    
    for (--i, k = 0;  k < i; ++k, --i) {
        temp = str[k];
        str[k] = str[i];
        str[i] = temp;
    }

    return str;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/*--------------------------------------------------------------------------------------------------------------------------
    TCP Protokolünün Seviyeli Çalışma Biçimi

    TCP protokolü RFC 793 dokümanlarında (https://tools.ietf.org/html/rfc793) tanımlanmıştır. Sonradan protokole bazı revizyonlar ve eklemeler yapılmıştır. 

    Paket tabanlı protokollerin hepsinde gönderilip alınan veriler paket biçimindedir (yani bir grup byte biçimindedir). Bu paketlerin
    "başlık (header) ve veri (data)"" kısmı vardır. Örneğin Ethernet paketinin başlık ve data kısmı, IP paketinin başlık ve data kısmı
    TCP paketinin başlık ve data kısmı bulunmaktadır. Öte yandan TCP protokolü aslında IP protokolünün üzerine konumlandırılmıştır. Yani aslında
    TCP Paketleri IP paketleri gibi gönderilip alınmaktadır. İşin gerçeği bu paketler bilgisayarımıza Ethernet paketi olarak gelmektedir.
    Paketlerin başlık kısımlarında önemli "meta data" bilgileri bulunmaktadır. O halde aslında bizim network kartımıza bilgiler sanki ethernet paketiymiş gibi gelmektedir. 
    O zaman network kartımıza gelen paketin bir ethernet başlığı ve bir de ethernet data kısmı olmalıdır. İşte aslında IP paketi de Ethernet paketinin data kısmında
    konuşlandırılır. TCP paketi de aslında IP paketinin data kısmında konuşlandırılmaktadır. O halde aslında bize gelen ethernet paketinin data kısmında ip paketi, 
    IP paketinin data kısmında TCP paketi bulunmaktadır. TCP'de gönderdiğimiz verier aslında TCP paketinin data kısmını oluşturmaktadır. Aşağıdaki şekilde bir paketin
    datas'sı TAB ile girintilenerek gösterilmiştir. İşte bize gelen Ethernet Paketi şu görünümdedir:

    Ether Başlığı
        IP Başlığı
            TCP Başlığı
                TCP Datası

    Örneğin biz send fonksiyonuyla "ankara" yazısını gönderiyor olsak bu "ankara" yazısını oluşturan byte'lar aslında TCP Data'sındadır.

    Ether Başlığı
        IP Başlığı
            TCP Başlığı
                "Ankara"

    Tabii IP paketleri aslında yalnızca bilgisayarımıza gelirken Ethernet paketi olarak gelir. Dışarda rotalanırken Ethernet paketi söz konusu değildir. 

    TCP Başlığı şöyledir:

    Source Port | Destination Port
    Sequence Number
    Acknowledge Number
    Data Offset | 000 | Flags | Window Size
    Checksum | Urgent Pointer
    Options

    Burada her satır 32 bit yani 4 byte yer kaplamaktadır. TCP başlığı 20 byte'tan 60 byte'a kadar değişen uzunlukta olabilir. Başlıktaki Data Offset
    TCP data'sının hangi offsetten başladığını dolayıısyla TCP başlığının uzunuğunu belirtir. Options 4 bit uzunluğundadır. Buradak değer 4 ile çarpılmalıdır. 
    Böylece Data Offset kısmında en az 5 (toplam 20 byte) en fazla 15 (topla    m 60 byte) değeri bulunabilir. Bu başlıkta kaynak ve hedef IP adreslerinin ve 
    TCP data kısmının uzunluğunun bulunmadığına dikkat ediniz. Çünkü bu bilgiler zaten IP başlığında doğrudan ya da dolaylı biçimde bulunmaktadır. 
    TCP paketi her zaman IP paketinin data kısmında kodlanır. 

    Başlıktaki Flags alanı 6 bitten oluşmaktadır. Her bir bir özelliği temsil eder. Buradaki belli bitler set edildiğinde başlıktaki belli alanlar da 
    anlamlı hale gelebilmektedir. Buradaki bitler şöyledir: URG, ACK, PSH, RST, SYN, FIN. Flags alanındaki bir'den fazla bit 1 olabilir. Bir TCP paketi (TCP segment)
    yalnızca başlık içerebilir. Yani hiç data içermeyebilir. 

    TCP protokolünde o anda iki tarafında bulunduğu bir durum vardır. Taraflar belli eylemler sonucunda durumdan duruma geçiş yaparlar. Bu nedenle TCP'nin çalışması
    bir "sonlu durum makinesi (finite state mschine)" biçiminde ele alınıp açıklanabilir. Henüz bağlantı yoksa iki taraf da CLOSED denilen durumdadır. 

    TCP bağlantısının kurulması için client ile server bazı paketleri gönderip almaktadır. Buna el sıkı������������ma (hand shaking) denilmektedir. TCP'de bağlantı kurulması
    için yapılan el sıkışma 3'lü (three way) ya da 4'lü (four way) olabilir. Uygulamada 3'lü el sıkışma kullanılmaktadır. Normal olarak bağlantının kurulabilmesi 
    için iki tarafın da birbirlerine SYN biti set edilmiş data kısmı olmayan TCP paketi (20 byte) gönderip karşı taraftan ACK biti set edilmiş (data'sı olmayan)
    TCP paketi alması gerekir. Bunun ikiyolu olabilir:

    Client              Server
    CLOSED              CLOSED
    ------- SYN -----> 
    SYN-SENT            SYN-RECEIVED
    <------ ACK ------
    <------ SYN ------
    ESTABLISHED
    ------- ACK ----->
                        ESTABLISHED

    Burada 4 paket kullanıldığı için buna 4'lü el sıkışma denilmektedir. Ancak pratikte 3'lü el sıkışma kullanılmaktadır:

    Client           Server
    CLOSED           CLOSED  
    ------- SYN -----> 
    SYN-SENT         SYN-RECEIVED
    <-- SYN + ACK ----
    ESTABLISHED
    ------- ACK ----->
                    ESTABLISHED

    Bağlantı kopartlması için iki tarafın da birbirilerine FIN biti set edilmiş paketler gönderip ACK biti set edilmiş paketleri alması gerekir. 
    Bağlantının kopartılması da tipik olarak 3'lü ya da 4'lü el sıkışma yoluyla yapılmaktadır. Bağlantının kopartılması talebini herhangi bir taraf başlatabilir.     
    3'lü el sıkışma ile bağlantının kopartılması şöyle 
    yapılmaktadır

    Peer-1              Peer-2

    ESTABLISHED         ESTABLISHED
    ------- FIN -----> 
    FIN-WAIT-1          CLOSE_WAIT
    <-- FIN + ACK ----
    FIN-WAIT-2          LAST-ACK
    ------- ACK ----->
    TIME-WAIT           CLOSED
    CLOSED

    Burada özetle bir taraf önce karşı tarafa FIN paketi yollamıştır. Karşı taraf buna ACK+FIN ile karşılık vermiştir. Diğer taraf da son olarak karşı tarafa ACK
    yollamıştır. Ancak bağlantıyı koprtmak isteyen taraf bu ACK yollama işinden sonra MSL (Maximum Segment Life) denilen bir zaman aralığının iki katı kadar
    beklemektedir (Tipik olarak 2 dakika). Eğer bu taraf beklemedne hemen CLOSED duruma geçseydi şöyle bir sorun oluşabilirdi: Bu taraf hemen yeniden programı çalıştırıp
    karşı tarafa paket yollayıp sanki eski bağlantıyı devam ettirme gibi bozuk bir durum söz konusu olabilirdi. Halbuki diğer taraf zaten bu son ACK paketini almamışsa
    belli zaman sonra CLOSED duruma geçmektedir. 

    Eğer shutdown işlemi ile sonlandırma yapılırsa sonlandırma 4'lü el sıkışmayla gerçekleşir. Pratikte daha çok bu durumla karşılaşılmaktadır. 4'lü el sıkışmaya
    "yarı kapama (half close)" el sıkışması da denmektedir. Yarı kapama bir tarafın artık send yapmayacağını ancak receive yapabileceğini belirtir. Bu durumda bağlantı devam
    edebilir. Ta ki karşı taraf da bu half close işlemini yapana kadar. 

    Peer-1              Peer-2

    ESTABLISHED         ESTABLISHED
    ------- FIN -----> 
    FIN-WAIT-1          CLOSE-WAIT
    <-- ACK -------
                        CLOSING

    Artık Pee1-1 data gönderemez ama alabilir. Peer2 ise alamaz ama gönderebilir.

    <-- FIN ------      
    TIME_WAIT
    ---- ACK ---->
                        TIME_WAIT
    CLOSED              CLOSED

    TCP'de akış kontrolü için "acknowledgement" yani alındı bildirimi kullanılmaktadır. Bir taraf bir tarafa birşeyler gönderdiği zaman karşı taraf bunu 
    aldığını Flags kısmındaki ACK biti set edilmiş bir paket ile bildirir. ACK paketleri boş olabilir ya da dolu olabilir. Yani karşı taraf bir bilgiyi 
    gönderirken de aynı anda daha önce almış olduğu bilgiler için ACK yollayabilir. TCP'de kümülatif bir "acknowledgement" sistemi kullanılmaktadır. 
    Gönderilen her byte'ın bir başlangıç sıra numarası vardır. Buna "sequence number" denilmektedir. Sequence number TCP başlığında 32 bitlik bir alandır. 
    Bu alandaki sayı son noktasına gelirse yeniden başa dönmektedir. Sequnce number bağlantı kurulduğunda sıfırdan başlamaz, rastgele bir değerden başlatılmaktadır. 
    Örneğin belli bir anda bir tarafın sequnce number değeri 1552 olsun. Şimdi bu taraf karşı tarafa 300 byte göndersin. Artık bu sequence number 1852 olacaktır. 
    Yani bir sonraki gönderimde bu taraf sequnce number olarak 1852 kullanacaktır. Sequnce number her gönderimde bulundurulmak zorundadır. Karşı taraf bilgiyi aldığını
    ACK bitiyle onaylarken TCP başlığındaki "acknowledgement number" denilen sayıyı da gönderir. Acknowledgement karşı taraftan talep edilen sonraki sequence number değeri olarak gnderilir.
    Örneğin:

    Peer-1                                          Peer-2
    
    300 byte (sequnce Number: 3560) ----->
    100 byte (sequnce Number: 3860) ----->
                                                  <---- ACK (Acknowledgement Number: 3960)
    50 byte  (sequnce Number: 3960) ------>
                                                    <---- ACK (Acknowledgement Number: 4010)    
    10 byte  (sequnce Number: 4010) ------>

    Pekiyi bir TCP paketi (TCP segment) gönderici (sender) tarafından gönderildikten sonra alıcı (receiver) bunu alamamışsa ne olacaktır? Çünkü TCP'nin güvenli bir protokol
    olması demek bir biçimde böyle bir durumda bir telafinin yapılması demektir. TCP protokolü şöyle yöntem izlemektedir: Gönderen taraf her gönderdiği paket (TCP segment) için 
    bir zamanlayıcı kurar. Bu zamanlayıcıya "retransmission timer" denilmektedir. Eğer belli süre içerisinde gönderilen TCP paketini kapsayan bir ACK gelediyse gönderici 
    taraf aynı paketi yeniden göndermektedir. Böylece aslında gönderilen paket henüz onun için ACK gelmedikçe gönderme tamponundan atılmaz. Retansmission Timer bazı değerlere
    göre dinamik bir biçimde oluşturulmaktadır. Bunun detayları için önerilen kaynaklara bakılabilir. Tabii böyle bir sistemde alıcı taraf aynı paketi birden fazla kez 
    alabilmektedir. Bu durumda bu paketlerin yalnızca tek bir kopyasını alıp diğerlerini atmak alıcı tarafın sorumluluğundadır. 

    Akış kontrolünün en önemli unsurlarından biri de tampon taşmasını engellemektir. Örneğin gönderici taraf sürekli bilgi gönderirse fakat alıcı taraftaki proses recv
    işlemiyle hiç okuma yapmazsa alıcı taraftaki işletim sisteminin alıcı tamponu dolabilir ve sistem çökebilir. İşte akış kontrolü sayesinde alıcı taraf gönderici tarafa
    "artık gönderme, benim tamponum doldu" diyebilmektedir. TCP'de bunun için "pencere (window)" kavramı kullanılmaktadır. Pencerenin bir büyüklüğü (window size) vardır. 
    Pencere büyüklüğü demek "hiç ACK gelmediği durumda göndericinin en fazla en fazla gönderebileceği byte sayısı" demektir. Örneğin pencerenin 8K olması demek "alıcı ACK"
    göndermedikten sonra göndericiinn en fazla 8K gönderebilmesi demektir. Pencere genişliği alıcı taraf tarafından gönderici tarafa bildirilir. Örneğin pencere genişliği
    8K olsun. Bu durumda gönderici taraf sırasıyla 1K + 1K + 1K + 1K + 1K uzunluğunda toplam 5K'lık bilgiyi karşı tarafa göndermiş olsun. Eğer henüz ACK gelmemişse
    gönderici taraf en fazla 3K kadar daha bilgi gönderebilir. Tam bu sırada iki ayrı 1K için kümülatif olarak ACK geldiğini düşünelim. Şimdi pencere genişliği gönderen taraf
    için ne olmalıdır? İşte bu durum alıcı taarafın ACK gönderirken aslında ACK gönderdiği bilgileri tamponunda eritmiş olup olmadığına bağlıdır. Pekala alıcı taraf
    ACK gönderdiği halde henüz oradaki proses recv yapmadığı için bu bilgileri 8K'lık tamponunda hala bekletiyor olabilir. Bu durumda gönderici tarafın pencere genişliğinin
    5K'ya düşürülmesi gerekir. İşte TCP'de her ACK sırasında yeni pencere genişliği de aslında karşı tarafa gönderilmektedir. O halde aslında pencere genişliği her ACK
    bildiriminde dinamik olarak ayarlanmaktadır. Tabii TCP çift taraflı olduğna göre her iki tarafın ayrı sequence number, acknowledgement number ve pencere genişlikleri 
    vardır. Ayrıca ACK paketlerinin illa da daha önce alınmış olan bir paketin alındığını bildirmek amaçlı kullanılmayabileceğini de belirtelim. Bir taraf pencere genişliğini
    ayarlamak için de ACK gönderebilir. Tabi bu durumda "acknowledgement number" yeni aynı değerde olmalıdır. 

    Pekiyi seqeunce number, pencere genişlikleri nasıl iki tarafa bildirilmektedir. İşte bağlantı kurulurken client taraf SYN paketi içerisinde
    kendi başlangıç sequence number'ını karşı tarafa iletmektedir. Server de bağlantıyı kabul ederken yine SYN (ya da SYN + ACK) paketinde kendi sequence number'ını
    karşı tarafa bildirmektedir. Aslında SYN paketi yalnızca başlık içermektedir. Data içermemektedir. Ancak TCP protokolüne göre özel bir durum olarak SYN paketlerinde
    sanki tek bir byte varmış gibi ackowledgement number alınmaktadır. Pencere genişliği de aslında ilk kez bağlantı yapılarkenki ACK paketlerinde belirtilmektedir. 
    Yukarıda belirtildiği gibi pencere genişliği her ACLK paketinde bildirilir. 

    TCP/IP stack gerçekleştirimleri ACK stratejisi için bazı yöntemler uygulamaktadır. Örneğin eğer gönderilecek paket varsa bununla birlikte ACK paketinin
    gönderilmesi, ACK'ların iki paket biriktirildikten sonra gönderilmesi gibi. Bunun için "Tcp IP Protocol Suite 466'ıncı sayfaya başvurabilirsiniz."

    TCP paketindeki önemli Flag'lerden birisi de "RST" bitidir. Buna "reset isteği" denilmektedir. Bir taraf RST bayrağı set edilmiş paket alırsa artık karşı tarafın
    "abnormal" bir biçimde bağlantıyı kopartıp yeniden bağlanma talep ettiği anlaşılır. Normal sonlanma el sıkışarak başarılı bir biçimde yapılırken RST işlemi anormal
    sonlanmaları temsil eder. Örneğin soket kütüphanelerinde hiç shutdown yapmadan soket close edilirse close eden taraf karşı tarafa RST paketi göndermektedir. 
    Halbuki önce shutdown yapılırsa el sıkışmalı sonlanma gerçekleştirilir. O halde her zaman aktif soketler shutdown yapıldıktan sonra close edilmelidir.   

---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    UDP protokolü aslında saf IP protokolüne çok benzerdir. UDP'yi IP'den ayıran iki önemli farklılık şudur:

    1) UDP'nin port numarası kavramına sahip olması 
    2) UDP'nin hata için bir checksum kontrolü uygulayabilmesidir. 

    Bir UDP paketi yine aslında IP paketinin data kısmında bulunmaktadır. IPV4 Formatı şöyledir:

    Source Port   | Destination Port
    Total Length  | Checksum
    Data

    Burada UDP paketinin toplam uzunluğunun bulunması aslında gereksizdir. Çünkü uzunluk TCP'de olduğu gibi aslında IP paketinin başlığına bakılarak
    tespit edilebilmektedir. Ancak hesaplama kolaylı oluşturmak için bu uzunluk UDP başlığında ayrıca bulundurulmuştur. Aslında checksum UDP paketlerinde
    bulunmak zorunda değildir.  Eğer gönderici checksum kontrolü istemiyorsa burayı 0 bitleriyle doldurur. (Eğer zaten checksum 0 ise burayı 1 bitleriyle 
    doldurmaktadır.) Alan taraf checksum hatasıyla karşılaşırsa TCP'de olduğu gibi paketi yeniden talep etmez. Yalnızca onu atar. 
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    İçerisinde derlenmiş bir biçimde fonksiyonların bulunduğu dosyalara kütüphane (library) denilmektedir. Kütüphaneler yalnızca fonksiyon değil
    global nesneler de içerebilirler. Kütüphaneler "statik" ve "dinamik" olmak üzere ikiye ayrılmaktadır. Statik kütüphane dosyalarının uzantıları
    UNIX/Linux sistemlerinde ".a", Windows sistemlerinde ".lib" biçimindedir. Dinamik kütüphanelerin uzantıları ise UNIX/Linux sistemlerinde ".so (shared object),
    Windows sistemlerinde ".dll (dynamic link library)" biçimindedir. 
    
    Statik kütüphaneler aslında "object modülleri (yani .o dosyalarını)" tutan birer kap gibidir. Statik kütüphaneler aslında object modüllerden oluşmaktadır. 
    Statik kütüphanelere link aşamasında linker tarafından bakılır. Bir program statk kütüphane dosyasından bir çağırma yaptıysa (ya da o kütüphaneden bir global değişkeni kullandıysa)
    linker o statik kütüphane içerisinde ilgili fonksiyonun bulunduğu  object modülü link aşamasında statik kütüphane dosyasından çekerek çalıştırılabilir dosyaya
    yazar. (Yani statik kütüphaneden bir tek fonksiyon çağırsak bile aslında o fonksiyonun bulunduğu object modülün tamamı çalıştırılabilen dosyaya yazılmaktadır.)
    Statik kütüphaneleri kullanan programlar artık o statik kütüphaneler olmadan çalıştırılabilirler. 

    Statik kütüphanelerin şu dezavantajları vardır:

    - Kütüphaneyi kullanan farklı programlar aynı fonksiyonun (onun bulunduğu object modülün) bir kopyasını çalıştırılabilir dosya içerisinde bulundururlar. 
    Yani örneğin printf fonksiyonu statik kütüphanede ise her printf kullanan C programı aslında printf fonksiyonun bir kopyasını da barındırıyor durumda olur.
    Bu da disk hacmini azaltır. Programların gereksinim duyacağı sanal bellek miktarını artırır.

    - Statik kütüphane kullanan programlar dinamik kütüphane kullanan programlara göre kimi zaman daha geç yüklenebilirler. 

    - Statik kütüphanede bir değişiklik yapıldığında onu kullanan programların yeniden link edilmesi gerekir.


    Statik kütüphane dosyalarının şu avantajları vardır:

    - Kolay konuşlandırılabilirler.

    - Kullanımları kolaydır ve build işlemini sadeleştirirler. 

    UNIX/Linux dünyasında kütüphane dosyaları geleneksel olarak başında "lib" öneki olacak biçimde isimlendirilmektedir. 

    UNIX/Linux sistemlerinde statik kütüphane dosyaları "ar" isimli utility programla oluşturulur. Programın tipik kullanım şöyledir:

    ar r libsample.a a.o b.o c.o

    r seçenği (yanında "-" olmadığına dikkat ediniz) ilgili object modüllerin kütüphaneye yerleştirilmesini sağlar. kütüphane yoksa ayrıca kütüphane dosyası da
    yaratılmaktadır. 
    
    t seçeneği kütüphane içerisindeki object modüllerin listesini almakta kullanılır. Örneğin:

    ar t libsample.a

    d seçeneği kütüphaneden bir object modülü silmekte, x seçeneği onu .o dosyası biçiminde save etmekte ve m seçeneği de yeni versiyonu eski versiyonla değiştirmekte
    kullanılır. O halde a.c dosyasının içindekileri statik kütüphaneye eklemek şöyle yapılmalıdır:

    gcc -c a.c
    ar r libsample.a a.o

    Statik kütüphaneler link aşamasında linker için komut satrında belirtilmelidir. Örneğin:

    gcc -o app app.c libsample.a

    gcc .a uzantılı dosyaları linker'a pass etmektedir. 

    Komut satırında kütüphane dosyalarının komut satırı argümanlarının sonunda belirtilmesi uygundur. Çünkü gcc programı kütüphane dosyalarının
    solundaki dosyalar link edilirken ilgili kütüphane dosyasını bu işleme dahil ederler. 

    Şüphesiz statik kütüphane kullanmak yerine aslında object modülleri de doğrudan link işlemine sokabiliriz. Örneğin:

    gcc -o sample sample.c a.o b.o

    Çok sayıda object modül söz konusu olduğunda bu işlemin zorlaşacağına dikkat ediniz. Yani object modüller dosyalara benzetilirse statik kütüphane dosyaları
    dizinler gibi düşünülebilir. 

    Derleme işlemi sırasında kütüphane dosyası -l<isim> biçiminde de belirtilebilir. Bu durumda arama sırasında "lib" öneki ve ".a" uzantısı aramaya 
    dahil edilmektedir. Yani örneğin:

    gcc -o sample sample.c -l sample

    İşleminde aslında libsample.a (ya da libsample.so) dosyaları aranmaktadır. Arama işlemi sırasıyla bazı dizinlerde yapılmaktadır. Örneğin /lib dizini, 
    /usr/lib dizini gibi dizinlere bakılmaktadır. Ancak bulunulan dizine bakılmamaktadır. Belli bir dizine bakılması isteniyorsa -L seçeneği ile dizin eklenebilir. 
    Örneğin:

     gcc -o sample sample.c -lsample -L.

    Buradaki '.' çalışma dizinini temsil etmektedir. 

    Bir statik kütüphane başka bir statik kütüphaneye bağımlı olabilir. Örneğin biz liby.a kütüphanesindeki kodda libx.a kütüphanesindeki 
    fonksiyonları kullanmış olabiliriz. Bu durumda liby.a kütüphanesini kullanan program libx.a kütüphanesini de komut satırında belirtmek zorundadır. Örneğin:

    gcc -o sample sample.c libx.a liby.a

---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Dinamik kütüphane dosyalarının UNIX/Linux sistemlerinde uzantıları ".so" (shared object'ten kısaltma), Windows sistemlerinde ise 
    .dll (Dynamic Link Library) biçimindedir. 

    Bir dinamik kütüphaneden bir fonksiyon çağrıldığında linker statik kütüphanede olduğu gibi gidip fonksiyonun kodunu çalıştırılabilen dosyaya yazmaz. 
    Bunun yerine çalıştırılabilen dosyaya çağrılan fonksiyonun hangi dinamik kütüphanede olduğu bilgisini yazar. Çalıştırılabilen dosyayı yükleyen işletim sistemi
    o dosyanın çalışması için gerekli olan dinamik kütüphaneleri çalıştırılabilen dosyayla birlikte bütünsel olarak sanal bellek alanına yüklemektedir. 
    Böylece birtakım ayarlamalar yapıldıktan sonra artık çağrılan fonksiyon için gerçekten o anda sanal belleğe yüklü olan dinamik kütüphane 
    kodlarına gidilmektedir. 

    Dinamik kütüphane kullanımının avantajları şunlardır:

    - Çalıştırılabilen dosyalar fonksiyon kodlarını içermezler. Dolayısıyla önemli bir disk hacmi kazanılmış olur. 

    - Dinamik kütüphaneler birden fazla program tarafından tekrar tekrar yüklenmeden kullanılabilmektedir. Yani işletim sistemi arka planda aslında
    aynı dinamik kütüphaneyi kullanan programlarda bu kütüphaneyi tekrar tekrar fiziksel belleğe yüklememektedir. Bu da statik kütüphanelere 
    göre önemli bir avantaj oluşturmaktadır. Bu durum eğer dinamik kütüphane daha önce yüklenmişse programın daha hızlı yüklemesine de yol açabilmektedir.

    - Dinamik kütüphaneleri kullanan programlar bu dinamik kütüphanelerdeki değişikliklerden etkilenmezler. Yani biz dinamik kütüphanenin yeni bir versiyonunu 
    oluşturduğumuzda bunu kullanan programları derlemek ya da link etmek zorunda kalmayız. 

    Dinamik kütüphaneler proseslerin sanal bellek alanlarının farklı yerlerine yüklenebilirler. Bunların yüklenme adreslerinin değişik olabilmesi "relocation"
    denilen sorunu ortaya çıkarmaktadır. "Relocation" çalıştırılabilir ya da dinamik kütüphane dosyalarının sanal bellekte herhangi bir yere yüklenebilmesi
    anlamına gelir. Ancak relocation işlemi basit bir işlem değildir. Çünkü bu dosyalar derlenirken derleyici onların sanal belleğin neresine yükleneceğini 
    bilmemektedir. Relocation işlemi için temelde iki teknik kullanılmaktadır:

    1) Relocation Tablosu Tekniği
    2) Konumdan Bağımsız Kod (Position Independent Code) Tekniği

    Windows işletim sistemi "relocation tablosu" tekniğini kullanmaktadır. Burada dosyada "relocation" bilgilerinin bulunduğu bir alan vardır. 
    Bu alanda adresleri düzeltilecek offset'ler dosyanın başından itibaren tek tek belirtilmektedir. Yükleyici DLL'i uygun yere yükledikten sonra 
    bu relocation tablosundaki offsetleri tek tek düzeltir. Böylece kod yüklendiği yerde çalışır hale getirilir. UNIX/Linux sistemlerinde ise ağırlıklı olarak
    "Konumdan Bağımsız Kod" Tekniği kullanılmaktadır. Burada üretilen kodlar zaten hep göreli adresler içerir. Böylece üretilen bu kodlar nereye 
    yüklenirse çalışabilir. 

    Relocation Tablosu yönteminde "relocation" işlemi belli bir zaman almaktadır. Bu da programın yüklenme zamanını uzatabilmektedir. Fakat dinamik kütüphane
    "reloaction" yapıldığında çalışma hızlıdır. Konumdan Bağımsız Kod tekniğinde "reloaction" zamanı minimize edilmiştir. Fakat göreli adreslerle çalışan kodlar
    toplamda daha yavaş olma eğilimindedir. 

    UNIX/Linux sistemlerinde bir dinamik kütüphane oluşturma işlemi şöyle yapılır:

    1) Önce dinamik kütüphaneye yerleştirilecek object modüllerin -fPIC seçeneği ile "Konumdan Bağımsız Kod (Position Independent Code)" tekniği 
    kullanılarak derlenmesi gerekir.
    2) Link işleminde "çalıştırılabilir (executable)" değil de "dinamik kütüphane" dosyasının oluşturulmaıs için -shared seçeneğinin kullanılması gerekir.
    -shared kullanılmazsa dinamik kütüphane değil normal çalıştırılabilir dosya oluşturulur.

    gcc -fPIC a.c b.c c.c
    gcc -o libsample.so -shared a.o b.o c.o

    Dinamik kütüphanelere daha sonra dosya eklenip çıkartılamaz. Onların her defasında yeniden oluşturulmaları gerekmektedir. Yukarıdaki işlem tek hamlede 
    şöyle de yapılabilir:

    gcc -o libsample.so -shared -fPIC a.c b.c c.c

    Dinamik kütüphane kullanan bir program link edilirken kullanılan dinamik kütüphanenin komut satırında belirtilmesi gerekir. Örneğin:

    gcc -o sample sample.c libsample.so

    Tabii bu işlem yine -l seçeneği ile de yapılabilirdi:

    gcc -o sample sample.c -lsample -L.

---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Default durumda gcc (ve tabii clang) derleyicileri standart C fonksiyonlarının ve POSIX fonksiyonlarını (glibc kütüphanesi)
    dinamik kütüphaneden alarak kullanır. Ancak programcı isterse -static seçeneği ile statik link işlemi de yapabilir. Bu durumda
    bu fonksiyonlar statik kütüphanelerden alınarak çalıştırılabilen dosyalara yazılacaktır. Örneğin:

    gcc -o sample -static sample.c

    Tabii bu biçimde statik link işlemi yapıldığında çalıştırılabilen dosyanın boyutu çok büyüyecektir.

    Bir programın kullandığı dinamik kütüphaneler ldd isimli uitility program ile basit bir biçimde görüntülenebilir. 
    Örneğin:

    csd@csd-vm:~/Study/Unix-Linux-SysProg/static-lib$ ldd sample
	linux-vdso.so.1 (0x00007fff38162000)
	libc.so.6 => /lib/x86_64-linux-gnu/libc.so.6 (0x00007f7ec0b5c000)
	/lib64/ld-linux-x86-64.so.2 (0x00007f7ec114f000

---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Pekiyi bizim programımız örneğin libsample.so isimli bir dinamik kütüphaneden çağrı yapıyor olsun. Bu libsample.so dosyasının 
    program çalıştırılırken nerede bulundurulması gerekir? İşte program çalıştırılırken ilgili dinamik kütüphane dosyasının özel bazı dizinlerde
    bulunuyor olması gerekir. Yükleme sırasında hangi dizinlere bakıldığı "man ld.so" sayfasından elde edilebilir. Bu dokümanda belirli sırada
    tek tek hangi dizinlere bakıldığı belirtilmiştir. Ayrıntılar bir yana bırakılırsa kabaca LD_LIBRARY_PATH isimli çevre değişkeninde 
    belirtilen dizinlere (bu çevre değişkeni de PATH çevre değişkeni gibi ':'ler ile ayrılmış dizinler oluşmaktadır. '.' dizini yine "o anki çalışma dizini"
    anlamına gelmektedir.) ve /lib, /usr/lib dizinlerine bakılmaktadır. O halde basit bir seçenek bizim dinamik kütüphanemizi /lib ya da /usr/lib
    dizinlerinin birinin içine çekmek ya da LD_LIBRARY_PATH çevre değişkenine dinamik kütüphanemizin bulunduğu dizini eklemktedir. /lib dizini işletim sisteminin
    boot edilebilmesi için gereken birtakım araçların da kullandığı daha temel bir kütüphane dizinidir. Uygulama programcılarının kütüphanelerini buraya değil
    /usr/lib içerisine yerleştirmesi daha uygun olur. 

    Dinamik kütüphanelerin aranacağı yer aslında doğrudan çalıştırılabilen dosyanın içerisine (.dynamic isimli bölüme (section)) da yazılabilir. Bunun için
    -rpath <yol ifadesi> linker seçeneği kullanılmalıdır. Buradaki yol ifadesinin mutlak olması gerekir. Ancak eskiden bunun için DT_RPATH isimli tag kullanılırken
    daha sonra bu tag "deprecated" yapılmış DT_RUNPATG tag'ı kullanılmaya başlanmıştır. Bu seçeneği linker'a geçirebilmek için gcc'de -Wl seçeneğini kullanmak 
    gerekir. -Wl seçeneği bitişik yazılan virgüllü alanlardan oluşmaktadır. gcc bınu ld linler'ına virgüller yerine boşluklar koyarak geçirmektedir. Örneğin:

    gcc -o sample -Wl,-rpath,/home/csd/Study/Unix-Linux-SysProg/static-lib,sample.c libsample.so

    Burada ELF formatının DT_RUNPATH tag'ına yerleştirme yapımaktadır. Eğer DT_RPATH tag'ına yerleştirme yapılmak isteniyorsa ayrıca --disable-new-dtags seçeneğinin
    de girilmesi gerekmektedir. Ancak burada küçük bir pürüz vardır. Kurulum sırasında dinamik kütüphane ya başka dizine yerleştirilirse ne olacaktır? İşte 
    -rpath seçeneğinde '$ORIGIN' program dosyasının bulunduğu dizin anlamına gelir. Örneğin:

    gcc -o sample -Wl,-rpath,'$ORIGIN'/. sample.c libsample.so 

    Burada artık neresi olursa olsun dinamik kütüphane çalıştırılan programla aynı dizinde bulunursa sorun oluşmayacaktır. Pekiyi DT_RPATH tag'ı neden deprecated yapılıp
    DT_RUNPATH tag'ı eklenmiştir? İşte aslında arama sırası bakımından DT_RPATH tag'ının en yukarıda olması (daha soğrusu LD_LIBRARY_PATH'in yukarısında olması) 
    yanlış bir tasarımdır. Geriye doğru uyumu koruyarak bu yanlış tasarım telafi edilmiştir. 

    Dinamik kütüphanenin aranması sırasında /lib ve /usr/lib dizilerine bakılmadan önce özel bir dosyaya da bakılmaktadır. Bu dosya /etc/ld.so.cache isimli dosyadır. 
    /etc/ld.so.cache dosyası aslında binary bir dosyadır. Bu dosya hızlı aramanın yapılabilmesi için "sözlük (dictionary)" tarzı bir içeriğe sahiptir. Bu dosya
    ilgili dinamik kütüphane dosyalarının hangi dizinler içerisinde olduğunu gösteren bir yapıdadır. (Yani bu dosya .so dosyalarının hangi dizinlerde olduğunu 
    belirten binary bir dosyadır.) Pekiyi bu dosyanın içerisinde hangi so dosyaları vardır? Aslında bu dosyanın içerisinde /lib ve /usr/lib dizinindeki so 
    dosyalarının hepsi vardır. Ama programcı isterse kendi dosyalarını da bu cache dosyasının içerisine yerleştirebilir. Pekiyi neden böyle bir cache 
    dosyasına gereksinim duyulmuştur? Dinamik kütüphaneler yüklenirken /lib ve /usr/lib dizinlerinin taranması göreli olarak uzun zaman almaktadır. 
    Bu da programın yüklenme süresini uzatabilmektedir. Halbuki bu dizinlere bakılmadan önce bu cache dosyasına bakılırsa ilgili dosyanın olup olmadığı varsa
    nerede olduğu çok daha hızlı bir biçimde elde edilebilmektedir. Burada dikkat edilmesi gereken nokta bu cache dosyasına /lib ve /usr/lib dizinlerinden 
    daha önce bakıldığı ve bu dizinlerin içeriğinin de zaten bu cache dosyasının içerisinde olduğudur. O halde aslında /lib ve /usr/lib dizinlerinde arama 
    çok nadir olarak yapılır. 

    Pekiyi /etc/ld.so.cache dosyasına biz nasıl bir dosya ekleriz? Aslında programcı bunu dolaylı olarak yapar. Şöyle ki: /sbin/ldconfig isimli bir program vardır.
    Bu program /etc/ld.so.conf isimli bir text dosyaya bakar. Bu dosya dizinlerden oluşmaktadır. Bu dizinlerin içindeki so dosyalarını /etc/ld.so.cache dosyasına
    ekler. Şimdiler de /etc/ld.so.conf dosyasının içeriği şöyledir:

    include /etc/ld.so.conf.d/*.conf

    Bu ifade /etc/ld.so.conf.d dizinindeki tüm .conf uzantılı dosyaların bu işleme dahil edileceğini belirtir. 

    Biz ldconfig programını çalıştırdığımızda bu program /lib, /usr/lib ve /etc/ld.so.conf (dolayısıyla /etc/ld.so.conf.d dizinindeki .conf dosyaları)na bakarak
    /etc/ld.so.cache dosyasını yeniden oluşturmaktadır. O halde bizim bu cache'e ekleme yapmak için tek yapacağımız şey /etc/ld.so.conf.d dizinindeki bir .conf
    dosyasına yeni bir satır olarak bir dizinin yol ifadesini girmektir. (.conf dosyaları her satırda bir dizinin yol ifadesinden oluşmaktadır) Tabii programcı 
    isterse bu dizine yeni bir .conf dosyası da ekleyebilir. İşte programcı bu işlemi yaptıktan sonra /sbin/ldconfig programını çalıştırınca artık onun eklediği
    dizinin içerisindeki so dosyaları da /etc/ld.so.cache dosyasının içerisine eklenmiş olacaktır. Daha açık bir anlatımla programcı bu cache dosyasına ekleme işini 
    adım adım şöyle yapar:

    1) Önce so dosyasını bir dizine yerleştirir. 
    2) Bu dizinin ismini /etc/ld.so.conf.d dizinindeki bir dosyanın sonuna ekler.
    3) /sbin/ldconfig programını çalıştırır.

    Programcı /etc/ld.so.conf.d dizinindeki herhangi bir dosyaya değil de -f seçeneği ile kendi belirlediği bir dosyaya da ilgili dizini yazabilmektedir. ldconfig 
    her çalıştırıldığında sıfırdan yeniden cache dosyasını oluşturmaktadır. 

    Programcı /lib ya da /usr/lib dizinine bir so dosyası eklediğinde ldconfig programını çalıştırması zorunlu olmasa da iyi bir tekniktir. Çünkü o dosya da cache
    dosyasına yazılacak ve daha hızlı bulunacaktır.

---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    UNIX/Linux sistemlerinde dinamik kütüphane dosyalarına isteğe bağlı olarak birer versiyon numarası verilmektedir. Bu versiyon numarası dosya 
    isminin bir parçası durumundadır. Linux sistemlerinde izlenen tipik numaralandırma (convention) şöyledir:

    <dosya ismi>.so.<majör numara>.<minör yüksek numara>.<minör alçak numara>

    Örneğin:

    libsample.so.2.4.6

    Majör numara büyük değişiklikleri, minör numaralar ise küçük değişiklikleri anlatmaktadır. Majör numara değişirse yeni dinamik kütüphane
    eskisiyle uyumlu olmaz. Burada "uyumlu değildir" lafı eski dinamik kütüphaneyi kullanan programların yenisini kullanamayacağı anlamına gelmektedir. 
    Çünkü muhtemelen bu yeni versiyonda fonksiyonların isimlerinde, parametrik yapılarında değişiklikler söz konusu olmuş olabilir. Bazı fonksiyonlar silinmiş olabilir. 
    Fakat majör numarası aynı ancak minör numaraları farklı olan kütüphaneler birbirleriyle uyumludur. Yani alçak minör numarayı kullanan program yüksek minör
    numarayı kullanırsa sorun olmayacaktır. Bu durumda yüksek minör numaralı kütüphanede hiçbir fonksiyonun ismi, parametrik yapısı değişmemiştir ve hiçbir fonksiyon
    silinmemiştir. Örneğin fonksiyonlarda daha hızlı çalışacak biçimde optimizasyonlar yapılmış olabilir. Ya da örneğin yeni birtakım fonksiyonlar da eklenmiş 
    olabilir. 

    Linux sistemlerinde bir konvansiyon olarak bir kütüphanenin üç ismi bulunmaktadır: Gerçek ismi (real name), so ismi (so name) ve linker ismi (linker name).
    Kütüphanenin majör ve çift minör versiyonlu ismine gerçek ismi denilmektedir. Örneğin:

    libsample.so.2.4.6

    so ismi ise yalnızca majör numara içeren ismidir. Örneğin yukarıdaki gerçek ismin so ismi şöyledir:

    libsample.so.2

    Linker ismi ismi ise hiç versiyon numarası içermeyen ismidir. Örneğin yukarıdaki kütüphanelerin linker ismi ise şöyledir:

    libsample.so

    İşte so ismi gerçek isme sembolik link, linker ismi de so ismine sembolik link yapılır. 

    linker ismi ---> so ismi ---> gerçek ismi

    Örneğin:

    gcc -o libsample.so.1.0.0 -shared -fPIC a.c b.c c.c     (gerçek isimli kütüphane dosyası oluşturuldu)      
    ln -s libsample.so.1.0.0 libsample.so.1                 (so ismi oluşturuldu)
    ln -s libsample.so.1 libsample.so                       (linker ismi oluşturuldu)

    lrwxrwxrwx 1 csd study   14 Nov 26 22:32 libsample.so -> libsample.so.1
    lrwxrwxrwx 1 csd study   18 Nov 26 22:31 libsample.so.1 -> libsample.so.1.0.0
    -rwxr-xr-x 1 csd study 7552 Nov 26 22:30 libsample.so.1.0.

    Dinamik kütüphanelerin linker isimleri link aşamasında (link ederken) kullanılan isimlerdir. Bu sayede link işlemini yapan programcıların daha az tuşa basarak 
    genel bir isim kullanması sağlanmıştır. Bu durumda örneğin biz libsample isimli kütüphane kullanan programı link etmek istersek şöyle yapabiliriz:

    gcc -o sample sample.c libsample.so

    Ya da şöyle yapabiliriz:

    gcc -o sample sample.c -lsample -L.
    
    Dinamik kütüphanelerin so isimleri aslında kütüphanenin tüm uyumlu (compatible) versiyonlarının ortak ismi gibi düşünülebilir. Kütüphanelerin so isimleri 
    aslında aynı zamanda kütüphanelerin gerçek isimlerine ilişkin kütüphane dosyalarının içerisinde SONAME tag'ıyla yazılmaktadır. Yani dinamik kütüphane 
    dosyalarının içerisinde SONAME isimli bir alan vardır. Bu SONAME alanı link işlemi sırasında -sonmame seneği ile doldurulur. Dİnamik kütüphaneyi 
    oluşturan programcı genel olarak bu SONAME alanına kütüphanenin soname'ini yazmalıdır. Örneğin:

    gcc -o libsample.so.1.0.0 -Wl,-soname,libsample.so.1 -shared a.o b.o c.o 

    Tabii programcı kütüphane dosyasında bu SONAME alanına hiç bir şey yazmayabilir. Örneğin:

    gcc -o libsample.so.1.0.0 -shared a.o b.o c.o 
    
    Bir kütüphane dosyasının SONAME alanı readelf -d seçeneği ile görüntülenebilir. (-d seçeneği ".dynamic" isimli bölünmü görüntülemektedir. SONAME alanı bu bölüm (section)
    içerisindedir.) Örneğin:

    readelf -d libsample.so.1.0.0 | grep SONAME

    Aynı işlemi objdum utility'si ile de şöyle yapabiliriz:

    objdump -x libsample.so.1.0.0 | grep SONAME

    Dinamik kütüphanelerin so isimleri yükleme sırasında gerçek yüklenecek dosyayı belirtmektedir. Yani örneğin libsample.so.1.0.0 dinamik kütüphane 
    dosyasının SONAME alanında libsample.so.1 ismi yazıyorsa aslında bu kütüphane yerine yükleyici libsample.so.1 isimli kütüphaneyi yükleyecektir. Tabii mademki
    libsample.so.1 dosyası libsample.so.1.0.0 dosyasına sembolik link yapılmıştır. Bu durumda yükleyici yine libsample.so.1.0.0 dosyasını yükler. Şimdi bu işlemleri
    yeniden sırasıyla en baştan yapalım:

    gcc -c -fPIC a.c b.c c.c
    gcc -o libsample.so.1.0.0 -shared -Wl,-soname,libsample.so.1 a.o b.o c.o
    ln -s libsample.so.1.0.0 libsample.so.1
    in -s libsample.so.1 libsample.so

    Şimdi de kütüphaneyi kullanan sample isimli programı derleyip link edelim:

    gcc -o sample sample.c libsample.so

    Şimdi ldd utility'si ile sample programının kullandığı dinamik kütüphanelere bakalım:

	linux-vdso.so.1 (0x00007ffd809b6000)
	libsample.so.1 => ./libsample.so.1 (0x00007ff0f491d000)
	libc.so.6 => /lib/x86_64-linux-gnu/libc.so.6 (0x00007ff0f452c000)
	/lib64/ld-linux-x86-64.so.2 (0x00007ff0f4d21000)

    Görüldüğü gibi aslında sample programı libsample.so sembolik linkinin izlediği libsample.so.1.0.0 dosyasını değil bu dosyanın SONAME alanında yazılı olan 
    libsample.so.1 dosyasını yüklemek istemektedir. Tabii neticede kütüphanelerin so isimleri gerçek isimlerine sembolik link yapıldığına göre aslında yine yükleyici
    libsample.so.1.0.0 dinamik kütüphanesini yğkleyecektir. 

    Pekiyi çalıştırılabilen bir dosyanın hangi dinamik kütüphaneleri kullandığı nerede yazmaktadır? İşte aslında bu bilgi çalıştırılabilen dosyanın içersinde
    .dynamic isimli bölümde DT_NEEDED taglarıyla belirtilir. ldd programı da aslında bu tag'lara bakmaktadır. Biz bu tagı yine istersek readelf -d ile görüntüleyebiliriz. 
    Örneğin:

    readelf -d sample | grep NEEDED
    0x0000000000000001 (NEEDED)             Shared library: [libsample.so.1]
    0x0000000000000001 (NEEDED)             Shared library: [libc.so.6]

    İşte aslında dinamik kütüphane kullanan program link edilirken linker kütüphane dosyasının SONAME tag alanına bakıp orada yazan dosyayı çalıştırılabilen dosyanın 
    NEEDED alanına yazmaktadır. Yükleyici aslında her zaman bu NEEDED alanındaki dinamik kütüphaneleri yüklemeye çalışmaktadır. 

    Pekiyi kütüphanenin SONAME alanına bir şey yazılmazsa ne olur? İşte bu durumda linker link işlemi sırasında belirtilen dinamik kütüphane dosyasını çalıştırılabilen dosyanın
    NEEDED alanına yerleştirir. Örneğin:

    gcc -c -fPIC a.c b.c c.c
    gcc -o libsample.so.1.0.0 a.o b.o c.o
    ln -s libsample.so.1.0.0 libsample.so.1
    in -s libsample.so.1 libsample.so

    gcc -o sample sample.c libsample.so

    Burada sample programının NEEDED tag'ı şöyle oluşturulacaktır:

    readelf -d sample | grep NEEDED
    x0000000000000001 (NEEDED)             Shared library: [libsample.so]
    0x0000000000000001 (NEEDED)             Shared library: [libc.so.6]

    Tabii sonuç olarak oluşturulan semblik linlerden dolayı yine yükleyici libsample.so.1.0.0 dosyasını yükleyecektir. 

    Peki bu durumda so isminin anlamı nedir? İşte eğer biz asıl isme ilişkin dosyanın so ismine yerleştirme yaparsak çalıştırılabi,len dosya o isimdeki dosyası yüklemek
    isteyecektir. Biz de sembolik linkleri değiştirerek onun başka bir minör versyonu yüklemesini sağlayabiliriz. Yani örneğin yukarıdaki uygulamada sample programı aslında
    sample.so.1 dosyasını yüklemek istemektedir. Normalde de bu dosya sample.so.1.0.0 dosyasını göstermektedir. Şimdi biz bu dosyanın ileride örneğin sample.so.1.0.1
    dosyasını göstermesini sağlayabiliriz. Artık sample programı çalıştırıldığında bu yeni versiyonu yüklemeye çalışacaktır. 

    so ismine ilişkin sembolik link çıkartma ve /etc/ld.so.cache dosyasının güncellenmesi işlemi ldconfig tarafından otomatik yapılmaktadır. Yani aslında biz kütüphanenin gerçek isimli dosyasını
    /lib ya da /usr/lib içerisinde yerleştirip ldconfig programını çalıştırdığımızda bu program zaten so ismine ilişkin sembolik linki de oluşturmaktadır.

    Özetle Dinamik kütüphane kullanırken şu konvansiyona uymak iyi bir tekniktir:

    - Kütüphane ismini lib ile başlatarak vermek
    - Kütüphane ismine mjör ve minör numara vermek
    - Gerçek isimli kütüphane dosyasını oluştururken so ismi olarak -Wl,-soname seçeneği ile kütüphanein so ismini yazmak
    - Kütüphane için linker ismi ve so ismini sembolik link biçiminde oluşturmak
    - Kütüphane paylaşılacaksa onu /usr/lib dizinine yerleştirmek ve ldconfig programı çalıştırarak /etc/ld.so.cache dosyasının güncellenmesini sağlamak. Bu işlem eğer
    kütüphaneyi /usr/lib içersine yerleştirmiyorsak yapılmayabilir.

---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Dinamik kütüphane dosyaları program çalıştırıldıktan sonra çalılşma zamanı sırasında belli bir noktada da yüklenebilir. Bu işlemin bazı avantajları
    şunlar olabilmektedir:

    - Program daha hızlı yüklenebilir.
    - Programın sanal bellek alanı gereksiz bir biçimde doldurulmayabilir. (Örneğin nadiren çalışacak bir fonksiyon dinamik kürüphanede olabilir. 
    Bu durumda o dinamik kütüphanenin işin başında yüklenmesi gereksiz bir yükleme zamanı ve bellek israfına yol açabilir.)

    Dinamik kütüphanelerin dinamik yüklenmesi dlopen, dlsym, dlerror ve dlclose fonksiyonlarıyla yapılmaktadır. Bu fonksiyonlarda libdl kütüphanesi 
    içerisindedir. Dolaısıyla link işlemi için -ldl seçeneğinin bulundurulması gerekir. dlopen fonksiyonun prototipi şöyledir:

    #include <dlfcn.h>

    void *dlopen(const char *filename, int flag);

    Fonksiyonun birinci parametresi yüklenecek dinamik kütüphanenin yol ifadesini, ikinci parametresi seçenek belirten bayrakları almaktadır. Fonksiyon başarı durumunda
    kütüphaneyi temsil eden bir handle değerine başarısızlık durumunda NULL adrese geri dönmektedir. Başarıszlık durumunda fonksiyon errno değişkenini set etmez. 
    Başarısızlığa ilikin yazı doğrudan dlerror fonksiyonuyla elde edilmektedir:

    char *dlerror(void);

    dlopen fonksiyonun birinci parametresindeki dinamik kütüphane isminde eğer hiç / karakteri yoksa bu durumda kütüphanenin aranması daha önce ele aldığımız
    prosedüre göre yapılmaktadır. Eğer dosya isminde en az bir / karakteri varsa dosya yalnızca bu mutlak ya da göreli yol ifadesinde aranmaktadır. 

    Dinamik yükleme sırasında yüklenecek kütüphanenin SONAME alanında yazılan isme hiç bakılmamaktadır. (Bu SONAME alanındaki isim yalnızca link aşamasında kullanılır)

    Kütüphanenin adres alanından boşaltılması ise dlclose fonksiyonuyla yapılmaktadır:

    int dlclose(void *handle);

    Fonksiyon başarı durumda 0, başarıszlık durumunda 0 dışı bir değere geri dönmektedir. Aynı kütüphane ikinci kez yüklenebilir. Bu durumda gerçek bir yükleme yapılmaz.
    Ancak yüklenen sayıda close işleminn yapılması gerekmektedir. 

    Kütüphanein içerisindeki fonksiyonlar ya da global nesneler adresleri elde eidlerek kullanılırlar. Bunların adreslerini elde edebilmek için dlsym isimli 
    fonksiyon kullanılmaktadır:

    void *dlsym(void *handle, const char *symbol);

    Fonksiyon başarı durumunda ilgili sembolün adresine başarısızlık durumunda NULL adrese geri döner. 

    Sembol isimleri konusunda dikkat etmek gerekir. Çünkü bazı derleyiciler bazı koşullar altında isimleri dekore edip object dosyaya
    yazabilmektedir. Örneğin C++ derleyicicileri fonksiyon isimlerini parametrik yapıyla kombine ederek başka bir isimle object dosyaya 
    yazar. Halbuki dlsym fonksiyonunda sembolün dinamik kütüphanedeki dekaore edilmiş isminin kullanılması gerekmektedir. Sembollerin dekore
    edilmiş isimlerini elde edebilmek için "nm" utility'sini kullanabilirisniz.    

    Aşağıda bir dinamik kütüphane dinamik olarak yüklenmiş ve oradan bir fonksiyon ve data adresi alınarak kullanılmıştır. 
---------------------------------------------------------------------------------------------------------------------------*/

#include <stdio.h>
#include <stdlib.h>
#include <dlfcn.h>

int main(void)
{
    void *dl;
    int (*padd)(int ,int);
    int result;
    int *pi;

    if ((dl = dlopen("libsample.so", RTLD_NOW)) == NULL) {
        fprintf(stderr, "dlopen: %s\n", dlerror());
        exit(EXIT_FAILURE);
    }

    if ((*(void **)&padd = dlsym(dl, "add")) == NULL) {
        fprintf(stderr, "dlsym: %s\n", dlerror());
        exit(EXIT_FAILURE);
    }

    result = padd(10, 20);
    printf("%d\n", result);

    if ((pi = (int *)dlsym(dl, "x")) == NULL) {
        fprintf(stderr, "dlsym: %s\n", dlerror());
        exit(EXIT_FAILURE);
    }
    printf("%d\n", *pi);

    dlclose(dl);

    return 0;
}   

/*--------------------------------------------------------------------------------------------------------------------------
    Dinamik kütüphane dlopen fonksiyonuyla yüklenirken global değişkenlerin ve fonksiyonların nihai yükleme adresleri bu dlopen işlemi sırasında
    hesaplanabilir ya da onlar kullanıldıklarında hesaplanabilir. İkisi arasında kullanıcı açısından bir fark olmamakla birlikte tüm sembollerin
    adreslerinin yükleme sırasında hesaplanması bazen yükleme işlemini (eğer çok sembol varsa) uzatabilmektedir. Bu durumu ayarlamak için dlopen fonksiyonun flags 
    parametresi kullanılır. Bu parametre RTLD_NOW olarak girilirse tüm sembollerin adresleri dlopen sırasında, RTLD_LAZY girilirse kullanıldıkları noktada 
    hesaplanmaktadır. İki biçim arasında çoğu kez programcı için bir farklılık oluşmamaktadır. Ancak aşağıdaki örnekte bu iki biçimin ne anlama geldiği 
    gösterilmektdir. 

    Aşağıdaki örnekte libmample.so kütüphanesindeki foo fonksiyonu gerçekte olmayan bir bar fonksiyonunu çağırmıştır. Bu fonksiyonun gerçekte olmadığı
    foo fonksiyonun sembol çözümlemesi yapıldığında anlaşılacaktır. İşte eğer bu kütüphaney,i kullanan sample.c programı kütüphaneyi RTLD_NOW ile yüklerse 
    tüm semboller o anda çözlümeye çalışılacağından dolayı bar'ın bulunmuyor olması hatası da dlopen sırasında oluşacaktır. Eğer kütüphane RTLD_LAZY ile
    yüklenirse bu durumda sembol çözümlemesi foo2nun kullanıldığı noktada (yani dlsym fonksiyonunda) gerçekleşecektir. Dolayısıyla hata da o o noktada oluşacaktır. 
---------------------------------------------------------------------------------------------------------------------------*/

/* mample.c */

#include <stdio.h>

void bar(void);

void foo(void)
{
    bar();
}

/* sample.c */

#include <stdio.h>
#include <stdlib.h>
#include <dlfcn.h>

int main(void)
{
    void *dl;
    void (*pf)(void);
    
    if ((dl = dlopen("libmample.so", RTLD_LAZY)) == NULL) {  /* RTLD_NOW ile de deneyiniz */
        fprintf(stderr, "dlopen: %s\n", dlerror());
        exit(EXIT_FAILURE);
    }

    printf("Ok\n");

    if ((*(void **)&pf = dlsym(dl, "foo")) == NULL) {
        fprintf(stderr, "dlsym: %s\n", dlerror());
        exit(EXIT_FAILURE);
    }

    pf();

    dlclose(dl);
   
    return 0;
}   
    
/*--------------------------------------------------------------------------------------------------------------------------
    Bazen bir dinamik kütüphane içerisindeki sembollerin o dinamik kütüphaneyi kullanan kodlar tarafından kullanılması istenmeyebilir. 
    Örneğin dinamik kütüphanede bar isimli bir fonksiyon vardır. Bu fonksiyon bu dinamik kütüphanenin kendi içerisinden başka fonksiyonlar tarafından
    kullanılıyor olabilir. Ancak bu fonksiyonun dinamik kütüphanenin dışından kullanılması istenmeyebilir. (Bunun çeşitli nedenleri olabilir. Örneğin
    kapsülleme sağlamak için, dışarıdaki sembol çakışmalarını ortadan kaldırmak için vs.) İşte bunu sağlamak amacıyla gcc'ye özgü __attribute__((...))
    eklentisindan faydalanılmaktadır. __attribute__((...)) eklentisi pek çok seçeneğe sahip platform spesifik bazı işlemlere yol açmaktadır. Bu eklentinin
    seçeneklerini gcc dokümanlarından elde edbilirsiniz. Bizim bu amaçla kullanacağımız __attribute__((...)) seçeneği "visibility" isimli seçenektir. 

    Aşağıdaki örnekte bar fonksiyonu foo fonksiyonu tarafından kullanılmaktadır. Ancak kütüphanin dışından bu fonksiyonun kullanılması istenmemiştir. 

    Burada fonksiyon özelliğinin (yani __attribute__ sentaksının) fonksiyon isminin hemen sola getirildiğine ve çift parantez kullanıldığına dikkat ediniz.
    Bıurada kullanılan özellik "visibility" isimli özelliktir ve değeri "hidden" biçimde verilmiştir. 

    Default durumda dinamik kütüphanedeki bütün global semboller dışarıdan kullanılabilmektedir. Buradaki __attribute__((visibility("hidden"))) özelliğinin
    fonksiyonu static yapmakla aynı şey olmadığına dikkat ediniz. Fonksiyon static yapılırsa o dinamik dinamik kütüphanedeki diğer modüller tarafından da kullanılamamaktadır.

---------------------------------------------------------------------------------------------------------------------------*/

/* mample.c */

#include <stdio.h>

void bar(void);

void foo(void)
{
    printf("foo\n");
    bar();
}

void __attribute__((visibility("hidden"))) bar(void)
{
    printf("bar\n");
}

/*--------------------------------------------------------------------------------------------------------------------------
    Bir dinamik kütüphane normal olarak ya da dinamik olarak yüklendiğinde birtakım ilk işlerin yapılması gerekebilir. (Örneğin
    kütüphane thread güvenli olma iddiasındadır ve birtakım senkronizasyon nesnelerinin ve thread'e özgü alanların yaratılması gerekebilir.)
    Bunun için __attribute__((constructor)) fonksiyon özelliği kullanılmaktadır. Benzer biçimde dinamik kütüphane programın adres alanından
    boşaltılırken de birtakım son işlemler için __attribute__((destructor)) ile belirtilen fonksiyon çağrılmaktadır. (Aslında bu constructor ve destructor 
    fonksiyonları normal programlarda da kullanılabilir. Bu durumda ilgili fonksiyonlar main fonksiyonundan önce ve main fonksiyonundan sonra çağrılmaktadır.)

    Dinamik kütüphane birden fazla kez yüklendiğinde yalnızca ilk yüklemede toplamda bir kez constructor fonksiyonu çağrılmaktadır. Benzer biçimde
    destructor fonksiyonu da yalnızca bir kez çağrılır.
---------------------------------------------------------------------------------------------------------------------------*/

/* mample.c */

#include <stdio.h>

void __attribute__((constructor)) dynamic_init()
{
    printf("dinamik kütüphane kullanılıyor..\n");
}

void __attribute__((destructor)) dynamic_exit()
{
    printf("dinamik kütüphane boşaltılıyor...\n");
}

void foo(void)
{
    printf("foo\n");
}

/* sample.c */

#include <stdio.h>
#include <stdlib.h>
#include <dlfcn.h>

int main(void)
{
    void *dl;
    
    if ((dl = dlopen("libmample.so", RTLD_NOW)) == NULL) {
        fprintf(stderr, "dlopen: %s\n", dlerror());
        exit(EXIT_FAILURE);
    }

    printf("ok\n");

    if ((dl = dlopen("libmample.so", RTLD_NOW)) == NULL) {
        fprintf(stderr, "dlopen: %s\n", dlerror());
        exit(EXIT_FAILURE);
    }

    dlclose(dl);

    return 0;
}   

/*--------------------------------------------------------------------------------------------------------------------------
    O anda makinemizdeki işletim sistemi hakındaki bilgi uname komutuyla elde edilebilir. Bu komut -r ile kullanılırsa o makinede yüklü olan
    kernek versiyonu elde edilmektedir. Örneğin:

    uname -r
    4.15.0-20-generic
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Kernel'ın bir parçası gibi işlev gören, herhangi bir koruma engeline takılmayan, kernel modda çalışan özel olarak hazırlanmış modüllere
    (yani kod parçalarına) Linux dünyasında "çekirdek modülleri (kernel modules)" denilmektedir. Çekirdek modülleri eğer kesme gibi bazı mekanizmaları
    kullanıyorsa ve bir donanım aygıtını yönetme iddiasındaysa bunlara özel olarak "aygıt sürücüleri (device drivers)" denilmektedir. 

    Genellikle bir Linux sistemini yüklediğimizde zaten kernel modüllerini ve aygıt sürücüleri oluşturabilmek için gereken kütüphaneler ve başlık dosyaları
    zaten yüklü biçimde bulunmaktadır. Tabii programcı kernel kodlarını da kendi makinesine indirmek isteyebilir. Bunun için aşağıdaki komut kullanılabilir:

    sudo apt-get install linux-source

    Eğer sisteminizde Linux'un kaynak kodları yüklü ise bu kaynak kodlar /usr/src dizininde bulunmaktadır. Bu dizindeki linux-headers-$(uname -r) 
    dizini kaynak kodlar yüklü olmasa bile bulunan bir dizindir ve bu dizin çekirdek modülleri ve aygıt sürücülerin "build edilmeleri" için gereken başlık dosyalarını
    barındırmaktadır. Benzer biçimde /lib/modules isimli dizinde $(uname -r) isimli bir dizin vardır. Bu dizin çekirek modüllerinin build edilmesi içingereken bazı kodları
    ve kütüphaneleri bulundurmaktadır. 

---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Bir kernel modülünde biz user mod için yazılmış kodları kullanamayız. Çünkü orası bir dünyadır. Kernnel modüllerinde biz
    yalnızca kernel içerisindeki bazı fonksiyonları kullanabiliriz. Bunlara "kernel tarafından export edilmiş fonksiyonlar" denilmektedir. 
    "Kernel tarafından export edilmiş fonksiyon kavramıyla "sistem fonksiyonu" kavramınn bir ilgisi yoktur. Sistem fonksiyonları user moddan çağrılmak 
    üzere tasarlanmış ayrı bir grup fonksiyondur. Oysa kernek tarafından export edilmiş fonksiyonlar user moddan çağrılamazlar. Yalnızca kernel modğllerinden
    çağrılabilirler. Buradan çıkan sonuç şudur: Bir kernel modül yazılırken ancak kernel'ın export ettiği fonksiyon ve datalar kullanılabilmektedir. Kernel kaynak kodları
    çok büyüktür buradaki kısıtlı sayıda fonksiyon export edilmiştir. Benzer biçimde programcının oluşturduğu bir kernel modül içerisindeki belli fonksiyonları da
    programcı export edebilir. Bu duurmda bu fonksiyonlar da başka kernel modüllerinden kullanılabilirler. 
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Mademki kernel modüller işletim sisteminin kernel kodlarındaki fonksiyon ve dataları kullanabiliyorlar o zaman kernel modüller o anda çalışılan
    kernel'ın yapısına da bağlı durumdadırlar. İşletim sistemlerinde "aygı sürücü yazmak" ya da "kernel modül yazmak" biçiminde genel bir konu yoktur. 
    Her işletim sisteminin kernel modül ve aygıt sürücü mimarisi diğerlerinden farklıdır. Dolayısıyla bu konu spesifik bir işletim sistemi için geçerli olabilecek
    oldukça platform bağımlı bir konudur. Hatta işletim sistemlerinde bazı versiyonlarda genel aygıt sürücü mimarisi bile değiştirilebilmektedir. Dolayısıyla eski aygıt
    sürücüleri yeni versiyonlarda çalışamamakta yenileri de eski versiyonlarda çalışamamaktadır. İşletim sistemlerinin yeni versiyonlarında kernel mimarisi de 
    değiştirilmiş olabilmektedir. Dolayısıyla daha farklı kernel fonksiyonları eskilerinin yerlerini almış olabilir. Yeni birtakım başka fonksiyonlar export edilmiş olabilir.
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Bir kernel modülünü derlemek ve link etmek maalesef sanıldığından daha zordur. Herne kadar kernel modüller de ELF object dosları
    iseler de bunlarda özel bazı bölümler (sections) bulunmaktadır. Dolayısıyla bu modillerin derlenmesinde özel gcc seçenekleri devreye sokulur. 
    Bunların link edilmeleri de bazı kütüphane dsoyalarının devreye sokulmasıyla yapılır. Dolayısıyla bir kernel modülün "build edilmesi" biraz
    ayrıntılı bilgi gerektirmektedir. İşte kernel tasarımcıları bu sıkıcı işlemleri kolaylaştırmak için özel "make dosyaları" düzenlemişlerdir. Programcı
    bu make dosyalarından faydalanarak build işlemini çok daha kolay yapabilmektedir.
    
    Kernel modüller için build işlemini yapan örnek bir Makefile aşağıdaki gibi olabilir. Burada önce /lib/modules/$(uname -r)/builf dizinindeki Makefile
    çalıştırılmış onadan sonra çalışma bu dosyadan devam ettirilmiştir. Özetle b Make dosyası "helloworld.c" isimli dosyanın derlenerek kernel modül biçimind elink
    edilmesini sağlamaktadır. Kernel modül birden fazla kaynak dosyadan oluşturulabilir. Bu durumda obj-m += a.o b.o c.o... biçiminde tüm dosyalar belirtilir. Ya da bunlar
    teker teker şöyle de belirtilebilir:

    obj-m += a.o
    obj-m += b.o
    obj-m += c.o
    ...
---------------------------------------------------------------------------------------------------------------------------*/

# Makelfile

obj-m += helloworld.o

all: 
	make -C /lib/modules/$(shell uname -r)/build M=${PWD} modules
clean:
	make -C /lib/modules/$(shell uname -r)/build M=${PWD} clean

/*--------------------------------------------------------------------------------------------------------------------------
    Tabii aslında make dosyası parametrik biçimde de oluşturabilmektedir. Tabii bu durumda make programı çalıştırılıken bu parametrenin değeri de
    belirtilmelidir. Örneğin:

    make file=helloworld

---------------------------------------------------------------------------------------------------------------------------*/

# Makelfile
    
obj-m += $(file).o

all: 
	make -C /lib/modules/$(shell uname -r)/build M=${PWD} modules
clean:
	make -C /lib/modules/$(shell uname -r)/build M=${PWD} clean

/*--------------------------------------------------------------------------------------------------------------------------
    Tipik bir "helloworld" modülü şöyle oluşturulabilir.  Bu modülü yukarıdaki make dosyası ile aşağıdaki gibi build yapmalısınız:

    make file=helloworld

    Kernel modüllerin yüklenmesi için insmod isimli program kullanımaktadır. Tabii bu program sudo ile çalıştırılmalıdır. Örneğin:

    sudo insmod helloworld.ko

    Kernel modüller istenildiği zaman rmmod isimli programla boşaltılabilirler. Örneğin:

    sudo rmmod helloworld.ko

---------------------------------------------------------------------------------------------------------------------------*/
    
/* helloworld.c */

#include <linux/module.h>
#include <linux/kernel.h>

int init_module(void)
{
    printk(KERN_INFO "Hello World...\n");

    return 0;
}

void cleanup_module(void)
{
    printk(KERN_INFO "Goodbye World...\n");
}

# Makelfile
    
obj-m += $(file).o
    
all:
    make -C /lib/modules/$(shell uname -r)/build M=${PWD} modules
clean:
    make -C /lib/modules/$(shell uname -r)/build M=${PWD} clean
    
/*--------------------------------------------------------------------------------------------------------------------------
    En basit bir kernel modülde aşağıdaki iki temel dosya include edilmelidir:

#include <linux/module.h>
#include <linux/kernel.h>

Bu iki dosya /lib/modules/$(uname -r)/build/include dizini içerisindedir. (Yani libc ve POSIX kütüphanelerinin başlık dosyalarının bulunduğu 
/usr/include içerisinde değildir.) Yukarıda açıklanan Make dosyası include dosyalarının bu zidinde aranmasını sağlamaktadır. Bir kernel modül yüklendiğinde
kernel modül içeisinde belirlenmiş olan bir fonksiyon çağrılır (bu "constructor" gibi düşünülebilir.) Default çağrılacak fonksiyonun ismi 
init_module biiçimindedir. Bu fonksiyonun geri dönüş değeri int türdendir ve parametresi yoktur. Fonksiyon başarı durumunda 0 değerine başarısızlık durumunda
negatif hata koduna geri dönmelidir. Bu fonksiyon başarısızlıkla geri dönerse modülün yüklenmesinden vazgeçilmektedir. Benzer biçimde bir modül kernel alanından
boşaltılırken de yine bir fonksiyon çağrılmaktadır. (Bu fonksiyon "destructor" gibi üşünülebilir.) Default çağrılacak fonksiyonun ismi cleanup_module biçimindedir. 
Bu fonksiyonun geri dönüş değeri ve parametresi void biçimdedir. 

Kernel modüller tıpkı deamon'lar gibi ekrana değil log dosyalarına ileri yazarlar. Bunun için kernel içindeki printk isimli fonksiyon kullanılmaktadır. 
printk fonksiyonun genel kullanımı printf gibidir. Default durumda yeni kernel'larda bu fonksiyon mesajların /var/log/syslog dosyasına yazdırılması sağlamaktadır. 
printk fonksiyonun prototipi <linux/kernel.h> dosyası içerisindedir. 

printk fonksiyonun örnek kullanımı şöyledir:

printk(KERN_INFO "This is test\n");

Mesajın solundaki KERN_XXX biçimindeki makrolar aslında bir string açımı yapmaktadır. Dolayısıyla yan yana iki string birleştirildiği için mesaj yazısının başında
küçük bir alan bulunur. Bu alan (yani bu makro) mesajın türünü ve aciliyetini belirtmektedir. Tipik KERN_XXX makroları şunlardır:

KERN_EMERG
KERN ALERT
KERN_CRIT
KERN_ERR
KERN_WARN
KERN_NOTICE
KERN_INFO
KERN_DEBUG

Bu makroların tipik biçimi şöyledir:

#define KERN_EMERG	 "<0>"	
#define KERN_ALERT	 "<1>"	
#define KERN_CRIT	 "<2>"	
#define KERN_ERR	 "<3>"	
#define KERN_WARNING "<4>"	
#define KERN_NOTICE	 "<5>"	
#define KERN_INFO	 "<6>"	
#define KERN_DEBUG	 "<7>"	

Aslında KERN_XXX makroları ile printk fonksiyonunu kullanmak yerine pr_xxx makrolarıda kullanılabilir.  Şöyle ki:

printk(KERN_INFO "Hello World...\n");

ile

pr_info("Hello World...\n");

tamamen eşdeğerdir. Aşağıdaki makrolar bulunmaktadır:

pr_emerg
pr_alert
pr_crit
pr_err
pr_warning
pr_notice
pr_info
pr_debug


printk fonksiyonun yazdıklarını /var/log/syslog dosyasına bakarak görebiliriz. Örneğin:

tail /var/log/syslog

Ya da dmesg programı ile de aynı bilgi elde edilebilir. 

Belli bir anda yüklenmiş olan modüller /proc/modules dosyasından elde edilebilir. Aslında lsmod isimli bir program daha vardır. lsmod
zaten /proc/modules dosyasını okuyarak sonu basitleştirerek yazdırmaktadır. 
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Aslında init_module ve cleanup_module fonksiyonlarının ismi değiştirilebilir. Fakat bunun için bildirimde bulunmak gerekir. 
    Bildirimde bulunmak için ise module_init(...) ve modeul_exit(...) makrları kullanılmaktadır. Bu makrolar kaynak kodun herhangi bir yerine 
    yazılabilir. Ancak makro içerisinde belirtilen fonksiyonların bildirimlerinin bu makroların yerleştiği yere kadar yapılmış olması gerekmektedir. 
    Bu makrolar tipik olarak kaynak kodun sonuna yerleştirilmektedir. 
---------------------------------------------------------------------------------------------------------------------------*/

/* helloworld.c */

#include <linux/module.h>
#include <linux/kernel.h>

int helloworld_init(void)
{
    printk(KERN_INFO "Hello World...\n");

    return 0;
}

void helloworld_exit(void)
{
    printk(KERN_INFO "Goodbye World...\n");
}

module_init(helloworld_init);
module_exit(helloworld_exit)
    
# Makelfile
    
obj-m += $(file).o
    
all:
    make -C /lib/modules/$(shell uname -r)/build M=${PWD} modules
clean:
    make -C /lib/modules/$(shell uname -r)/build M=${PWD} clean

/*--------------------------------------------------------------------------------------------------------------------------
    Genellikle kernel modül içerisindeki global değişkenlerin ve fonksiyonların "internal linkage" yapılması tercih edilmektedir.
---------------------------------------------------------------------------------------------------------------------------*/

/* helloworld.c */

#include <linux/module.h>
#include <linux/kernel.h>

static int helloworld_init(void)
{
    printk(KERN_INFO "Hello World...\n");

    return 0;
}

static void helloworld_exit(void)
{
    printk(KERN_INFO "Goodbye World...\n");
}

module_init(helloworld_init);
module_exit(helloworld_exit);

    
# Makelfile
    
obj-m += $(file).o
    
all:
    make -C /lib/modules/$(shell uname -r)/build M=${PWD} modules
clean:
    make -C /lib/modules/$(shell uname -r)/build M=${PWD} clean
    
/*--------------------------------------------------------------------------------------------------------------------------
    Kernel modüllerde başlangıç ve bitiş fonksiyonlarında fonksiyon isimlerinin soluna __init ve __exit makroları getirilebilmektedir. 
    Bu makrolar <linux/init.h> dosyası içerisindedir. __init ilgili fonksiyonu özel bir ELF bölümüne (section) yerleştirir. Modül yüklendikten sonra
    bu bölüm kernel alanından atıılmaktadır. __exit makrosu ise kernel'ın içine gömülmüş modüllerde fonksiyonun dikkate alınmayacağını (dolayısıyla
    hiç yüklenmeyeceğini) belirtir. Ancak sonradan yüklemelerde bu makronun bir etkisi yoktur. 
---------------------------------------------------------------------------------------------------------------------------*/

/* helloworld.c */

#include <linux/module.h>
#include <linux/kernel.h>

static int __init helloworld_init(void)     
{
    printk(KERN_INFO "Hello World...\n");

    return 0;
}

static void __exit helloworld_exit(void)
{
    printk(KERN_INFO "Goodbye World...\n");
}

module_init(helloworld_init);
module_exit(helloworld_exit);

# Makelfile
    
obj-m += $(file).o
    
all:
    make -C /lib/modules/$(shell uname -r)/build M=${PWD} modules
clean:
    make -C /lib/modules/$(shell uname -r)/build M=${PWD} clean
    
/*--------------------------------------------------------------------------------------------------------------------------
    insmod ile yüklediğimiz her modül için /sys/modules dizinin içerisinde ismi modül ismiyle aynı olan bir dizin yaratılmaktadır. 
    /proc/modules dosyası ile bu dizini karıştırmayınız. /proc/modules dosyasının satırları yüklü olan modüllerin isimlerini tutar. 
    Modüllere ilikin asıl önemli bilgiler kenel tarafından /sys/modules dizininde tutulmaktadır. 
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Modüllere parametre geçirebiliriz. Parametre geçirme işlemi insmod ile modül yüklenirken komut satırında modül isminden sonra
    değişken=değer çiftleriyle yapılmaktadır. Örneğin:

    sudo insmod ./helloworld number=10 msg="\"This is a test\"" values=10,20,30,40,50

    Kernel modüllere bu biçimde değer aktarmak için module_param ve module_param_array isimli makrolar kullanılır. Makronun üç parametresi 
    vardır:

    module_param(name, type, perm)

    name parametresi ilgili değişkenin ismini belirtmektedir. Bu ismin komut satırındaki argüman ismiyle aynı olması gerekir. type ilgili
    parametrenin türünü belirtir. Bu tür şunlardan biri olabilir: int, long, short, uint, ulong, ushort, charp, bool, invbool. perm ise 
    /sys/modules/<modül ismi> dizininde yaratılacak olan parameters dizininin erişim haklarını belirtir. Bu makrolar global alanda 
    herhangi bir yere yerleştirilebilir. 

    module_param_array makrosu da şöyledir:

    define module_param_array(name, type, nump, perm)

    Makronun birinci ve ikinci parametreleri yine değişken ismi ve türüdür Tabii buradaki değişken isminin bir dizi ismi olarak girilmesi gerekmektedir. 
    Üçüncü parametre toplam kaç değerin modüle dizi biçiminde aktarıldığını belirten değişkenin adresini (ismini değil) alır. Son parametre 
    yine erişim haklarını belirtmektedir. 

    Aşağıdaki örnekte üç parametre komut satırından kernel modüle geçirilmiştir. Komut satırındaki isimlerle programın içerisindeki değişken
    isimlerinin aynı olması gerekmektedir. Yazıların geçirilmesinde iki tırnaklar kullanılır. Ancak kabuk programının söz konusu yazıyı
    tek bir parametre olarak ele alabilmesi için yazının dışarıdan da tırnaklanması gerekmektedir. Kabuktaki iki tırnak ile tek tırnak 
    arasında yalnızca küçük bir farklılık vardır. Dizi geçirirken yanlışlıkla boşluk karakteri kullanılmamalıdır. 

    Aşağıdaki programı şöyle bir örnekle çalıştırabilirsiniz:

    sudo insmod helloworld.ko count=100 msg='"this is a test"' values=10,20,30,40,50

---------------------------------------------------------------------------------------------------------------------------*/

/* helloworld.c */

#include <linux/module.h>
#include <linux/kernel.h>
#include <linux/moduleparam.h>

static int count;
static char *msg;
static int values[5];
static int size;

module_param(count, int, S_IRUSR|S_IWUSR|S_IRGRP|S_IROTH);
module_param(msg, charp, S_IRUSR|S_IWUSR|S_IRGRP|S_IROTH);
module_param_array(values, int, &size, S_IRUSR|S_IWUSR|S_IRGRP|S_IROTH);

static int __init helloworld_init(void)     
{
    int i;

    printk(KERN_INFO "Hello World...\n");
    printk(KERN_INFO "count = %d, msg = %s\n", count, msg);

    printk(KERN_INFO "values:\n");
    for (i = 0; i < size; ++i)
        printk(KERN_INFO "%d\n", values[i]);

    return 0;
}

static void __exit helloworld_exit(void)
{
    printk(KERN_INFO "Goodbye World...\n");
}

module_init(helloworld_init);
module_exit(helloworld_exit);

# Makelfile
    
obj-m += $(file).o
    
all:
    make -C /lib/modules/$(shell uname -r)/build M=${PWD} modules
clean:
    make -C /lib/modules/$(shell uname -r)/build M=${PWD} clean
    
/*--------------------------------------------------------------------------------------------------------------------------
    Her kernel modül parametresi /sys/modules/<modül_ismi>/parameters dizinin içerisinde bir dosyayla temsil edilir. Örneğin yukarıdaki 
    kodda biz bu dizin içerisinde count, msg ve values isimli üç dosya görürüz. Zatem module_param ve module_param_array makrolarındaki 
    erişim hakları bu dosyaların erişim haklarıdır.
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    errno değişkeni aslında libc kütüphanesinin (standart C ve POSIX kütüphanesi) içerisinde tanımlanmış bir değişkendir. 
    Kernel modda yani kernel'ın içerisinde errno isimli bir değişken yoktur. Bu nedenle kerneldaki fonksiyonlar POSIX fonksiyonları gibi
    başarısızlık durumunda -1 ile geri dönmezler. Başarısızlık durumunda negatif errno değeri ile ger dönerler. Örneğin open POSIX
    fonksiyonu sys_open kernel fonksiyonunu çağırdığında onun negatif bir değerler geri dönüp dönmediğine bakar. Eğer sys_open
    negatif errno değeriyle geri dönerse bu durumda bu değerin pozitiflisini errno değişkenine yerleştirip open -1 ile geri dönmektedir. 
    Kernel modül yazan programcılarında bu konvansiyona uyması iyi bir tekniktir. Örneğin:

    if (işler ters gitti)
        return -EXXXX;

    POSIX arayüzünde adrese geri dönen fonksiyonlar genel olarak başarısızlık durumunda NULL adrese geri dönmektedir. Oysa kernel kodlarında
    adrese geri dönen fonksiyonlar başarısız olduklarında yine sanki bir adresmiş gibi negatif erro değerine geri dönmektedir. 

    Kernel kodlarındaki ERR_PTR isimli makro bir tamsayı değeri alıp onu adres türüne dönüştürmektedir. Bu nedenle adrese geri dönen
    fonksiyonlarda şöylesi kodlar görülebilir:

    void *foo(void)
    {
        ...
        if (işler ters gitti)
            return ERR_PTR(-EXXXX);
        ...
    }

    Bu işlemin tersi de PTR_ERR makrosuyla yapılmaktadır. Yani PTR_ERR makrosu bir adresi alıp onu tamsayıya dönüştürmektedir. Bu durumda
    kernel kodlarında adrese geri dönen fonksiyonların başarısızlığı aşağıdaki gibi kodlarla kontrol edilmektedir:

    void *ptr;
    
    ptr = foo();
    if (PTR_ERR(ptr) < 0) 
        return PTR_ERR(ptr)
    
    Kernel modül programcılarının da buradaki konvansiyona uygun kod yazması iyi bir tekniktir.

    Linux çekirdeğindeki EXXX sembolik sabitleri POSIX arayüzündeki EXXX sabitleriyle aynı değerdedir. 
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Linux'ta bir kernel modül artık user mod'tan kullanılabilir hale getirildiyse buna "aygıt sürücü (device driver)" denir. 
    Aygıt sürücüler open fonksiyonuyla bir dosya gibi açılırlar. Bu açma işleminden bir dosya betimleyicisi elde edilir. Bu dosya
    betimleyicisi read, write, lseek, close gibi fonksiyonlarda kullanılabilir. Aygıt sürücülere ilişkin dosya betimleyicileri
    bu fonksiyonlarla kullanıldığında aygıt sürücü içerisindeki belirlenen bazı fonksiyonlar çağrılmaktadır. Yani tersten gidersek biz
    örneğin read fonksiyonu çağrıldığında aygıt sürücümüzdeki belli bir fonksiyonun çalışmasını sağlayabiliriz. Böylece aygıt sürücü ile
    user mod arasında veri transferleri yine sanki dosyaymış gibi read, write gibi fonksiyonlarla yapılır. Pekiyi user moddan aygıt sürücümüzdeki
    herhangi bir fonksiyonu çağırabilir miyiz? Yanıt evet. Bunun için ioctl isimli POSIX fonksiyonu kullanılmaktadır. Aygıt sürücü içerisinde
    fonksiyonlara birer kod numarası atanır. Sonra ioctl fonksiyonunda bu kod numarası belirtilir. Böylece akış user mod'tan kernel moda
    geçerek belirlenen fonksiyonu kernel modda çalıştıracaktır.

    Pekiyi aygıt sürücüleri açmak için open fonksiyonunda yol ifadesi olarak (yani dosya ismi olarak) ne verilecektir? İşte aygıt sürücüler
    dosya sisteminde bir dizin girişiyle temsil edilir. O dizin girişi open ile açıldığında aslında o dizin girişinin temsil ettiği aygıt sürücü
    açılmış olur. İşte aygıt srücüleri temsil eden dizin girişlerine "aygıt dosyaları (device files)" denilmektedir. 

    Pekiyi bir aygıt dosyası nasıl bir aygıt sürücüyü temsil eder hale getirilmektedir ve nasıl yaratılmaktadır? İşte her aygıt sürücünün
    majör ve minör numaraları vardır. Aynı zamanda aygıt dosyalarının da majör ve minör numaraları vardır. Bir aygıt sürücünün majör ve
    minör numarası bir aygıt dosyasının majör ve minör numarasıyla aynıysa bu durumda o aygıt dıosyası o aygıt sürücüyü temsil eder. 
    Aygıt dosyaları özel dosyalardır. Bir dosyanınj aygıt dosyası olup olmadığı ls -l komutunda dosya türü olarak 'c' (karakter aygıt sürücüsü)
    ya da 'b' (blok aygıt sürücüsü) ile temsil edilir. Anımsanacağı gibi dosya bilgileri stat, fstat, lstat fonksiyonlarıyla elde edilmektedir.
    İşte struct stat yapısının dev_t türünden st_rdev elemanı eğer dosya bir aygıt dosyasıysa dosyanın majör ve minör numaralarını belirtir. 
    Tabii biz <sys/stat.h> dosyasındaki S_ISCHR ve S_ISBLK makrolarıyla bunu öğrenebiliriz. 

    O halde şimdi bizim bir aygıt dosyasını nasıl oluşturacağımızı ve aygıt sürücüye nasıl majör ve minör numara atayacağımızı bilmemiz
    gerekir. 

---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Aygıt dosyaları mknod isimli POSIX fonksiyonuyla (bu fonksiyon sistem fonksiyounu çağırmaktadır) ya da komut satırından mknod 
    komutuyla (bu komut da mknod fonksiyonu ile işlemini yapmaktadır) yaratılabilir. mknod fonksiyonun prototipi şöyledir:

    int mknod(const char *pathname, mode_t mode, dev_t dev);

    Fonksiyonun birinci parametresi yaratılacak aygıt dosyasının yol ifadesini, ikinci parametresi erişim haklarını ve üçüncü parametresi de 
    aygıt dosyasının majör ve minör numarasını belirtmektedir. Aygıt dosyasının majör ve minör numaraları user mod programda makedev makrosuyla
    tek bir dev_t nesnesi haline getirilebilmektedir. Bir dev_t nesnesinin içerisindeki numaralardan majör olanı major makrosuyla, minör olanı
    ise minır makrosuyla elde edebiliriz. 

    dev_t makedev(unsigned int maj, unsigned int min);
    unsigned int major(dev_t dev);
    unsigned int minor(dev_t dev);

    Ancak kernel modda bu makrolar yerine aşağıdakiler kullanılmaktadır:

    MKDEV(major, minor)
    MAJOR(dev)
    MINOR(dev)

    Linux'ta son versiyonlar da dikkate alındığında dev_t 32 bitlik işaretsiz bir tamsayı türündendir. Bu 32 bitin yüksek anlamlı 10 biti majör numarayı,
    düşük anlamlı 20 biti ise minör numarayı temsil etmektedir. Ancak programcı bu varsayımlarla kodunu düzenlememeli yukarıda belirtilen makroları
    kullanmalıdır. 

    mknod fonksiyonun ikinci parametresindeki erişim haklarına ayrıca eğer karakter aygıt sürücü dosyası yaratuılmak isteniyorse S_IFCHR, blok
    aygıt sürücü dosyası yaratılmak isteniyorsa S_IFBLK bayraklarını eklemek gerekmektedir. Tabii mknod fonksiyonun başarılı olabilmesi için
    ilkgili prosesin proses id'sinin 0 olması gerekir. 

    Aşağıdaki aygıt dosyası yaratan örnek bir program görülmektedir. 

---------------------------------------------------------------------------------------------------------------------------*/

/* mymknod.c */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/stat.h>
#include <sys/sysmacros.h>

int is_octal(const char *str);
void exit_sys(const char *msg);

/* mymknod <erişim hakları>  <aygıt cinsi> <majör numara> <minör numara> <dosya ismi> */

int main(int argc, char *argv[])    
{
    int i;
    int mode;
    mode_t modes[] = {S_IRUSR, S_IWUSR, S_IXUSR, S_IRGRP, S_IWGRP, S_IXGRP, S_IROTH, S_IWOTH, S_IXOTH};
    mode_t result_mode;
    unsigned major, minor;
    
    if (argc != 6) {
        fprintf(stderr, "wrong number of arguments!..\n");
        exit(EXIT_FAILURE);
    }

    if (!is_octal(argv[1]) || (mode = (mode_t)strtoul(argv[1], NULL, 8)) > 0x777) {
        fprintf(stderr, "invalid octal digits!..\n");
        exit(EXIT_FAILURE);
    }

    major = (unsigned)strtoul(argv[3], NULL, 10);
    minor = (unsigned)strtoul(argv[4], NULL, 10);

    result_mode = 0;
    for (i = 8; i >= 0; --i)
        if (mode >> i & 1) 
            result_mode |= modes[8 - i];

    if (strcmp(argv[2], "c") == 0)
        result_mode |= S_IFCHR;
    else if (strcmp(argv[2], "b") == 0)
        result_mode |= S_IFBLK;
    else {
        fprintf(stderr, "invalid device type!..\n");
        exit(EXIT_FAILURE);
    }
    
    umask(0);

    if (mknod(argv[5], result_mode, makedev(major, minor)) == -1)
        exit_sys("mkdir");
       
    return 0;
}

int is_octal(const char *str)
{
    int i;
    
    for (i = 0; str[i] != '\0'; ++i) 
        if (str[i] < '0' || str[i] > '7')
            return 0;
    
    return 1;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}
    
# Makelfile
    
obj-m += $(file).o
    
all:
    make -C /lib/modules/$(shell uname -r)/build M=${PWD} modules
clean:
    make -C /lib/modules/$(shell uname -r)/build M=${PWD} clean

/*--------------------------------------------------------------------------------------------------------------------------
    Aslında mknod fonksiyonunu kullanmak yerine doğrudan mknod komutuyla da kabuk üzerinden aygıt dosyası yaratılabilir. Komutun
    genel bçimi şöyledir:

    sudo mknod <dosya ismi> <c ya da b> <majör numara> <minör numara>

    Örneğin:

    sudo mknod devfile c 20 30

---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Bir kernel modülün karakter aygıt sürücüsü haline getirilebilmesi için öncelikle bir aygıt numarasıylşa temsil edilip çekirdeğe
    kaydettirilmesi gerekmektedir. Bu işlem tipik olarak register_chrdev_region isimli fonksiyonla yapılır. Fonksiyonun prototpi şöyledir:

    int register_chrdev_region(dev_t from, unsigned count, const char *name)

    Fonksiyonun birinci parametresi aygıt sürücünün majör ve minör numaralarının belirtildiği dev_t türünden nesneyi belirtir. Bu genellikle
    MKDEV makrosuyla oluşturulmaktadır. İkinci parametre ilk parametrede belirtilen minör numaradan itibaren kaç minör numaranın kaydettirileceğini
    belirtmektedir. Örneğin biz majör= 20, minör=0'dan itibaren 5 minör numarayı kaydettirebiliriz. Fonksiyonun son parametresi proc ve sys dosyas 
    sistemlerindeki aygıt sürücünün ismini belirtir. Kernel modüllerin isimleri kernel modül dosyasından gelmektedir. Ancak karakter aygıt sürücülerinin
    isimlerini biz istediğimiz gibi veririz. Her aygıt sürücü bir kernel modül biçiminde yazılmak zorundadır. Fonksiyon başarı durumunda 0 değerine
    başarısızlık durumunda negatif errno değerine geri döner. 

    register_chrdev_region fonksiyonu modülün init fonksiyonunda register ettirilen majör ve minör numaralar unregister_chrdev_region
    fonksiyonuyla modülğn exit fonksiyonlarında geri bırakılmalıdır. Aksi halde modül kernel alanından rmmod komutuyla atılsa bile
    bu aygıt numaraları tahsis edilmiş bir biçimde kalmaya devam etmektedir. unregister_chrdev_region fonksiyonun prototipi şöyledir:

    void unregister_chrdev_region (dev_t from, unsigned count);

    Fonksiyonun birinci parametresi aygıt sürücünün register ettirilmiş olan majör ve minör numarasını, ikinci parametresi ise yine 
    o noktadan başlayan kaç minör numaranın unregister ettirileceğidir. 

    Bir aygıt sürücü register-chrdev-region fonksiyonuyla majör ve minör numarayı register ettirdiğinde artık /proc/devices dosyasında
    bu aygıt sürücü için bir satır yaratılmaktadır. Aygıt sürücü unregister_chrdev_region fonksiyonuyla yok edildiğinde /proc/devices
    dosyasındaki satır silinmektedir.

---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Bir kernel modülü yazarken o modül le ilgili önemli bazı belirlemeler "modül makroları" denilen MODULE_XXXX biçimindeki makrolarka
    yapılmaktadır. Her ne kadar bu modül makrolarının bulundurulması zorunlu değilse de şiddetle tavsiye edilmektedir. En önemli üç makronun tipik kullanımı
    şöyledir:

    MODULE_LICENCE("GPL");
    MODULE_AUTHOR("Kaan Aslan");
    MODULE_DESCRIPTION("General Character Device Driver");

    Modül lisansı herhangi bir open source lisans olabilir. Tipik olarak "GPL" tercih edilmektedir. MODULE_AUTHOR makrosu ile modülün yazarı belirtilir. 
    MODULE_DESCRPTION modülün ne iş yaprığına yönelik kısa bir başlık yazısı içermektedir. 

    Bu makrolar global alanda herhangi bir yere yerleştirilebilmektedir. 

---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Bir modülü bir aygıt numarasıyla ilişkilendirdikten sonra artık ona gerçek anlamda bir karakter aygıt sürücü kimliği kazandırmak
    gerekmektedir. Bu işlem sstruct cdev isimli bir yapının için doldurularak sisteme eklenmesi (yerleştirilmesi) ile yapılır. Linux çekirdeği
    tüm kernel modülleri ve aygıt sürücüleri çeşitli veri yapılarıyla tutmaktadır. Aygıt sürücü yazan programcılar kernel'ın bu organizasyonunu
    bilmek zorunda değiller. Ancak bazı işlemleri tam gerektiği gibi yapmak zorundalar. 

    cdev yapısı aşağıdaki gibi bir yapıdır:

    struct cdev {
        struct kobject kobj;
        struct module *owner;
        const struct file_operations *ops;
        struct list_head list;
        dev_t dev;
        unsigned int count;
    };

    Bu türden bir yapı nesnesi programcı tarafından global olarak tanımlanabilir ya da alloc_cdev isimli kernel fonksiyonuyla kernel'ın 
    heap sistemi (slab allocator) kullanılarak dinamik bir biçimde tahsis edilebilir. Eğer bu yapı nesnei programcı tarafından global bir biçimde 
    tanımlanacaksa yapının elemanlarına ilkdeğer vermek için cdev_init fonksiyonu çağrılmalıdır. Eğer cdev yapısı cdev_alloc fonksiyouyla dinamik bir biçimde
    tahsis edilecekse cdev_init yapılmaz çünkü zaten cdev_alloc bu işlemi de yapmaktadır. Fakat yine de programcının bu kez manuel olarak bu yapının bazı
    elemanlarına değer ataması gerekir. Bu iki yoldan biriyle oluşturulmuş olan cdev yapısının en sonunda cdev_add isimli fonkiyonla kernel veri yapılarına
    yerleştirilmeleri gerekir. Tabii aygıt sürücü boşaltılırken bu yerleştirme işlemi cdev_del fonksiyonuyla geri alınmalıdır. 

    cdev_init fonksiyonun parametrik yapısı şöyledir:

    void cdev_init(struct cdev *cdev, const struct file_operations *fops);

    Fonksiyonun birinci paranetresi ilkdeğer verilecek global cdev nesnenin adresini alır. İkinci parametre ise file_operations türünden 
    bir yapı nesnesinin adresi almaktadır. file_operations isimli yapı birtakım fonksiyon adreslerinden oluşmaktadır. Yani yapının tüm elemanları
    birer fonksiyon göstericisidir. Bu yapı user moddaki program tarafından ilgili aygıt dosyası açılıp çeşitli işlemler yapıldığında çağrılacak
    fonksiyonların adreslerini tutmaktadır. Yani örneğin user moddaki program open, cloase, read, write yaptığında çağrılacak fonksiyonlarımızı burada belirtiriz. 
    file_operations yapısı büyük bir yapıdır:

    struct file_operations {
        struct module *owner;
        loff_t (*llseek) (struct file *, loff_t, int);
        ssize_t (*read) (struct file *, char __user *, size_t, loff_t *);
        ssize_t (*write) (struct file *, const char __user *, size_t, loff_t *);
        ssize_t (*read_iter) (struct kiocb *, struct iov_iter *);
        ssize_t (*write_iter) (struct kiocb *, struct iov_iter *);
        int (*iopoll)(struct kiocb *kiocb, bool spin);
        int (*iterate) (struct file *, struct dir_context *);
        int (*iterate_shared) (struct file *, struct dir_context *);
        __poll_t (*poll) (struct file *, struct poll_table_struct *);
        long (*unlocked_ioctl) (struct file *, unsigned int, unsigned long);
        long (*compat_ioctl) (struct file *, unsigned int, unsigned long);
        int (*mmap) (struct file *, struct vm_area_struct *);
        unsigned long mmap_supported_flags;
        int (*open) (struct inode *, struct file *);
        int (*flush) (struct file *, fl_owner_t id);
        int (*release) (struct inode *, struct file *);
        int (*fsync) (struct file *, loff_t, loff_t, int datasync);
        int (*fasync) (int, struct file *, int);
        int (*lock) (struct file *, int, struct file_lock *);
        ssize_t (*sendpage) (struct file *, struct page *, int, size_t, loff_t *, int);
        unsigned long (*get_unmapped_area)(struct file *, unsigned long, unsigned long, unsigned long, unsigned long);
        int (*check_flags)(int);
        int (*flock) (struct file *, int, struct file_lock *);
        ssize_t (*splice_write)(struct pipe_inode_info *, struct file *, loff_t *, size_t, unsigned int);
        ssize_t (*splice_read)(struct file *, loff_t *, struct pipe_inode_info *, size_t, unsigned int);
        int (*setlease)(struct file *, long, struct file_lock **, void **);
        long (*fallocate)(struct file *file, int mode, loff_t offset,
                loff_t len);
        void (*show_fdinfo)(struct seq_file *m, struct file *f);
    #ifndef CONFIG_MMU
        unsigned (*mmap_capabilities)(struct file *);
    #endif
        ssize_t (*copy_file_range)(struct file *, loff_t, struct file *,
                loff_t, size_t, unsigned int);
        loff_t (*remap_file_range)(struct file *file_in, loff_t pos_in,
                    struct file *file_out, loff_t pos_out,
                    loff_t len, unsigned int remap_flags);
        int (*fadvise)(struct file *, loff_t, loff_t, int);
    };

    Bu yapının bazı elemanlarına atama yapabiliriz. Bunun için gcc eklentileri kullanılabilir. (Bu eklentiler C99 ile birlikte C'ye eklenmiştir.) Örneğin:

    int generic_open(struct inode *inodep, struct file *filp);
    int generic_release(struct inode *inodep, struct file *filp);

    struct file_operations g_file_ops = {
        .owner = THIS_MODULE,
        .open = generic_open,
        .release = generic_release
    };

    Yapının owner elemanına THIS_MODULE atamasının yapılması iyi bir tekniktir. 

    cdev yapısı cdev_alloc fonksiyonuyla dinamik bir biçimde de yahsis edilebilir:

    struct cdev *cdev_alloc(void);

    Fonksiyon başarı durumunda cdev yapısının adresine başarısılık durumunda NULL adrese geri dönmektedir. Yukarıda da belirtildiği gibi cdev yapısı
    cdev_alloc ile tahsis edilmişse cdev_init yapılmasına gerek yoktur. Ancak bu durumda programcının manuel olarak owner, ops elemanlarına 
    değer ataması uygun olur. Örneğin:

    struct cdev *g_cdev;
    ...
    if ((gcdev = cdev_alloc()) == NULL) {
        printk(KERN_INFO "Cannot allocate cdev!..\n");
        return -ENOMEM;
    }
    g_cdev->owner = THIS_MODULE;
    g_cdev->ops = &g_file_ops;

    cdev yapı nesnesi başarılı bir biçimde oluşturulduktan sonra artık bu yapının kernel içerisine yerleştirilmesi gerekir. Bu da cdev_add fonksiyonuyla
    yapılmaktadır:

    int cdev_add(struct cdev *devp, dev_t dev, unsigned count);

    Fonksiyonun birinci paranetresi cdev türünden yapı nesnesinin adresini almaktadır. İkinci parametre aygıt sürücünün majör ve minör numarasını belirtmektedir. 
    Üçüncü paraetres ise ilgili minör numaradan kaç minör numaranın kullanılacağı belirtir. Fonksiyon başarı durumunda sıfır değerine başarısızlık durumunda negatif
    errno değerine geri döner. 

    Aygıt sürücü boşaltılırken cdev_add ile yapılan işlemin geri alınması gerekir. Bu da cdev_del fonksiyonuyla yapılmaktadır. (cdev_alloc işlemi için
    bunu free hale getiren ayrı bir fonksiyon yoktur. cdev_del sırasında eğer bu yapı dinamik tahsis edilmişse free işlemi yapılmaktadır.)

    void cdev_del(struct cdev *devp);

    Fonksiyon parametre olarak cdev yapısının adresini almaktadır. 
    
    Buradaki önemli bir nokta şudur: cdev_add fonksiyonu cdev nesnesinin  içini kernel'daki uygun veri yapısına kopyalamamaktadır. Bizzat bu nesnenin adresini
    kullanmaktadır. Bu cdev nesnesinin yaşıyor olması gerekir. Bu da cdev nesnesinin ve file_operations nesnesinin global biçimde tanımlanması gerekir. 

    Aşağıda bu işlemlerin yapıldığı örnek bir karakter aygıt sürücüsü verilmiştir. Bu aygıt sürücü majör=25, minör=0 aygıtını kullanmaktadır. 
    Dolayısıyla aşağıdaki programın testi için şöyle bir aygıt dosyasının yaratılması gerekir:

    sudo mknod generic -m=666 c 25 0

---------------------------------------------------------------------------------------------------------------------------*/

/* generic-char-driver.c */

#include <linux/module.h>
#include <linux/kernel.h>
#include <linux/fs.h>
#include <linux/cdev.h>

MODULE_LICENSE("GPL");
MODULE_DESCRIPTION("General Character Device Driver");
MODULE_AUTHOR("Kaan Aslan");

#define DEV_MAJOR    25
#define DEV_MINOR    0  

static int generic_open(struct inode *inodep, struct file *filp);
static int generic_release(struct inode *inodep, struct file *filp);

static dev_t g_dev = MKDEV(DEV_MAJOR, DEV_MINOR);
static struct cdev g_cdev;
static struct file_operations g_file_ops = {
    .owner = THIS_MODULE,
    .open = generic_open,
    .release = generic_release,
};

static int __init generic_init(void)     
{
    int result;

    if ((result = register_chrdev_region(g_dev, 1, "generic-char-driver")) < 0) {
        printk(KERN_INFO "Cannot register driver!...\n");
        return result; 
    }

    cdev_init(&g_cdev, &g_file_ops);
    
    if ((result = cdev_add(&g_cdev, g_dev, 1)) != 0) {
        unregister_chrdev_region(g_dev, 1);
        printk(KERN_INFO "Cannot add charecter device driver!...\n");
        return result;
    }
    
    printk(KERN_INFO "Success...\n");

    return 0;
}

static void __exit generic_exit(void)
{
    cdev_del(&g_cdev);
    unregister_chrdev_region(g_dev, 1);

    printk(KERN_INFO "Goodbye...\n");
}

static int generic_open(struct inode *inodep, struct file *filp)
{
    printk(KERN_INFO "Generic device opened!..\n");

    return 0;
}

static int generic_release(struct inode *inodep, struct file *filp)
{
    printk(KERN_INFO "Generic device released!..\n");

    return 0;
}

module_init(generic_init);
module_exit(generic_exit);
    
# Makelfile
    
obj-m += $(file).o
    
all:
    make -C /lib/modules/$(shell uname -r)/build M=${PWD} modules
clean:
    make -C /lib/modules/$(shell uname -r)/build M=${PWD} clean

/* sample.c */

#include <stdio.h>
#include <stdlib.h>
#include <fcntl.h>
#include <unistd.h>

void exit_sys(const char *msg);

int main(void)    
{
    int fd;

    if ((fd = open("generic", O_RDWR)) == -1) 
        exit_sys("open");

    close(fd);
       
    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/*--------------------------------------------------------------------------------------------------------------------------
    Yukarıdaki programı cdev nesnesini alloc_cdev fonksiyonuyla dinamik bir biçimde tahsis ederek de şöyle yazabiliriz:
---------------------------------------------------------------------------------------------------------------------------*/

/* generic-char-driver.c */

#include <linux/module.h>
#include <linux/kernel.h>
#include <linux/fs.h>
#include <linux/cdev.h>

MODULE_LICENSE("GPL");
MODULE_DESCRIPTION("General Character Device Driver");
MODULE_AUTHOR("Kaan Aslan");

#define DEV_MAJOR    25
#define DEV_MINOR    0  

static int generic_open(struct inode *inodep, struct file *filp);
static int generic_release(struct inode *inodep, struct file *filp);

static dev_t g_dev = MKDEV(DEV_MAJOR, DEV_MINOR);
static struct cdev *g_cdev;
static struct file_operations g_file_ops = {
    .owner = THIS_MODULE,
    .open = generic_open,
    .release = generic_release,
};

static int __init generic_init(void)     
{
    int result;

    if ((result = register_chrdev_region(g_dev, 1, "generic-char-driver")) < 0) {
        printk(KERN_INFO "Cannot register driver!...\n");
        return result; 
    }

    if ((g_cdev = cdev_alloc()) == NULL) {
        printk(KERN_INFO "Cannot allocate cdev!..\n");
        return -ENOMEM;
    }

    g_cdev->owner = THIS_MODULE;
    g_cdev->ops = &g_file_ops;
    
    if ((result = cdev_add(g_cdev, g_dev, 1)) != 0) {
        unregister_chrdev_region(g_dev, 1);
        printk(KERN_INFO "Cannot add charecter device driver!...\n");
        return result;
    }
    
    printk(KERN_INFO "Success...\n");

    return 0;
}

static void __exit generic_exit(void)
{
    cdev_del(g_cdev);
    unregister_chrdev_region(g_dev, 1);

    printk(KERN_INFO "Goodbye...\n");
}

static int generic_open(struct inode *inodep, struct file *filp)
{
    printk(KERN_INFO "Generic device opened!..\n");

    return 0;
}

static int generic_release(struct inode *inodep, struct file *filp)
{
    printk(KERN_INFO "Generic device released!..\n");

    return 0;
}

module_init(generic_init);
module_exit(generic_exit);
    
# Makelfile
    
obj-m += $(file).o
    
all:
    make -C /lib/modules/$(shell uname -r)/build M=${PWD} modules
clean:
    make -C /lib/modules/$(shell uname -r)/build M=${PWD} clean

/* sample.c */

#include <stdio.h>
#include <stdlib.h>
#include <fcntl.h>
#include <unistd.h>

void exit_sys(const char *msg);

int main(void)    
{
    int fd;

    if ((fd = open("generic", O_RDWR)) == -1) 
        exit_sys("open");

    close(fd);
       
    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/*--------------------------------------------------------------------------------------------------------------------------
    Kernel kodları ya da aygıt sürücü kodları çoğu zaman kernel alanı ile user alanı arasında veri tarnsferi yapmak isterler. 
    Örneğin sys_read fonksiyonu kernel alanında elde ettiği bilgileri user alanındaki programcının verdiği adrese kopyalar. 
    Benzer biçimde sys_write fonksiyonu da bunun tersini yapmaktadır. Kernel alanı ile user alanı arasında birkaç nedenden dolayı
    memcpy fonksiyonuyla transfer yapılamamaktadır. Bu tür transferlerde kernel mod programcılarının user alanındaki adresin geçerliliğini
    kontrol etmesi gerekir. Aksi takdirde kernel modda geçersiz bir alana kopyalama yapmak sistemin çökmesine yol açabilmektedir. Ayrıca
    user alanına ilişkin prosesin sayfa tablosunun bazı bölümleri o anda bellekte olmayabilir (yani swap out yapılmış olabilir). Böyle bir durumda
    işleme devam etmek kernel tasarımı açısından sorun olmaktadır. Eğer böyle bir durum varsa kernel kodlarının önce sayfa tablosunu RAM'e geri yükleyip
    işlemine devam etmesi uygun olmaktadır. 

    İşte yukarıda açıklanan bazı nedenlerden dolayı kernel alanı ile user alanı arasında kopyalama işlemi için özel kernel fonksiyonları kullanılmaktadır. 
    En temel iki fonksiyon copy_to_user ve copY_from_user fonksiyonlarıdır. Bu fonksiyonların prototipleri <linux/uaccess.h> içerisindedir:

    unsigned long copy_to_user(void *to, const void *from, unsigned len); 
    unsigned long copy_from_user(void *to, const void *from, unsigned len); 

    Fonskiyonların birinci parametreleri kopyalamanın yapılacağı hedef adreslerdir. Yani copy_to_user için birinci parametre user alanındaki adres, 
    copy_from_user için birinci parametre kernel alanındaki adrestir. İkinci parametre kaynak adresi belirtmektedir. Bu kaynak adres copy_to_user için kernel
    alanındaki adres, copy_from_user için user alanındakş adrestir. Son parametre transfer edilecek byte sayısını belirtmektedir. Fonksiyonlar başarı durumunda 0
    değerine, başarısızlık durumunda transfer edilemeyen byte sayısına geri dönerler. Kernel mod programcılaının bu fonksiyonlar başarısızken bunu çağıran foksiyonlarını
    -EFAULT (Bad address) ile geri döndürmesi uygun olur. 

    Bazen user alanındaki adresin zaten geçerliliği sınanmıştır. Bu durumda yeniden geçerlilik sınaması yapmadan yukarıdaki işlemleri yapan
    __copy_to_user ve __copy_drom_user fonksiyonları kullanılabilir. Bu fonksiyonların parametrik yapıları aynıdır.

    Bazı durumlarda programcı 1 byte, 2 byte, 4 byte, 8 byte'lık verileri kopyalamak isteyebilir. Bu küçük m,iktardaki verilen kopyalaması
    için daha hızlı çalışan özel iki makro vardır: put_user ve get_user. Makroların parametrik yapısı şöyledir:

    put_user(x, ptr)	
    get_user(x, ptr)

    Burada x aktarılacak nesneyi belirtir. (Adresini programcı almaz, makro içinde bu işlem yapılmaktadır.) ptr ise tarnsfer adresini belirtir. Aktarım ikinci
    parametrede belirtilen adresin türünün uzunluğu kadar yapılmaktadır. Yine makrolar başarı durumunda 0 başarısızlık durumunda negatif hata koduna geri dönmektedir.
    Bu makroların da geçerlilik kontrolü yapmayan __put_user ve __get_user isimli versiyonları vardır. Örneğin biz 4 byte'lık int bir x nesnesinin içerisindeki bilgiyi
    pi user adresine kopyalamak isteyelim. Bu işlemi şöye yaparız:

    int x;      
    int *puser;    
    ...
    put_user(x, puser)

    Nihayet user alanındaki adresin geçerliliği de access_ok isimli makroula sorgulanabilmektedir. Makro şöyledir:

    access_ok(type,addr,size)

    Buradaki type geçerliliğin türünü anlatmaktadır. Okuma geçerliliği için bu paraetre VERIFY_READ, yazma geçerliliği için VERIFY_WRITE ve hem okuma hem de yazma 
    geçerliliği için VERIFY_READ|VERIFY_WRITE biçiminde olmalıdır.  İkinci parametre geçerliliği sınanacak adresi ve üçüncü parametre de o adresten başlayan alanın
    uzunluğunu belirtmektedir. Fonksiyon başarı durumunda sıfır dışı bir değere başarısızlık durumunda sıır değerine geri dönmektedir. 

---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Aygıt sürücümüz için read ve write fonksiyonları aşağıdaki parametrik yapıya uygun olacak biminde file_operations yapısına yerleştirilmelidir:

    static ssize_t generic_read(struct file *filp, char *buf, size_t size, loff_t *off);
    static ssize_t generic_write(struct file *filp, const char *buf, size_t size, loff_t *off);

    static struct file_operations g_file_ops = {
        .owner = THIS_MODULE,
        .open = generic_open,
        .release = generic_release,
        .read = generic_read,
        .write = generic_write,
    };

    read ve write fonksiyonlarının birinci parametresi açılmış dosyaya ilişkin struct file nesnesinin adresini belirtir. Linux dosya sisteminde
    üç önemli yapı vardır: struct file, struct dentry ve struct inode. file yapısının bir elemanı denrty yapısını, dentry yapısının da bir elemanı inode yapısını 
    göstermektedir. Yani biz dentry ve inode yapılarının elemanlarına aslında struct file nesnesi yoluyla erişiriz. Daha önceden de anımsanacağı gibi struct file
    nesnesi içerisinde dosya göstericisinin konumu, dosyanın erişim hakları, referans sayacının değeri, dosyanın açış modu ve başka birtakım bilgiler de vardır. read ve
    write fonksiyonlarının ikinci parametresi user alanındaki transfer adresini belirtir. Üçüncü parametreler okunacak ya da yazılacak byte miktarını belirtmektedir. 
    Son parametre dosya göstericisinin konumunu belirtir. (Aslında bu parametre file yapısı içerisindeki f_pos lemanın adresidir. Ancak kolay erişim için ayrı bir
    parametre olarak geçirilmiştir.) Fonksiyon başarı durumunda transfer edilen byte sayısına başarısızlık durumunda negatif errno değerine geri dönmektedir. 

    Aşağıdaki örnekte aygıt sürücü için read fonksiyonu yazılmıştır. Bu fonksiyon aslında g_buf isimli dizinin içini dosya gibi vermektedir.

---------------------------------------------------------------------------------------------------------------------------*/

/* generic-char-driver.c */

#include <linux/module.h>
#include <linux/kernel.h>
#include <linux/fs.h>
#include <linux/cdev.h>
#include <linux/uaccess.h>

MODULE_LICENSE("GPL");
MODULE_DESCRIPTION("General Character Device Driver");
MODULE_AUTHOR("Kaan Aslan");

#define DEV_MAJOR    25
#define DEV_MINOR    0  

static int generic_open(struct inode *inodep, struct file *filp);
static int generic_release(struct inode *inodep, struct file *filp);
static ssize_t generic_read(struct file *filp, char *buf, size_t size, loff_t *off);

static dev_t g_dev = MKDEV(DEV_MAJOR, DEV_MINOR);
static struct cdev *g_cdev;
static struct file_operations g_file_ops = {
    .owner = THIS_MODULE,
    .open = generic_open,
    .release = generic_release,
    .read = generic_read,
};

char g_buf[] = "abcdefghijklmnoprstuvyz";

static int __init generic_init(void)     
{
    int result;

    if ((result = register_chrdev_region(g_dev, 1, "generic-char-driver")) < 0) {
        printk(KERN_INFO "Cannot register driver!...\n");
        return result; 
    }

    if ((g_cdev = cdev_alloc()) == NULL) {
        printk(KERN_INFO "Cannot allocate cdev!..\n");
        return -ENOMEM;
    }

    g_cdev->owner = THIS_MODULE;
    g_cdev->ops = &g_file_ops;
    
    if ((result = cdev_add(g_cdev, g_dev, 1)) != 0) {
        unregister_chrdev_region(g_dev, 1);
        printk(KERN_INFO "Cannot add charecter device driver!...\n");
        return result;
    }
    
    printk(KERN_INFO "Success...\n");

    return 0;
}

static void __exit generic_exit(void)
{
    cdev_del(g_cdev);
    unregister_chrdev_region(g_dev, 1);

    printk(KERN_INFO "Goodbye...\n");
}

static int generic_open(struct inode *inodep, struct file *filp)
{
    printk(KERN_INFO "Generic device opened!..\n");

    return 0;
}

static int generic_release(struct inode *inodep, struct file *filp)
{
    printk(KERN_INFO "Generic device released!..\n");

    return 0;
}

static ssize_t generic_read(struct file *filp, char *buf, size_t size, loff_t *off)
{
    size_t asize;

    asize = size + *off > strlen(g_buf) ? strlen(g_buf) - *off : size;

    if (copy_to_user(buf, g_buf + *off, asize) != 0) 
        return -EFAULT;

    *off += asize;

    printk(KERN_INFO "Reading...\n");

    return asize;
}

module_init(generic_init);
module_exit(generic_exit);

/* sample.c */

#include <stdio.h>
#include <stdlib.h>
#include <fcntl.h>
#include <unistd.h>

void exit_sys(const char *msg);

int main(void)    
{
    int fd;
    char buf[100];
    ssize_t result;

    if ((fd = open("generic", O_RDWR)) == -1) 
        exit_sys("open");

    while ((result = read(fd, buf, 3)) > 0) {
        buf[result] = '\0';
        printf("Read from %ld bytes: %s\n", (long)result, buf);
    }

    if (result < 0)
        exit_sys("read");

    close(fd);

    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

# Makelfile
    
obj-m += $(file).o
    
all:
    make -C /lib/modules/$(shell uname -r)/build M=${PWD} modules
clean:
    make -C /lib/modules/$(shell uname -r)/build M=${PWD} clean
    
/*--------------------------------------------------------------------------------------------------------------------------
    Aygıt sürücü için write fonksiyonu da tamamen read fonksiyonuna benzer biçimde yazılmaktadır. write fonksiyonu içerisinde
    biz user moddaki bilgiyi copy_from_user ya da get_user fonksiyonlarıyla alırız. Yine write fonksiyonu da bir sorun çıktığında
    -EFAULT değeri ile başarılı sonlanmada yazılan (kernel alanına yazılan) byte miktarı ile geri dönmelidir. Aşağıda erite
    işlemine bir örnek verilmiştir.
---------------------------------------------------------------------------------------------------------------------------*/

/* generic-char-driver.c */

#include <linux/module.h>
#include <linux/kernel.h>
#include <linux/fs.h>
#include <linux/cdev.h>
#include <linux/uaccess.h>

MODULE_LICENSE("GPL");
MODULE_DESCRIPTION("General Character Device Driver");
MODULE_AUTHOR("Kaan Aslan");

#define DEV_MAJOR    25
#define DEV_MINOR    0  

#define BUFFER_SIZE     128

static int generic_open(struct inode *inodep, struct file *filp);
static int generic_release(struct inode *inodep, struct file *filp);
static ssize_t generic_read(struct file *filp, char *buf, size_t size, loff_t *off);
static ssize_t generic_write(struct file *filp, const char *buf, size_t size, loff_t *off);

static dev_t g_dev = MKDEV(DEV_MAJOR, DEV_MINOR);
static struct cdev *g_cdev;
static struct file_operations g_file_ops = {
    .owner = THIS_MODULE,
    .open = generic_open,
    .release = generic_release,
    .read = generic_read,
    .write = generic_write,
};

char g_buf[BUFFER_SIZE];

static int __init generic_init(void)     
{
    int result;

    if ((result = register_chrdev_region(g_dev, 1, "generic-char-driver")) < 0) {
        printk(KERN_INFO "Cannot register driver!...\n");
        return result; 
    }

    if ((g_cdev = cdev_alloc()) == NULL) {
        printk(KERN_INFO "Cannot allocate cdev!..\n");
        return -ENOMEM;
    }

    g_cdev->owner = THIS_MODULE;
    g_cdev->ops = &g_file_ops;
    
    if ((result = cdev_add(g_cdev, g_dev, 1)) != 0) {
        unregister_chrdev_region(g_dev, 1);
        printk(KERN_INFO "Cannot add charecter device driver!...\n");
        return result;
    }
    
    printk(KERN_INFO "Success...\n");

    return 0;
}

static void __exit generic_exit(void)
{
    cdev_del(g_cdev);
    unregister_chrdev_region(g_dev, 1);

    printk(KERN_INFO "Goodbye...\n");
}

static int generic_open(struct inode *inodep, struct file *filp)
{
    printk(KERN_INFO "Generic device opened!..\n");

    return 0;
}

static int generic_release(struct inode *inodep, struct file *filp)
{
    printk(KERN_INFO "Generic device released!..\n");

    return 0;
}

static ssize_t generic_read(struct file *filp, char *buf, size_t size, loff_t *off)
{
    size_t asize;

    asize = size + *off > BUFFER_SIZE ? BUFFER_SIZE - *off : size;

    if (copy_to_user(buf, g_buf + *off, asize) != 0) 
        return -EFAULT;

    *off += asize;

    printk(KERN_INFO "Reading...\n");

    return asize;
}

static ssize_t generic_write(struct file *filp, const char *buf, size_t size, loff_t *off)
{
    size_t asize;

    asize = size + *off > BUFFER_SIZE ? BUFFER_SIZE - *off : size;
    if (copy_from_user(g_buf + *off, buf, asize) != 0)
        return -EFAULT;

    *off += asize;

    printk(KERN_INFO "Writing...\n");

    return asize;
}

module_init(generic_init);
module_exit(generic_exit);
    
# Makelfile
    
obj-m += $(file).o
    
all:
    make -C /lib/modules/$(shell uname -r)/build M=${PWD} modules
clean:
    make -C /lib/modules/$(shell uname -r)/build M=${PWD} clean

/* sample.c */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <fcntl.h>
#include <unistd.h>

void exit_sys(const char *msg);

int main(void)    
{
    int fd;
    char wbuf[100] = "this is a test";
    char rbuf[100];
    ssize_t result;

    if ((fd = open("generic", O_WRONLY)) == -1) 
        exit_sys("open");

    if ((result = write(fd, wbuf, strlen(wbuf))) == -1) 
        exit_sys("write");

    printf("%ld bytes written...\n", (long)result);

    close(fd);

    if ((fd = open("generic", O_RDONLY)) == -1) 
        exit_sys("open");

    if ((result = read(fd, rbuf, 10)) == -1)
        exit_sys("read");
    rbuf[result] = '\0';

    printf("%ld bytes read: %s\n", result, rbuf);

    close(fd);

    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/*--------------------------------------------------------------------------------------------------------------------------
    User moddan aygıt dosyası betimleyicisi ile lseek işlemi yapıldığında aygıt sürücünün file_operations yapısı içerisine yerleştirilen
    llseek fonksiyonu çağrılmaktadır. Fonksiyonun parametrik yapısı şöyledir:

    static loff_t  generic_llseek(struct file *filp, loff_t off, int whence);

    Fonksiyonun birinci parametresi dosya nesnesini, ikinci parametresi konumlandırılmak istenen offset'i üçüncü parametresi ise 
    konumlandırmanın nereye göre yapılacağını belirtir. Bu fonksiyonu gerçekleştiriken programcı file yapısı içerisindeki f_pos 
    elemanını güncellemelidir. Tipik olarak programcı whence parametresini switch içerisine alır. Hedeflene offset'i hesaplar ve en sonunda
    file yapsının f_pos elemanına bu hedeflenen offset'i yerleştirir. Hedeflenen offset uygun değilse fonksiyon tipik olarak -EINVAL değeriyle
    geri döndürülür. Eğer konumlandırma offset'i başarılı ise fonksiyon dosya gösterivcisinin yenri değerine geri dönmelidir. 

    Aşağıda llseek fonksiyonun gerçeleştirimesine ilişkin bir örnek verilmiştir.
---------------------------------------------------------------------------------------------------------------------------*/

/* generic-char-driver.c */

#include <linux/module.h>
#include <linux/kernel.h>
#include <linux/fs.h>
#include <linux/cdev.h>
#include <linux/uaccess.h>

MODULE_LICENSE("GPL");
MODULE_DESCRIPTION("General Character Device Driver");
MODULE_AUTHOR("Kaan Aslan");

#define DEV_MAJOR    25
#define DEV_MINOR    0  

#define BUFFER_SIZE     128

static int generic_open(struct inode *inodep, struct file *filp);
static int generic_release(struct inode *inodep, struct file *filp);
static ssize_t generic_read(struct file *filp, char *buf, size_t size, loff_t *off);
static ssize_t generic_write(struct file *filp, const char *buf, size_t size, loff_t *off);
static loff_t  generic_llseek(struct file *filp, loff_t off, int whence);

static dev_t g_dev = MKDEV(DEV_MAJOR, DEV_MINOR);
static struct cdev *g_cdev;
static struct file_operations g_file_ops = {
    .owner = THIS_MODULE,
    .open = generic_open,
    .release = generic_release,
    .read = generic_read,
    .write = generic_write,
    .llseek = generic_llseek,
};

char g_buf[BUFFER_SIZE];

static int __init generic_init(void)     
{
    int result;

    if ((result = register_chrdev_region(g_dev, 1, "generic-char-driver")) < 0) {
        printk(KERN_INFO "Cannot register driver!...\n");
        return result; 
    }

    if ((g_cdev = cdev_alloc()) == NULL) {
        printk(KERN_INFO "Cannot allocate cdev!..\n");
        return -ENOMEM;
    }

    g_cdev->owner = THIS_MODULE;
    g_cdev->ops = &g_file_ops;
    
    if ((result = cdev_add(g_cdev, g_dev, 1)) != 0) {
        unregister_chrdev_region(g_dev, 1);
        printk(KERN_INFO "Cannot add charecter device driver!...\n");
        return result;
    }
    
    printk(KERN_INFO "Success...\n");

    return 0;
}

static void __exit generic_exit(void)
{
    cdev_del(g_cdev);
    unregister_chrdev_region(g_dev, 1);

    printk(KERN_INFO "Goodbye...\n");
}

static int generic_open(struct inode *inodep, struct file *filp)
{
    printk(KERN_INFO "Generic device opened!..\n");

    return 0;
}

static int generic_release(struct inode *inodep, struct file *filp)
{
    printk(KERN_INFO "Generic device released!..\n");

    return 0;
}

static ssize_t generic_read(struct file *filp, char *buf, size_t size, loff_t *off)
{
    size_t asize;

    asize = size + *off > BUFFER_SIZE ? BUFFER_SIZE - *off : size;

    if (copy_to_user(buf, g_buf + *off, asize) != 0) 
        return -EFAULT;

    *off += asize;

    printk(KERN_INFO "Reading...\n");

    return asize;
}

static ssize_t generic_write(struct file *filp, const char *buf, size_t size, loff_t *off)
{
    size_t asize;

    asize = size + *off > BUFFER_SIZE ? BUFFER_SIZE - *off : size;
    if (copy_from_user(g_buf + *off, buf, asize) != 0)
        return -EFAULT;

    *off += asize;

    printk(KERN_INFO "Writing...\n");

    return asize;
}

static loff_t  generic_llseek(struct file *filp, loff_t off, int whence)
{
    loff_t toff;

    switch (whence) {
        case SEEK_SET:
            toff = off;
            break;
        case SEEK_CUR:
            toff = filp->f_pos + off;
            break;
        case SEEK_END:
            toff = BUFFER_SIZE + off;
            break;
        default:
            return -EINVAL;
    }
    
    if (toff > BUFFER_SIZE || toff < 0)
        return -EINVAL;

    filp->f_pos = toff;

    printk(KERN_INFO "file pointer positioning...\n");

    return toff;
}

module_init(generic_init);
module_exit(generic_exit);

# Makelfile
    
    obj-m += $(file).o
    
all:
    make -C /lib/modules/$(shell uname -r)/build M=${PWD} modules
clean:
    make -C /lib/modules/$(shell uname -r)/build M=${PWD} clean

/* sample.c */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <fcntl.h>
#include <unistd.h>

void exit_sys(const char *msg);

int main(void)    
{
    int fd;
    char wbuf[100] = "0123456789012345678901234567890";
    char rbuf[100];
    ssize_t result;

    if ((fd = open("generic", O_RDWR)) == -1) 
        exit_sys("open");

    if ((result = write(fd, wbuf, strlen(wbuf))) == -1) 
        exit_sys("write");

    printf("%ld bytes written...\n", (long)result);

    if (lseek(fd, 0, SEEK_SET) == -1)
        exit_sys("lseek");

    if ((result = read(fd, rbuf, 10)) == -1)
        exit_sys("read");
    rbuf[result] = '\0';

    printf("%ld bytes read: %s\n", result, rbuf);

    if (lseek(fd, -5, SEEK_CUR) == -1)
        exit_sys("lseek");

    if ((result = read(fd, rbuf, 10)) == -1)
        exit_sys("read");
    rbuf[result] = '\0';

    printf("%ld bytes read: %s\n", result, rbuf);

    close(fd);

    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/*--------------------------------------------------------------------------------------------------------------------------
    Biz şimdiye kadarki örneklerimizde aygıt sürücümüzün majör ve minör numarasını batan belirledik. Bunun en önemli sakıncası zaten o numaralı
    bir aygıt sürücünün yüklü olarak bulunuyor olmasıdır. Bu durumda aygıt sürücümüz yüklenemeyecektir. Aslında daha doğru bir strateji tersten
    gitmektir. Yani önce aygıt sürücümüz içerisinde biz boş bir aygıt numarasını bulup onu kullanmalıyız. Sonra user moddan bu numaralı bir aygıt
    dosyası yaratmalıyız. 

    Boş bir aygıt numarasını bize veren alloc_chrdev_region isimli bir kernel fonksiyonu vardır. Fonksiyonun parametrik yapısı şöyledir:

    int alloc_chrdev_region(dev_t *dev, unsigned baseminor, unsigned count, const char *name);

    Fonksiyonun birinci parametresi boş aygıt numarasının yerleştirileceği dev_t nesnesinin adresini alır. İkinci ve üçüncü parametreler başlangıç
    minör numarası ve onun sayısıdır. Son parametre ise aygıt rüsücünün /proc/devices dosyasında ve /sys/dev dizininde görüntülenecek ismini 
    belirtir. alloc_chrdev_region fonksiyonu zaten register_chrdev_region fonksiyonun yaptığını da yapmaktadır. Dolayısıyla bu iki fonksiyondan
    yalnızca biri kullanılmalıdır. Fonksiyon başarı durumunda 0 başarısızlık durumunda negatif errno değerine geri döner. 

    Aygıt sürücümüzde alloc_chrdev_region fonksiyonu ile boş bir majör numara numaranın bulunup augıt sürücümüzün register ettirildiğini düşünelim.
    Pekiyi biz bu numaraya nasıl bilip bu numaraya uygun aygıt dosyası yaratacağız? İşte bunun genellikle izlenen yöntem /proc/devices dosyasına bakıp
    oradan majör numarayı alıp aygıt dosyasını yaratmaktır. Tabii bu manuel olarak yapılabilir ancak bir shell script ile otomatize de edilebilir. 
    Aşağıdaki load isimli script bu işlemi yapmaktadır.

    #!/bin/bash
    
    module=$1
    mode=666

    /sbin/insmod ./$module.ko ${@:2} || exit 1
    major=$(awk "\$2 == \"$module\" {print \$1}" /proc/devices)
    rm -f $module
    mknod $module c $major 0
    chmod $mode $module

    Artık biz bu load script'i ile aygıt sürücümüzü yükleyip aygıt dosyasımızı yaratacağız. Bu script'i load ismiyle yazıp aşağıdaki gibi x hakkı vermelisiniz:

    chmod +x load 

    Çalıştırmayı komut satırı argümanı vererek aşağıdaki gibi yapmalısınız:

    ./load generic-char-driver

    Aşağıdaki örnekte majör numara alloc_chrdev_region fonksiyonuyla elde edilmiştir. Yüklemyi load scripti ile yapnız.

---------------------------------------------------------------------------------------------------------------------------*/

/* generic-char-driver.c */

#include <linux/module.h>
#include <linux/kernel.h>
#include <linux/fs.h>
#include <linux/cdev.h>
#include <linux/uaccess.h>

MODULE_LICENSE("GPL");
MODULE_DESCRIPTION("General Character Device Driver");
MODULE_AUTHOR("Kaan Aslan");

#define BUFFER_SIZE     128

static int generic_open(struct inode *inodep, struct file *filp);
static int generic_release(struct inode *inodep, struct file *filp);
static ssize_t generic_read(struct file *filp, char *buf, size_t size, loff_t *off);
static ssize_t generic_write(struct file *filp, const char *buf, size_t size, loff_t *off);
static loff_t  generic_llseek(struct file *filp, loff_t off, int whence);

static dev_t g_dev;
static struct cdev *g_cdev;
static struct file_operations g_file_ops = {
    .owner = THIS_MODULE,
    .open = generic_open,
    .release = generic_release,
    .read = generic_read,
    .write = generic_write,
    .llseek = generic_llseek,
};

char g_buf[BUFFER_SIZE];

static int __init generic_init(void)     
{
    int result;

    if ((result = alloc_chrdev_region(&g_dev, 0, 1, "generic-char-driver")) < 0) {
        printk(KERN_INFO "Cannot alloc char driver!...\n");
        return result; 
    }

    if ((g_cdev = cdev_alloc()) == NULL) {
        printk(KERN_INFO "Cannot allocate cdev!..\n");
        return -ENOMEM;
    }

    g_cdev->owner = THIS_MODULE;
    g_cdev->ops = &g_file_ops;
    
    if ((result = cdev_add(g_cdev, g_dev, 1)) != 0) {
        unregister_chrdev_region(g_dev, 1);
        printk(KERN_INFO "Cannot add charecter device driver!...\n");
        return result;
    }
    
    printk(KERN_INFO "Module initialized with %d:%d device number...\n", MAJOR(g_dev), MINOR(g_dev));

    return 0;
}

static void __exit generic_exit(void)
{
    cdev_del(g_cdev);
    unregister_chrdev_region(g_dev, 1);

    printk(KERN_INFO "Goodbye...\n");
}

static int generic_open(struct inode *inodep, struct file *filp)
{
    printk(KERN_INFO "Generic device opened!..\n");

    return 0;
}

static int generic_release(struct inode *inodep, struct file *filp)
{
    printk(KERN_INFO "Generic device released!..\n");

    return 0;
}

static ssize_t generic_read(struct file *filp, char *buf, size_t size, loff_t *off)
{
    size_t asize;

    asize = size + *off > BUFFER_SIZE ? BUFFER_SIZE - *off : size;

    if (copy_to_user(buf, g_buf + *off, asize) != 0) 
        return -EFAULT;

    *off += asize;

    printk(KERN_INFO "Reading...\n");

    return asize;
}

static ssize_t generic_write(struct file *filp, const char *buf, size_t size, loff_t *off)
{
    size_t asize;

    asize = size + *off > BUFFER_SIZE ? BUFFER_SIZE - *off : size;
    if (copy_from_user(g_buf + *off, buf, asize) != 0)
        return -EFAULT;

    *off += asize;

    printk(KERN_INFO "Writing...\n");

    return asize;
}

static loff_t  generic_llseek(struct file *filp, loff_t off, int whence)
{
    loff_t toff;

    switch (whence) {
        case SEEK_SET:
            toff = off;
            break;
        case SEEK_CUR:
            toff = filp->f_pos + off;
            break;
        case 2:
            toff = BUFFER_SIZE + off;
        default:
            return -EINVAL;
    }
    
    if (toff > BUFFER_SIZE || toff < 0)
        return -EINVAL;

    filp->f_pos = toff;

    printk(KERN_INFO "file pointer positioning...\n");

    return toff;
}

module_init(generic_init);
module_exit(generic_exit);
    
# Makelfile
    
obj-m += $(file).o
    
all:
    make -C /lib/modules/$(shell uname -r)/build M=${PWD} modules
clean:
    make -C /lib/modules/$(shell uname -r)/build M=${PWD} clean


/* sample.c */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <fcntl.h>
#include <unistd.h>

void exit_sys(const char *msg);

int main(void)    
{
    int fd;
    char wbuf[100] = "0123456789012345678901234567890";
    char rbuf[100];
    ssize_t result;

    if ((fd = open("generic-char-driver", O_RDWR)) == -1) 
        exit_sys("open");

    if ((result = write(fd, wbuf, strlen(wbuf))) == -1) 
        exit_sys("write");

    printf("%ld bytes written...\n", (long)result);

    if (lseek(fd, 0, SEEK_SET) == -1)
        exit_sys("lseek");

    if ((result = read(fd, rbuf, 10)) == -1)
        exit_sys("read");
    rbuf[result] = '\0';

    printf("%ld bytes read: %s\n", result, rbuf);

    if (lseek(fd, -5, SEEK_CUR) == -1)
        exit_sys("lseek");

    if ((result = read(fd, rbuf, 10)) == -1)
        exit_sys("read");
    rbuf[result] = '\0';

    printf("%ld bytes read: %s\n", result, rbuf);

    close(fd);

    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/* load  */

#!/bin/bash

module=$1
mode=666

/sbin/insmod ./$module.ko ${@:2} || exit 1
major=$(awk "\$2 == \"$module\" {print \$1}" /proc/devices)
rm -f $module
mknod $module c $major 0
chmod $mode $module

/*--------------------------------------------------------------------------------------------------------------------------
    Aşağıda gelinen noktaya kadar görülmüş olan konulara kullanılarak yazılmış basit bir boru örneği verilmiştir. 
    Bu boru örneğinde bir proses boruyu yazma modunda açar ve write fonksiyonuyla yazdıkları aygıt sürücü içerisindeki bir kuyruğa
    yazılır. Diğer proses de read fonksiyonuyla bu kuyruktan okuma yapar. Bu gerçekleştirimin özellekleri şöyledir:

    1) write fonksiyonu borudaki boş alan miktarından daha fazla bilgi yazılmaya çalışılırsa blokeye yol açmaz, -NOMEM ile geri döner. 
    2) read fonksiyonu boruda hiçbir bilgi yoksa blokeye yol açmaz 0 ile geri döner. Ancak read diğer durumda okuyabildiği kadar
    byte sayısını okuyup onunla geri döner.
    3) Aygıt sürücünün read/write fonksiyonlarında hiçbir senkronizasyon uygulanmamıştır. Dolayısıyla eşzamanlı işlemlerde tanımsız davranış
    ortaya çıkabilir.
    4) İki proses de boruyu kapatsa bile boru silinmemektedir.  

    Aygıt sürücüyü önce build edip sonra aşağıdaki gibi yükleyiniz:

    make file=pipe-dirver
    sudo ./load pipe-driver
---------------------------------------------------------------------------------------------------------------------------*/

/* pipe-driver.c */

#include <linux/module.h>
#include <linux/kernel.h>
#include <linux/fs.h>
#include <linux/cdev.h>
#include <linux/uaccess.h>

MODULE_LICENSE("GPL");
MODULE_DESCRIPTION("General Character Device Driver");
MODULE_AUTHOR("Kaan Aslan");

#define MIN(a, b)       ((a) < (b) ? (a) : (b))

#define PIPE_SIZE     4096

static int generic_open(struct inode *inodep, struct file *filp);
static int generic_release(struct inode *inodep, struct file *filp);
static ssize_t generic_read(struct file *filp, char *buf, size_t size, loff_t *off);
static ssize_t generic_write(struct file *filp, const char *buf, size_t size, loff_t *off);

static dev_t g_dev;
static struct cdev *g_cdev;
static struct file_operations g_file_ops = {
    .owner = THIS_MODULE,
    .open = generic_open,
    .release = generic_release,
    .read = generic_read,
    .write = generic_write,
};

static char g_pipebuf[PIPE_SIZE];
static size_t g_head = 0, g_tail = 0;
static size_t g_count = 0;

static int __init generic_init(void)     
{
    int result;

    if ((result = alloc_chrdev_region(&g_dev, 0, 1, "pipe-driver")) < 0) {
        printk(KERN_INFO "Cannot alloc char driver!...\n");
        return result; 
    }

    if ((g_cdev = cdev_alloc()) == NULL) {
        printk(KERN_INFO "Cannot allocate cdev!..\n");
        return -ENOMEM;
    }

    g_cdev->owner = THIS_MODULE;
    g_cdev->ops = &g_file_ops;
    
    if ((result = cdev_add(g_cdev, g_dev, 1)) != 0) {
        unregister_chrdev_region(g_dev, 1);
        printk(KERN_INFO "Cannot add charecter device driver!...\n");
        return result;
    }
    
    printk(KERN_INFO "Pipe driver initialized with %d:%d device number...\n", MAJOR(g_dev), MINOR(g_dev));

    return 0;
}

static void __exit generic_exit(void)
{
    cdev_del(g_cdev);
    unregister_chrdev_region(g_dev, 1);

    printk(KERN_INFO "Goodbye...\n");
}

static int generic_open(struct inode *inodep, struct file *filp)
{
    printk(KERN_INFO "Pipe device opened!..\n");

    return 0;
}

static int generic_release(struct inode *inodep, struct file *filp)
{
    printk(KERN_INFO "Pipe device released!..\n");

    return 0;
}

static ssize_t generic_read(struct file *filp, char *buf, size_t size, loff_t *off)
{
     size_t len;

     size = MIN(size, g_count);

     if (size == 0)
        return 0;

    if (g_head >= g_tail)
        len = MIN(size, PIPE_SIZE - g_head);
    else
        len = size;
    
    if (copy_to_user(buf, g_pipebuf + g_head, len) != 0) 
            return -EFAULT;
    if (size > len)
        if (copy_to_user(buf + len, g_pipebuf, size - len) != 0) 
            return -EFAULT;

    g_head = (g_head + size ) % PIPE_SIZE;
    g_count -= size;

    return size;
}

static ssize_t generic_write(struct file *filp, const char *buf, size_t size, loff_t *off)
{
    size_t len;

    if (size > PIPE_SIZE - g_count)    
        return -ENOMEM;

    if (g_tail >= g_head)
        len = MIN(size, PIPE_SIZE - g_tail);
    else
        len = size;

    if (copy_from_user(g_pipebuf + g_tail, buf, len) != 0) 
        return -EFAULT;
    
    if (size > len)
        if (copy_from_user(g_pipebuf, buf + len, size - len) != 0) 
            return -EFAULT;

    g_tail = (g_tail + size ) % PIPE_SIZE;
    g_count += size;

    return size;
}

module_init(generic_init);
module_exit(generic_exit);
    
# Makelfile
    
obj-m += $(file).o
    
all:
    make -C /lib/modules/$(shell uname -r)/build M=${PWD} modules
clean:
    make -C /lib/modules/$(shell uname -r)/build M=${PWD} clean

/* pipeproc1.c */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <fcntl.h>
#include <unistd.h>

#define PIPE_SIZE     4096

void exit_sys(const char *msg);

int main(void)    
{
    int fd;
    char buf[PIPE_SIZE];
    char *str;
    size_t len;

    if ((fd = open("pipe-driver", O_WRONLY)) == -1) 
        exit_sys("open");

    for (;;) {
        printf("Enter text:");
        fflush(stdout);
        fgets(buf, PIPE_SIZE, stdin);
        if ((str = strchr(buf, '\n')) != NULL)
            *str = '\0';
        if (!strcmp(buf, "quit"))
            break;
        len = strlen(buf);
        if (write(fd, buf, len) == -1) {
            fprintf(stderr, "Cannot write pipe! Maybe pipe is full!\n");
            continue;
        }

        printf("%lu bytes written...\n", (unsigned long)len);
    }

    close(fd);

    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/* pipeproc2.c */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <fcntl.h>
#include <unistd.h>

#define PIPE_SIZE     4096

void exit_sys(const char *msg);

int main(void)    
{
    int fd;
    char buf[PIPE_SIZE + 1];
    int len;
    ssize_t result;

    if ((fd = open("pipe-driver", O_RDONLY)) == -1) 
        exit_sys("open");

    for (;;) {
        printf("How many bytes to read? ");
        fflush(stdout);
        scanf("%d", &len);
        if (!len)
            break;
        if ((result = read(fd, buf, len)) == -1)
            exit_sys("read");
        buf[result] = '\0';

        printf("%ld bytes read: \"%s\"\n", (long)result, buf);
    }

    close(fd);

    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

#!/bin/bash
    
module=$1
mode=666

/sbin/insmod ./$module.ko ${@:2} || exit 1
major=$(awk "\$2 == \"$module\" {print \$1}" /proc/devices)
rm -f $module
mknod $module c $major 0
chmod $mode $module

/*--------------------------------------------------------------------------------------------------------------------------
    Kernel modda da senkronizasyon nesneleri vardır. Aygıt sürücülerde bu senkronizasyon nesneleri mecburen çok yoğun kullanılmaktadır. 
    Çünkü aynı anda aygıt sürücü kodları değişik prosesler tarafından kullanıldığında buradaki değerler bozulabilir. Yukarıdaki boru örneğinde
    iki proses aynı anda read/write yaparsa kuyruğu oluşturan veri yapıları bozulacaktır. 

    Biz kernel modda user moddaki senkronizasyon nesnelerini kullanamayız. User modda kullandığımız bütün o senkronizasyon nesnelerinin 
    birer kernel mod karşılıkları vardır. Aslında pthread kütüphanesi de arka planda bu mekaznizmaları kullanmaktadır. 
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Kernel modda mutex mekanizması 2.6 kernel'ında eklenmiştir. Bu mutex mekanizması user moddaki mutex mekanizmasına çok benzemektedir. 
    Yine kernel moddaki mutex'in thread temelinde sahpliği vardır. Thread'e bloke edip sleep kuyruklarında bekletebilmektedir. Kernel mod mutex
    mekanizmasının tipik çalışması şöyledir:

    1) lock işlemi sırasında maliyersiz compare/jump komutlarıyla mutex'in kilitli olup olmadığına bakılır.
    2) mutex kilitliyse biraz spin işlemi yapılır (diğer bir işlemcideki proses kilitlemişse boşuna bloke olmamak için)
    3) spin işleminden sonuç elde eidlemese bloke oluşturulur. 

    Kernel moddaki mutex'ler tipik olarak şöyle kullanılmaktadır:

    1) mutex DEFINE_MUTEX(name) makrosuyla ya da mutex_init fonksiyonuyla ilkdeğerlenir. Örneğin:

    DEFINE_MUTEX(g_name);

    ile aşağıdaki işlem işlevsel olarak eşdeğrdir:

    struct mutex g_mutex;
    ...
    mutex_init(&g_mutex);

    2) Mutex'i kilitlemek için mutex_lock fonksiyonu kullanılır:

    void mutex_lock(struct mutex *lock);

    Mutex'in kilitli olup olmadığı ise mutex_trylock fonksiyonuyla kontrol edilebilir:

    int  mutex_trylock(struct mutex *lock);

    Sinyal geldiğinde uykudaki thread'in uyandrılması için mutex_lock_interruptible fnksiyonu kullanılmaktadır:

    int mutex_lock_interruptible(struct mutex *lock);

    Fonksiyon başarı normal sonlanmada 0 değerine, sinyal dolayıyla sonlandığında -EINTR değerine geri dönmektedir. 

    3) Mutex'i unlock etmek için mutex_unlock fonksiyonu kullanılmaktadır:

    void mutex_unlock(struct mutex *lock);

    Aşağıdaki örnekte yukarıdaki boru sürücüsü daha güvenli olacak biçimde mutex nesneleriyle senkronize edilmiştir.

---------------------------------------------------------------------------------------------------------------------------*/

/* pipe-driver.c */

#include <linux/module.h>
#include <linux/kernel.h>
#include <linux/fs.h>
#include <linux/cdev.h>
#include <linux/uaccess.h>
#include <linux/mutex.h>

MODULE_LICENSE("GPL");
MODULE_DESCRIPTION("General Character Device Driver");
MODULE_AUTHOR("Kaan Aslan");

#define MIN(a, b)       ((a) < (b) ? (a) : (b))

#define PIPE_SIZE     4096

static int generic_open(struct inode *inodep, struct file *filp);
static int generic_release(struct inode *inodep, struct file *filp);
static ssize_t generic_read(struct file *filp, char *buf, size_t size, loff_t *off);
static ssize_t generic_write(struct file *filp, const char *buf, size_t size, loff_t *off);

static dev_t g_dev;
static struct cdev *g_cdev;
static struct file_operations g_file_ops = {
    .owner = THIS_MODULE,
    .open = generic_open,
    .release = generic_release,
    .read = generic_read,
    .write = generic_write,
};

static char g_pipebuf[PIPE_SIZE];
static size_t g_head = 0, g_tail = 0;
static size_t g_count = 0;
static DEFINE_MUTEX(g_mutex);

static int __init generic_init(void)     
{
    int result;

    if ((result = alloc_chrdev_region(&g_dev, 0, 1, "pipe-driver")) < 0) {
        printk(KERN_INFO "Cannot alloc char driver!...\n");
        return result; 
    }

    if ((g_cdev = cdev_alloc()) == NULL) {
        printk(KERN_INFO "Cannot allocate cdev!..\n");
        return -ENOMEM;
    }

    g_cdev->owner = THIS_MODULE;
    g_cdev->ops = &g_file_ops;
    
    if ((result = cdev_add(g_cdev, g_dev, 1)) != 0) {
        unregister_chrdev_region(g_dev, 1);
        printk(KERN_INFO "Cannot add charecter device driver!...\n");
        return result;
    }
    
    printk(KERN_INFO "Pipe driver initialized with %d:%d device number...\n", MAJOR(g_dev), MINOR(g_dev));

    return 0;
}

static void __exit generic_exit(void)
{
    cdev_del(g_cdev);
    unregister_chrdev_region(g_dev, 1);

    printk(KERN_INFO "Goodbye...\n");
}

static int generic_open(struct inode *inodep, struct file *filp)
{
    printk(KERN_INFO "Pipe device opened!..\n");

    return 0;
}

static int generic_release(struct inode *inodep, struct file *filp)
{
    printk(KERN_INFO "Pipe device released!..\n");

    return 0;
}

static ssize_t generic_read(struct file *filp, char *buf, size_t size, loff_t *off)
{
    size_t len;
    ssize_t result;

    if (mutex_lock_interruptible(&g_mutex))
        return -ERESTARTSYS;

     size = MIN(size, g_count);

     if (size == 0) {
         result = 0;
         goto EXIT;
     }

    if (g_head >= g_tail)
        len = MIN(size, PIPE_SIZE - g_head);
    else
        len = size;
    
    if (copy_to_user(buf, g_pipebuf + g_head, len) != 0) {
        result = -EFAULT;
        goto EXIT;
    }

    if (size > len)
        if (copy_to_user(buf + len, g_pipebuf, size - len) != 0) {
            result = -EFAULT;
            goto EXIT;
        }

    g_head = (g_head + size ) % PIPE_SIZE;
    g_count -= size;

    result = size;
EXIT:
    mutex_unlock(&g_mutex);

    return result;
}

static ssize_t generic_write(struct file *filp, const char *buf, size_t size, loff_t *off)
{
    size_t len;
    ssize_t result;

    if (mutex_lock_interruptible(&g_mutex))
        return -ERESTARTSYS;

    if (size > PIPE_SIZE - g_count)   {
        result = -ENOMEM;
        goto EXIT;
    } 

    if (g_tail >= g_head)
        len = MIN(size, PIPE_SIZE - g_tail);
    else
        len = size;

    if (copy_from_user(g_pipebuf + g_tail, buf, len) != 0) {
        result = -EFAULT;
        goto EXIT;
    }
    
    if (size > len)
        if (copy_from_user(g_pipebuf, buf + len, size - len) != 0) {
            result = -EFAULT;
            goto EXIT;
        }

    g_tail = (g_tail + size ) % PIPE_SIZE;
    g_count += size;

    result = size;

    mutex_unlock(&g_mutex);
EXIT:
    return result;
}

module_init(generic_init);
module_exit(generic_exit);

# Makelfile
    
obj-m += $(file).o
    
all:
    make -C /lib/modules/$(shell uname -r)/build M=${PWD} modules
clean:
    make -C /lib/modules/$(shell uname -r)/build M=${PWD} clean
    
/* pipeproc1.c */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <fcntl.h>
#include <unistd.h>

#define PIPE_SIZE     4096

void exit_sys(const char *msg);

int main(void)    
{
    int fd;
    char buf[PIPE_SIZE];
    char *str;
    size_t len;

    if ((fd = open("pipe-driver", O_WRONLY)) == -1) 
        exit_sys("open");

    for (;;) {
        printf("Enter text:");
        fflush(stdout);
        fgets(buf, PIPE_SIZE, stdin);
        if ((str = strchr(buf, '\n')) != NULL)
            *str = '\0';
        if (!strcmp(buf, "quit"))
            break;
        len = strlen(buf);
        if (write(fd, buf, len) == -1) {
            fprintf(stderr, "Cannot write pipe! Maybe pipe is full!\n");
            continue;
        }

        printf("%lu bytes written...\n", (unsigned long)len);
    }

    close(fd);

    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/* pipeproc2.c */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <fcntl.h>
#include <unistd.h>

#define PIPE_SIZE     4096

void exit_sys(const char *msg);

int main(void)    
{
    int fd;
    char buf[PIPE_SIZE + 1];
    int len;
    ssize_t result;

    if ((fd = open("pipe-driver", O_RDONLY)) == -1) 
        exit_sys("open");

    for (;;) {
        printf("How many bytes to read? ");
        fflush(stdout);
        scanf("%d", &len);
        if (!len)
            break;
        if ((result = read(fd, buf, len)) == -1)
            exit_sys("read");
        buf[result] = '\0';

        printf("%ld bytes read: \"%s\"\n", (long)result, buf);
    }

    close(fd);

    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

#!/bin/bash
    
module=$1
mode=666

/sbin/insmod ./$module.ko ${@:2} || exit 1
major=$(awk "\$2 == \"$module\" {print \$1}" /proc/devices)
rm -f $module
mknod $module c $major 0
chmod $mode $module

/*--------------------------------------------------------------------------------------------------------------------------
    Kernel semaphore nesneleri de tamamen user modda kullandığımız semaphore nesneleri gibidir. Bunların sayacı vardır. Sayaç 0'dan büyükse
    semaphore açık durumdadır. Kritik koda girildiğinde sayaç eksiltilir. Sayaç 0 olduğunda thread bloke edilir. Yine bloke işleminde 
    biraz spin işlemi yapılıp sonra bloke uygulanmaktadır. Semaphore nesneleri şöyle kullanılmaktadır:

    1) Semaphore nesnesi struct semaphore isimli bir yapıyla temsil edilmiştir. Bir semaphore nesnesi DEFINE_SEMAPHORE(name) makrosuyla 
    aşağıdaki gibi oluşturulabilir. 

    DEFINE_SEMAPHORE(g_sem);

    Bu biçimde yaratılan semaphore nesnesinin sayaç değeri başlangıçta 1'dir. Semaphore nesneleri sema_init fonksiyonuyla da yaratılabilmektedir:

    struct semaphore g_sem;
    ...
    sema_init(&g_sem, 1);

    Fonksiyonun ikinci parametresi başlangıç sayaç numarasıdır.

    2) Kritik kod down ve up fonksiyonları arasına alınır. down fonksiyonları sayacı bir eksilterek kritik koda giriş yapar. up fonksiyonu ise
    sayacı bir artırmaktadır. Fonksiyonların prototipleri şöyledir:

    void down(struct semaphore *sem);
    int down_interruptible(struct semaphore *sem);
    int down_killable(struct semaphore *sem);
    int down_trylock(struct semaphore *sem);
    int down_timeout(struct semaphore *sem, long jiffies);
    void up(struct semaphore *sem);  

    Yine down_interruptible sinyal geldiğinde sonlanabilen bir fonksiyondur. down_killable yalnızca SIGKILL sinyali geldiğinde sonlanabilir. 
    down fonksiyonu sinyal gelse de sonlanmaz. down_trylock yine nesnenin açık olup olmadığına bakmaktadır. down_timeout en kötü olasılıkla belli miktar
    jiffy zamanı kadar blokeye yol açar. 

    interruptible down fonksiyonları normal sonlanmada 0 değerine, sinyal yoluyla sonlanmada -ERESTARTSYS değeri ile geri dönmektedir. 
    Normal uygulama eğer bu fonksiyonlar -ERESTARTSYS ile geri dönerse aygıt sürücüdeki fonksiyonu da aynı değerle geri döndürmektedir. Zaten VFS
    bu -ERESTARTSYS geri dönüş değerini aldığında asıl sistem fonksiyonunu -EINTR değeri ile geri dönddürmektedir. Bu da tabii POSIX fonksiyonlarının 
    başarısz olup errno değerinin EINTR biçiminde set edilmesine yol açmaktadır. 

    Yukarıdaki boru örneğinde biz mutex nesnesi yerine binary semaphore nesnesi de kullanabilirdik. 

---------------------------------------------------------------------------------------------------------------------------*/

/* pipe-driver.c */

#include <linux/module.h>
#include <linux/kernel.h>
#include <linux/fs.h>
#include <linux/cdev.h>
#include <linux/uaccess.h>
#include <linux/semaphore.h>

MODULE_LICENSE("GPL");
MODULE_DESCRIPTION("General Character Device Driver");
MODULE_AUTHOR("Kaan Aslan");

#define MIN(a, b)       ((a) < (b) ? (a) : (b))

#define PIPE_SIZE     4096

static int generic_open(struct inode *inodep, struct file *filp);
static int generic_release(struct inode *inodep, struct file *filp);
static ssize_t generic_read(struct file *filp, char *buf, size_t size, loff_t *off);
static ssize_t generic_write(struct file *filp, const char *buf, size_t size, loff_t *off);

static dev_t g_dev;
static struct cdev *g_cdev;
static struct file_operations g_file_ops = {
    .owner = THIS_MODULE,
    .open = generic_open,
    .release = generic_release,
    .read = generic_read,
    .write = generic_write,
};

static char g_pipebuf[PIPE_SIZE];
static size_t g_head = 0, g_tail = 0;
static size_t g_count = 0;
static DEFINE_SEMAPHORE(g_sem);

static int __init generic_init(void)     
{
    int result;

    if ((result = alloc_chrdev_region(&g_dev, 0, 1, "pipe-driver")) < 0) {
        printk(KERN_INFO "Cannot alloc char driver!...\n");
        return result; 
    }

    if ((g_cdev = cdev_alloc()) == NULL) {
        printk(KERN_INFO "Cannot allocate cdev!..\n");
        return -ENOMEM;
    }

    g_cdev->owner = THIS_MODULE;
    g_cdev->ops = &g_file_ops;
    
    if ((result = cdev_add(g_cdev, g_dev, 1)) != 0) {
        unregister_chrdev_region(g_dev, 1);
        printk(KERN_INFO "Cannot add charecter device driver!...\n");
        return result;
    }
    
    printk(KERN_INFO "Pipe driver initialized with %d:%d device number...\n", MAJOR(g_dev), MINOR(g_dev));

    return 0;
}

static void __exit generic_exit(void)
{
    cdev_del(g_cdev);
    unregister_chrdev_region(g_dev, 1);

    printk(KERN_INFO "Goodbye...\n");
}

static int generic_open(struct inode *inodep, struct file *filp)
{
    printk(KERN_INFO "Pipe device opened!..\n");

    return 0;
}

static int generic_release(struct inode *inodep, struct file *filp)
{
    printk(KERN_INFO "Pipe device released!..\n");

    return 0;
}

static ssize_t generic_read(struct file *filp, char *buf, size_t size, loff_t *off)
{
    size_t len;
    ssize_t result;

    if (down_interruptible(&g_sem))
        return -ERESTARTSYS;

     size = MIN(size, g_count);

     if (size == 0) {
         result = 0;
         goto EXIT;
     }

    if (g_head >= g_tail)
        len = MIN(size, PIPE_SIZE - g_head);
    else
        len = size;
    
    if (copy_to_user(buf, g_pipebuf + g_head, len) != 0) {
        result = -EFAULT;
        goto EXIT;
    }

    if (size > len)
        if (copy_to_user(buf + len, g_pipebuf, size - len) != 0) {
            result = -EFAULT;
            goto EXIT;
        }

    g_head = (g_head + size ) % PIPE_SIZE;
    g_count -= size;

    result = size;
EXIT:
    up(&g_sem);

    return result;
}

static ssize_t generic_write(struct file *filp, const char *buf, size_t size, loff_t *off)
{
    size_t len;
    ssize_t result;

    if (down_interruptible(&g_sem))
        return -ERESTARTSYS;

    if (size > PIPE_SIZE - g_count)   {
        result = -ENOMEM;
        goto EXIT;
    } 

    if (g_tail >= g_head)
        len = MIN(size, PIPE_SIZE - g_tail);
    else
        len = size;

    if (copy_from_user(g_pipebuf + g_tail, buf, len) != 0) {
        result = -EFAULT;
        goto EXIT;
    }
    
    if (size > len)
        if (copy_from_user(g_pipebuf, buf + len, size - len) != 0) {
            result = -EFAULT;
            goto EXIT;
        }

    g_tail = (g_tail + size ) % PIPE_SIZE;
    g_count += size;

    result = size;

    up(&g_sem);
EXIT:
    return result;
}

module_init(generic_init);
module_exit(generic_exit);

# Makelfile
    
obj-m += $(file).o
    
all:
    make -C /lib/modules/$(shell uname -r)/build M=${PWD} modules
clean:
    make -C /lib/modules/$(shell uname -r)/build M=${PWD} clean

/* pipeproc1.c */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <fcntl.h>
#include <unistd.h>

#define PIPE_SIZE     4096

void exit_sys(const char *msg);

int main(void)    
{
    int fd;
    char buf[PIPE_SIZE];
    char *str;
    size_t len;

    if ((fd = open("pipe-driver", O_WRONLY)) == -1) 
        exit_sys("open");

    for (;;) {
        printf("Enter text:");
        fflush(stdout);
        fgets(buf, PIPE_SIZE, stdin);
        if ((str = strchr(buf, '\n')) != NULL)
            *str = '\0';
        if (!strcmp(buf, "quit"))
            break;
        len = strlen(buf);
        if (write(fd, buf, len) == -1) {
            fprintf(stderr, "Cannot write pipe! Maybe pipe is full!\n");
            continue;
        }

        printf("%lu bytes written...\n", (unsigned long)len);
    }

    close(fd);

    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/* pipeproc2.c */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <fcntl.h>
#include <unistd.h>

#define PIPE_SIZE     4096

void exit_sys(const char *msg);

int main(void)    
{
    int fd;
    char buf[PIPE_SIZE + 1];
    int len;
    ssize_t result;

    if ((fd = open("pipe-driver", O_RDONLY)) == -1) 
        exit_sys("open");

    for (;;) {
        printf("How many bytes to read? ");
        fflush(stdout);
        scanf("%d", &len);
        if (!len)
            break;
        if ((result = read(fd, buf, len)) == -1)
            exit_sys("read");
        buf[result] = '\0';

        printf("%ld bytes read: \"%s\"\n", (long)result, buf);
    }

    close(fd);

    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

#!/bin/bash
    
module=$1
mode=666

/sbin/insmod ./$module.ko ${@:2} || exit 1
major=$(awk "\$2 == \"$module\" {print \$1}" /proc/devices)
rm -f $module
mknod $module c $major 0
chmod $mode $module

/*--------------------------------------------------------------------------------------------------------------------------
    Tıpkı thread'lerde olduğu gibi aygıt sürücülerde de basit atama, artırma, eksiltme gibi işlemlerin atomic yapılmasını sağlayan
    özel fonksiyonlar vardır. Aslında bu işlemler thread konusunda görmüş olduğumuz gcc'nin built-in atimic fonksiyonlarıyla
    yaplabilir. Ancak çekirdek içerisindeki fonksiyonların kullanılması uyum bakımından daha uygundur. Bu fonksiyonların hepsi 
    nesneyi atomic_t türü biçiminde istemektedir. Bu aslında içerisinde yalnızca int bir nesne olan bir yapı türüdür. Bu yapı nesnesinin
    içerisindeki değeri alan atomic_read isimli bir fonksiyon da vardır. Atomic fonksiyonların bazıları şunlardır:

    atomic_set
    atomic_add
    atomic_sub
    atomic_inc
    atomic_dec
    ....
----------------------------------------------------------------------------------------------------------------------------*/


/*--------------------------------------------------------------------------------------------------------------------------
    Bir thread nasıl bloke olmaktadır? Aslında bloke olma demek kabaca ilgi thread'i (yani task_struct nesnesini) Run kuyruğundan
    çıkartarak bir wait kuyruğuna yerleştirmek demektir. Pekiyi wait kuyrukları nerededir ve biz bir thread'i wait kuyruklarına nasıl yerleştirip
    yeniden run kuyruğuna atayabiliriz?

    İşte aslında wait kuyrukları istenildiği kadar çok olabilir. Her aygıt sürücü kendi wait kuyruğunu yaratabilir. Kernel içeisinde
    wait kuyruğu yaratan mekanizmalar vardır. Bir thread'i (yani task_struct nesnesini) run kuyruğundan wait kuyruğuna, wait kuyruğundan run
    kuyruğuna yerleştiren hazır fonksiyonlar bulunmaktadır. 

    Wait kuyrukları wait_queue_head_t isimli yapıyla temsil edilmektedir. Bir wait kuyruğu DECLARE_WAIT_QUEUE_HEAD(name) makrosuyla oluşturulabilir:

    DECLARE_WAIT_QUEUE_HEAD(g_wq);

    Ya da nesne tanımlanıp init_waitqueueu_head fonksiyonuyla da ilkdeğerlenebilir:

    wait_queeue_head_t g_wq;
    ...
    init_waitqueue_head(&g_wq);

    Bir thread'i (yani task_struct nesnesini) run kuyruğundan çıkartıp istenilen wait kuyruğuna yerleştirme işlemi event_wait makrolarıyla
    gerçekleştirilmektedir. Temel wait_event makroları şunlardır:

    wait_event(wq_head, condition);
    wait_event_interruptible(wq_head, condition);
    wait_event_killable(wq_head, condition);
    wait_event_timeout(wq_head, condition, timeout);	
    wait_event_interruptible_timeout(wq_head, condition, timeout);	
    wait_event_interruptible_exclusive(wq_head, condition);

    wait_event fonksiyonu "uninterruptible" biçimdedir. Yani o andaki thread akışını wait kuyruğuna yerleştirir. Dolayısıyla run kuyruğundan çıkartır. 
    Fakat sinyal oluştuğunda thread uykudan uyanmaz. wait_queue_interruptible makrosu ise aynı işlemi "interruptible" olarak yapmaktadır. Yani sinyal
    geldiğinde thread uyandırılır. wait_event_killable makrosu yalnızca SIGKILL sinyali için thread'i uyandırır. wait_event_timeout ise belli bir jiffy değerini
    zaman aşımı olarak kullanır. Makrolardaki condition (koşul) parametresi aslında bool bir ifade biçiminde oluşturulmakatadır. Bu ifade ya sıfır
    olur ya da sıfır dışı olur. Bu koşul ifadesi "uyanık kalmak için bir koşul" belirtmektedir. Ancak bu koşul uyandırma koşulu değildir. Uyanık kalma koşuludur.
    Thread  uyandırılır, sonra uyanmış olan thread bu koşula bakar. Koşul sağlanmıyorsa (condition == 0 ise) yeniden uyutulur. Tabii aslında thread henüz
    uyutulmadan da bu koşula bakılmaktadır. Bu koşul zaten sağlanıyorsa thread hiç uyutulmamaktadır. 

    wait_event_interruptible_exclusive (bunun interrutible olmayan biçimi yoktur) fonksiyonu Lİnux çekirdeklerine 2.6'ının belli sürümünden sonra sokulmuştur.
    Yine bu fonksiyonla birlikte aşağıda ele alınan wake_up_xxxx_nr fonksiyonları da eklenmiştir. Bir prosesin exclusive olarak wait kuyruğuna yerleştirilmes
    onlardan belli sayıda olanların uyandırılabilmesini sağlamaktadır. 

    O halde wait_event makroları o andaki thread'i çizelgeden (yani run kuyruğundan) çıkartıp wait kuyruğuna yerleştirdikten sonra "task switch"  işlemini
    yapar. Task switch işlemi sonrasında artık run kuyruğundaki yeni bir thread çalışır. 

    Wait kuyruğundaki thread (yani task_struct nesnesi) yeniden run kuyruğuna wake_up makrolarıyla sokulmaktadır. wait_event makrolarındaki koşula
    wake_up makroları bakmaz. wake_up makroları yalnızca thread'i wait kuyruklarından run kuyruğuna taşımaktadır. Koşula uyandırımış thread'in kendisi 
    bakmaktadır. Eğer koşul sağlanmıyorsa yeniden uyutulmaktadır. (Zaten belli bir koşula bakarak uyandırma gerçekleştirim olarak mümkün değildir.)
    Durum böyle olsa da aslında sonuçta koşulu sağlamayan thread'ler yeniden uyutulduklarına göre gerçek anlamda uyandırılmış olmamaktadır. Kullanılan
    wake_up makroları şunlardır:

    wake_up(wq_head);			
    wake_up_nr(wq_head, nr);	
    wake_up_all(wq_head);
    wake_up_interruptible(wq_head);
    wake_up_interruptible_nr(wq_head, nr);
    wake_up_interruptible_all(wq_head);
    
    Buradaki sonu xxx_interruptible ile biten isimdeki makrolar "sinyalle kesilebilir" olanları uyandırma işini yapar.  Sonu xxx_nr ile biten makrolar ise
    wait kuyruğundaki belli sayıda exclusive bekleyen (yani wait_event_interruptible_exclusive ile bekleyen)  thread'i uyandırmaktadır. wake_up_all makrosu 
    wait kuyruğundaki tüm thread'leri uyandırır.  wake_up ve wake_up_interruptible makroları kuyruktaki tek bir exclusive thread'i uyandırmaktadır. 
    wake_up makrolarının "interruptible" olanları yalnızca  "interruptible" olarak wait kuyruğunda bekleyenleri (yani wait_event_interruptible ile bekleyenleri) uyandırmaktadır. 
    Eskiden prosesi uyandıran wake_up fonksiyonlarının yalnızca wait kuyruğundaki tüm prosesleri uyandıran biçimleri vardı. Sonra belli sayıda exclusive bekleyen prosesi uyandıran
    wake_up fonksiyonları da çekirdeğe eklenmiştir. Belli sayıda exclusive prosesi uayndıramn makrolar exclusive olmayan prosesleri de uyandırmaktadır.  
    Programcı wake_up makrolarına wait_queue_head_t nesnelerinin adreslerini geçirmelidir. (Halbuki wait_event makrolarına
    programcı nesnelerin kendisini geçirmektedir. Adresi makrolar almaktadır.)
    
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Aşağıdaki örnekte aygıt sürücünün read fonksiyonunda proses wait_event_interruptible fonksiyonu ile bloke edilerek yaratılmış olan wait 
    kuyruğuna aktarılmıştır. write fonksiyonu ise prosesi wait kuyruğundan yeniden wake_up fonksiyonuyla run kuyruğuna aktarmaktadır. 
---------------------------------------------------------------------------------------------------------------------------*/

/* generic-char-driver.c */

#include <linux/module.h>
#include <linux/kernel.h>
#include <linux/fs.h>
#include <linux/cdev.h>
#include <linux/wait.h>

MODULE_LICENSE("GPL");
MODULE_DESCRIPTION("General Character Device Driver");
MODULE_AUTHOR("Kaan Aslan");

static int generic_open(struct inode *inodep, struct file *filp);
static int generic_release(struct inode *inodep, struct file *filp);
static ssize_t generic_read(struct file *filp, char *buf, size_t size, loff_t *off);
static ssize_t generic_write(struct file *filp, const char *buf, size_t size, loff_t *off);

static dev_t g_dev;
static struct cdev *g_cdev;
static struct file_operations g_file_ops = {
    .owner = THIS_MODULE,
    .open = generic_open,
    .release = generic_release,
    .read = generic_read,
    .write = generic_write,
};
static DECLARE_WAIT_QUEUE_HEAD(g_wq);
static int g_cond;

static int __init generic_init(void)     
{
    int result;

    if ((result = alloc_chrdev_region(&g_dev, 0, 1, "generic-char-driver")) < 0) {
        printk(KERN_INFO "Cannot alloc char driver!...\n");
        return result; 
    }

    if ((g_cdev = cdev_alloc()) == NULL) {
        printk(KERN_INFO "Cannot allocate cdev!..\n");
        return -ENOMEM;
    }

    g_cdev->owner = THIS_MODULE;
    g_cdev->ops = &g_file_ops;
    
    if ((result = cdev_add(g_cdev, g_dev, 1)) != 0) {
        unregister_chrdev_region(g_dev, 1);
        printk(KERN_INFO "Cannot add charecter device driver!...\n");
        return result;
    }
    
    printk(KERN_INFO "Module initialized with %d:%d device number...\n", MAJOR(g_dev), MINOR(g_dev));

    return 0;
}

static void __exit generic_exit(void)
{
    cdev_del(g_cdev);
    unregister_chrdev_region(g_dev, 1);

    printk(KERN_INFO "Goodbye...\n");
}

static int generic_open(struct inode *inodep, struct file *filp)
{
    printk(KERN_INFO "Pipe device opened!..\n");

    return 0;
}

static int generic_release(struct inode *inodep, struct file *filp)
{
    printk(KERN_INFO "Pipe device released!..\n");

    return 0;
}

static ssize_t generic_read(struct file *filp, char *buf, size_t size, loff_t *off)
{
    printk(KERN_INFO "Process sleeping!..\n");

    g_cond = 0;
    if (wait_event_interruptible(g_wq, g_cond != 0))
        return -ERESTARTSYS;

    printk(KERN_INFO "Process waking up!..\n");
   
    return 0;
}

static ssize_t generic_write(struct file *filp, const char *buf, size_t size, loff_t *off)
{
    g_cond = 1;
    wake_up_all(&g_wq);

    return 0;
}

module_init(generic_init);
module_exit(generic_exit);

module_init(generic_init);
module_exit(generic_exit);

# Makelfile
    
obj-m += $(file).o
    
all:
    make -C /lib/modules/$(shell uname -r)/build M=${PWD} modules
clean:
    make -C /lib/modules/$(shell uname -r)/build M=${PWD} clean

/* ddproc.1 */

#include <stdio.h>
#include <stdlib.h>
#include <fcntl.h>
#include <unistd.h>

void exit_sys(const char *msg);

int main(void)    
{
    int fd;
    char ch;

    if ((fd = open("generic-char-driver", O_RDONLY)) == -1)
        exit_sys("open");

    printf("read call begins...\n");

    if (read(fd, &ch, 1) == -1)
        exit_sys("read");

    printf("read call ends...\n");

    close(fd);
       
    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/* ddproc2.c */

#include <stdio.h>
#include <stdlib.h>
#include <fcntl.h>
#include <unistd.h>

void exit_sys(const char *msg);

int main(void)    
{
    int fd;
   
    if ((fd = open("generic-char-driver", O_WRONLY)) == -1)
        exit_sys("open");

    printf("Press ENTER to write!..\n");
    getchar();

    if (write(fd, "a", 1) == -1)
        exit_sys("read");

    close(fd);
       
    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

#!/bin/bash
    
module=$1
mode=666

/sbin/insmod ./$module.ko ${@:2} || exit 1
major=$(awk "\$2 == \"$module\" {print \$1}" /proc/devices)
rm -f $module
mknod $module c $major 0
chmod $mode $module

/*--------------------------------------------------------------------------------------------------------------------------
    Aşağıdai kodda wait kuyruğunda bekleyen proseslerden yalnızca 1 tanesini wake_up makrosuyla çıkartan kod verilmiştir.
---------------------------------------------------------------------------------------------------------------------------*/

/* generic-char-driver.c */

#include <linux/module.h>
#include <linux/kernel.h>
#include <linux/fs.h>
#include <linux/cdev.h>
#include <linux/wait.h>

MODULE_LICENSE("GPL");
MODULE_DESCRIPTION("General Character Device Driver");
MODULE_AUTHOR("Kaan Aslan");

static int generic_open(struct inode *inodep, struct file *filp);
static int generic_release(struct inode *inodep, struct file *filp);
static ssize_t generic_read(struct file *filp, char *buf, size_t size, loff_t *off);
static ssize_t generic_write(struct file *filp, const char *buf, size_t size, loff_t *off);

static dev_t g_dev;
static struct cdev *g_cdev;
static struct file_operations g_file_ops = {
    .owner = THIS_MODULE,
    .open = generic_open,
    .release = generic_release,
    .read = generic_read,
    .write = generic_write,
};
static DECLARE_WAIT_QUEUE_HEAD(g_wq);
static int g_cond;

static int __init generic_init(void)     
{
    int result;

    if ((result = alloc_chrdev_region(&g_dev, 0, 1, "generic-char-driver")) < 0) {
        printk(KERN_INFO "Cannot alloc char driver!...\n");
        return result; 
    }

    if ((g_cdev = cdev_alloc()) == NULL) {
        printk(KERN_INFO "Cannot allocate cdev!..\n");
        return -ENOMEM;
    }

    g_cdev->owner = THIS_MODULE;
    g_cdev->ops = &g_file_ops;
    
    if ((result = cdev_add(g_cdev, g_dev, 1)) != 0) {
        unregister_chrdev_region(g_dev, 1);
        printk(KERN_INFO "Cannot add charecter device driver!...\n");
        return result;
    }
    
    printk(KERN_INFO "Module initialized with %d:%d device number...\n", MAJOR(g_dev), MINOR(g_dev));

    return 0;
}

static void __exit generic_exit(void)
{
    cdev_del(g_cdev);
    unregister_chrdev_region(g_dev, 1);

    printk(KERN_INFO "Goodbye...\n");
}

static int generic_open(struct inode *inodep, struct file *filp)
{
    printk(KERN_INFO "Generic device opened!..\n");

    return 0;
}

static int generic_release(struct inode *inodep, struct file *filp)
{
    printk(KERN_INFO "Generic device released!..\n");

    return 0;
}

static ssize_t generic_read(struct file *filp, char *buf, size_t size, loff_t *off)
{
    printk(KERN_INFO "Process sleeping!..\n");

    g_cond = 0;
    if (wait_event_interruptible_exclusive(g_wq, g_cond != 0))
        return -ERESTARTSYS;

    printk(KERN_INFO "Process waking up!..\n");
   
    return 0;
}

static ssize_t generic_write(struct file *filp, const char *buf, size_t size, loff_t *off)
{
    g_cond = 1;
    wake_up(&g_wq);

    return 0;
}

module_init(generic_init);
module_exit(generic_exit);

/*--------------------------------------------------------------------------------------------------------------------------
    Şimdi de boru örneğimizi gerçek bir pipe haline getirelim. Yani özellikleri katalım:

    1) Okuma yapan prosesler eğer boruda okunacak hiçbir byte yoksa blokede beklemelidir. (Tabii birden fazla proses bloke olmuşsa boruya
    bilgi geldiğinde hangisinin bu bilgiyi alacağının garantisi yoktur.)

    2) Yazma işlemi sırasında eğer boruda yazılanların hepsini alacak kadar boş yer yoksa yazan proses bloke olmalıdır. 

    Aşağıdaki örnekte blokenin çözülmesi sırasında while dönüsüne dikkat ediniz:

     while (g_count == 0) {
        up(&g_sem);
        if (wait_event_interruptible(g_wqread, g_count > 0))
            return -ERESTARTSYS;
        if (down_interruptible(&g_sem))
            return -ERESTARTSYS;
    }

    Burada birden fazla proses uykudan uyandırılabilir. Ancak bunlardna biri semaphore'dan geçecektir. Bu durumda semaphore'dan geçen proses
    her şeyi okuyabileceği için  uyanmış olup semaphore'da kalan prosesin semaphore'dan çıktığında yeniden koşula bakması gerekir. Bu nedenle yukarıdaki kodda
    mecburen if deyimi yerine while deyimi kullanılmıştır. Aynı durum write işleminde de söz konusudur. Ayrıca bu örnekte uyandırma işlemi tüm kuyruktaki prosslerin
    wake_up_all ile uyandırılması biçiminde gerçekleştirilmektedir. Çünkü birden fazla proses boruda kalanları okuyabilmelidir. 

---------------------------------------------------------------------------------------------------------------------------*/

/* pipe-driver.c */

#include <linux/module.h>
#include <linux/kernel.h>
#include <linux/fs.h>
#include <linux/cdev.h>
#include <linux/uaccess.h>
#include <linux/semaphore.h>

MODULE_LICENSE("GPL");
MODULE_DESCRIPTION("General Character Device Driver");
MODULE_AUTHOR("Kaan Aslan");

#define MIN(a, b)       ((a) < (b) ? (a) : (b))

#define PIPE_SIZE     10

static int generic_open(struct inode *inodep, struct file *filp);
static int generic_release(struct inode *inodep, struct file *filp);
static ssize_t generic_read(struct file *filp, char *buf, size_t size, loff_t *off);
static ssize_t generic_write(struct file *filp, const char *buf, size_t size, loff_t *off);

static dev_t g_dev;
static struct cdev *g_cdev;
static struct file_operations g_file_ops = {
    .owner = THIS_MODULE,
    .open = generic_open,
    .release = generic_release,
    .read = generic_read,
    .write = generic_write,
};

static char g_pipebuf[PIPE_SIZE];
static size_t g_head = 0, g_tail = 0;
static size_t g_count = 0;
static DEFINE_SEMAPHORE(g_sem);
static DECLARE_WAIT_QUEUE_HEAD(g_wqread);
static DECLARE_WAIT_QUEUE_HEAD(g_wqwrite);

static int __init generic_init(void)     
{
    int result;

    if ((result = alloc_chrdev_region(&g_dev, 0, 1, "pipe-driver")) < 0) {
        printk(KERN_INFO "Cannot alloc char driver!...\n");
        return result; 
    }

    if ((g_cdev = cdev_alloc()) == NULL) {
        printk(KERN_INFO "Cannot allocate cdev!..\n");
        return -ENOMEM;
    }

    g_cdev->owner = THIS_MODULE;
    g_cdev->ops = &g_file_ops;
    
    if ((result = cdev_add(g_cdev, g_dev, 1)) != 0) {
        unregister_chrdev_region(g_dev, 1);
        printk(KERN_INFO "Cannot add charecter device driver!...\n");
        return result;
    }
    
    printk(KERN_INFO "Pipe driver initialized with %d:%d device number...\n", MAJOR(g_dev), MINOR(g_dev));

    return 0;
}

static void __exit generic_exit(void)
{
    cdev_del(g_cdev);
    unregister_chrdev_region(g_dev, 1);

    printk(KERN_INFO "Goodbye...\n");
}

static int generic_open(struct inode *inodep, struct file *filp)
{
    printk(KERN_INFO "Pipe device opened!..\n");

    return 0;
}

static int generic_release(struct inode *inodep, struct file *filp)
{
    printk(KERN_INFO "Pipe device released!..\n");

    return 0;
}

static ssize_t generic_read(struct file *filp, char *buf, size_t size, loff_t *off)
{
    size_t len;
    ssize_t result;

    if (down_interruptible(&g_sem))
        return -ERESTARTSYS;

    while (g_count == 0) {
        up(&g_sem);
        if (wait_event_interruptible(g_wqread, g_count > 0))
            return -ERESTARTSYS;
        if (down_interruptible(&g_sem))
            return -ERESTARTSYS;
    }

    size = MIN(size, g_count);

    if (g_head >= g_tail)
        len = MIN(size, PIPE_SIZE - g_head);
    else
        len = size;
    
    if (copy_to_user(buf, g_pipebuf + g_head, len) != 0) {
        result = -EFAULT;
        goto EXIT;
    }

    if (size > len)
        if (copy_to_user(buf + len, g_pipebuf, size - len) != 0) {
            result = -EFAULT;
            goto EXIT;
        }

    g_head = (g_head + size ) % PIPE_SIZE;
    g_count -= size;

    result = size;
    
    wake_up_all(&g_wqwrite);
EXIT:
    up(&g_sem);

    return result;
}

static ssize_t generic_write(struct file *filp, const char *buf, size_t size, loff_t *off)
{
    size_t len;
    ssize_t result;

    if (down_interruptible(&g_sem))
        return -ERESTARTSYS;

    while (PIPE_SIZE - g_count < size) {
        up(&g_sem);
        if (wait_event_interruptible(g_wqwrite, PIPE_SIZE - g_count >= size)) 
            return -ERESTARTSYS;
                    
        if (down_interruptible(&g_sem))
            return -ERESTARTSYS;
    } 

    if (g_tail >= g_head)
        len = MIN(size, PIPE_SIZE - g_tail);
    else
        len = size;

    if (copy_from_user(g_pipebuf + g_tail, buf, len) != 0) {
        result = -EFAULT;
        goto EXIT;
    }
    
    if (size > len)
        if (copy_from_user(g_pipebuf, buf + len, size - len) != 0) {
            result = -EFAULT;
            goto EXIT;
        }

    g_tail = (g_tail + size ) % PIPE_SIZE;
    g_count += size;

    result = size;

    wake_up_all(&g_wqread);

EXIT:
    up(&g_sem);

    return result;
}

module_init(generic_init);
module_exit(generic_exit);

obj-m += $(file).o

all: 
	make -C /lib/modules/$(shell uname -r)/build M=${PWD} modules
clean:
	make -C /lib/modules/$(shell uname -r)/build M=${PWD} clean

/* pipeproc1.c */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <fcntl.h>
#include <unistd.h>

#define PIPE_SIZE     4096

void exit_sys(const char *msg);

int main(void)    
{
    int fd;
    char buf[PIPE_SIZE];
    char *str;
    size_t len;

    if ((fd = open("pipe-driver", O_WRONLY)) == -1) 
        exit_sys("open");

    for (;;) {
        printf("Enter text:");
        fflush(stdout);
        fgets(buf, PIPE_SIZE, stdin);
        if ((str = strchr(buf, '\n')) != NULL)
            *str = '\0';
        if (!strcmp(buf, "quit"))
            break;
        len = strlen(buf);
        if (write(fd, buf, len) == -1) 
            exit_sys("write");

        printf("%lu bytes written...\n", (unsigned long)len);
    }

    close(fd);

    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/* pipeproc2.c */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <fcntl.h>
#include <unistd.h>

#define PIPE_SIZE     4096

void exit_sys(const char *msg);

int main(void)    
{
    int fd;
    char buf[PIPE_SIZE + 1];
    int len;
    ssize_t result;

    if ((fd = open("pipe-driver", O_RDONLY)) == -1) 
        exit_sys("open");

    for (;;) {
        printf("How many bytes to read? ");
        fflush(stdout);
        scanf("%d", &len);
        if (!len)
            break;
        if ((result = read(fd, buf, len)) == -1)
            exit_sys("read");
        buf[result] = '\0';

        printf("%ld bytes read: \"%s\"\n", (long)result, buf);
    }

    close(fd);

    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

#!/bin/bash

module=$1
mode=666

/sbin/insmod ./$module.ko ${@:2} || exit 1
major=$(awk "\$2 == \"$module\" {print \$1}" /proc/devices)
rm -f $module
mknod $module c $major 0
chmod $mode $module

/*--------------------------------------------------------------------------------------------------------------------------
    Aslında wait_event fonksiyonları export edilmiş birkaç fonksiyon çağrılarak yazılmıştır. Dolayısıyla wait_event fonksiyonlarını çağırmak
    yerine programcı daha aşağı seviyeli (zaten wait_event fonksiyonlarının çağırmış olduğu) fonksiyonları çağırabilir. Yani bu işlemi
    daha aşağı seviyede manuel yapabilir. MProsesin manuel olarak wait kuyruğuna alınması prepare_tow_wait ve prepare_to_wait_exclusive isimli fonksiyonlar 
    tarafından yapılmaktadır:

    void prepare_to_wait(struct wait_queue_head *wq_head, struct wait_queue_entry *wq_entry, int state);
    void prepare_to_wait_exclusive(struct wait_queue_head *wq_head, struct wait_queue_entry *wq_entry, int state);

    Bu fonksiyonlardaki state parametreleri TASK_UNINTERRUPTIBLE ya da TASK_INTERRUPTIBLE olabilmektedir. Aslında wait kuyrukları struct wait_queue_entry nesnelerinden
    oluşmaktadır. Dolayısıyla bu fonksiyonlar da aslında wait kuruğunabir wait_queue_enty nesnesi eklemektedir. Yani programcının bunun için yeni bir struct 
    wait_queue_entry nesnesi oluşturması gerekmektedir. prepare_to_wait_exclusive exclusive uyuma için kullanılmaktadır. 

    Bir struct wait_queue_entry nesnesi şöyle oluşturulabilir:

    DEFINE_WAIT(entry)

    Ya da açıkça tanımlanıp init_wait makrosuyle ilkdeğerlenebilir. Örneğin:

    struct wait_queue_entry entry;
    ...
    init_wait(&entry);

    prepare_to_wait ve prepare_to_wait_exclusive fonksiyonları şunları yapmaktadır:

    1) Prosesi run kuyruğundan çıkartıp wait kuyruğuna yerleştirir. (Run kuruğunun organizasyonu ve bu işlemin gerçek ayrıntıları biraz karmaşıktır.)
    2) Prosesin durum bilgisini (task state) state parametresiyşe belirtilen duruma çeker. 
    3) prepareto_wait fonksiyonu kuyruk elemanını eclusive olmaktan çıkartırken, prepare_to_wait_exclusive onu exclusive yapar. 

    Tabii biz prepare_wait ya da prepare_to_wait_event fonksiyonlarını çağırdıktan sonra bir biçimde koşul durumuna bakmalıyız. Eğer koşul sağlanmışsa
    hiç prossi uykuya daldırmadan hemen wait kıuruğundan çıkarmalıyız. Eğer koşul sağlanmamışsa gerçekten artık schedule fonksiyonuyla "proseslearası geçiş"
    yapmalıyız. Biz schedle fonksiyonunu çağırdıktan sonra artık uyandırılana kadar bir daha çizelgelenmeyiz. Başka bir akış bizi uyandırınca
    biz schedule fonksiyonun içinden çıkarak yoluma devam ederiz. (Prosesin bloke olup dondurulması aslında schedule fonksiyonu içerisinde yapılmaktadır. 
    Dolayısıyla proses wake_up fonksiyonlarıyla uyandırıldığında aslında schedule içerisinden akış devam eder ve schedule fonksiyonu geri döner.)

    Yukarıda da belirtildiği eğer koşul sağlanmışsa bu uyuma işleminden vazgeçmek gerekir. Vazgeçme işlemi için finish_wait fonksiyonu çağrılır:

    void finish_wait(struct wait_queue_head *wq_head, struct wait_queue_entry *wq_entry);

    Bu fonksiyon zaten proses wake_up fonksiyonları tarafından wait kuyruğundan çıkartılmışsa çıkartma işlemini yapmamaktadır. Bu durumda manuel 
    uyuma şöyle yapılabilir. 

    DEFINE_WAIT(entry);
    
    prepare_to_wait(&g_wq, &entry, TASK_UNINTERRUPTIBLE);
    if (!condition)
        schedule();
    finish_wait(&entry);

    Tabii eğer INTERRUPTIBLE olarak uyunuyorsa schedule fonksiyonundan çıkıldığında sinyal dolayısıyla da çıkılmış olabilir. Bunu anlamak için 
    signal_pending isimli fonksiyon çağrılır. Bu fonksiyon sıfır dışı bir değerle geri dönmüşse uyandırma işleminin sinyal yoluyla yapıldığı anlaşılır. 
    Bu durumda tabii aygıt sürücü fonksiyonu -ERESTARTSYS ile geri döndürülmelidir.  Örneğin:

    DEFINE_WAIT(entry);
    
    prepare_to_wait(&g_wq, &entry, TASK_INTERRUPTIBLE);
    if (!condition)
        schedule();
    if (signal_pending(current))
        return -ERESTARTSYS;
    finish_wait(&entry);

    wake_up makroları da şunları yapmaktadır:

    1)  Wait kuyruğundaki prosesleri çıkartarak run kuyruğuna yerleştirir.
    2) Prosesin durumunu TASK_RUNNING haline getirir. 

    Aşağıda boru örneğinde manuel uykuya dalma işlemi uygulamıştır.

---------------------------------------------------------------------------------------------------------------------------*/

/* pipe-driver.c */

#include <linux/module.h>
#include <linux/kernel.h>
#include <linux/fs.h>
#include <linux/cdev.h>
#include <linux/uaccess.h>
#include <linux/semaphore.h>
#include <linux/sched/signal.h>

MODULE_LICENSE("GPL");
MODULE_DESCRIPTION("General Character Device Driver");
MODULE_AUTHOR("Kaan Aslan");

#define MIN(a, b)       ((a) < (b) ? (a) : (b))

#define PIPE_SIZE     10

static int generic_open(struct inode *inodep, struct file *filp);
static int generic_release(struct inode *inodep, struct file *filp);
static ssize_t generic_read(struct file *filp, char *buf, size_t size, loff_t *off);
static ssize_t generic_write(struct file *filp, const char *buf, size_t size, loff_t *off);

static dev_t g_dev;
static struct cdev *g_cdev;
static struct file_operations g_file_ops = {
    .owner = THIS_MODULE,
    .open = generic_open,
    .release = generic_release,
    .read = generic_read,
    .write = generic_write,
};

static char g_pipebuf[PIPE_SIZE];
static size_t g_head = 0, g_tail = 0;
static size_t g_count = 0;
static DEFINE_SEMAPHORE(g_sem);
static DECLARE_WAIT_QUEUE_HEAD(g_wqread);
static DECLARE_WAIT_QUEUE_HEAD(g_wqwrite);

static int __init generic_init(void)     
{
    int result;

    if ((result = alloc_chrdev_region(&g_dev, 0, 1, "pipe-driver")) < 0) {
        printk(KERN_INFO "Cannot alloc char driver!...\n");
        return result; 
    }

    if ((g_cdev = cdev_alloc()) == NULL) {
        printk(KERN_INFO "Cannot allocate cdev!..\n");
        return -ENOMEM;
    }

    g_cdev->owner = THIS_MODULE;
    g_cdev->ops = &g_file_ops;
    
    if ((result = cdev_add(g_cdev, g_dev, 1)) != 0) {
        unregister_chrdev_region(g_dev, 1);
        printk(KERN_INFO "Cannot add charecter device driver!...\n");
        return result;
    }
    
    printk(KERN_INFO "Pipe driver initialized with %d:%d device number...\n", MAJOR(g_dev), MINOR(g_dev));

    return 0;
}

static void __exit generic_exit(void)
{
    cdev_del(g_cdev);
    unregister_chrdev_region(g_dev, 1);

    printk(KERN_INFO "Goodbye...\n");
}

static int generic_open(struct inode *inodep, struct file *filp)
{
    printk(KERN_INFO "Pipe device opened!..\n");

    return 0;
}

static int generic_release(struct inode *inodep, struct file *filp)
{
    printk(KERN_INFO "Pipe device released!..\n");

    return 0;
}

static ssize_t generic_read(struct file *filp, char *buf, size_t size, loff_t *off)
{
    size_t len;
    ssize_t result;
    DEFINE_WAIT(entry);

    if (down_interruptible(&g_sem))
        return -ERESTARTSYS;

    while (g_count == 0) {
        up(&g_sem);

        prepare_to_wait(&g_wqread, &entry, TASK_INTERRUPTIBLE);
        if (g_count == 0)
            schedule();
        if (signal_pending(current))
            return -ERESTARTSYS;
        finish_wait(&g_wqread, &entry);
        
        if (down_interruptible(&g_sem))
            return -ERESTARTSYS;
    }

    size = MIN(size, g_count);

    if (g_head >= g_tail)
        len = MIN(size, PIPE_SIZE - g_head);
    else
        len = size;
    
    if (copy_to_user(buf, g_pipebuf + g_head, len) != 0) {
        result = -EFAULT;
        goto EXIT;
    }

    if (size > len)
        if (copy_to_user(buf + len, g_pipebuf, size - len) != 0) {
            result = -EFAULT;
            goto EXIT;
        }

    g_head = (g_head + size ) % PIPE_SIZE;
    g_count -= size;

    result = size;
    
    wake_up_all(&g_wqwrite);
EXIT:
    up(&g_sem);

    return result;
}

static ssize_t generic_write(struct file *filp, const char *buf, size_t size, loff_t *off)
{
    size_t len;
    ssize_t result;
    DEFINE_WAIT(entry);

    if (down_interruptible(&g_sem))
        return -ERESTARTSYS;

    while (PIPE_SIZE - g_count < size) {
        up(&g_sem);

        prepare_to_wait(&g_wqwrite, &entry, TASK_INTERRUPTIBLE);
        if (PIPE_SIZE - g_count < size)
            schedule();
        if (signal_pending(current))
            return -ERESTARTSYS;
        finish_wait(&g_wqwrite, &entry);
            
        if (down_interruptible(&g_sem))
            return -ERESTARTSYS;
    } 

    if (g_tail >= g_head)
        len = MIN(size, PIPE_SIZE - g_tail);
    else
        len = size;

    if (copy_from_user(g_pipebuf + g_tail, buf, len) != 0) {
        result = -EFAULT;
        goto EXIT;
    }
    
    if (size > len)
        if (copy_from_user(g_pipebuf, buf + len, size - len) != 0) {
            result = -EFAULT;
            goto EXIT;
        }

    g_tail = (g_tail + size ) % PIPE_SIZE;
    g_count += size;

    result = size;

    wake_up_all(&g_wqread);

EXIT:
    up(&g_sem);

    return result;
}

module_init(generic_init);
module_exit(generic_exit);

obj-m += $(file).o

all: 
	make -C /lib/modules/$(shell uname -r)/build M=${PWD} modules
clean:
	make -C /lib/modules/$(shell uname -r)/build M=${PWD} clean

/* pipeproc1.c */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <fcntl.h>
#include <unistd.h>

#define PIPE_SIZE     4096

void exit_sys(const char *msg);

int main(void)    
{
    int fd;
    char buf[PIPE_SIZE];
    char *str;
    size_t len;

    if ((fd = open("pipe-driver", O_WRONLY)) == -1) 
        exit_sys("open");

    for (;;) {
        printf("Enter text:");
        fflush(stdout);
        fgets(buf, PIPE_SIZE, stdin);
        if ((str = strchr(buf, '\n')) != NULL)
            *str = '\0';
        if (!strcmp(buf, "quit"))
            break;
        len = strlen(buf);
        if (write(fd, buf, len) == -1) 
            exit_sys("write");

        printf("%lu bytes written...\n", (unsigned long)len);
    }

    close(fd);

    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/* pipeproc2.c */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <fcntl.h>
#include <unistd.h>

#define PIPE_SIZE     4096

void exit_sys(const char *msg);

int main(void)    
{
    int fd;
    char buf[PIPE_SIZE + 1];
    int len;
    ssize_t result;

    if ((fd = open("pipe-driver", O_RDONLY)) == -1) 
        exit_sys("open");

    for (;;) {
        printf("How many bytes to read? ");
        fflush(stdout);
        scanf("%d", &len);
        if (!len)
            break;
        if ((result = read(fd, buf, len)) == -1)
            exit_sys("read");
        buf[result] = '\0';

        printf("%ld bytes read: \"%s\"\n", (long)result, buf);
    }

    close(fd);

    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

#!/bin/bash

module=$1
mode=666

/sbin/insmod ./$module.ko ${@:2} || exit 1
major=$(awk "\$2 == \"$module\" {print \$1}" /proc/devices)
rm -f $module
mknod $module c $major 0
chmod $mode $module

/*--------------------------------------------------------------------------------------------------------------------------
    Aygıt sürücülerdeki okuma ve yazma işlemlerine "nonblocking" desteği verilebilir. open fonksiyonundaki açış modu dosya nesnesini
    belirten struct file yapısının f_flags elemanına kopyalanmaktadır. Dolayısıyla aygıt sürücüyü yazan programcı aygıt sürücünün read 
    ve write fonkisyonlarında aygıtın "nonblocking" modda açılıp açılmadığını şmyle anlayabilir:

    if (filp->f_flags & O_NONBLOCK) {
        /* open fonksiyonunda aygıt O_NONBLOCK bayrağı ile açılmış
    }

    Aşağıdaki örnekte boru işlemine "nonblocking" okuma yazma özellği de eklenmiştir. Anımsanacağı gibi borularda blokesiz okuma işlemi sırasında
    eğer boruda hiçbir bilgi yoksa read fonksiyonu -1 ile geri döner ve errno EAGAIN değeri ile set edilir. Benzer biçimde yazma sırasında da
    eğer boruda yazılmak istenenlerin hepsini alacak kadar yer yoksa write boruya hiçbir şey yazmaz ve -1 değerine geri döner. errno EAGAIN 
    değeri ile set edilir. 

---------------------------------------------------------------------------------------------------------------------------*/

#include <linux/module.h>
#include <linux/kernel.h>
#include <linux/fs.h>
#include <linux/cdev.h>
#include <linux/uaccess.h>
#include <linux/semaphore.h>

MODULE_LICENSE("GPL");
MODULE_DESCRIPTION("General Character Device Driver");
MODULE_AUTHOR("Kaan Aslan");

#define MIN(a, b)       ((a) < (b) ? (a) : (b))

#define PIPE_SIZE     10

static int generic_open(struct inode *inodep, struct file *filp);
static int generic_release(struct inode *inodep, struct file *filp);
static ssize_t generic_read(struct file *filp, char *buf, size_t size, loff_t *off);
static ssize_t generic_write(struct file *filp, const char *buf, size_t size, loff_t *off);

static dev_t g_dev;
static struct cdev *g_cdev;
static struct file_operations g_file_ops = {
    .owner = THIS_MODULE,
    .open = generic_open,
    .release = generic_release,
    .read = generic_read,
    .write = generic_write,
};

static char g_pipebuf[PIPE_SIZE];
static size_t g_head = 0, g_tail = 0;
static size_t g_count = 0;
static DEFINE_SEMAPHORE(g_sem);
static DECLARE_WAIT_QUEUE_HEAD(g_wqread);
static DECLARE_WAIT_QUEUE_HEAD(g_wqwrite);

static int __init generic_init(void)     
{
    int result;

    if ((result = alloc_chrdev_region(&g_dev, 0, 1, "pipe-driver")) < 0) {
        printk(KERN_INFO "Cannot alloc char driver!...\n");
        return result; 
    }

    if ((g_cdev = cdev_alloc()) == NULL) {
        printk(KERN_INFO "Cannot allocate cdev!..\n");
        return -ENOMEM;
    }

    g_cdev->owner = THIS_MODULE;
    g_cdev->ops = &g_file_ops;
    
    if ((result = cdev_add(g_cdev, g_dev, 1)) != 0) {
        unregister_chrdev_region(g_dev, 1);
        printk(KERN_INFO "Cannot add charecter device driver!...\n");
        return result;
    }
    
    printk(KERN_INFO "Pipe driver initialized with %d:%d device number...\n", MAJOR(g_dev), MINOR(g_dev));

    return 0;
}

static void __exit generic_exit(void)
{
    cdev_del(g_cdev);
    unregister_chrdev_region(g_dev, 1);

    printk(KERN_INFO "Goodbye...\n");
}

static int generic_open(struct inode *inodep, struct file *filp)
{
    printk(KERN_INFO "Pipe device opened!..\n");

    return 0;
}

static int generic_release(struct inode *inodep, struct file *filp)
{
    printk(KERN_INFO "Pipe device released!..\n");

    return 0;
}

static ssize_t generic_read(struct file *filp, char *buf, size_t size, loff_t *off)
{
    size_t len;
    ssize_t result;

    if (down_interruptible(&g_sem))
        return -ERESTARTSYS;

    while (g_count == 0) {
        up(&g_sem);

        if (filp->f_flags & O_NONBLOCK)
            return -EAGAIN;

        if (wait_event_interruptible(g_wqread, g_count > 0))
            return -ERESTARTSYS;
        if (down_interruptible(&g_sem))
            return -ERESTARTSYS;
    }

    size = MIN(size, g_count);

    if (g_head >= g_tail)
        len = MIN(size, PIPE_SIZE - g_head);
    else
        len = size;
    
    if (copy_to_user(buf, g_pipebuf + g_head, len) != 0) {
        result = -EFAULT;
        goto EXIT;
    }

    if (size > len)
        if (copy_to_user(buf + len, g_pipebuf, size - len) != 0) {
            result = -EFAULT;
            goto EXIT;
        }

    g_head = (g_head + size) % PIPE_SIZE;
    g_count -= size;

    result = size;
    
    wake_up_all(&g_wqwrite);
EXIT:
    up(&g_sem);

    return result;
}

static ssize_t generic_write(struct file *filp, const char *buf, size_t size, loff_t *off)
{
    size_t len;
    ssize_t result;

    if (down_interruptible(&g_sem))
        return -ERESTARTSYS;

    while (PIPE_SIZE - g_count < size) {
        up(&g_sem);
        
        if (filp->f_flags & O_NONBLOCK)
            return -EAGAIN;
        if (wait_event_interruptible(g_wqwrite, PIPE_SIZE - g_count >= size)) 
            return -ERESTARTSYS;
                    
        if (down_interruptible(&g_sem))
            return -ERESTARTSYS;
    } 

    if (g_tail >= g_head)
        len = MIN(size, PIPE_SIZE - g_tail);
    else
        len = size;

    if (copy_from_user(g_pipebuf + g_tail, buf, len) != 0) {
        result = -EFAULT;
        goto EXIT;
    }
    
    if (size > len)
        if (copy_from_user(g_pipebuf, buf + len, size - len) != 0) {
            result = -EFAULT;
            goto EXIT;
        }

    g_tail = (g_tail + size) % PIPE_SIZE;
    g_count += size;

    result = size;

    wake_up_all(&g_wqread);

EXIT:
    up(&g_sem);

    return result;
}

module_init(generic_init);
module_exit(generic_exit);

obj-m += $(file).o

all: 
	make -C /lib/modules/$(shell uname -r)/build M=${PWD} modules
clean:
	make -C /lib/modules/$(shell uname -r)/build M=${PWD} clean

/* pipeproc1.c */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <errno.h>
#include <fcntl.h>
#include <unistd.h>

#define PIPE_SIZE     4096

void exit_sys(const char *msg);

int main(void)    
{
    int fd;
    char buf[PIPE_SIZE];
    char *str;
    size_t len;

    if ((fd = open("pipe-driver", O_WRONLY|O_NONBLOCK)) == -1) 
        exit_sys("open");

    for (;;) {
        printf("Enter text:");
        fflush(stdout);
        fgets(buf, PIPE_SIZE, stdin);
        if ((str = strchr(buf, '\n')) != NULL)
            *str = '\0';
        if (!strcmp(buf, "quit"))
            break;
        len = strlen(buf);
        if (write(fd, buf, len) == -1) {
            if (errno == EAGAIN) {
                printf("Nonblocking write returns -1 with errno EAGAIN...\n");
                continue;
            }
            else
                exit_sys("write")            ;
        }

        printf("%lu bytes written...\n", (unsigned long)len);
    }

    close(fd);

    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/* pipeproc2.c */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <errno.h>
#include <fcntl.h>
#include <unistd.h>

#define PIPE_SIZE     4096

void exit_sys(const char *msg);

int main(void)    
{
    int fd;
    char buf[PIPE_SIZE + 1];
    int len;
    ssize_t result;

    if ((fd = open("pipe-driver", O_RDONLY|O_NONBLOCK)) == -1) 
        exit_sys("open");

    for (;;) {
        printf("How many bytes to read? ");
        fflush(stdout);
        scanf("%d", &len);
        if (!len)
            break;
        if ((result = read(fd, buf, len)) == -1) {
            if (errno == EAGAIN) {
                printf("Nonblocking read return -1 with errno EAGAIN...\n");
                continue;
            }
            else
                exit_sys("read");
        }
            
        buf[result] = '\0';

        printf("%ld bytes read: \"%s\"\n", (long)result, buf);
    }

    close(fd);

    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

#!/bin/bash

module=$1
mode=666

/sbin/insmod ./$module.ko ${@:2} || exit 1
major=$(awk "\$2 == \"$module\" {print \$1}" /proc/devices)
rm -f $module
mknod $module c $major 0
chmod $mode $module

/*--------------------------------------------------------------------------------------------------------------------------
    32 Bit linux sistemlerinde proseslerin sanal bellek alanları 3GB User, 1GB Kernel olmak üzere 2 bölüme ayrılmıştır. 64 bir Linux
    sistemlerinde ise yalnızca sanal bellek alanının 256 TB'si kullanılmaktadır. 128 TB User alanı için 128 TB Kernel alanı için kullanılmaktadır. 
    Çekirdeğin bulunduğu sayfa tabloları prosesler arası geçişte sabit kalır. Dolayısıyla o andaki proses ne olursa olsun her zaman çekirdek aynı 
    sanal adrestedir. Tabii çekirdek fiziksel RAM'in de istediği yerine erişebilmelidir. Bunn için Linux'ta çekirdeğin sanal bellekte başlangıç yerinden 
    itibaren fiziksel RAM sayfa tablosunda haritalandırılmıştır. Yani örneğin 32 bit Linuz sistemlerinde çekirdek alanı 0xC0000000'dan (3GB) başlar. 
    biz bu sistemlerde kernel moddayken (örneğin aygıt sürücü içerisindeyken 0xC0000000 adresine eriştiğimizde aslında fiziksel RAM'in 0'ıncı adresine erişmiş oluruz.)
    Böylece 32 bit Linux sistemlerinde kernel moddaki kodlar fiziksel RAM'de ptr adresine erişmek istediklerinde aslında erişimi 0xC0000000 + ptr biçiminde yaparlar.
    Ancak 32 bit Linux sistemleri tüm fiziksel RAM'i bu biçimde haritalandırmamaktadır. (Bunun nedeni çekirdeğin kendisinin de sanal bellekte beli bir yer kaplamasıdır.)
    32 Bit Linux sistemleri 0xC0000000'dan itibaren ancak fiziksel RAM'in 896 MB'ını bu biçimde haritalandırabilmektedir. 32 Linux sistemlerinde RAM'in ilk 896 MB'dinr
    "normal memory zone" denilmektedir. 32 bit Linux sistemleri 896 MB'ın yukarısındaki RAM'e sayfat tablosunu değiştirerek biraz daha fazla çabayla eriçmektedir. 
    32 Bit Linux sistemlerinde 896 MB'nin yukarısındaki fiziksel RAM'e "high memory zone" denilmektedir.

    64 Bit Linux sistemlerinde çekirdeğin sanal bellek alanı 128 TB olduğu için bu 128'TB'nin başından itibaren tüm fiziksel RAM haritalandırılmıştır. Dolayısıya 
    64 bit Linux sistemlerinde "normal memory zone" tüm fiziksel RAM'i kapsamaktadır. 64 bit Linuz sistemlerinde "high memory zone" yoktur. 


    Biz kernel modda kod yazarken belli bir fiziksel adrese erişmek istersek onun sanal adresini bulmamız gerekir. Bu işin manuel yapılması yerine bunun için
    __va isimli makro kullanılmaktadır. Biz bu makroya bir fiziksel adres veririz o da bize o fiziksel adrese erişmek için gereken sanal adresi verir. Benzer biçimde
    bir sanal adresin fiziksel RAM karşılığını bulmak için de __pa makrosu kullanılmaktadır. Biz bu makroya sanal adresi veririz o da bize o sanal adresin aslında
    RAM'deki hangi fiziksel adres olduğunu verir. 

    Kernel modda RAM'in her yerine erişebildiğimize ve bu konuda bizi engelleyen hiçbir mekanizmanın olmadığına dikkat ediniz. 

    Linux çekirdeği için RAM temel olarak 3 bölgeye (zone) ayrılmıştır:

    ZONE_DMA
    ZONE_NORMAL
    ZONE_HIGHMEM

ZONE_DMA ilgili sistemde disk ile RAM arasında transfer yapan DMA'nın erişebildiği RAM alanıdır. Bazı sistemlerde DMA tüm fiziksel RAM'in her yerine transfer yapamamaktadır.
ZONE_NORMAL doğrudan çekirdeğin sayfa tablosu yoluyla haritalandırdığı fizilsel bellek bölgesidir. Intel 32 bit Linuz sistemlerinde bu bölge ilk 896 MB'dir. 
ZONE_HIGHMEM ise çekirdeğin doğrudan haritalandıramadığı sayfa tablosu değişimiyle erişebildiği fiziksel RAM alanıdır. 32 Bit Intel Linuz sistemlerinde 896 MB'nin
yukarısındaki fiziksel RAM'dir. 64 bit Intel işlemcilerinde ZONE_NORMAL tüm fiziksel RAM'i kapsar. Bu sistemlerde ZONE_HIGHMEM yoktur. 
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    malloc gibi fonksiyonların uyguladığı klasik tahsisat algoritması "boş alan bağlı listesi" denilen yöntemdir. Bu yöntemde yalnızca 
    boş alanların kayıtları bir bağlı listede tutulur. Dolayısıyla malloc gibi bir fonksiyon bu bağlı listede uygun bir elemanı bulmaktadır. free fonksiyonu da 
    tahsis edilmiş olan alanı bağlı listeye eklemektedir. Ancak bu klasik yöntem çekirdek heap sistemi için çok yavaş kalmaktadır. Bu nedenle çekirdeğin heap sistemi
    için hızlı çalışan tahsisat algoritmaları kullanılmaktadır. BSD ve Linux sistemleri "dilimli tahsis sistemi (slab allocator)" denilen bir algoritmik yöntemi
    kullanmaktadır. 

    İşte eğer her yapı için ayrı ve eşit uzunlukta boş bloklardan oluşan heap kullanılırsa bağlı listede arama işlemi elimine edilebilmektedir. Dielimli tahsisat 
    sistemi çekirdek içerisindeki her veri yapısı için (örneğin task_struct, struct file, struct inode gibi) eşit uzunluklu bloklardan oluşan ayrı bir heap oluşturmaktadır. 
    Çekirdek genel amaçlı (yani kernel tarafından uzunluğunu bilinmeyen) alanlar için dilimli tahsisat heap'leri de oluşturmuştur. Bu genel dilim sistemlerinin blok uzunlukları
    şöyledir: 32, 64, 96, 128, 192, 256 512, 1024, 2048, 4096, 8192, 16384, 32768, 65536, ....

    İşte kmalloc isimli genel amaçlı çekirdektahsisat  fonksiyonu aslında bu dilim sistemlerinin bir tanesinden eşit uzunluklu dilimlerden bize tahsisat yapmaktadır. 
    Örneğin biz kmalloc fonksiyonu ile 100 byte tahsis etmek isteyelim. Aslında kmalloc 128'lik dilimlerin bulunduğu heap'ten bize blok verir. Yani aslında bu durumda
    kmalloc bizim talep ettiğimizden daha büyük bir alanı bize vermektedir. Benzer biçimde kfree fonksiyonu da hangi dilim heap'inden tahsisat yapılmışsa o alanı
    o dilim sistemine iade etmektedir. Dilimli tahsisat sisteminden amaç sabit zamanlı dinamik tahsisat işleminni yapılmasıdır. Yani bu tahsisat sistemi ile bellek
    tahsis edilirken bir döngü kullanılmamaktadır. 

    void *kmalloc (size_t size, int flags);
    void kfree (const void *objp);

    kmalloc fonksiyonunun birinci parametresi tahsis edilecek byte sayısını belirtir. İkincisi parametresi tahsis edilecek alan ve biçim hakkında 
    bayrakları içermektedir. Bu ikinci parametre çeşitli sembolik sabitlerden oluştrulmaktadır. Burada önemli birkaç byrak şunlardır:

    GFP_KERNEL: Kernel alanı içerisinde normal tahsisat. En sık bu bayrak kullanılmaktadır. Burada RAM doluysa swap işlemi yapılabilir. Bu işlem sırasında
    akış kernel modda wait kuruklarında bekletilebilir. Tahsisat ZONE_NORMAL alanından yapılmaktadır. 

    GFP_NOWAIT: GFP_KERNEL gibidir. Ancak hazırda bellek yoksa proses uykuya yatılmaz. Fonksiyon başarısız olur. 

    GFP_HIGHUSER: 32 bit sistemlerde ZONE_HIHMEM alanından tahssat yapar. 

    GFP_DMA: İlgili sistemde DMA'nın erişebildiği RAM alanından tahsisat yapar. 

    kfree fonksiyonun parametresi daha önce tahsis edilmiş olan bloğun adresidir. 

    Aşağıdaki örnekte borunun kullandığı değişkenler bir yapı içerisinde toplanmış ve o yapı türünden kmalloc ile dinamik tahsisat yapılmıştır. 
    Aygıt sürücü yok edilirken alan kfree fonksiyonuyla boşaltılmıştır.

---------------------------------------------------------------------------------------------------------------------------*/

#include <linux/module.h>
#include <linux/kernel.h>
#include <linux/fs.h>
#include <linux/cdev.h>
#include <linux/uaccess.h>
#include <linux/semaphore.h>
#include <linux/slab.h>

MODULE_LICENSE("GPL");
MODULE_DESCRIPTION("General Character Device Driver");
MODULE_AUTHOR("Kaan Aslan");

#define MIN(a, b)       ((a) < (b) ? (a) : (b))

#define PIPE_SIZE     10

static int generic_open(struct inode *inodep, struct file *filp);
static int generic_release(struct inode *inodep, struct file *filp);
static ssize_t generic_read(struct file *filp, char *buf, size_t size, loff_t *off);
static ssize_t generic_write(struct file *filp, const char *buf, size_t size, loff_t *off);

static dev_t g_dev;
static struct file_operations g_file_ops = {
    .owner = THIS_MODULE,
    .open = generic_open,
    .release = generic_release,
    .read = generic_read,
    .write = generic_write,
};

struct pipe_dev {
    char pipebuf[PIPE_SIZE];
    size_t head;
    size_t tail;
    size_t count;
    struct semaphore sem;
    wait_queue_head_t wqread;
    wait_queue_head_t wqwrite;
    struct cdev cdev;
};

static struct pipe_dev *g_pdev;

static int __init generic_init(void)     
{
    int result;

    if ((result = alloc_chrdev_region(&g_dev, 0, 1, "pipe-driver")) < 0) {
        printk(KERN_INFO "Cannot alloc char driver!...\n");
        return result; 
    }

    if ((g_pdev = (struct pipe_dev *)kmalloc(sizeof(struct pipe_dev), GFP_KERNEL)) == NULL) {
        printk(KERN_INFO "Cannot allocate memory!...\n");
        return -ENOMEM;
    }

    g_pdev->head = g_pdev->tail = g_pdev->count = 0;
    init_waitqueue_head(&g_pdev->wqread);
    init_waitqueue_head(&g_pdev->wqwrite);
    sema_init(&g_pdev->sem, 1);

    cdev_init(&g_pdev->cdev, &g_file_ops);
    
    if ((result = cdev_add(&g_pdev->cdev, g_dev, 1)) != 0) {
        kfree(g_pdev);
        unregister_chrdev_region(g_dev, 1);
        printk(KERN_INFO "Cannot add charecter device driver!...\n");
        return result;
    }
    
    printk(KERN_INFO "Pipe driver initialized with %d:%d device number...\n", MAJOR(g_dev), MINOR(g_dev));

    return 0;
}

static void __exit generic_exit(void)
{
    cdev_del(&g_pdev->cdev);
    unregister_chrdev_region(g_dev, 1);
    kfree(g_pdev);

    printk(KERN_INFO "Goodbye...\n");
}

static int generic_open(struct inode *inodep, struct file *filp)
{
    printk(KERN_INFO "Pipe device opened!..\n");

    return 0;
}

static int generic_release(struct inode *inodep, struct file *filp)
{
    printk(KERN_INFO "Pipe device released!..\n");

    return 0;
}

static ssize_t generic_read(struct file *filp, char *buf, size_t size, loff_t *off)
{
    size_t len;
    ssize_t result;
    
    if (down_interruptible(&g_pdev->sem))
        return -ERESTARTSYS;

    while (g_pdev->count == 0) {
        up(&g_pdev->sem);

        if (filp->f_flags & O_NONBLOCK)
            return -EAGAIN;

        if (wait_event_interruptible(g_pdev->wqread, g_pdev->count > 0))
            return -ERESTARTSYS;
        if (down_interruptible(&g_pdev->sem))
            return -ERESTARTSYS;
    }

    size = MIN(size, g_pdev->count);

    if (g_pdev->head >= g_pdev->tail)
        len = MIN(size, PIPE_SIZE - g_pdev->head);
    else
        len = size;
    
    if (copy_to_user(buf, g_pdev->pipebuf + g_pdev->head, len) != 0) {
        result = -EFAULT;
        goto EXIT;
    }

    if (size > len)
        if (copy_to_user(buf + len, g_pdev->pipebuf, size - len) != 0) {
            result = -EFAULT;
            goto EXIT;
        }

    g_pdev->head = (g_pdev->head + size) % PIPE_SIZE;
    g_pdev->count -= size;

    result = size;
    
    wake_up_all(&g_pdev->wqwrite);
EXIT:
    up(&g_pdev->sem);

    return result;
}

static ssize_t generic_write(struct file *filp, const char *buf, size_t size, loff_t *off)
{
    size_t len;
    ssize_t result;
    
    if (down_interruptible(&g_pdev->sem))
        return -ERESTARTSYS;

    while (PIPE_SIZE - g_pdev->count < size) {
        up(&g_pdev->sem);
        
        if (filp->f_flags & O_NONBLOCK)
            return -EAGAIN;
        if (wait_event_interruptible(g_pdev->wqwrite, PIPE_SIZE - g_pdev->count >= size)) 
            return -ERESTARTSYS;
                    
        if (down_interruptible(&g_pdev->sem))
            return -ERESTARTSYS;
    } 

    if (g_pdev->tail >= g_pdev->head)
        len = MIN(size, PIPE_SIZE - g_pdev->tail);
    else
        len = size;

    if (copy_from_user(g_pdev->pipebuf + g_pdev->tail, buf, len) != 0) {
        result = -EFAULT;
        goto EXIT;
    }
    
    if (size > len)
        if (copy_from_user(g_pdev->pipebuf, buf + len, size - len) != 0) {
            result = -EFAULT;
            goto EXIT;
        }

    g_pdev->tail = (g_pdev->tail + size) % PIPE_SIZE;
    g_pdev->count += size;

    result = size;

    wake_up_all(&g_pdev->wqread);

EXIT:
    up(&g_pdev->sem);

    return result;
}

module_init(generic_init);
module_exit(generic_exit);

obj-m += $(file).o

all: 
	make -C /lib/modules/$(shell uname -r)/build M=${PWD} modules
clean:
	make -C /lib/modules/$(shell uname -r)/build M=${PWD} clean

/* pipeproc1.c */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <errno.h>
#include <fcntl.h>
#include <unistd.h>

#define PIPE_SIZE     4096

void exit_sys(const char *msg);

int main(void)    
{
    int fd;
    char buf[PIPE_SIZE];
    char *str;
    size_t len;

    if ((fd = open("pipe-driver", O_WRONLY)) == -1) 
        exit_sys("open");

    for (;;) {
        printf("Enter text:");
        fflush(stdout);
        fgets(buf, PIPE_SIZE, stdin);
        if ((str = strchr(buf, '\n')) != NULL)
            *str = '\0';
        if (!strcmp(buf, "quit"))
            break;
        len = strlen(buf);
        if (write(fd, buf, len) == -1) {
            if (errno == EAGAIN) {
                printf("Nonblocking write returns -1 with errno EAGAIN...\n");
                continue;
            }
            else
                exit_sys("write")            ;
        }

        printf("%lu bytes written...\n", (unsigned long)len);
    }

    close(fd);

    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/* pipeproc1.c */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <errno.h>
#include <fcntl.h>
#include <unistd.h>

#define PIPE_SIZE     4096

void exit_sys(const char *msg);

int main(void)    
{
    int fd;
    char buf[PIPE_SIZE];
    char *str;
    size_t len;

    if ((fd = open("pipe-driver", O_WRONLY)) == -1) 
        exit_sys("open");

    for (;;) {
        printf("Enter text:");
        fflush(stdout);
        fgets(buf, PIPE_SIZE, stdin);
        if ((str = strchr(buf, '\n')) != NULL)
            *str = '\0';
        if (!strcmp(buf, "quit"))
            break;
        len = strlen(buf);
        if (write(fd, buf, len) == -1) {
            if (errno == EAGAIN) {
                printf("Nonblocking write returns -1 with errno EAGAIN...\n");
                continue;
            }
            else
                exit_sys("write")            ;
        }

        printf("%lu bytes written...\n", (unsigned long)len);
    }

    close(fd);

    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/* pipeproc1.c */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <errno.h>
#include <fcntl.h>
#include <unistd.h>

#define PIPE_SIZE     4096

void exit_sys(const char *msg);

int main(void)    
{
    int fd;
    char buf[PIPE_SIZE];
    char *str;
    size_t len;

    if ((fd = open("pipe-driver", O_WRONLY)) == -1) 
        exit_sys("open");

    for (;;) {
        printf("Enter text:");
        fflush(stdout);
        fgets(buf, PIPE_SIZE, stdin);
        if ((str = strchr(buf, '\n')) != NULL)
            *str = '\0';
        if (!strcmp(buf, "quit"))
            break;
        len = strlen(buf);
        if (write(fd, buf, len) == -1) {
            if (errno == EAGAIN) {
                printf("Nonblocking write returns -1 with errno EAGAIN...\n");
                continue;
            }
            else
                exit_sys("write")            ;
        }

        printf("%lu bytes written...\n", (unsigned long)len);
    }

    close(fd);

    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

#!/bin/bash

module=$1
mode=666

/sbin/insmod ./$module.ko ${@:2} || exit 1
major=$(awk "\$2 == \"$module\" {print \$1}" /proc/devices)
rm -f $module
mknod $module c $major 0
chmod $mode $module

/*--------------------------------------------------------------------------------------------------------------------------
    Aygıt sürücünün majör ve minör numaraları ne anlam ifade etmektedir? Majör numara aygıt sürücünün türünü belirtir. 
    Minör numara ise aynı türden aygıt sürücülerin farklı örneklerini (instance'larını) belirtmektedir. Örneğin biz yukarıdaki pipe-driver
    aygıt sürücümüzün tek bir boruyu değil on farklı boruyu idare etmesini isteyebiliriz. Bu durumda aygıt sürücümüzün bir tane majör numarası, 10 tane minör numarası
    olacaktır. Aygıt sürücülerin majör numaraları aynı ise bunların kodları aynıdır. O aynı kod birden fazla aygıt sürücü için işlev görmektedir. 

    Birden fazla minör numara kullanan aygıt sürücüleri yazarken dikkatli olmak gerekir. Çünkü tek bir kod birden fazla aynı türden bağımsız aygıtı
    idare edecektir. 

    Birden fazla minör numara üzerinde çalışacak aygıt sürücüleri tipik olarak şöyle yazılmaktadır:

    1) Programcının majör ve minör numaraları tahsis etmesi gerekir. Majör numara alloc_chrdev_region fonksiyonuyla dinamik olarak belirlenebilmektedir.
    Bu fonksiyon aynı zamanda belli bir minör numaradan başlayarak n tane minör numarayı da tahsis edebilmektedir. Örneğin:

    if ((result = alloc_chrdev_region(&g_dev, 0, 10, "pipe-driver")) < 0) {
        printk(KERN_INFO "Cannot alloc char driver!...\n");
        return result; 
    }

    Burada 0'ıncı minör numaradan 10 tane minör numara için aygıt tahsisatı yapılmıştır. 

    2) Her aygıt bir yapıyla temsil edilmeli ve N tane aygıt için N elemanlı bir yapı dizisi oluşturulmalıdır. Yukarıdaki örnekte 
    olduğu gibi struct cdev nesnesi bu yapının içinde bulundurulmalıdır. 

    3) N tane minör numaralı aygıt için cdev_add fonksiyonuyla aygıtlar çekirdeğe eklenmelidir. 

    4) Aygıt sürücünün open fonksiyonunda programcının inode yapısının i_cdev elemanından hareketle cdev nesnesinin içinde bulunduğu yapı nesnesinin
    başlangıç adresini container_of makrosuyla bulmalı ve yapı adresini struct file yapısının private_data elemanına yerleştirmelidir. Böylece aygıt sürücünün
    read ve write fonksiyonları ilgili minör numaraya ilişkin aygıtın yapı nesnesine erişebilecektir. 

    5) Aygıt sürücüün read ve write fonksiyonları yazılırç 

    6) release (close) işleminde yapılacak birtakım son işlemler varsa yapılır. 

    7) Aygıt sürücünün exit fonksiyonunda yine tüm minör numaralar için cdev_del ve unregister_chrdev_region işlemi yapılır.  

    Tabii birden fazla minör numara için çalışacak aygıt sürücülerin birden fazla aygıt dosdyası yaratması gerekir. Bu da onları yüklemek
    için kullandığımız load scriptinde değişiklik yapmayı gerekitrmektedir. O halde biz N tane minör numaraya ilişkin aygıt dosyası yaratacak biçimde 
    yeni bir "loadmulti" isimli script yazalım:

    #!/bin/bash

    module=$2
    mode=666

    /sbin/insmod ./${module}.ko ${@:3} || exit 1
    major=$(awk "\$2 == \"$module\" {print \$1}" /proc/devices)

    for ((i = 0; i < $1; ++i))
    do
        rm -f ${module}$i
        mknod ${module}$i c $major $i    
        chmod $mode ${module}$i    
    done

    Aşağıdaki örnekte boru aygıt sürücüsü MAX_DEVICE kadar minör numaraı (yani farklı boruları) destekleyecek duruma getirilmiştir. 

---------------------------------------------------------------------------------------------------------------------------*/

#include <linux/module.h>
#include <linux/kernel.h>
#include <linux/fs.h>
#include <linux/cdev.h>
#include <linux/uaccess.h>
#include <linux/semaphore.h>

MODULE_LICENSE("GPL");
MODULE_DESCRIPTION("General Character Device Driver");
MODULE_AUTHOR("Kaan Aslan");

#define MIN(a, b)       ((a) < (b) ? (a) : (b))

#define MAX_DEVICE      10
#define PIPE_SIZE       4096

static int generic_open(struct inode *inodep, struct file *filp);
static int generic_release(struct inode *inodep, struct file *filp);
static ssize_t generic_read(struct file *filp, char *buf, size_t size, loff_t *off);
static ssize_t generic_write(struct file *filp, const char *buf, size_t size, loff_t *off);

static dev_t g_dev;
static struct file_operations g_file_ops = {
    .owner = THIS_MODULE,
    .open = generic_open,
    .release = generic_release,
    .read = generic_read,
    .write = generic_write,
};

struct pipe_dev {
    char pipebuf[PIPE_SIZE];
    size_t head;
    size_t tail;
    size_t count;
    struct semaphore sem;
    wait_queue_head_t wqread;
    wait_queue_head_t wqwrite;
    struct cdev cdev;
};

static struct pipe_dev g_devs[MAX_DEVICE];

static int __init generic_init(void)     
{
    int result;
    int i, k;
    dev_t dev;

    if ((result = alloc_chrdev_region(&g_dev, 0, MAX_DEVICE, "pipe-driver")) < 0) {
        printk(KERN_INFO "Cannot alloc char driver!...\n");
        return result; 
    }

    for (i = 0; i < MAX_DEVICE; ++i) {
        g_devs[i].head = g_devs[i].tail = g_devs[i].count = 0;
        init_waitqueue_head(&g_devs[i].wqread);
        init_waitqueue_head(&g_devs[i].wqwrite);
        sema_init(&g_devs[i].sem, 1);

        cdev_init(&g_devs[i].cdev, &g_file_ops);
        dev = MKDEV(MAJOR(g_dev), i);
        if ((result = cdev_add(&g_devs[i].cdev, dev, 1)) != 0) {
            for (k = 0; k < i; ++k) 
                cdev_del(&g_devs[i].cdev);
            unregister_chrdev_region(g_dev, MAX_DEVICE);
            return result;
        }

    }
    
    printk(KERN_INFO "Pipe driver initialized with %d:%d + %d device numbers...\n", MAJOR(g_dev), MINOR(g_dev), MAX_DEVICE);

    return 0;
}

static void __exit generic_exit(void)
{
    int i;

    for (i = 0; i < MAX_DEVICE; ++i)
        cdev_del(&g_devs[i].cdev);

    unregister_chrdev_region(g_dev, MAX_DEVICE);
    
    printk(KERN_INFO "Goodbye...\n");
}

static int generic_open(struct inode *inodep, struct file *filp)
{
    struct pipe_dev *pdev = container_of(inodep->i_cdev, struct pipe_dev, cdev);

    filp->private_data = pdev;

    printk(KERN_INFO "Pipe device opened!..\n");

    return 0;
}

static int generic_release(struct inode *inodep, struct file *filp)
{
    printk(KERN_INFO "Pipe device released!..\n");

    return 0;
}

static ssize_t generic_read(struct file *filp, char *buf, size_t size, loff_t *off)
{
    size_t len;
    ssize_t result;
    struct pipe_dev *pdev = (struct pipe_dev *)filp->private_data;
    
    if (down_interruptible(&pdev->sem))
        return -ERESTARTSYS;

    while (pdev->count == 0) {
        up(&pdev->sem);

        if (filp->f_flags & O_NONBLOCK)
            return -EAGAIN;

        if (wait_event_interruptible(pdev->wqread, pdev->count > 0))
            return -ERESTARTSYS;
        if (down_interruptible(&pdev->sem))
            return -ERESTARTSYS;
    }

    size = MIN(size, pdev->count);

    if (pdev->head >= pdev->tail)
        len = MIN(size, PIPE_SIZE - pdev->head);
    else
        len = size;
    
    if (copy_to_user(buf, pdev->pipebuf + pdev->head, len) != 0) {
        result = -EFAULT;
        goto EXIT;
    }

    if (size > len)
        if (copy_to_user(buf + len, pdev->pipebuf, size - len) != 0) {
            result = -EFAULT;
            goto EXIT;
        }

    pdev->head = (pdev->head + size) % PIPE_SIZE;
    pdev->count -= size;

    result = size;
    
    wake_up_all(&pdev->wqwrite);
EXIT:
    up(&pdev->sem);

    return result;
}

static ssize_t generic_write(struct file *filp, const char *buf, size_t size, loff_t *off)
{
    size_t len;
    ssize_t result;
    struct pipe_dev *pdev = (struct pipe_dev *)filp->private_data;
    
    if (down_interruptible(&pdev->sem))
        return -ERESTARTSYS;

    while (PIPE_SIZE - pdev->count < size) {
        up(&pdev->sem);
        
        if (filp->f_flags & O_NONBLOCK)
            return -EAGAIN;

        if (wait_event_interruptible(pdev->wqwrite, PIPE_SIZE - pdev->count >= size)) 
            return -ERESTARTSYS;
                    
        if (down_interruptible(&pdev->sem))
            return -ERESTARTSYS;
    } 

    if (pdev->tail >= pdev->head)
        len = MIN(size, PIPE_SIZE - pdev->tail);
    else
        len = size;

    if (copy_from_user(pdev->pipebuf + pdev->tail, buf, len) != 0) {
        result = -EFAULT;
        goto EXIT;
    }
    
    if (size > len)
        if (copy_from_user(pdev->pipebuf, buf + len, size - len) != 0) {
            result = -EFAULT;
            goto EXIT;
        }

    pdev->tail = (pdev->tail + size) % PIPE_SIZE;
    pdev->count += size;

    result = size;

    wake_up_all(&pdev->wqread);

EXIT:
    up(&pdev->sem);

    return result;
}

module_init(generic_init);
module_exit(generic_exit);

obj-m += $(file).o

all: 
	make -C /lib/modules/$(shell uname -r)/build M=${PWD} modules
clean:
	make -C /lib/modules/$(shell uname -r)/build M=${PWD} clean

/* pipeproc1.c */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <errno.h>
#include <fcntl.h>
#include <unistd.h>

#define PIPE_SIZE     4096

void exit_sys(const char *msg);

int main(int argc, char *argv[])    
{
    int fd;
    char buf[PIPE_SIZE];
    char *str;
    size_t len;

    if (argc != 2) {
        fprintf(stderr, "wrong number of arguments!..\n");
        exit(EXIT_FAILURE);
    }

    if ((fd = open(argv[1], O_WRONLY)) == -1) 
        exit_sys("open");

    for (;;) {
        printf("Enter text:");
        fflush(stdout);
        fgets(buf, PIPE_SIZE, stdin);
        if ((str = strchr(buf, '\n')) != NULL)
            *str = '\0';
        if (!strcmp(buf, "quit"))
            break;
        len = strlen(buf);
        if (write(fd, buf, len) == -1) {
            if (errno == EAGAIN) {
                printf("Nonblocking write returns -1 with errno EAGAIN...\n");
                continue;
            }
            else
                exit_sys("write")            ;
        }

        printf("%lu bytes written...\n", (unsigned long)len);
    }

    close(fd);

    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/* pipeproc2.c */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <errno.h>
#include <fcntl.h>
#include <unistd.h>

#define PIPE_SIZE     4096

void exit_sys(const char *msg);

int main(int argc, char *argv[])    
{
    int fd;
    char buf[PIPE_SIZE + 1];
    int len;
    ssize_t result;

    if (argc != 2) {
        fprintf(stderr, "wrong number of arguments!..\n");
        exit(EXIT_FAILURE);
    }

    if ((fd = open(argv[1], O_RDONLY)) == -1) 
        exit_sys("open");

    for (;;) {
        printf("How many bytes to read? ");
        fflush(stdout);
        scanf("%d", &len);
        if (!len)
            break;
        if ((result = read(fd, buf, len)) == -1) {
            if (errno == EAGAIN) {
                printf("Nonblocking read return -1 with errno EAGAIN...\n");
                continue;
            }
            else
                exit_sys("read");
        }
            
        buf[result] = '\0';

        printf("%ld bytes read: \"%s\"\n", (long)result, buf);
    }

    close(fd);

    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

#!/bin/bash

module=$2
mode=666

/sbin/insmod ./${module}.ko ${@:3} || exit 1
major=$(awk "\$2 == \"$module\" {print \$1}" /proc/devices)

for ((i = 0; i < $1; ++i))
do
    rm -f ${module}$i
    mknod ${module}$i c $major $i    
    chmod $mode ${module}$i    
done

/*--------------------------------------------------------------------------------------------------------------------------
    Birden fazla minör numara kullanılırken bu minör numaralar için yapı nesneleri kmalloc ile de dinamik bir biçimde tahsis edilebilir. 
    Bu durum tipik olarak modül parametresi ile aygıt sayısının dışarıdan verildiği uygulamalarda gerekebilmektedir. 

    Aşağıda örnekte aygıt sürücünün kaç minör numarayı destekleyeceği aygıt sürücü yüklenirken ndevice modül parametresiyle belirlenmektedir. 
    Eğer bu parametre girilmezse default değer 10 olarak alınmaktadır. Bu aygıt sürücüyü şöyle yükleyebilirsiniz:

    ./loadmulti 2 pipe-driver ndevice=2
---------------------------------------------------------------------------------------------------------------------------*/

#include <linux/module.h>
#include <linux/kernel.h>
#include <linux/fs.h>
#include <linux/cdev.h>
#include <linux/uaccess.h>
#include <linux/semaphore.h>
#include <linux/slab.h>

MODULE_LICENSE("GPL");
MODULE_DESCRIPTION("General Character Device Driver");
MODULE_AUTHOR("Kaan Aslan");

#define MIN(a, b)       ((a) < (b) ? (a) : (b))

#define DEF_NDEVICE      10
#define PIPE_SIZE           4096

static int generic_open(struct inode *inodep, struct file *filp);
static int generic_release(struct inode *inodep, struct file *filp);
static ssize_t generic_read(struct file *filp, char *buf, size_t size, loff_t *off);
static ssize_t generic_write(struct file *filp, const char *buf, size_t size, loff_t *off);

static dev_t g_dev;
static struct file_operations g_file_ops = {
    .owner = THIS_MODULE,
    .open = generic_open,
    .release = generic_release,
    .read = generic_read,
    .write = generic_write,
};

struct pipe_dev {
    char pipebuf[PIPE_SIZE];
    size_t head;
    size_t tail;
    size_t count;
    struct semaphore sem;
    wait_queue_head_t wqread;
    wait_queue_head_t wqwrite;
    struct cdev cdev;
};

static int ndevice = DEF_NDEVICE;
static struct pipe_dev *g_devs;

module_param(ndevice, int, S_IRUSR|S_IWUSR|S_IRGRP|S_IROTH);

static int __init generic_init(void)     
{
    int result;
    int i, k;
    dev_t dev;

    if ((result = alloc_chrdev_region(&g_dev, 0, ndevice, "pipe-driver")) < 0) {
        printk(KERN_INFO "Cannot alloc char driver!...\n");
        return result; 
    }

    if ((g_devs = (struct pipe_dev *)kmalloc(sizeof(struct pipe_dev) * ndevice, GFP_KERNEL)) == NULL) {
        unregister_chrdev_region(g_dev, ndevice);
        printk(KERN_INFO "Cannot allocate memory!..\n");
        return -ENOMEM;
    }

    for (i = 0; i < ndevice; ++i) {
        g_devs[i].head = g_devs[i].tail = g_devs[i].count = 0;
        init_waitqueue_head(&g_devs[i].wqread);
        init_waitqueue_head(&g_devs[i].wqwrite);
        sema_init(&g_devs[i].sem, 1);

        cdev_init(&g_devs[i].cdev, &g_file_ops);
        dev = MKDEV(MAJOR(g_dev), i);
        if ((result = cdev_add(&g_devs[i].cdev, dev, 1)) != 0) {
            for (k = 0; k < i; ++k) 
                cdev_del(&g_devs[i].cdev);
            unregister_chrdev_region(g_dev, ndevice);
            kfree(g_devs);
            return result;
        }
    }
    
    printk(KERN_INFO "Pipe driver initialized with %d:%d + %d device numbers...\n", MAJOR(g_dev), MINOR(g_dev), ndevice);

    return 0;
}

static void __exit generic_exit(void)
{
    int i;

    for (i = 0; i < ndevice; ++i)
        cdev_del(&g_devs[i].cdev);

    unregister_chrdev_region(g_dev, ndevice);
    kfree(g_devs);
    
    printk(KERN_INFO "Goodbye...\n");
}

static int generic_open(struct inode *inodep, struct file *filp)
{
    struct pipe_dev *pdev = container_of(inodep->i_cdev, struct pipe_dev, cdev);

    filp->private_data = pdev;

    printk(KERN_INFO "Pipe device opened!..\n");

    return 0;
}

static int generic_release(struct inode *inodep, struct file *filp)
{
    printk(KERN_INFO "Pipe device released!..\n");

    return 0;
}

static ssize_t generic_read(struct file *filp, char *buf, size_t size, loff_t *off)
{
    size_t len;
    ssize_t result;
    struct pipe_dev *pdev = (struct pipe_dev *)filp->private_data;
    
    if (down_interruptible(&pdev->sem))
        return -ERESTARTSYS;

    while (pdev->count == 0) {
        up(&pdev->sem);

        if (filp->f_flags & O_NONBLOCK)
            return -EAGAIN;

        if (wait_event_interruptible(pdev->wqread, pdev->count > 0))
            return -ERESTARTSYS;
        if (down_interruptible(&pdev->sem))
            return -ERESTARTSYS;
    }

    size = MIN(size, pdev->count);

    if (pdev->head >= pdev->tail)
        len = MIN(size, PIPE_SIZE - pdev->head);
    else
        len = size;
    
    if (copy_to_user(buf, pdev->pipebuf + pdev->head, len) != 0) {
        result = -EFAULT;
        goto EXIT;
    }

    if (size > len)
        if (copy_to_user(buf + len, pdev->pipebuf, size - len) != 0) {
            result = -EFAULT;
            goto EXIT;
        }

    pdev->head = (pdev->head + size) % PIPE_SIZE;
    pdev->count -= size;

    result = size;
    
    wake_up_all(&pdev->wqwrite);
EXIT:
    up(&pdev->sem);

    return result;
}

static ssize_t generic_write(struct file *filp, const char *buf, size_t size, loff_t *off)
{
    size_t len;
    ssize_t result;
    struct pipe_dev *pdev = (struct pipe_dev *)filp->private_data;
    
    if (down_interruptible(&pdev->sem))
        return -ERESTARTSYS;

    while (PIPE_SIZE - pdev->count < size) {
        up(&pdev->sem);
        
        if (filp->f_flags & O_NONBLOCK)
            return -EAGAIN;

        if (wait_event_interruptible(pdev->wqwrite, PIPE_SIZE - pdev->count >= size)) 
            return -ERESTARTSYS;
                    
        if (down_interruptible(&pdev->sem))
            return -ERESTARTSYS;
    } 

    if (pdev->tail >= pdev->head)
        len = MIN(size, PIPE_SIZE - pdev->tail);
    else
        len = size;

    if (copy_from_user(pdev->pipebuf + pdev->tail, buf, len) != 0) {
        result = -EFAULT;
        goto EXIT;
    }
    
    if (size > len)
        if (copy_from_user(pdev->pipebuf, buf + len, size - len) != 0) {
            result = -EFAULT;
            goto EXIT;
        }

    pdev->tail = (pdev->tail + size) % PIPE_SIZE;
    pdev->count += size;

    result = size;

    wake_up_all(&pdev->wqread);

EXIT:
    up(&pdev->sem);

    return result;
}

module_init(generic_init);
module_exit(generic_exit);

obj-m += $(file).o

all: 
	make -C /lib/modules/$(shell uname -r)/build M=${PWD} modules
clean:
	make -C /lib/modules/$(shell uname -r)/build M=${PWD} clean

/* pipeproc1.c */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <errno.h>
#include <fcntl.h>
#include <unistd.h>

#define PIPE_SIZE     4096

void exit_sys(const char *msg);

int main(int argc, char *argv[])    
{
    int fd;
    char buf[PIPE_SIZE];
    char *str;
    size_t len;

    if (argc != 2) {
        fprintf(stderr, "wrong number of arguments!..\n");
        exit(EXIT_FAILURE);
    }

    if ((fd = open(argv[1], O_WRONLY)) == -1) 
        exit_sys("open");

    for (;;) {
        printf("Enter text:");
        fflush(stdout);
        fgets(buf, PIPE_SIZE, stdin);
        if ((str = strchr(buf, '\n')) != NULL)
            *str = '\0';
        if (!strcmp(buf, "quit"))
            break;
        len = strlen(buf);
        if (write(fd, buf, len) == -1) {
            if (errno == EAGAIN) {
                printf("Nonblocking write returns -1 with errno EAGAIN...\n");
                continue;
            }
            else
                exit_sys("write")            ;
        }

        printf("%lu bytes written...\n", (unsigned long)len);
    }

    close(fd);

    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/* pipeproc2.c */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <errno.h>
#include <fcntl.h>
#include <unistd.h>

#define PIPE_SIZE     4096

void exit_sys(const char *msg);

int main(int argc, char *argv[])    
{
    int fd;
    char buf[PIPE_SIZE + 1];
    int len;
    ssize_t result;

    if (argc != 2) {
        fprintf(stderr, "wrong number of arguments!..\n");
        exit(EXIT_FAILURE);
    }

    if ((fd = open(argv[1], O_RDONLY)) == -1) 
        exit_sys("open");

    for (;;) {
        printf("How many bytes to read? ");
        fflush(stdout);
        scanf("%d", &len);
        if (!len)
            break;
        if ((result = read(fd, buf, len)) == -1) {
            if (errno == EAGAIN) {
                printf("Nonblocking read return -1 with errno EAGAIN...\n");
                continue;
            }
            else
                exit_sys("read");
        }
            
        buf[result] = '\0';

        printf("%ld bytes read: \"%s\"\n", (long)result, buf);
    }

    close(fd);

    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

#!/bin/bash

module=$2
mode=666

/sbin/insmod ./${module}.ko ${@:3} || exit 1
major=$(awk "\$2 == \"$module\" {print \$1}" /proc/devices)

for ((i = 0; i < $1; ++i))
do
    rm -f ${module}$i
    mknod ${module}$i c $major $i    
    chmod $mode ${module}$i    
done

/*--------------------------------------------------------------------------------------------------------------------------
    Aygıt sürücüden bilgi okumak için read fonksiyonun, aygıt sürücüye bilgi göndermek için ise write fonksiyonun kullanıldığını gördük.
    Ancak bazen aygıt sürücüye başka komutların da gönderilmesi gerekebilir. Benzer biçimde aygıt sürücüden bazı bilgilerin de okunması 
    gerekebilir. BAzen hiç bilgi okumadan ve gönderilmeden aygıt sürüye bazı şeylerin yaptırılması da istenebilir. Bu işlemler
    read ve write fonksiyonlarıyla yapılmaya çalışılırsa bu read ve write fonksiyonlarının işlevleri farklı olduğu için bu işlem hiç kolay olmaz.

    Örneğin yukarıdaki pipe-driver örneğinde biz aygıt sürücüden kullandığı FIFO alanın uzunluğunu isteyebiliriz. Ya da bu alanın boyutunu
    değiştirmek isteyebiliriz. Bu işlemleri read ve write fonksiyonlarıyla yapmaya çalışsak aygıt sürücümüz sanki boruyu temsil eden kuyruktan
    okuma yazma yapmak istediğimizi sanacaktır. Tabii bu tür amaçlarla read ve write fonksiyonları yine kullanılabilir. Ancak bu tür tasarımların
    gerçekleştirimleri çok zor olabilmektedir. 

    İşte aygıt sürücüye komut gönderip ondan bilgi almak için genel amaçlı ioctl siminde özel bir fonksiyon bulundurulmuştur. Linux sistemlerinde
    ioctl POSIX fonksiyonu sys_ioctl sistem fonksiyonunu çağırmaktadır. ioctl fonksiyonunun parametrik yapısı şöyledir:

    int ioctl(int fd, unsigned long request, ...);

    Fonksiyonun birinci parametresi aygıt sürücüye ilişkin dosya betimleyicisini belirtir. İkinci parametre ileride açıklanacak olan komut kodudur. 
    Programcı aygıt sürücüsünde farklı komut kodları (yani numaralar) oluşturur. Sonra bu numaraları switch içerisine sokarak hangi numara istekte
    bulunulmuşsa onu yapar. ioctl fonksiyonu iki parametreyle ya da üç parametreyle kullanılmaktadır. Eğer bir veri transferi söz konusu değilse 
    ioctl iki argümanla çağrılır. Ancak bir veri transferi söz konusu ise ioctl üç argümanla çağrılmalıdır. Bu durumda üçüncü argüman transfer adres olmalıdır. 
    Tabii aslında bu üçüncü parametrenin veri transferi ile ilgili olması dlayısıyla bir adres belirtmesi zorunlu değildir. 

    Fonksiyon başarı durumunda 0 değerine, başarıszlık durumunda -1 değerine geri döner. errno uygun biçimde set edilmektedir. 

    User moddan bir program aygıt sürücü için ioctl fonksiyonunu çağırdığında proses use r moddan kernel moda geçer ve aygıt sürücüdeki 
    file_operations yapısının unlocked_ioctl elemanında belirtilen fonksiyon çağrılır. Bu fonksiyonun parametrik yapısı şöyle olmalıdır:

    long generic_ioctl(struct file *filp, unsigned int cmd, unsigned long arg);

    Bu fonksiyon başarı durumunda 0 değerine başarısızlık durumunda negatif hata koduna geri dönmelidir. Fakat bazen programcı doğrudan iletilecek değeri 
    geri dönüş değeri biçiminde oluşturabilir. Bu durumda geri dönüş değeri pozitif değer olabilir.


    ioctl işleminde fonksiyonun ikinci parametresi olan kontrol kodu belli bir biçime göre (konvansiyona göre) oluşturulmaktadır. Bu biçime göre
    kontrol kodu toplam 32 bitlik dört parçadan oluşturulmalıdır. Bu dört parça istenirse _IOC isimli makro ile birleştirilebilir. Bu makro şu 
    parametrelere sahiptir:

    _IOC(dir, type, nr, size)

    dir (direction): Bu iki bitlik bir alandır. Buradaki kullanılacak sembolik sabitler _IOC_NONE, _IOC_READ, _IOC_WRITE
    ve _IOC_READ|_IOC_WRITE  biçimindedir. ([30, 31] bitleri)

    type: Bu aygıt sürücüyü yazan programcı tarafından uydurulması gereken 1 byte'lık bir değeridir. Buna "magic number" da denilmektedir. ([8, 15] bitleri)

    nr: Programcı tarafından kontrol koduna verilen sıra numarasıdır. Genellikle aygıt sürücü programcıları 0'dan başlayarak her koda bir numara
    vermektedir. ([0, 7] bitleri)

    size: Bu alan kaç byte'lık bir transferin yapılacağını belirtmektedir. ([16:29] bitleri)

    Örnek bir komut numarası şöyle oluşturulabilir:

    #define PIPE_MAGIC              'x'
    #define IOC_PIPE_GETBUFSIZE     _IOC(_IOC_READ, PIPE_MAGIC, 0, 4)

    Aslında _IOC makrosundan daha kolay kullanılabilen aşağıdaki makrolar da oluşturulmuştur:

    #ifndef __KERNEL__
        #define _IOC_TYPECHECK(t) (sizeof(t))
    #endif

    #define _IO(type,nr)		_IOC(_IOC_NONE,(type),(nr),0)
    #define _IOR(type,nr,size)	_IOC(_IOC_READ,(type),(nr),(_IOC_TYPECHECK(size)))
    #define _IOW(type,nr,size)	_IOC(_IOC_WRITE,(type),(nr),(_IOC_TYPECHECK(size)))
    #define _IOWR(type,nr,size)	_IOC(_IOC_READ|_IOC_WRITE,(type),(nr),(_IOC_TYPECHECK(size)))

    Bu makrolarda artık uzunluk byte olarak değil tür olarak belirtilmelidir. Makrolar bu türleri sizof operatörüne kendisi sokmaktadır. Görüldüğü 
    gibi _IO makrosu veri transferinin söz konusu olmadığı durumda kullanılır. _IOR aygıt sürücüden okuma yapıldığı durumda, _IOW aygıt sürücüye yazma
    yapıldığı durumda, _IOWR ise aygıt sürücüden hem okuma hem de yazma yapıldığı durumlarda kullanılmaktadır. Örneğin:

    #define PIPE_MAGIC              'x'
    #define IOC_PIPE_GETBUFSIZE     _IOR(PIPE_MAGIC, 0, int)

    ioctl için kontrol kodları hem aygıt sürücünün içerisinden hem de user moddan kullanılacağına göre user moddan kullanım için bir başlık dosyasının 
    oluşturulması uygun olur. Örneğin:
    
    #ifndef PIPE_DRIVER_H_
    #define PIPE_DRIVER_H_

    #include <sys/ioctl.h>

    #define PIPE_MAGIC              'x'
    #define IOC_PIPE_GETBUFSIZE     _IOR(PIPE_MAGIC, 0, int)

    #endif

    Aygıt sürücüdeki ioctl fonksiyonunu yazarken iki noktaya dikkat etmek gerekir:

    1) ioctl fonksiyonun üçüncü parametresi unsigned long türden olmasına karşın aslında genellikle user mod programcısı buraya bir nesnesin
    adresini geçirmektedir. Dolayısıyla bu transfer adresine aktarım gerekmektedir. Bunun için copy_to_user, copy_from_use, put_user, get_user
    gibi adresin geçerliliğini sorguladıktan sonr tranfers yapan fonksiyonlar kullanılabilir.

    2) User mod programcısının olmayan bir komut kodu girmesi durumunda ioctl fonksiyonu -ENOTTY değeri ile geri döndürülmelidir. Bu tuhaf hata kodu
    tarihsel bir durumdan kaynaklanmaktadır. Bu hata kodu için user modda "Inappropriate ioctl for device" biçiminde bir hata yazısı elde edilmektedir.

    Aşağıdaki örnekte  boru sürücüne bir IOCTL komutu gönderilmektedir. Bu komut borunun uzunluğunu user mod programa vermektedir. 

---------------------------------------------------------------------------------------------------------------------------*/

#include <linux/module.h>
#include <linux/kernel.h>
#include <linux/fs.h>
#include <linux/cdev.h>
#include <linux/uaccess.h>
#include <linux/semaphore.h>
#include <linux/slab.h>

MODULE_LICENSE("GPL");
MODULE_DESCRIPTION("General Character Device Driver");
MODULE_AUTHOR("Kaan Aslan");

#define MIN(a, b)       ((a) < (b) ? (a) : (b))

#define DEF_NDEVICE      10
#define PIPE_SIZE        4096

#define PIPE_MAGIC              'x'
#define IOC_PIPE_GETBUFSIZE     _IOR(PIPE_MAGIC, 0, int)

static int generic_open(struct inode *inodep, struct file *filp);
static int generic_release(struct inode *inodep, struct file *filp);
static ssize_t generic_read(struct file *filp, char *buf, size_t size, loff_t *off);
static ssize_t generic_write(struct file *filp, const char *buf, size_t size, loff_t *off);
long generic_ioctl(struct file *filp, unsigned int cmd, unsigned long arg);


static dev_t g_dev;
static struct file_operations g_file_ops = {
    .owner = THIS_MODULE,
    .open = generic_open,
    .release = generic_release,
    .read = generic_read,
    .write = generic_write,
    .unlocked_ioctl = generic_ioctl,
};

struct pipe_dev {
    char pipebuf[PIPE_SIZE];
    size_t head;
    size_t tail;
    size_t count;
    struct semaphore sem;
    wait_queue_head_t wqread;
    wait_queue_head_t wqwrite;
    struct cdev cdev;
};

static int ndevice = DEF_NDEVICE;
static struct pipe_dev *g_devs;

module_param(ndevice, int, S_IRUSR|S_IWUSR|S_IRGRP|S_IROTH);

static int __init generic_init(void)     
{
    int result;
    int i, k;
    dev_t dev;

    if ((result = alloc_chrdev_region(&g_dev, 0, ndevice, "pipe-driver")) < 0) {
        printk(KERN_INFO "Cannot alloc char driver!...\n");
        return result; 
    }

    if ((g_devs = (struct pipe_dev *)kmalloc(sizeof(struct pipe_dev) * ndevice, GFP_KERNEL)) == NULL) {
        unregister_chrdev_region(g_dev, ndevice);
        printk(KERN_INFO "Cannot allocate memory!..\n");
        return -ENOMEM;
    }

    for (i = 0; i < ndevice; ++i) {
        g_devs[i].head = g_devs[i].tail = g_devs[i].count = 0;
        init_waitqueue_head(&g_devs[i].wqread);
        init_waitqueue_head(&g_devs[i].wqwrite);
        sema_init(&g_devs[i].sem, 1);

        cdev_init(&g_devs[i].cdev, &g_file_ops);
        dev = MKDEV(MAJOR(g_dev), i);
        if ((result = cdev_add(&g_devs[i].cdev, dev, 1)) != 0) {
            for (k = 0; k < i; ++k) 
                cdev_del(&g_devs[i].cdev);
            unregister_chrdev_region(g_dev, ndevice);
            kfree(g_devs);
            return result;
        }
    }
    
    printk(KERN_INFO "Pipe driver initialized with %d:%d + %d device numbers...\n", MAJOR(g_dev), MINOR(g_dev), ndevice);

    return 0;
}

static void __exit generic_exit(void)
{
    int i;

    for (i = 0; i < ndevice; ++i)
        cdev_del(&g_devs[i].cdev);

    unregister_chrdev_region(g_dev, ndevice);
    kfree(g_devs);
    
    printk(KERN_INFO "Goodbye...\n");
}

static int generic_open(struct inode *inodep, struct file *filp)
{
    struct pipe_dev *pdev = container_of(inodep->i_cdev, struct pipe_dev, cdev);

    filp->private_data = pdev;

    printk(KERN_INFO "Pipe device opened!..\n");

    return 0;
}

static int generic_release(struct inode *inodep, struct file *filp)
{
    printk(KERN_INFO "Pipe device released!..\n");

    return 0;
}

static ssize_t generic_read(struct file *filp, char *buf, size_t size, loff_t *off)
{
    size_t len;
    ssize_t result;
    struct pipe_dev *pdev = (struct pipe_dev *)filp->private_data;
    
    if (down_interruptible(&pdev->sem))
        return -ERESTARTSYS;

    while (pdev->count == 0) {
        up(&pdev->sem);

        if (filp->f_flags & O_NONBLOCK)
            return -EAGAIN;

        if (wait_event_interruptible(pdev->wqread, pdev->count > 0))
            return -ERESTARTSYS;
        if (down_interruptible(&pdev->sem))
            return -ERESTARTSYS;
    }

    size = MIN(size, pdev->count);

    if (pdev->head >= pdev->tail)
        len = MIN(size, PIPE_SIZE - pdev->head);
    else
        len = size;
    
    if (copy_to_user(buf, pdev->pipebuf + pdev->head, len) != 0) {
        result = -EFAULT;
        goto EXIT;
    }

    if (size > len)
        if (copy_to_user(buf + len, pdev->pipebuf, size - len) != 0) {
            result = -EFAULT;
            goto EXIT;
        }

    pdev->head = (pdev->head + size) % PIPE_SIZE;
    pdev->count -= size;

    result = size;
    
    wake_up_all(&pdev->wqwrite);
EXIT:
    up(&pdev->sem);

    return result;
}

static ssize_t generic_write(struct file *filp, const char *buf, size_t size, loff_t *off)
{
    size_t len;
    ssize_t result;
    struct pipe_dev *pdev = (struct pipe_dev *)filp->private_data;
    
    if (down_interruptible(&pdev->sem))
        return -ERESTARTSYS;

    while (PIPE_SIZE - pdev->count < size) {
        up(&pdev->sem);
        
        if (filp->f_flags & O_NONBLOCK)
            return -EAGAIN;

        if (wait_event_interruptible(pdev->wqwrite, PIPE_SIZE - pdev->count >= size)) 
            return -ERESTARTSYS;
                    
        if (down_interruptible(&pdev->sem))
            return -ERESTARTSYS;
    } 

    if (pdev->tail >= pdev->head)
        len = MIN(size, PIPE_SIZE - pdev->tail);
    else
        len = size;

    if (copy_from_user(pdev->pipebuf + pdev->tail, buf, len) != 0) {
        result = -EFAULT;
        goto EXIT;
    }
    
    if (size > len)
        if (copy_from_user(pdev->pipebuf, buf + len, size - len) != 0) {
            result = -EFAULT;
            goto EXIT;
        }

    pdev->tail = (pdev->tail + size) % PIPE_SIZE;
    pdev->count += size;

    result = size;

    wake_up_all(&pdev->wqread);

EXIT:
    up(&pdev->sem);

    return result;
}

long generic_ioctl(struct file *filp, unsigned int cmd, unsigned long arg)
{
    int *pi = (int *)arg;

    switch (cmd) {
        case IOC_PIPE_GETBUFSIZE:
            if (put_user(PIPE_BUF, pi) != 0)
                return -EFAULT;
            break;
        default:
            return -ENOTTY;       
    }

    return 0;
}

module_init(generic_init);
module_exit(generic_exit);

obj-m += $(file).o

all: 
	make -C /lib/modules/$(shell uname -r)/build M=${PWD} modules
clean:
	make -C /lib/modules/$(shell uname -r)/build M=${PWD} clean

/* pipe-driver.h */

#ifndef PIPE_DRIVER_H_
#define PIPE_DRIVER_H_

#include <sys/ioctl.h>

/* Driver Control Codes */

#define PIPE_MAGIC      'x'
#define IOC_PIPE_GETBUFSIZE     _IOR(PIPE_MAGIC, 0, int)

#endif

/* pipeproc-test.c */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <fcntl.h>
#include <unistd.h>
#include <sys/ioctl.h>
#include "pipe-driver.h"

#define PIPE_SIZE     4096

void exit_sys(const char *msg);

int main(void)    
{
    int fd;
    int size;

    if ((fd = open("pipe-driver0", O_WRONLY)) == -1) 
        exit_sys("open");

    if (ioctl(fd, IOC_PIPE_GETBUFSIZE, &size) == -1)
        exit_sys("ioctl");

    printf("Pipe buffer size: %d\n", size);

    close(fd);

    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

#!/bin/bash

module=$2
mode=666

/sbin/insmod ./${module}.ko ${@:3} || exit 1
major=$(awk "\$2 == \"$module\" {print \$1}" /proc/devices)

for ((i = 0; i < $1; ++i))
do
    rm -f ${module}$i
    mknod ${module}$i c $major $i    
    chmod $mode ${module}$i    
done

/*--------------------------------------------------------------------------------------------------------------------------
    Aşağıdaki örnekte birkaç ioctl kodu işlenmiştir. Borudan atmadan byte okumak için özel peek'li ioctl fonksiyonları yazılmıştır. 
    ioctl fonksiyonun tek bir parametresi olabilir. Birden fazla parametre bir yapı biçiminde fonksiyona verilmelidir. Yukarıda da belirtildiği gibi
    ioctl fonksiyonun geri dönüş değeri başarıszlık durumunda negatif hata kodu, başarı durumunda tipik olarak 0'dır. Ancak başarı durumunda 0 olması
    mutlak bir zorunluluk değildir. Programcılar işlerini uzatmamak için başarı durumunda anlamlı başka bir değerle de geri dönebilmektedir. 
    Aşağıda örnekte peek için iki ayrı ioctl fonksiyonu bulundurulmuştur. IOC_PIPE_PEEK fonksiyonunda okunan byte miktarı ioctl fonksiyonun
    geri dönüş değeri biçimide bize verilmektedir. Halbuki IOC_PIPE_PEEK_BIDIREC fonksiyonunda okunan byte miktarı yapının yeniden size elemanına 
    yerleştirilmiştir. 
---------------------------------------------------------------------------------------------------------------------------*/

/* pipe-driver.c */

#include <linux/module.h>
#include <linux/kernel.h>
#include <linux/fs.h>
#include <linux/cdev.h>
#include <linux/uaccess.h>
#include <linux/semaphore.h>
#include <linux/slab.h>
#include <linux/atomic.h>

MODULE_LICENSE("GPL");
MODULE_DESCRIPTION("General Character Device Driver");
MODULE_AUTHOR("Kaan Aslan");

#define MIN(a, b)       ((a) < (b) ? (a) : (b))

#define DEF_NDEVICE      10
#define PIPE_SIZE        4096

#define PIPE_MAGIC              'x'
#define IOC_PIPE_GETBUFSIZE     _IOR(PIPE_MAGIC, 0, int)
#define IOC_PIPE_GETMAXDEVICE   _IOR(PIPE_MAGIC, 1, int)
#define IOC_PIPE_GETOPENCOUNT   _IOR(PIPE_MAGIC, 2, int)
#define IOC_PIPE_PEEK           _IOC(_IOC_READ|_IOC_WRITE, PIPE_MAGIC, 3, 4096)
#define IOC_PIPE_PEEK_BIDIREC   _IOC(_IOC_READ|_IOC_WRITE, PIPE_MAGIC, 4, 4096)

static int generic_open(struct inode *inodep, struct file *filp);
static int generic_release(struct inode *inodep, struct file *filp);
static ssize_t generic_read(struct file *filp, char *buf, size_t size, loff_t *off);
static ssize_t generic_write(struct file *filp, const char *buf, size_t size, loff_t *off);
static long generic_ioctl(struct file *filp, unsigned int cmd, unsigned long arg);

static dev_t g_dev;
static struct file_operations g_file_ops = {
    .owner = THIS_MODULE,
    .open = generic_open,
    .release = generic_release,
    .read = generic_read,
    .write = generic_write,
    .unlocked_ioctl = generic_ioctl,
};

struct pipe_dev {
    char pipebuf[PIPE_SIZE];
    size_t head;
    size_t tail;
    size_t count;
    struct semaphore sem;
    wait_queue_head_t wqread;
    wait_queue_head_t wqwrite;
    struct cdev cdev;
};

struct pipe_peek {
    int size;
    char *buf;
};

static int read_peek(struct file *filp, const struct pipe_peek *pp);

static int ndevice = DEF_NDEVICE;
static struct pipe_dev *g_devs;
static atomic_t g_nopens;

module_param(ndevice, int, S_IRUSR|S_IWUSR|S_IRGRP|S_IROTH);

static int __init generic_init(void)     
{
    int result;
    int i, k;
    dev_t dev;

    if ((result = alloc_chrdev_region(&g_dev, 0, ndevice, "pipe-driver")) < 0) {
        printk(KERN_INFO "Cannot alloc char driver!...\n");
        return result; 
    }

    if ((g_devs = (struct pipe_dev *)kmalloc(sizeof(struct pipe_dev) * ndevice, GFP_KERNEL)) == NULL) {
        unregister_chrdev_region(g_dev, ndevice);
        printk(KERN_INFO "Cannot allocate memory!..\n");
        return -ENOMEM;
    }

    for (i = 0; i < ndevice; ++i) {
        g_devs[i].head = g_devs[i].tail = g_devs[i].count = 0;
        init_waitqueue_head(&g_devs[i].wqread);
        init_waitqueue_head(&g_devs[i].wqwrite);
        sema_init(&g_devs[i].sem, 1);

        cdev_init(&g_devs[i].cdev, &g_file_ops);
        dev = MKDEV(MAJOR(g_dev), i);
        if ((result = cdev_add(&g_devs[i].cdev, dev, 1)) != 0) {
            for (k = 0; k < i; ++k) 
                cdev_del(&g_devs[i].cdev);
            unregister_chrdev_region(g_dev, ndevice);
            kfree(g_devs);
            return result;
        }
    }
    
    printk(KERN_INFO "Pipe driver initialized with %d:%d + %d device numbers...\n", MAJOR(g_dev), MINOR(g_dev), ndevice);

    return 0;
}

static void __exit generic_exit(void)
{
    int i;

    for (i = 0; i < ndevice; ++i)
        cdev_del(&g_devs[i].cdev);

    unregister_chrdev_region(g_dev, ndevice);
    kfree(g_devs);
    
    printk(KERN_INFO "Goodbye...\n");
}

static int generic_open(struct inode *inodep, struct file *filp)
{
    struct pipe_dev *pdev = container_of(inodep->i_cdev, struct pipe_dev, cdev);

    filp->private_data = pdev;
    atomic_inc(&g_nopens);

    printk(KERN_INFO "Pipe device opened!..\n");

    return 0;
}

static int generic_release(struct inode *inodep, struct file *filp)
{
    printk(KERN_INFO "Pipe device released!..\n");

    atomic_dec(&g_nopens);

    return 0;
}

static ssize_t generic_read(struct file *filp, char *buf, size_t size, loff_t *off)
{
    size_t len;
    ssize_t result;
    struct pipe_dev *pdev = (struct pipe_dev *)filp->private_data;
    
    if (down_interruptible(&pdev->sem))
        return -ERESTARTSYS;

    while (pdev->count == 0) {
        up(&pdev->sem);

        if (filp->f_flags & O_NONBLOCK)
            return -EAGAIN;

        if (wait_event_interruptible(pdev->wqread, pdev->count > 0))
            return -ERESTARTSYS;
        if (down_interruptible(&pdev->sem))
            return -ERESTARTSYS;
    }

    size = MIN(size, pdev->count);

    if (pdev->head >= pdev->tail)
        len = MIN(size, PIPE_SIZE - pdev->head);
    else
        len = size;
    
    if (copy_to_user(buf, pdev->pipebuf + pdev->head, len) != 0) {
        result = -EFAULT;
        goto EXIT;
    }

    if (size > len)
        if (copy_to_user(buf + len, pdev->pipebuf, size - len) != 0) {
            result = -EFAULT;
            goto EXIT;
        }

    pdev->head = (pdev->head + size) % PIPE_SIZE;
    pdev->count -= size;

    result = size;
    
    wake_up_all(&pdev->wqwrite);
EXIT:
    up(&pdev->sem);

    return result;
}

static ssize_t generic_write(struct file *filp, const char *buf, size_t size, loff_t *off)
{
    size_t len;
    ssize_t result;
    struct pipe_dev *pdev = (struct pipe_dev *)filp->private_data;
    
    if (down_interruptible(&pdev->sem))
        return -ERESTARTSYS;

    while (PIPE_SIZE - pdev->count < size) {
        up(&pdev->sem);
        
        if (filp->f_flags & O_NONBLOCK)
            return -EAGAIN;

        if (wait_event_interruptible(pdev->wqwrite, PIPE_SIZE - pdev->count >= size)) 
            return -ERESTARTSYS;
                    
        if (down_interruptible(&pdev->sem))
            return -ERESTARTSYS;
    } 

    if (pdev->tail >= pdev->head)
        len = MIN(size, PIPE_SIZE - pdev->tail);
    else
        len = size;

    if (copy_from_user(pdev->pipebuf + pdev->tail, buf, len) != 0) {
        result = -EFAULT;
        goto EXIT;
    }
    
    if (size > len)
        if (copy_from_user(pdev->pipebuf, buf + len, size - len) != 0) {
            result = -EFAULT;
            goto EXIT;
        }

    pdev->tail = (pdev->tail + size) % PIPE_SIZE;
    pdev->count += size;

    result = size;

    wake_up_all(&pdev->wqread);

EXIT:
    up(&pdev->sem);

    return result;
}

static long generic_ioctl(struct file *filp, unsigned int cmd, unsigned long arg)
{
    int *pi;
    struct pipe_peek peek;
    int result;

    switch (cmd) {
        case IOC_PIPE_GETBUFSIZE:
             pi = (int *)arg;
            if (put_user(PIPE_BUF, pi) != 0)
                return -EFAULT;
            break;
        case IOC_PIPE_GETMAXDEVICE:
            pi = (int *)arg;
            if (put_user(ndevice, pi) != 0)
                return -EFAULT;
            break;
        case IOC_PIPE_GETOPENCOUNT:
            pi = (int *)arg;
            if (put_user(atomic_read(&g_nopens), pi) != 0)
                return -EFAULT;
            break;

        case IOC_PIPE_PEEK:
            if (copy_from_user(&peek, (void *)arg, sizeof(struct pipe_peek)) != 0)
                return -EFAULT;
            return read_peek(filp, &peek);

         case IOC_PIPE_PEEK_BIDIREC:
            if (copy_from_user(&peek, (void *)arg, sizeof(struct pipe_peek)) != 0)
                return -EFAULT;
            result = read_peek(filp, &peek);
            peek.size = result;
            if (copy_to_user((void *)arg, &peek, sizeof(struct pipe_peek)) != 0)
                return -EFAULT;
            break;

        default:
            return -ENOTTY;       
    }

    return 0;
}

static int read_peek(struct file *filp, const struct pipe_peek *pp)
{
    size_t len;
    ssize_t result;
    ssize_t size;
    struct pipe_dev *pdev = (struct pipe_dev *)filp->private_data;
    
    if (down_interruptible(&pdev->sem))
        return -ERESTARTSYS;

    if (pdev->count == 0) {
        result = 0;
        goto EXIT;
    }

    size = MIN(pp->size, pdev->count);

    if (pdev->head >= pdev->tail)
        len = MIN(size, PIPE_SIZE - pdev->head);
    else
        len = size;
    
    if (copy_to_user(pp->buf, pdev->pipebuf + pdev->head, len) != 0) {
        result = -EFAULT;
        goto EXIT;
    }

    if (size > len)
        if (copy_to_user(pp->buf + len, pdev->pipebuf, size - len) != 0) {
            result = -EFAULT;
            goto EXIT;
        }

    result = size;
EXIT:
    up(&pdev->sem);

    return result;
}

module_init(generic_init);
module_exit(generic_exit);

obj-m += $(file).o

all: 
	make -C /lib/modules/$(shell uname -r)/build M=${PWD} modules
clean:
	make -C /lib/modules/$(shell uname -r)/build M=${PWD} clean

/* pipe-driver.h */

#ifndef PIPE_DRIVER_H_
#define PIPE_DRIVER_H_

#include <sys/ioctl.h>

/* Type declarations */

struct pipe_peek {
    int size;
    char *buf;
};

/* Driver Control Codes */

#define PIPE_MAGIC      'x'
#define IOC_PIPE_GETBUFSIZE     _IOR(PIPE_MAGIC, 0, int)
#define IOC_PIPE_GETMAXDEVICE   _IOR(PIPE_MAGIC, 1, int)
#define IOC_PIPE_GETOPENCOUNT   _IOR(PIPE_MAGIC, 2, int)
#define IOC_PIPE_PEEK           _IOC(_IOC_READ|_IOC_WRITE, PIPE_MAGIC, 3, 4096)
#define IOC_PIPE_PEEK_BIDIREC   _IOC(_IOC_READ|_IOC_WRITE, PIPE_MAGIC, 4, 4096) 

#endif

/* pipeproc-test.c */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <fcntl.h>
#include <unistd.h>
#include <sys/ioctl.h>
#include "pipe-driver.h"

#define PIPE_SIZE     4096

void exit_sys(const char *msg);

int main(void)    
{
    int fd;
    int size, ndevice, nopens;
    struct pipe_peek pp;
    char buf[11];
    int result;

    if ((fd = open("pipe-driver0", O_WRONLY)) == -1) 
        exit_sys("open");

    if (ioctl(fd, IOC_PIPE_GETBUFSIZE, &size) == -1)
        exit_sys("ioctl");

    printf("Pipe buffer size: %d\n", size);

    if (ioctl(fd, IOC_PIPE_GETMAXDEVICE, &ndevice) == -1)
        exit_sys("ioctl");

    printf("Maximum device count: %d\n", ndevice);

    if (ioctl(fd, IOC_PIPE_GETOPENCOUNT, &nopens) == -1)
        exit_sys("ioctl");

    printf("Number of opens: %d\n", nopens);

    pp.size = 10;
    pp.buf = buf;

    if ((result = ioctl(fd, IOC_PIPE_PEEK, &pp)) == -1)
        exit_sys("ioctl");
    
    buf[result] = '\0';
    printf("%d bytes poke: %s\n", result, buf);

    if ((result = ioctl(fd, IOC_PIPE_PEEK, &pp)) == -1)
        exit_sys("ioctl");
    
    buf[pp.size] = '\0';
    printf("%d bytes poke: %s\n", pp.size, buf);

    getchar();

    close(fd);

    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

#!/bin/bash

module=$2
mode=666

/sbin/insmod ./${module}.ko ${@:3} || exit 1
major=$(awk "\$2 == \"$module\" {print \$1}" /proc/devices)

for ((i = 0; i < $1; ++i))
do
    rm -f ${module}$i
    mknod ${module}$i c $major $i    
    chmo

/*--------------------------------------------------------------------------------------------------------------------------
    Anımsanacağı gibi proc dosya sistemi disk tabanlı bir dosya sistemi değildir. Kernel çalışması sırasında dış dümyaya bilgi vermek
    için bazen de davranışını dış dünyadan gelen verilerle değiştirebilmek için proc dosya sistemini kullanmaktadır. Daha sonra proc
    gibi sys isimli dosya sistemi de Linuc sistemlerine eklenmiştir. 

    proc dosya sistemi aslında yalnızca kernel tarafından değil aygıt sürücüler tarafından da kullanılabilmektedir. Ancak bu dosya sisteminin
    içerisinde user moddan dosyalar ya da dizinler yaratılamamktadır. 

    proc dosya sisteminin kernel ve aygıt sürücüler tarafından kullanılmasına ilişkin fonksiyonlar birkaç kere değişik kernel versiyonlarında değiştirilmiştir.
    Dolayısıyla eski kernel'larda çalışan kodlar yeni kernel'larda derlenmeyecektir. Biz burada en yeni fonksiyonları ele alacağız. 

    proc dosya sisteminde bir dosya yaratabilmek için proc_create isimli fonksiyon kullanılmaktadır. 

    struct proc_dir_entry *proc_create(const char *name, umode_t mode, struct proc_dir_entry *parent, const struct proc_ops *proc_ops);

    Fonksiyonun birinci parametresi yaratılacak dosyanın ismini belirtir. İkinci parametresi erişim haklarını belrtmektedir. Bu parametre 0 geçilirse 
    default erişim hakları kullanılır. Üçüncü parametre dosyanın hangi dizinde yaratılacağını belirtmektedir. Bu parametre NULL geçilirse dosya ana
    /proc dizini içerisinde yaratılır. Son parametre proc dosya sistemindeki ilgi dosyaya yazma ve okuma yapldığında çalıştırılacak fonksiyonları belirtir. 
    Aslında birkaç sene önceki kernel'larda bu fonksiyonun son parametresi struct proc_ops biçiminde değil, struct file_operations biçimindeydi. Dolayısıyla
    kernelınızda hangi fonksiyonun bulunuyor olduğuna dikkat ediniz. Kursun yapıdlığı sistemde bu fonksiyonun son parametresi struct file_operations biçimindedir. 
    Fonksiyon başarı durumunda yaratılan dosyanın bilgilerini içeren proc_dir_entry türünden bir yapı nesnesinin adresiyle, başarıszlık durumunda NULL adresle
    geri dönmektedir. 

    proc dosya sisteminde yaratılan dosya remove_proc_entry fonksiyonuyla silinebilmektedir. 
    
    void remove_proc_entry(const char *name, struct proc_dir_entry *parent);

    Aşağıdaki örnekte modülün init fonksiyonunda proc dosya sisteminin kökünde "generic-char-driver" isimli bir dosya yaratılmıştır. Modülün exit fonksiyonunda
    bu dosya remove_proc_entry fonksiyonuyla silinmiştir.

---------------------------------------------------------------------------------------------------------------------------*/

/* generic-char-driver.c */

#include <linux/module.h>
#include <linux/kernel.h>
#include <linux/fs.h>
#include <linux/cdev.h>
#include <linux/proc_fs.h>

MODULE_LICENSE("GPL");
MODULE_DESCRIPTION("General Character Device Driver");
MODULE_AUTHOR("Kaan Aslan");

static dev_t g_dev;
static struct cdev *g_cdev;
static struct file_operations g_file_ops = {
    .owner = THIS_MODULE,
};

static ssize_t proc_read(struct file *filp, char *buf, size_t size, loff_t *off);

static struct file_operations g_proc_ops = {
    .owner = THIS_MODULE,
    .read = proc_read,
};

static int __init generic_init(void)     
{
    int result;

    if ((result = alloc_chrdev_region(&g_dev, 0, 1, "generic-char-driver")) < 0) {
        printk(KERN_INFO "Cannot alloc char driver!...\n");
        return result; 
    }

    if ((g_cdev = cdev_alloc()) == NULL) {
        printk(KERN_INFO "Cannot allocate cdev!..\n");
        return -ENOMEM;
    }

    g_cdev->owner = THIS_MODULE;
    g_cdev->ops = &g_file_ops;
    
    if ((result = cdev_add(g_cdev, g_dev, 1)) != 0) {
        unregister_chrdev_region(g_dev, 1);
        printk(KERN_INFO "Cannot add charecter device driver!...\n");
        return result;
    }

    if (proc_create("generic-char-driver", S_IRUSR|S_IRGRP|S_IROTH, NULL, &g_proc_ops) == NULL) {
        unregister_chrdev_region(g_dev, 1);
        cdev_del(g_cdev);
        printk(KERN_INFO "Cannot create proc file!...\n");
        return -ENOMEM;
    }
    
    printk(KERN_INFO "Module initialized with %d:%d device number...\n", MAJOR(g_dev), MINOR(g_dev));

    return 0;
}

static void __exit generic_exit(void)
{
    cdev_del(g_cdev);
    unregister_chrdev_region(g_dev, 1);
    remove_proc_entry("generic-char-driver", NULL);

    printk(KERN_INFO "Goodbye...\n");
}

static ssize_t proc_read(struct file *filp, char *buf, size_t size, loff_t *off)
{
    return 0;
}

module_init(generic_init);
module_exit(generic_exit);

obj-m += $(file).o

all: 
	make -C /lib/modules/$(shell uname -r)/build M=${PWD} modules
clean:
	make -C /lib/modules/$(shell uname -r)/build M=${PWD} clean

#!/bin/bash

module=$1
mode=666

/sbin/insmod ./$module.ko ${@:2} || exit 1
major=$(awk "\$2 == \"$module\" {print \$1}" /proc/devices)
rm -f $module
mknod $module c $major 0
chmod $mode $module

/*--------------------------------------------------------------------------------------------------------------------------
    proc dosya sisteminde yaratılmış olan dosyadan okuma ve yazma yapılması 
---------------------------------------------------------------------------------------------------------------------------*/

/* generic-char-driver.c */

#include <linux/module.h>
#include <linux/kernel.h>
#include <linux/fs.h>
#include <linux/cdev.h>
#include <linux/uaccess.h>
#include <linux/proc_fs.h>

#define BUF_SIZE        4096

MODULE_LICENSE("GPL");
MODULE_DESCRIPTION("General Character Device Driver");
MODULE_AUTHOR("Kaan Aslan");

static dev_t g_dev;
static struct cdev *g_cdev;
static struct file_operations g_file_ops = {
    .owner = THIS_MODULE,
};

static ssize_t proc_read(struct file *filp, char *buf, size_t size, loff_t *off);
static ssize_t proc_write(struct file *filp, const char *buf, size_t size, loff_t *off);
static loff_t  proc_llseek(struct file *filp, loff_t off, int whence);

static struct file_operations g_proc_ops = {
    .owner = THIS_MODULE,
    .read = proc_read,
    .write = proc_write,
    .llseek = proc_llseek,
};

static char g_text[BUF_SIZE] = "this is a test\n";

static int __init generic_init(void)     
{
    int result;

    if ((result = alloc_chrdev_region(&g_dev, 0, 1, "generic-char-driver")) < 0) {
        printk(KERN_INFO "Cannot alloc char driver!...\n");
        return result; 
    }

    if ((g_cdev = cdev_alloc()) == NULL) {
        printk(KERN_INFO "Cannot allocate cdev!..\n");
        return -ENOMEM;
    }

    g_cdev->owner = THIS_MODULE;
    g_cdev->ops = &g_file_ops;
    
    if ((result = cdev_add(g_cdev, g_dev, 1)) != 0) {
        unregister_chrdev_region(g_dev, 1);
        printk(KERN_INFO "Cannot add charecter device driver!...\n");
        return result;
    }

    if (proc_create("generic-char-driver", S_IRUSR|S_IWUSR|S_IRGRP|S_IROTH, NULL, &g_proc_ops) == NULL) {
        unregister_chrdev_region(g_dev, 1);
        cdev_del(g_cdev);
        printk(KERN_INFO "Cannot create proc file!...\n");
        return -ENOMEM;
    }
    
    printk(KERN_INFO "Module initialized with %d:%d device number...\n", MAJOR(g_dev), MINOR(g_dev));

    return 0;
}

static void __exit generic_exit(void)
{
    cdev_del(g_cdev);
    unregister_chrdev_region(g_dev, 1);
    remove_proc_entry("generic-char-driver", NULL);

    printk(KERN_INFO "Goodbye...\n");
}

static ssize_t proc_read(struct file *filp, char *buf, size_t size, loff_t *off)
{
    ssize_t left, n;

    left = strlen(g_text) - *off;
    n = left < size ? left : size;

    if (n != 0) {
        if (copy_to_user(buf, g_text, n) != 0)
            return -EFAULT;
        *off += n;
    }

    return n;
}

static ssize_t proc_write(struct file *filp, const char *buf, size_t size, loff_t *off)
{
    ssize_t left, n;

    if (filp->f_flags & O_APPEND) 
        *off = strlen(g_text);
    
    left = BUF_SIZE - *off;
    n = left < size ? left : size;
    if (n != 0) {
        if (copy_from_user(g_text + *off, buf, n) != 0)
            return -EFAULT;
        *off += n;
    }

    return n;
}

static loff_t  proc_llseek(struct file *filp, loff_t off, int whence)
{
    loff_t toff;

    switch (whence) {
        case SEEK_SET:
            toff = off;
            break;
        case SEEK_CUR:
            toff = filp->f_pos + off;
            break;
        case SEEK_END:
            toff = (loff_t)strlen(g_text) - off;
            break;
        default:
            return -EINVAL;
    }
    
    if (toff > BUF_SIZE || toff < 0)
        return -EINVAL;

    filp->f_pos = toff;

    return toff;
}


module_init(generic_init);
module_exit(generic_exit);

obj-m += $(file).o

all: 
	make -C /lib/modules/$(shell uname -r)/build M=${PWD} modules
clean:
	make -C /lib/modules/$(shell uname -r)/build M=${PWD} clean

#!/bin/bash

module=$1
mode=666

/sbin/insmod ./$module.ko ${@:2} || exit 1
major=$(awk "\$2 == \"$module\" {print \$1}" /proc/devices)
rm -f $module
mknod $module c $major 0
chmod $mode $module

/* sample.c */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <fcntl.h>
#include <unistd.h>

void exit_sys(const char *msg);

int main(void)    
{
    int fd;
    ssize_t n;
    
    if ((fd = open("/proc/generic-char-driver", O_RDWR|O_APPEND)) == -1) 
        exit_sys("open");

    n = write(fd, "xxx", 3);
    if (n == -1)
        exit_sys("write");
    
    printf("%ld bytes written...\n", (long)n);

    close(fd);

    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/*--------------------------------------------------------------------------------------------------------------------------
    Biz yukarıdaki örneklerde dosyayı proc dizininin kökünde yarattık. İstersek proc dizininde bir dizin yaratıp dosyalarımızı 
    o dizinin içerisinde de yaratbilirdik. Bunun için proc_mkdir fonksiyonu kullanılmaktadır:

    struct proc_dir_entry *proc_mkdir(const char *name, struct proc_dir_entry *parent);

    Fonksiyonun birinci parametresi yaratılacak dizin'in simini, ikinci parametresi dizinin hanfi dizin içerisinde yaratılacağını belirtir. Bu parametre NULL
    geçilirse dizin proc dizininin kökünde yaratılır. Buradan aldığımız geri dönüş değerini proc_create fonksiyonun parent parent parametresinde
    kullanırsak ilgili dosyamızı bu dizinde yaratmış oluruz. Örneğin:

    struct proc_dir_entry *pdir;

    pdir = proc_mkdir("generic-char-driver", NULL);
    proc_create("info", 0, pdir, &g_proc_ops);

    Dizinlerin silinmesi yine remove_proc_entry fonksiyonuyla yapılabilmektedir. Dizin içerisindeki dosyaları silerken remove_proc_entry fonksiyonund ayine
    dosyanın hangi dizin içerisinde olduğu belirtilmelidir. Aslında bütün silme işlemleri proc_remove fonksiyonuyla da yapılabilmektedir. Bu fonksiyon
    parametre olarak proc_create ya da proc_mkdir fonksiyonun verdiği geri dönüş değerini alır. 

    Aşağıda generic-char-driver isimli aygıt sürücü proc dizinin altında "generic-char-driver" isimli bir dizin yaratmıştır. Bu dizinin içerisinde de 
    "info" isimli bir dosya yaratmıştır.

---------------------------------------------------------------------------------------------------------------------------*/

/* generic-char-driver.c */

#include <linux/module.h>
#include <linux/kernel.h>
#include <linux/fs.h>
#include <linux/cdev.h>
#include <linux/uaccess.h>
#include <linux/proc_fs.h>

#define BUF_SIZE        4096

MODULE_LICENSE("GPL");
MODULE_DESCRIPTION("General Character Device Driver");
MODULE_AUTHOR("Kaan Aslan");

static dev_t g_dev;
static struct cdev *g_cdev;
static struct file_operations g_file_ops = {
    .owner = THIS_MODULE,
};

static ssize_t proc_read(struct file *filp, char *buf, size_t size, loff_t *off);
static ssize_t proc_write(struct file *filp, const char *buf, size_t size, loff_t *off);
static loff_t  proc_llseek(struct file *filp, loff_t off, int whence);

static struct file_operations g_proc_ops = {
    .owner = THIS_MODULE,
    .read = proc_read,
    .write = proc_write,
    .llseek = proc_llseek,
};

static struct proc_dir_entry *g_pdir;
static char g_text[BUF_SIZE] = "this is a test\n";

static int __init generic_init(void)     
{
    int result;
    
    if ((result = alloc_chrdev_region(&g_dev, 0, 1, "generic-char-driver")) < 0) {
        printk(KERN_INFO "Cannot alloc char driver!...\n");
        return result; 
    }

    if ((g_cdev = cdev_alloc()) == NULL) {
        printk(KERN_INFO "Cannot allocate cdev!..\n");
        return -ENOMEM;
    }

    g_cdev->owner = THIS_MODULE;
    g_cdev->ops = &g_file_ops;
    
    if ((result = cdev_add(g_cdev, g_dev, 1)) != 0) {
        unregister_chrdev_region(g_dev, 1);
        printk(KERN_INFO "Cannot add charecter device driver!...\n");
        return result;
    }

    if ((g_pdir = proc_mkdir("generic-char-driver", NULL)) == NULL) {
        unregister_chrdev_region(g_dev, 1);
        cdev_del(g_cdev);
        printk(KERN_INFO "Cannot create proc directory!...\n");
        return -ENOMEM;
    }
    if (proc_create("info", S_IRUSR|S_IWUSR|S_IRGRP|S_IROTH, g_pdir, &g_proc_ops) == NULL) {
        remove_proc_entry("generic-char-driver", NULL);
        unregister_chrdev_region(g_dev, 1);
        cdev_del(g_cdev);
        printk(KERN_INFO "Cannot create proc file!...\n");
        return -ENOMEM;
    }
    
    printk(KERN_INFO "Module initialized with %d:%d device number...\n", MAJOR(g_dev), MINOR(g_dev));

    return 0;
}

static void __exit generic_exit(void)
{
    cdev_del(g_cdev);
    unregister_chrdev_region(g_dev, 1);
    remove_proc_entry("generic-char-driver", NULL);
    remove_proc_entry("info", g_pdir);
    printk(KERN_INFO "Goodbye...\n");
}

static ssize_t proc_read(struct file *filp, char *buf, size_t size, loff_t *off)
{
    ssize_t left, n;

    left = strlen(g_text) - *off;
    n = left < size ? left : size;

    if (n != 0) {
        if (copy_to_user(buf, g_text, n) != 0)
            return -EFAULT;
        *off += n;
    }

    return n;
}

static ssize_t proc_write(struct file *filp, const char *buf, size_t size, loff_t *off)
{
    ssize_t left, n;

    if (filp->f_flags & O_APPEND) 
        *off = strlen(g_text);
    
    left = BUF_SIZE - *off;
    n = left < size ? left : size;
    if (n != 0) {
        if (copy_from_user(g_text + *off, buf, n) != 0)
            return -EFAULT;
        *off += n;
    }

    return n;
}

static loff_t  proc_llseek(struct file *filp, loff_t off, int whence)
{
    loff_t toff;

    switch (whence) {
        case SEEK_SET:
            toff = off;
            break;
        case SEEK_CUR:
            toff = filp->f_pos + off;
            break;
        case SEEK_END:
            toff = (loff_t)strlen(g_text) - off;
            break;
        default:
            return -EINVAL;
    }
    
    if (toff > BUF_SIZE || toff < 0)
        return -EINVAL;

    filp->f_pos = toff;

    return toff;
}

module_init(generic_init);
module_exit(generic_exit);

obj-m += $(file).o

all: 
	make -C /lib/modules/$(shell uname -r)/build M=${PWD} modules
clean:
	make -C /lib/modules/$(shell uname -r)/build M=${PWD} clean

#!/bin/bash

module=$1
mode=666

/sbin/insmod ./$module.ko ${@:2} || exit 1
major=$(awk "\$2 == \"$module\" {print \$1}" /proc/devices)
rm -f $module
mknod $module c $major 0
chmod $mode $module

/*--------------------------------------------------------------------------------------------------------------------------
    Kesmeler (interrupts) konusunda bugün kullandığımız PC mimarisindeki kesme mekanizmasının donanımsal tarafını ele alacağız. 
    Eskiden tek CPU'lu makineler kullanıyordu. Bugün ağırlıklı olarak birden fazla çekirdeğe sahip işlemcileri kullanıyoruz. 
    Bu çekirdeklerin her birinin içerisinde o çekirdeğe özgü periyodik kesme oluşturan bir timer devresi vardır. Böylece her çekirdek
    kendi timer devresiyle "context switch" yapmakta ve proses istatistiklerini güncellemektedir. Fakat bunların dışında ayrıca bir de
    eski sistemlerde zaten var olan IRQ0 harttına bağlı global bir timer bulunmaktadır. Bu global timer "context switch" değil sistem zamanının 
    ilerletilmesi görevini yapmaktadır. Bugünki Linux sistemlerinde söz konusu olan bu timer'ların hepsi 1 milisaniye ya da 10 milisaniye 
    periyoda kurulmuş durumdadır. Yani böylece her 1 milisaniye ya da 10 milisaniyede araya timer kesmesi gelip sistem zamanını güncellemktedir. 
    İşte global timer'ın (IRQ0) her periyotta oluşturduğu kesmeler "jiffies" isimli kernel içerisindeki global bir değişkeni aryırmaktadır.
    Dolayısıyla bu jiffies değişkeni iki farklı zamanda okunduğunda geçen gerçek zaman timer periyodu da biiniyorsa elde edilebilmektedir. 

    Timer periyodu Linux kernel içerisindeki HZ isimli sembolik sabitle bildirilmiştir. Ancak bu HZ sembolik sabiti bu timer değeri için nihai
    belirlemeyi içermez, default durumu belirtir. Timer periyodunun ne olacağı aslında boot işlemi sırasında kernel konfigürasyonlarına da bakılarak 
    belirlenmektedir. İşte genellikle bu süre 1 ms 4 ms ya da 10 ms olmaktadır. (Ancak değişik mimarilerde farklı değerlerde olabilir.)

    İşte Global timer her bir kesme oluşturduğunda işletim sisteminin kesme kodu (interrupt handler) devereye girip "jiffies" isimli global dğeişkeni
    1 artırmaktadır. Bu jiffies değişkeni unsigned long türdendir. Bildindiği gibi unsigned long türü 32 bit Linux sistemlerinde 32 bit 64 bit Linux sistemlerinde 
    64 bittir. 32 bit Linux sistemlerinde ayrıca jiffies_64 isimli bir değişken daha vardır. bu değişken hem 32 bit sistemde hem de 64 bit sistemde 64 bitliktir. 
    
    Aşağıdaki örnekte aygıt sürücü proc dosya sisteminde bir dosya yaratmış ve o andaki jiffies değerini bu dosyaya yazdırmıştır. Yani biz proc içerisindeki 
    generic-char-driver isimli dosyayı okuduğumuzda aslında aygıt sürücünün en son yazmış olduğu jiffies değerini görmüş oluruz.

---------------------------------------------------------------------------------------------------------------------------*/

/* generic-char-driver.c */

#include <linux/module.h>
#include <linux/kernel.h>
#include <linux/fs.h>
#include <linux/cdev.h>
#include <linux/uaccess.h>
#include <linux/proc_fs.h>
#include <linux/sched.h>

MODULE_LICENSE("GPL");
MODULE_DESCRIPTION("General Character Device Driver");
MODULE_AUTHOR("Kaan Aslan");

static dev_t g_dev;
static struct cdev *g_cdev;
static struct file_operations g_file_ops = {
    .owner = THIS_MODULE,
};

static ssize_t proc_read(struct file *filp, char *buf, size_t size, loff_t *off);

static struct file_operations g_proc_ops = {
    .owner = THIS_MODULE,
    .read = proc_read,
};

static int __init generic_init(void)     
{
    int result;
    
    if ((result = alloc_chrdev_region(&g_dev, 0, 1, "generic-char-driver")) < 0) {
        printk(KERN_INFO "Cannot alloc char driver!...\n");
        return result; 
    }

    if ((g_cdev = cdev_alloc()) == NULL) {
        printk(KERN_INFO "Cannot allocate cdev!..\n");
        return -ENOMEM;
    }

    g_cdev->owner = THIS_MODULE;
    g_cdev->ops = &g_file_ops;
    
    if ((result = cdev_add(g_cdev, g_dev, 1)) != 0) {
        unregister_chrdev_region(g_dev, 1);
        printk(KERN_INFO "Cannot add charecter device driver!...\n");
        return result;
    }

    if (proc_create("generic-char-driver", S_IRUSR|S_IWUSR|S_IRGRP|S_IROTH, NULL, &g_proc_ops) == NULL) {
        cdev_del(g_cdev);
        unregister_chrdev_region(g_dev, 1);
        printk(KERN_INFO "Cannot create proc file!...\n");
        return -ENOMEM;
    }
    
    printk(KERN_INFO "Module initialized with %d:%d device number...\n", MAJOR(g_dev), MINOR(g_dev));

    return 0;
}

static void __exit generic_exit(void)
{
    cdev_del(g_cdev);
    unregister_chrdev_region(g_dev, 1);
    remove_proc_entry("generic-char-driver", NULL);
    printk(KERN_INFO "Goodbye...\n");
}

static ssize_t proc_read(struct file *filp, char *buf, size_t size, loff_t *off)
{
    static char sbuf[32];
    ssize_t left, n;

    sprintf(sbuf, "%lu\n", jiffies);
   
    left = strlen(sbuf) - *off;
    n = left < size ? left : size;
    if (n != 0) {
        if (copy_to_user(buf, sbuf + *off, n) != 0)
            return -EFAULT;
        *off += n;
    }

    return n;
}

module_init(generic_init);  
module_exit(generic_exit);

obj-m += $(file).o

all: 
	make -C /lib/modules/$(shell uname -r)/build M=${PWD} modules
clean:
	make -C /lib/modules/$(shell uname -r)/build M=${PWD} clean

#!/bin/bash

module=$1
mode=666

/sbin/insmod ./$module.ko ${@:2} || exit 1
major=$(awk "\$2 == \"$module\" {print \$1}" /proc/devices)
rm -f $module
mknod $module c $major 0
chmod $mode $module

/*--------------------------------------------------------------------------------------------------------------------------
    Eğer 64 bit sistemde çalışılıyorsa jiffies değerinin taşması (overflow olması) mümkün değildir. Ancak 32 bit sistemlerde
    49 günde taşma meydana gelebilmektedir. Aygıt sürücü programcısı bazen geçen zamanı hesaplamak için iki noktada jiffies değerini
    alıp aradaki farka bakmak isteyebilmektedir. Ancak bu durumda 32 bit sistemlerde "overflow" olasılığının ele alınması gerekir. 
    İşaretli sayıların ikili sistemdeki temsiline dayanarak iki jiffies arasındaki fark aşağıdaki gibi tek bir ifadeyle de hesaplanabilmektedr:

    unsigned long int prev_jiffies, next_jiffies;
    ...
    net_jiffies = (long) next_jiffies - (long) prev_jiffies;

    Kernel içerisinde iki jiffies değeri alarak bool bir değere geri dönen dört makro bulunmaktadır. Bunlar 32 bit sistemlerde taşma (overflow) durumunu da
    değerlerndirmektedir:

    time_after(jiffy1, jiffy2)
    time_before(jiffy1, jiffy2)
    time_after_eq(jiffy1, jiffy2)
    time_before_eq(jiffy1, jiffy2)
    
    Aşağıdaki örnekte proc dosya sisteminde iki okuma arasındaki geçen süre jiffy cinsinden verilmektedir. 
 ---------------------------------------------------------------------------------------------------------------------------*/

static ssize_t proc_read(struct file *filp, char *buf, size_t size, loff_t *off)
{
    static char sbuf[1024];
    loff_t left, n;
    long int net_jiffies;

    net_jiffies = (long)jiffies - (long)g_prev_jiffies;
    
    sprintf(sbuf, "Son okumadan geçen zaman: %10ld\n", net_jiffies);
   
    left = (loff_t)strlen(sbuf) - *off;
    printk(KERN_INFO "Left: %lld, size=%lu\n", left, size);
    n = left < size ? left : size;

    if (n != 0) {
        if (copy_to_user(buf, sbuf + *off, n) != 0)
            return -EFAULT;
        *off += n;
    }

    g_prev_jiffies = jiffies;

    return (ssize_t)n;
}

/*--------------------------------------------------------------------------------------------------------------------------
    Aygıt sürücü içerisinde bazen belli bir süre beklemek gerekebilmektedir. Bekleme işlemi kısa ise meşgul bir döngüde yapılabilir. 
    Ancak beklenecek süre uzun ise meşgul döngü uygun bir yöntem olmaz. Bu durumda daha önceden de görmüş olduğumuz wait kuyruklarında
    bekleme uygun olabilir. 

    Uzun beklemelerin aşağıdaki gibi yapılması uygun değildir:

    while (time_before(jiffies, jiffies_target))
        schedule();

    Buradaki temel sorun CPU'nun çok meşgul edilmesidir. Her ne kadar aygıt sürücü hemen schedule fonksiyonu ile CPU'yu bırakıyor olsa da
    context switch önemli bir zaman kaybına (throughput düşmesine)  neden olmaktadır. Bu nedenle uzun beklemelerin gerçekten zaman aşımlı wait kuyruklarında 
    yapılması gerekir.
    
    Uzun beklemeler için bir wait kuyruğu oluşturulup wait_event_timeout ya da wait_event_interrptible_timeaout fonksiyonlarıyla koşul 
    0 yapılarak gerçekleştirilebilir. Ancak bunun için bir wait kuyruğunun oluşturulması gerekir. Bu işlemi zaten kendi içerisinde yapan özel fonksiyonlar vardır. 

    schedule_timeout fonksiyonu belli bir jiffy zamanı geçene kadar thread'i önceden oluşturulmuş bir wait kuyruğunda bekletir. 

    signed long schedule_timeout(signed long timeout);

    Fonksiyon parametre olarak beklenecek jiffy değerini alır. Eğer sinyal dolayısıyla fonksiyon sonlanırsa kalan jiffy sayısına, eğer zaman aşımının dolması nedeniyle
    fonksiyon sonlanısa 0 değerine geri döner. Fonksiyon başarısız olmamaktadır. Fonksiyonu kullanmadan önce prosesin durum bilgisini set_current_state isimli
    fonksiyonla değiştirmek gerekir. Değiştirilecek durum TASK_UNINTERRUPTIBLE ya da TASK_INTERRUPTIBLE olabilir. Bu işlem yapılmazsa bekleme gerçekleşmemektedir.
    Örneğin:

    set_current_state(TASK_INTERRUPTIBLE);
    schedule_timeout(jiffies + 5 * HZ);

    Uzun beklemeyi kendi içerisinde yapan (yani schedule_timeout) fonksiyonunu kullnarak yapan üç yardımcı fonksiyon da vardır:

    void msleep(unsigned int msecs);
    unsigned long msleep_interruptible(unsigned int msecs);
    void ssleep(unsigned int secs);
    void ssleep_interruptible(unsigned int secs);

    Aşağıdaki örnekte /proc/generic dosyasından okuma yapılmaya çalışıldığında 5 saniye kernel modda thread bekletilecektir. 
    Burada yalnızca proc_read fonksiyonu verilmiştir. Yukarıdaki programı bu fonksiyonu değiştirerek kullanabilirsiniz.

---------------------------------------------------------------------------------------------------------------------------*/

static ssize_t proc_read(struct file *filp, char *buf, size_t size, loff_t *off)
{
    set_current_state(TASK_INTERRUPTIBLE);
    schedule_timeout(5 * HZ);

    /* ssleep_interruptible(5) */

    return 0;
}

/*--------------------------------------------------------------------------------------------------------------------------
    milisaniye, mikrosaniye ve nano saniye değerlerini jiffies değerine dönüştüren üç fonksiyon bulunmaktadır:

    unsigned long msecs_to_jiffies(const unsigned int m);
    unsigned long usecs_to_jiffies(const unsigned int m);
    unsigned long usecs_to_jiffies(const unsigned int m);

    Bu işlemin tersini yapan da üç fonksiyon vardır:

    unsigned int jiffies_to_msecs(const unsigned long j);    
    unsigned int jiffies_to_usecs(const unsigned long j);    
    unsigned int jiffies_to_nsecs(const unsigned long j);    

    Bu fonksiyonlar o andaki aktif HZ değerini dikkate almaktadır. 

    Ayrıca jiffies değerini saniye ve nano saniye biçiminde ayırıp bize struct timespec64 biçiminde bir yapı nesnesi olarak veren 
    jiffies_to_timespec64 isimli bir fonksiyon da vardır. Bunun tersi timespec64_to_jiffies fonksiyonuyla yapılmaktadır.


    Örneğin aygıt sürücü içerisinde 5 saniye bekleme işlemi aşağıdaki gibi de yapılabilirdi
---------------------------------------------------------------------------------------------------------------------------*/

static ssize_t proc_read(struct file *filp, char *buf, size_t size, loff_t *off)
{
    set_current_state(TASK_INTERRUPTIBLE);
    schedule_timeout(msecs_to_jiffies(5000));

    return 0;
}

/*--------------------------------------------------------------------------------------------------------------------------
    Aygıt sürücü içerisinde kısa beklemeler gerebilmektedir. Çünkü bazı donanım aygıtlarının programlanabilmesi için bazı beklemelere gereksinim
    duyulabilmektedir. Kısa beklemeler megul döngü yoluyla yani hiç sleep yapğılmadan sağlanmaktadır. Ayrıca kısa bekleme yapan fonksiyonlar atomiktir. 
    Atomiklikten kastedilen şey preemption işleminin kapatılmasıdır. Yani kısa bekleme yapan fonksiyonlar context switch işlemini o işlemci için kapatırlar. 
    Bu sırada thread'ler arası geçiş söz konusu olmamaktadır. Ancak donanım kesmeleri bu süre içerisinde oluşabilmektedir. 

    Kısa süreli döngü içerisinde bekleme yapan fonksiyonlar şunlardır:

    void ndelay(unsigned int nsecs); 
    void udelay(unsigned int usecs); 
    void mdelay(unsigned int msecs); 
   
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Linux çekirdeklerine belli versionyondan sonra bir timer mekanizması da eklenmiştir. Bu sayede aygıt sürücü programcısı belli bir zaman sonra
    belirlediği bir fonksiyonun çağrılmasını saplayabilmektedir. Bu mekanizmaya "kernel timer" mekanizması denilmektedir. Maalesf kernel timer mekanizması da
    birkaç kere arayüz olarak değiştirilmiştir. Belli zaman sonra çağrılacak fonksiyonun bir proses adına çalışmadığına dikkat etmek gerekir. Yani belirlenen fonksiyon
    çaprıldığında biz current değişkeni ile o andaki prosese erişemeyiz. O anda çalışan prosesin user alanına kopyalamalar yapamayız. Çünkü bu fonksiyon timer tick kesmeleri 
    tarafından çağrılmaktadır. Son Linux çekirdeklerindeki kernel timer kullanımı şöyledir:

    1) struct timer_list türünden bir yapı nesnesi statik düzeyde tanımlanır ve bu yapı nesnesine ilkdeğeri verilir. İlkdeğer verme işlemi DEFINE_TIMER makrosuyla
    yapılabilir. 

    #define DEFINE_TIMER(_name, _function)	
    
    ya da timer_setup fonksionuyla yapılabilmektedir:

    #define timer_setup(timer, callback, flags)	

    Makronun birinci parametresi timer nesnesinin adresini almaktadır. İkinci parametresi çağrılacak fonksiyonun adresidir. flags parametresi 0 geçilebilir. 

    2) Tanımlanan struct timer_list nesnesi add_timer fonksiyonu ile bir bağlı listeye yerleştirilir. 

    void add_timer(struct timer_list *timer);

    3) Daha sonra ne zaman fonksiyonun çağrılacağını anlatmak için modtimer fonksiyonu kullanılır. 

    int mod_timer(struct timer_list *timer, unsigned long expires);

    Buradaki expiry parametresi jiffy türündendir. Bu parametre hedef jiffy değerini içermeliir. (Yani jiffies + gecikme jiffy değeri)

    4) Timer nesnesinin silinmesi için del_timer fonksiyonu kullanılmaktadır:

    int del_timer(struct timer_list * timer);

    Normal olarak belirlenen fonksiyon yalnızca 1 kez çağrılmaktadır. Ancak bu fonksiyonun içerisinde yeniden mod_timer ile yeniden çağırma sağlanabilmektedir. 

    Çağrılması istenen fonksiyonun parametrik yapısı şöyle olmalıdır:

    void call_back_func(struct timer_list *tl);

    Bu fonksiyon add_timer sırasında verdiğimiz struct timer_list adresi parametre yapılarka çağrılmaktadır. 

    Aşağıda kernel timer'larının kullanımına ilişkin bir örnek görülmektedir. Bu örnekte kernel timer /proc/generic-char-driver dosyasından
    okuma yapıldığında yaratılıp periyodik bir biçimde çağrılmaktadır. 5 çağrımdam sonra yaratılan timer yok edilmiştir. 

---------------------------------------------------------------------------------------------------------------------------*/

/* generic-char-driver.c */

#include <linux/module.h>
#include <linux/kernel.h>
#include <linux/fs.h>
#include <linux/cdev.h>
#include <linux/uaccess.h>
#include <linux/proc_fs.h>
#include <linux/sched.h>

MODULE_LICENSE("GPL");
MODULE_DESCRIPTION("General Character Device Driver");
MODULE_AUTHOR("Kaan Aslan");

static dev_t g_dev;
static struct cdev *g_cdev;
static struct file_operations g_file_ops = {
    .owner = THIS_MODULE,
};
static long int g_prev_jiffies;

static ssize_t proc_read(struct file *filp, char *buf, size_t size, loff_t *off);

static struct file_operations g_proc_ops = {
    .owner = THIS_MODULE,
    .read = proc_read,
};

static int __init generic_init(void)     
{
    int result;
    
    if ((result = alloc_chrdev_region(&g_dev, 0, 1, "generic-char-driver")) < 0) {
        printk(KERN_INFO "Cannot alloc char driver!...\n");
        return result; 
    }

    if ((g_cdev = cdev_alloc()) == NULL) {
        printk(KERN_INFO "Cannot allocate cdev!..\n");
        return -ENOMEM;
    }

    g_cdev->owner = THIS_MODULE;
    g_cdev->ops = &g_file_ops;
    
    if ((result = cdev_add(g_cdev, g_dev, 1)) != 0) {
        unregister_chrdev_region(g_dev, 1);
        printk(KERN_INFO "Cannot add charecter device driver!...\n");
        return result;
    }

    if (proc_create("generic-char-driver", S_IRUSR|S_IWUSR|S_IRGRP|S_IROTH, NULL, &g_proc_ops) == NULL) {
        cdev_del(g_cdev);
        unregister_chrdev_region(g_dev, 1);
        printk(KERN_INFO "Cannot create proc file!...\n");
        return -ENOMEM;
    }
    
    g_prev_jiffies = jiffies;

    printk(KERN_INFO "Module initialized with %d:%d device number...\n", MAJOR(g_dev), MINOR(g_dev));

    return 0;
}

static void __exit generic_exit(void)
{
    cdev_del(g_cdev);
    unregister_chrdev_region(g_dev, 1);
    remove_proc_entry("generic-char-driver", NULL);
    printk(KERN_INFO "Goodbye...\n");
}

static void timer_callback_func(struct timer_list *tl)
{
    static int count = 0;

    printk(KERN_INFO "timer callback...\n");

    mod_timer(tl, jiffies + msecs_to_jiffies(5000)); 

    if (count == 5) {
        del_timer(tl);
        count = 0;
    }
    else
        ++count;
}

static ssize_t proc_read(struct file *filp, char *buf, size_t size, loff_t *off)
{   
    static struct timer_list tl;

    timer_setup(&tl, timer_callback_func, 0);
    add_timer(&tl);
    mod_timer(&tl, jiffies + msecs_to_jiffies(5000)); 

    return 0;
}

module_init(generic_init);  
module_exit(generic_exit);

obj-m += $(file).o

all: 
	make -C /lib/modules/$(shell uname -r)/build M=${PWD} modules
clean:
	make -C /lib/modules/$(shell uname -r)/build M=${PWD} clean

#!/bin/bash

module=$1
mode=666

/sbin/insmod ./$module.ko ${@:2} || exit 1
major=$(awk "\$2 == \"$module\" {print \$1}" /proc/devices)
rm -f $module
mknod $module c $major 0
chmod $mode $module

/*--------------------------------------------------------------------------------------------------------------------------
    Önceki konularda da UNIX/Linux sistemlerinde kernel modda çalışan işletim sistemine ait thread'ler olduğundan bahsetmiştik. Bu thread'ler
    run kuyruğunda bulunan uykuya dalabilen işletim sisteminin programm gibi çalışan thread'leridir. Çeşitli işlemlerdne sorumludurlar. Linux 
    işletim sisteminde bunların da isimleri genellikle "user mode deamon"lar gibi sonu 'd' ile bitmektedir ve yine bunlar 
    isimleri genellikle 'k' harfi ile başlarlar. Örneğin "kupdate", "kswapd", "keventd" gibi. 

    İşte aygıt sürücüler de isterlerse arka planda kernel modda bir proses gibi çalışan thread'ler yaratabilirler. Ancak bu thread'ler
    bir proses ile ilişkisiz çalıştırılmaktadır. Bu nedenle bunlar içerisinde current değişkeni kullanılamaz ve copy_to_user ya da copy_from_user
    gibi fonksiyonlar kullanılmaz. 

    Aygıt sürücüdeki kodlarımız genellikle bir olay olduğunda (örneğin kesme gibi), ya da user moddan çağrıldığında (read, write, ioctl) gibi
    çalıştırılmaktadır. Ancak kernel thread'ler aygıt sürücüye sanki bir programmış gibi kernel modda sürekli çalışma imkanı verirler. 

    Kernel thread'ler şöyle kullanılırlar:

    1) Önce kernel thread aygıt sürücü içerisinde yaratılır. Yaratılma modülün init işleminde yapılabileceği gibi aygıt üsürücü ilk kez açıldığında
    open fonksiyonunda ya da belli bir süre sonra belli bir fonksiyonda da yapılabilmektedir. Krnel thread'ler kthread_create fonksiyonuyla yaratılabilirler:

    struct task_struct *kthread_create (int (*threadfn)(void *data), void *data, const char  *namefmt);

    Fonksiyon başarı durumunda yaratılan thread'in task_struct adresine, başarısızlık durumunda negatif error değerine geri dönmektedir. 
    Adrese geri dönen diğer kernel fonksiyonlarında olduğu gibi başarısızlık IS_ERR makrosuyla test edilmelidir. Eğer fonksiyon başarısz olmuşsa
    error kodu PTR_ERR makrosuyle elde edilmelidir. Örneğin:

    struct task_struct *ts;

    ts = kthread_create(...);
    if (IS_ERR(ts)) {
        printk(KERN_ERROR "cannot create kernel thread!..")
        return PTR_ERR(ts);
    }

    Kernel threda bu fonksiyonla yaratıldıktan sonra hemen çalışmaz. Onu çalıştırmak için wake_process fonksiyonun çağrılması gerekir:

    int wake_up_process(struct task_struct *tsk);

    Fonksiyon başarı durumunda 0 değerine başarıszlık durumunda negatif error koduna geri dönmektedir. 

    Aslında yukarıdaki işlemi tek hamlede yapan kthread_run isimli bir fonksiyon da vardır:

    struct task_struct *kthread_run(int (*threadfn)(void *data), void *data, const char  *namefmt);

    2) Kernel thread kthread_stop fonksiyonuyla herhangi bir zaman ya da aygıt sürücü silinirken yok edilebilir:

    int kthread_stop(struct task_struct *ts);

    Fonksiyon thread sonlanana kadar blokeye yol açar. Fonksiyon thread fonksiyonunun exit koduyla (yani thread fonksiyonunun geri dönüş değeri ile)
    geri döner. Genellikle programcılar başarı için 0 değerini kullanmaktadır. Burada önemli nokta kthread_stop fonksiyonunun kernel thread'i zorla 
    sonlandırmadığıdır. Kerle thread'in sonlanması zorla yapılmaz. kthread_stop fonksiyonu bir bayrağı set eder. Kernel thread de bu bayrak set edilmiş mi
    diye bir döngü içerisinde bakar. Eğer baurak set edilmişse kendini sonlandırır. Kernel thread'in bu bayrağa bakması kthread_should_stop
    fonksiyonuyla yapılmaktadır. 

    bool kthread_should_stop(void);

    Fonksiyon eğer flag set edilmişse sıfrı dışı bir değere ser edilmediyse 0 değerine geri dönmektedir. Tipik olarak kernel  threda fonksiyonu 
    aşağıdaki gibi bir döngüde yaşamını geçirir:

    while (!kthread_should_stop()) {
        ...
    }

    Aşağıdaki örnekte modül initialize edilirken kernel thread yaratılmış, modül yok edilirken kthread_stop ile 
    kernel thread'in sonlanması beklenmiştir. kernel thread içerisinde msleep fonksiyonu ile 1 saniyelik beklemeler yapılmıştır. 
---------------------------------------------------------------------------------------------------------------------------*/

/* generic-char-driver.c */

#include <linux/module.h>
#include <linux/kernel.h>
#include <linux/fs.h>
#include <linux/cdev.h>
#include <linux/sched.h>
#include <linux/kthread.h>
#include <linux/delay.h>

MODULE_LICENSE("GPL");
MODULE_DESCRIPTION("General Character Device Driver");
MODULE_AUTHOR("Kaan Aslan");

static dev_t g_dev;
static struct cdev *g_cdev;
static struct file_operations g_file_ops = {
    .owner = THIS_MODULE,
};

static int generic_kernel_thread(void *data);

struct task_struct *g_ts;

static int __init generic_init(void)     
{
    int result;
    
    if ((result = alloc_chrdev_region(&g_dev, 0, 1, "generic-char-driver")) < 0) {
        printk(KERN_INFO "Cannot alloc char driver!...\n");
        return result; 
    }

    if ((g_cdev = cdev_alloc()) == NULL) {
        printk(KERN_INFO "Cannot allocate cdev!..\n");
        return -ENOMEM;
    }

    g_cdev->owner = THIS_MODULE;
    g_cdev->ops = &g_file_ops;
    
    if ((result = cdev_add(g_cdev, g_dev, 1)) != 0) {
        unregister_chrdev_region(g_dev, 1);
        printk(KERN_INFO "Cannot add charecter device driver!...\n");
        return result;
    }

    g_ts = kthread_run(generic_kernel_thread, NULL, "generic-kernel-thread");
    if (IS_ERR(g_ts)) {
        printk(KERN_INFO "cannot create kernel thread!..");
        return PTR_ERR(g_ts);
    }

    printk(KERN_INFO "Module initialized with %d:%d device number...\n", MAJOR(g_dev), MINOR(g_dev));

    return 0;
}

static void __exit generic_exit(void)
{
    kthread_stop(g_ts);
    cdev_del(g_cdev);
    unregister_chrdev_region(g_dev, 1);
    remove_proc_entry("generic-char-driver", NULL);
    printk(KERN_INFO "Goodbye...\n");
}

static int generic_kernel_thread(void *data)
{
    static int count = 0;

    while (!kthread_should_stop()) {
        printk(KERN_INFO "Kernel thread running: %d\n", count);
        ++count;
        msleep(1000);
    }

    return 0;
}

module_init(generic_init);  
module_exit(generic_exit);

obj-m += $(file).o

all: 
	make -C /lib/modules/$(shell uname -r)/build M=${PWD} modules
clean:
	make -C /lib/modules/$(shell uname -r)/build M=${PWD} clean

#!/bin/bash

module=$1
mode=666

/sbin/insmod ./$module.ko ${@:2} || exit 1
major=$(awk "\$2 == \"$module\" {print \$1}" /proc/devices)
rm -f $module
mknod $module c $major 0
chmod $mode $module

/*--------------------------------------------------------------------------------------------------------------------------
    Kesme işlemcinin çalıştırmakta olduğu koda ara vererek başka bir kodu çalıştırması sürecidir. Kesme oluştuğunda çalıştırılan koda
    "kesme kodu (interrupt handler)" denilmektedir. Kesmeler üç kısma ayrılabilir. Kesme denildiğinde akla "donanım kesmeleri (hardware interrupts")
    gelir. Donanım kesmeleri işlemcilerin INT ucunun elektriksel olarak dış bir aygıt tarafından uyarılmasıyla oluşturulur. Böylece aygıtlar birtakım
    olayları bildirmek için kesme oluşturabilmektedir. "Yazılım kesmeleri (software interrupts)" her işlemcide yoktur. Bunlar program kodu içerisinde
    özel kesme oluşturan makine kodları ile (örneğin Intel'deki INT makine komutu gibi) oluşturulurlar. "İçsel kesmeler (internal interrupts)" ise
    işlemci tarafından bazı müşküllerle karşılaşıldığında oluşturulmaktadır. Örneğin işlemci sanal adresi fiziksel adrese dönüştürürken syfa tablosunda
    sanal sayfaya karşı bir fiziksel sayfanın eşleştirilmediğini gördüğünde "page fault" denilen içsel kesmeyi oluşturmaktadır. Ancak kesme denildiğinde
    default olarak donanım kesmeleri akla gelmektedir. 

    Donanım kesmesi oluşturan elektronik birimlerin hepsi doğrudan CPU'nın INT ucuna bağlanmamaktadır. Genellikle bu işe aracılık eden daha akıllı
    bir işlemci kullanılır. Bu işlemcilere "kesme denetelyecileri (interrupt controller)" denilmektedir. Bazı mimarilerde kesme denetleyicisi işlemciin
    içerisine taşınmıştır. Bazı mimarilerde dışarıda ayrı bir entegre devre olarak bulunur. Bazı mimarilerde her iki durum da söz konusudur. Kesme denetleyicilerinin
    şu faydaları vardır:

    1) Birden fazla donanım biriminin aynı anda kesme oluşturması durumunda bunları sıraya dizebilme
    2) Birden fazla donanım biriminin aynı anda kesme oluşturması durumunda bunlara öncelik verebilme
    3) Belli birimlerden gelen kesme isteklerini disable edebilme, ya da tümden tüm uçlardan gelen istekleri disable edebilme
    4) Multicore sistemlerde kesmenin belli bir core'da çalışttırılabilmesini sağlama

    Bugün kullandığımız PC'lerde (laptop ve notebook'lar da dahil olmak üzere) eskiden kesme denetleyicisi olarak bir tane 8259 (PIC) devresi vardı. 
    Bunun 8 girişi bulunuyordu. Yani bu denetleyicinin uçları 8 ayrı donanım birimine bağlanabiliyordu. Sonra bunun sayısı ikiye çıkartıldı. 
    Ancak bir uç ikisini bağlamak için kullanıldığından toplam 15 uç elde edildi. Bu uçlara IRQ Interrupt Request) denildi ve bunlara numaralar
    verildi (IRQ-0, IRQ-1, ...) Ancak bu 8259 denetleyicisinin zamanla yetersizliği görüldü. Özellikle birden fazla çekirdek ile çalışmalar başlayınca
    bu denetleyici yetersiz kalmıştır. Çünkü bu denetleyici tek bir çekirdeğe bağlanabilmektedir. İşte daha sonraları 8259 yerine ismine
    IOAPIC (82801) denilen daha gelişmiş bir kesme denetleyicisi kullanılmaya başlanmıştır. Bu yeni kesme denetleyicisinin 24 ucu vardır. Aynı zamanda bu
    kesme denetleyicisi birden fazla çekirdeğin bulunduğu ortamda çekirdeklerin istenen bir tanesinde kesme oluşturabilmektedir. Kesme denetleyicilerinin
    bazı uçlarına zaten üretimden bazı birimler bağlanmıştır. Ancak bunların bazıları boştadır. Genişleme yuvalarına takılan kartlar bu boştaki kesme uçlarını
    kullanabilmektedir. Bugün PC'lerde kullanılan modern genişleme yuvalarına PCI ve PCI-X denilmektedir. 

    Bugün Pentium ve eşdeğer AMD ieşlemcilerinin içeisinde de ismine "Local APIC" denilen bir kesme denetleyicisi vardır. Bu local APIC iki uca sahiptir.
    Aynı zamanda bir timer devresi de bulundurmaktadır. Bu local APIC içerisindeki timer devresi o işlemcide jiffy oluşturulmasında ve context switch
    yapılmasında kullanılmaktadır. Local APIC'in en önemli özelliklerinden birisi "data bus" yoluyla kesme alabilmesidir. Bu özellik sayesinde hiç işlemcinin
    INT uyarılmadan çok fazla sayıda kesme sanki belleğe bir değer yazıyormuş ginbi oluşturulabilmektedir. Gerçekten de bugün PCI slotlara takılan bazı
    kartlar kesmeleri bu biçimde oluşturmaktadır. Bu tekniğe "Message Signaled Intterpt (MSI)" denilmektedir. 

    O halde bugünkü durum şöyledir:

    - Bazı donanım birimleri built-in biçimde IOAPIC'in uçlarına bağlı durumdadır. Bu u.lar eskiye uyumu korumak için 8259'un uçlarıyla aynıdır.
    - Bazı PCI kartlar slot üzerindeki 4 IRQ hattından (INTA, INTB, INTC, INTD) birini kullanarak kesme oluşturmaktadır. Bu hatlar IOAPIC'in bazı uçlarına
    bağlıdır. 
    - Bazı PCI kartlar ise doğurdan MSI biçiminde IOAPIC'i pass geçerek memory işlemleriyle ilgili çekirdekte kesme oluşturabilmektedir. 

    Bir aygıt sürücü programcısı mademki birtakım kartlar için onu işler hale getiren temel yazılımları da yazma iddiasındadır. O halde o kartın
    kullanacağı kesme için kesme kodu yazabilmelidir. Tabii işletim sisteminin aygıt sürücü mimarisinde bu işlemler de özel kernel fonksiyonlarıyla
    yapılır. Yani kesme kodu yazmanın belli bir kuralı vardır. Eskiden ve hala bazı kesmeler birden fazla donanım tarafından ortak kullanılabilmektedir. 
    Örneğin kesme denetleyicisinin belli bir ucunu birden fazla donanım uyarabilir. Bu durumda işletim sisteminin bir kesme oluştuğunda birden fazla 
    kesme kodunu kuyruğa alıp çalıştırabilmesi beklenir. Böylece aygıt sürücüyü yazan programcı kesmenin kendi kartından gelip gelmediğini anlamak
    zorundadır. Eğer kesme kendi kartından gelmemişse programcı kesme kodundan hemen çıkar, kesme kendi kartından gelmişse onu işler. 

    Pekiyi çok çekirdekli bilgisayar sistemlerinde oluşan bir kesme hangi çekirdek tarafından işlenecektir? Bugün kullanılan IOAPIC devreleri bu bakımdan 
    şu özelliklere sahiptir:

    1) Kesme IOAPIC tarafından donanım birimi tarafından istenilen bir çekirdekte oluşturulabilir. 
    2) IOAPIC en az yüklü çekirdeğe karar vererek kesmenin orada oluşturulmasını sağlayabilir. 
    3) IOAPIC döngüsel bir biçimde çekirdeklere kesme oluşturabilmektedir. 

    IOAPIC'in en az yüklü işlemciyi bilmesi mümkün değildir. Onu işletim sistemi bilebilir. İşte işlemcilerin Local APIC'leri içerisinde özel bazı yazmaçlar
    vardır. Aslında IOAPIC bu yazmaçtaki değerlere bakıp en düşüğünü seçmektedir. Bu değerleri de işletim sistemi set eder. İşletim sisteminin yaptığı
    bu faaliyete "kesme dengeleme (IRQ balancing)" denilmektedir. Linux sistemlerinde bir süredir kesme dengeleyicisi bir kernel thread (irqbalance) olarak 
    çalıştırılmaktadır. Böylece Linux sistemlerinde aslında donanım kesmeleri her defasında farklı çekirdeklerde çalıştırışıyor olabilir. 

    Pek çok CPU ailesinde donanım kesmelerinin teorik maksimum bir limiti vardır. Örneğin Intel mimarisinde toplam kesme sayısı 256'yı geçememektedir. 
    Bu mimaride her kesmenin bir numarası vardır. IRQ numarası ile kesme numarasının bir ilgisi yoktur. Biz örneğin PIC ya da IOAPIC'i programlayarak belli bir kesmenin
    belli bir IRQ için belli numaralı bir kesmenin oluşmasını sağlayabiliriz. Örneğin timer (IRQ-0) için 8 numaralı kesmenin çalışmasını sağlayabiliriz. 
    Pekiyi bir IRQ oluşturulduğunda çekirdek kaç numaralı kesme kodunun çalıştırılacağını nereden anlamaktadır? İşte PIC ya da IOAPIC CPU'nun INT ucunu uyararak 
    kesme oluşturuken Data Bus'ın ilk 8 ucundan kesme numarasını da CPU'ya bildirmektedir. 

---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Bir aygıt sürücüsü bir kesme oluştuğunda kendi fonksiyonunun çağrılmasını istiyorsa onu request_irq isimli kernel fonksiyonuyla 
    register ettirmelidir. 

    static int request_irq(unsigned int irq, irq_handler_t handler, unsigned long flags, const char *name, void *dev_id);

    Fonksiyonun birinci parametresi IRQ numarasıdır. İkinci parametresi IRQ oluştuğunda çağrılacak fonksiyonu belirtmektedir. Bu fonksiyonun 
    geri dönüş değeri irqreturn_t üründen (bu bir tamsayı türüdür) parametreleri de sırasıyla int ve void * türündendir. Örneğin:

    irqreturn_t my_irq_handler(int irq, void *dev_id)
    {
        ....
    }

    Fonksiyonun üçüncü parametresi bazı bayraklardan oluşur. Bu bayrak 0 geçilebilir ya da örneğin IRQF_SHARED geçilebilir. Diğer seçenkler için dokümanlara başvurabilirsiniz. 
    IRQF_SHARED aynı kesmenin birden fazla aygıt sürücü tarafından kullanılabileceği anlamına gelmektedir. (Tabii biz ilk register ettiren değilsek daha önce resgister ettirenlerin
    bu bayrağı kullanmış olması gerekir. Aksi halde biz de bu bayrağı kullanamayız.) Fonksiyonun dördüncü parametresiş /proc/interrupts dosyasına görüntülenecek ismi belirtir. Son parametre
    sistem genelinde tek olan bir nesnenin adresi olarak girilmelidir. Aygıt sürücü programcıları bu parametreye tipik olarak aygıt yapısını ya da çağrılacal foksiyonu girerler. irq_request fonksiyonu
    başarı durumunda 0 değerne başarısızlık durumunda negatif hata değerine geri dönmektedir. 


    Bir kesme kodu request_irq fonksiyonuyla register ettirilmişse bunun geri alınması free_irq fonksiyonuyla yapılmaktadır:

    const void *free_irq(unsigned int irq, void *dev_id);

    Fonksiyonun birinci parametresi silinecek irq numarasını, ikinci parametresi irq_reuest fonksiyonuna girilen son parametreyi belirtir. Fonksiyon başarı durumunda aygıt ismine, 
    başarıszlık durumunda NULL adrese geri dönmektedir. 

    Bazen sistem programcısı belli bir IRQ'yu belli süre için disable etmek isteyebilir. Bunun disable_irq ve enable_irq isimli iki kernel fonksiyonu kullanılmaktadır. 
    Bu fonksiyonlar belli numaralı bir IRQ'yu disable, enable etmeketdir. Bu işlemi doğrudan kesme denetleyicisini (PIC ya da IOAPIC) programlayarak yapmakmaktadır. 

    void disable_irq(unsigned int irq);
    void enable_irq(unsigned int irq);

    Fonksiyonlar şrq numarasını parametre olarak alır. 

---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Kesme mekanizmasının tipik örneklerinden biri klavye kullanımıdır. PC klavyesinde bir tuşa basıldığında klavye içerisindeki 
    işlemci (keyboard encoder - Intel 8048) basılan ya da çekilen tuşun klavyedeki sıra numarasını (buna "scan code" denilmektedir) dış dünyaya
    seri bir biçimde kodlamaktadır. Bu bilgi bilgisayardaki klavye denetleyicisine (Intel 8042) gelir. Klavye denetleyicisi PIC ya da APIC'in 1 numaralı
    ucuna bağlıdır ve bu uçtan IRQ1 kesmesini oluşturur. Ama basılan ve çekilen tuşun scan kodunu kendi içerisinde saklar. Böylece tuşa basıldığında ve parmek tuştan 
    çekildiğinde işletim sisteminni IRQ1 kesme kodu çalışmaktadır. Bu kodda klavye denetleyicisinden basılan ya da çekilen kodun scan kodu alınarak bir yazılımsal kuyruk sistemine
    yerleştirilmektedir. stdin terminal sürücüsü aslında bu kuyruktan okumayı yapmaktadır. 

    Klavyedeki tuşların üzerinde yazan harflerin hiçbir önemi yoktur. Yani İngilizce klavye ile Türkçe klavye aynı tuşlar için aynı scan kodu göndermektedir. 
    Basılan tuşun hangi tuş olduüu aslında dil ayarlarına bakılarak işletim sistemi tarafından anlamlandırılmaktadır. Klavye ile bilgisayar arasındaki iletişim 
    tek yönlü değil çift yönlüdür. Yani Klavye işlemcisi de isterse klavye içerisindeki işlemciye komut gönderebilmektedir. Aslında klavye üzerindeki ışıkların yakılması da
    klavyenin içerisinde tuşa basılınca yapılmamaktadır. Işıklı tuşlara basıldığında gönderilen scan kod klavye denetleyicisi tarafından alınır ve kesme kodu yeniden klavye işlmcisine
    ışığı yak komutunu gönderir. Örneğin bilisayardaki işletim sistemi çökmüşse bu ışıklar yanmayacaktır. 

    Aşağıdaki örnekte klavyedne tuşa basıldığında ve çekildiğinde oluşan IRQ-1 ele alınmıştır.
---------------------------------------------------------------------------------------------------------------------------*/

/* generic-char-driver.c */

#include <linux/module.h>
#include <linux/kernel.h>
#include <linux/fs.h>
#include <linux/cdev.h>
#include <linux/interrupt.h>

MODULE_LICENSE("GPL");
MODULE_DESCRIPTION("General Character Device Driver");
MODULE_AUTHOR("Kaan Aslan");

static dev_t g_dev;
static struct cdev *g_cdev;
static struct file_operations g_file_ops = {
    .owner = THIS_MODULE,
};

static irqreturn_t keyboard_irq_handler(int irq, void *dev_id);

static int __init generic_init(void)     
{
    int result;
    
    if ((result = alloc_chrdev_region(&g_dev, 0, 1, "generic-char-driver")) < 0) {
        printk(KERN_INFO "Cannot alloc char driver!...\n");
        return result; 
    }

    if ((g_cdev = cdev_alloc()) == NULL) {
        printk(KERN_INFO "Cannot allocate cdev!..\n");
        return -ENOMEM;
    }

    g_cdev->owner = THIS_MODULE;
    g_cdev->ops = &g_file_ops;
    
    if ((result = cdev_add(g_cdev, g_dev, 1)) != 0) {
        unregister_chrdev_region(g_dev, 1);
        printk(KERN_INFO "Cannot add charecter device driver!...\n");
        return result;
    }

    if ((result = request_irq(1, keyboard_irq_handler, IRQF_SHARED, "generic-char-driver-irq", &g_cdev)) != 0) {
        printk(KERN_ERR "interrupt couldn't registered!..\n");
        return result;
    }

    printk(KERN_INFO "Module initialized with %d:%d device number...\n", MAJOR(g_dev), MINOR(g_dev));

    return 0;
}

static irqreturn_t keyboard_irq_handler(int irq, void *dev_id)
{
    static int count = 0;

    ++count;

    printk(KERN_INFO "Keyboard IRQ occurred: %d\n", count);

    return IRQ_HANDLED;
}

static void __exit generic_exit(void)
{
    free_irq(1, &g_cdev);
    cdev_del(g_cdev);
    unregister_chrdev_region(g_dev, 1);
    printk(KERN_INFO "Goodbye...\n");
}

module_init(generic_init);  
module_exit(generic_exit);

/*--------------------------------------------------------------------------------------------------------------------------
    CPU ile RAM arasında veri transferi aslında tamamen elektriksel düzeyde 1'lerle 0'larla (5V/0V) gerçekleşmektedir. CPU'nun adres uçları 
    (address bus) RAM'dan hangi adresten başlayan bilginin transfer edileceğini belirlemek için kullanılır. CPU'nun data uçları ise bilginin alınıp 
    gönderilmesinde kullanılmaktadır. İşlemin okuma mı yazma mı olduğu genellikle R/W biçiminde isimlendirilen ayrı bir control ucuyla yapılmaktadır. 
    Örneğin MOV EAX, [XXXXXXXX] komutu 32 bit INTEL işlemcilerinde RAM'deki XXXXXXXX adresinden başlayan 4 byte bilginin CPU içerisindeki EAX yazmacına 
    çekileceği anlamına gelmektedir. Bu makina komutu işletilirken CPU önce erişilecek adres olan XXXXXXXX adresini adres uçlarına elektriksel işaret olarka kodlar.
    RAM bu adresi alır bu adresten başlayan 4 byte'lık bilgiyi data uçlarına elektirksel olarak kodlar. CPU'da bu açlardan bilgiyi elektirksel olarak alır ve 
    EAX yazmacına yerleştirir. CPU'nun adres uçları RAM'in uçlarına, CPU'nun data uçları ise RAM'in data uçlarına bağlıdır. Tranfer yönü R/W ucuyla belirlenmektedir. 
    Tabii CPU'lar bugün DRAM belleklerden daha hızlıdır. Dolayısıyla CPU RAM'den yanıt gelene kadar beklemektedir (wait state). 

    Bir bilisayar sisteminde yalnızca Merkezi İşllemci (CPU) değil aynı zamanda yerel birtakım olaylardan sorumlu yardımcı işlemciler de vardır. Bu yardımcı işlemcilere
    genellikle "controller (denetleyici)" denilmektedir. Örneğin PC mimarisinde "Kesme Denetleyicisi (Intel 8250-PIC)", "Klavye Denetleyicisi (Intel 8042-KC)", 
    "UART İşlemcisi (Intel 8250/NS 16550-UART)" gibi pek çok işlemci vardır. Bu işlemcilere komutlar tıpkı CPU/RAM haberleşmesinde olduğu gibi elektriksel düzeyde
    CPU'nun adres ve data uçlarıyla yapılmaktadır. Yani CPU'nun adres ve data auçları yalnızca RAM'e değil yardımcı işlemcilere de bağlıdır. Pekiyi bu durumda CPU RAM'e erişirken
    aynı zamanda yardımcı işlemcilere de erişmez mi? İşte CPU'ların genellikle IO/Mem biçiminde isimlendirilen bir uçları daha vardır. Bu ucun 5V ya da 0V olması erişimin RAM'e mi yoksa
    yardımcı işlemciye mi yapılacağını belirtir. Yardımcı işlemcileri tasarlayanlar bu uca bakarak bilginin RAM'e değil kendilerine geldiğini anlayabilirler. Nomral RAM erişimlerine 
    ilişkin MOV makine komutlarında bu IO/Mem ucu "mem" biçiminde aktive edilir. Ancak bazı IN, OUT gibi komutlarda bu uç "IO" biçiminde aktive edilmektedir. Bu durumda yardımcı işlemcilere
    erişmek için MOV komutları değil özel IN, OUT komutları kullanılır. Ancak bazı yardımcı işlemciler bu IO/Mem ucu tam tersine "Mem" olarak aktive edildiğinde işlevini yapmaktadır. 
    Bu durumda bu işlemcilere biz IN, OUT komutlarıyla değil RAM'e erişirmiş gibi MOV komutlarıyla erişiriz. İşte bu tekniğe "Memory Mapped IO" denilmektedir. Memory Mapped IO yardımcı
    işlemcilere sanki RAM'miş gibi erişme anlamına gelir. 

    Pekiyi yardımcı işlemcileri biribirnden ayıran şey nedir? İşte CPU'nun adres uçları bu yardımcı işlemciler tarafından özel bazı değerlerde ise dikkate alınmaktadır. Yani yardımcı işlemcilerin de
    aynı RAM'deki byte'ların adresleri olduğu adresleri vardır. Bu adresler PC mimarisini tasarlayanlar tarafından önceden belirlenirler. Modern sistemlerde programlama yoluyla değiştirilebilen
    adresler de söz konusudur. Yardımcı işlemcilerin adreslerine genel olarak "port numaraları" denilmektedir. O halde bizim bir yardımcı işlemciyi programlayabilmemiz için şu bilgileri 
    biliyor olmamız gerekir:

    1) Yardımcı işlemci normal IO mu yoksa Memory Mapped IO mu kullanmaktadır?
    2) Yardımcı işlemcinin port numaraları (ya da memory mappe dio için adres numaraları) nedir?
    3) Bu yardımcı işlemcinin hangi portunahangi değerler gönderildiğinde bu işlemci ne yapacaktır?
    4) İşlemci bana bilgi verecekse hangi porttan vermektedir. Bilginin biçimi nedir?
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    İşlemcilerin IN, OUT gibi makine komutları "özel (privileged)" komutlardır. Bunlar user moddan kullanılırsa işlemci koruma mekanizması gereği
    bir içsel kesme oluşturur, işletim sistemi de bu kesme kodunda prosesi sonlandırır. Dolayısıyla bu komutları kullanarak donanım aygıtlarıyla konuşabilmek için
    kernel mod aygıt sürücü yazmak gerekir. 
    
    Aygıtlara erişmekte kullanılan komutlar CPU mimarisine göre değişebildiği için Linux çekirdeğinde bunlar için ortak arayüze sahip fonksiyonlar (makrolar) bulundurulmuştur. 
    Bu fonksiyonlar (ya da makrolar) şunlardır:

    unsigned char inb(int addr);
    unsigned short inw(int addr);
    unsigned int inl(int addr);

    void outb(unsigned char b, int addr);
    void outw(unsigned short b, int addr);
    void outl(unsigned int b, int addr);

    inb yardımcı işlemciden 1 byte, inw 2 byte, inl 4 byte okumak için kullanılmaktadır. Benzer biçimde yardımcı işlemcilere outb 1 byte, outw 2 byte ve outl 4 byte göndermek
    için kullanılır. 

    Bazı mimarilerde bir bellek adresinden başlayarak belli bir sayıda byte'ı belli bir porta gönderen ve belli bir prottan yapılan okumaları belli bir adresten itibaren belleğe 
    yerleştiren özel makine makumtları vardır. Bu komutlara string komutları denilmektedir. (Intel'de string komutları yalnızca IO ile ilgili değildir.) İşte bu komutlara sahip
    mimarilerde bu string komutlarıyla IN, OUT yapan kernel fonksiyonları da bulundurulmıştur:

    void insb(unsigned long addr, void *buffer, unsigned int count);
    void insw(unsigned long addr, void *buffer, unsigned int count);
    void insl(unsigned long addr, void *buffer, unsigned int count);

    void outsb(unsigned long addr, const void *buffer, unsigned int count);
    void outsw(unsigned long addr, const void *buffer, unsigned int count);
    void outsl(unsigned long addr, const void *buffer, unsigned int count);

    insb, insw ve insl sırasıyla 1 byte 2 byte ve 4 byte'lık sitring fonksiyonlarıdır. Bu fonksiyonlar birinci parametresiyle belirtilen port numarasından 1, 2 ya da 4 byte'lık bilgileri
    ikinci parametresinde belirtilen adresten itibaren belleğe yerleştirir. Bu işlemi de count kere tekrar eder. Yani bu fonksiyonlar porttan count defa okuma yapıp okunanları buffer
    ile belirtilen adresten itibaren belleğe yerleştirmektedir. outsb, outsw ve outsl fonksiyonları bu işlemin tam tersini yapmaktadır. Yani bellekte bir adresten başlayarak count tane byte'ı
    birinci parametresiyle belirtilen port'a yerleştirmektedir. 

    Bir haberleşme portu ile çalışmadan önce o portun boşta olup olmadığını belirlemek gerekebilir. Çünkü başka aygıtların kullandığı port'lara erişmek sorunlara yol açabilmektedir. 
    Tabii eğer biz emin isek başkasının kullandığı port'u kullanabiliriz. Yani böylesi bir durum çekirdek tarafından kontrol edilmemektedir. İşte kullanmadan önce bir portun sorgulanması 
    için request_region isimli kernek fonksiyonu kullanılmaktadır.

    struct resource *request_region(unsigned long first, unsigned long n, const char *name);

    Fonksiyonun birinci parametresi kullanılmak istenen port numarasının başlangıç adresini, ikinci parametresi sayısını, üçüncü parametresi ise /proc/ioports dosyasına görüntülenecek
    ismi belirtir. Fonksiyon başarı durumunda portları betimleyen resource isimli yapının başlangıç adresine başarısızlık durumunda NULL adrese geri dönmektedir. request_region
    fonksiyonu ile tahsis edilen port release_region foksiyonu ile serbest bırakılmalıdır:

    void release_region(unsigned long start, unsigned long n);

    Yukarıda da belirttiğimiz gibi portların kullanılması için bu biçimde tahsisat yapma zorunluluğu yoktur. Ancak programcı programlanabilir IO portları için başkalarının kullanmadığı port
    numaralarından emin olmak için bu yöntemi izleemelidir. 

    Bazı sistemlerde aygıtlar yavaş kalabilmektedir. Yani bus çok hızlı aygıt yavaş ise o aygıt port'larına peşi sıra bilgiler gönderilip alınırken sorunlar oluşabilmektedir. 
    Bunun için bilgiyi porta gönderdikten ya da bilgiyi port'tan aldıktan sonra kısa bir süre bekleme yapmak gerekebilir. İşte bu nedenle yukarıdaki fonksiyonların bekleme yapan p'li (pause) versiyonları da bulundurulmuştur. 

    unsigned char inb_p(int addr);
    unsigned short inw_p(int addr);
    unsigned int inl_p(int addr);

    void outb_p(unsigned char b, int addr);
    void outw_p(unsigned short b, int addr);
    void outl_p(unsigned int b, int addr);

---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------

    8042 Klavye denetleyicisinin 60H ve 64H numaralı iki port'u vardır. 60H portu hem okunabilir hem de yazılabilir durumdadır. 60H portu 1 byte olarak okunduğunda 
    son basılan ya da çekilen tuşun klavye scan kodu elde edilmektedir. Klavye terminolojisinde tuşa basılırken oluşturulan scan koduna "make code", parmak tuştan
    çekildiğinde oluşturulan koda ise "break code" denilmektedir. Elde edilen 1 byte kodun 7 biti scan kodunu son biti ise kodun make kod mu yoksa break kod mu olduğunu belirtmektedir. 

    Klavye denetleyicisi kablo ya da USB yoluyla klavye içerisindeki işlemciye bağlıdır. Aslında klavyenin ışıklarının yakılması gibi, typematic hızının ayarlanması gibi işlemler
    klavyenin içerisindeki işlemci tarafından yapılmaktadır. Ancak klavyenin içerisindeki işlemci klavye denetleyicisinden uygun komutlar geldiğinde bunları yapar. Yani aslında örneğin
    Caps Lock tuşuna basıldığında bu tuşun ışığı o anda yakılmamaktadır. Bu tuşun make kodu klavye denetleyicisine iletilir. Klavye denetleyicisi IRQ1 kesmesini oluşturur. İşletim sistemi
    bu kesme kodu içerisinde basılan tuşun Caps Lock olduğunu anlar 60H portuna komut gönderir. Klavye denetleyicisi de bu komutu klavye içerisindeki işlemciye iletir. Işığı klavye içerisindeki
    işlemci yakar. 

    Klavye denetleyicisinin 60H portuna gönderilen 1 byte değere "keyboard encoder command" denilmektedir. Bu 1 byte'lık komut klavye denetleyicisi tarafından klavye içerisinde işlemciye gönderilir. 
    Ancak bu 1 byte'tan sonra bazı komutlar parametre almaktadır. Parametre de yine 60H portuna komut sonra 1 byte yollanarak gönderilmeketdir. 

---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Kesme kodlarının en çok yaptığı şey bir yerden bilgiyi alıp (örneğin network kartından, seri porttan, klavye denetleyicisinden) onu bir yere yerleştirip, 
    uyuyan thread'leri uyandırmaktır. Aşağıdaki örnekte aygıt sürücüye bir IOCTL komutu veridliğinde thread'i uyutan, klavyeden bir tuşa basıldığında kesme kodu yoluyla
    uyuyan prosesleri uyandıran bir örnek verilmiştir. Basılan tuşun scan kodu ioctl fonksiyonunun geri dönüş değeri biçiminde user mod programa iletilmektedir. 
---------------------------------------------------------------------------------------------------------------------------*/

/* keyboard-driver.c */

#include <linux/module.h>
#include <linux/kernel.h>
#include <linux/fs.h>
#include <linux/cdev.h>
#include <linux/interrupt.h>

#define KEYBOARD_MAGIC       'k'
#define IOC_GETKEY           _IOR(KEYBOARD_MAGIC, 0, int)

MODULE_LICENSE("GPL");
MODULE_DESCRIPTION("General Character Device Driver");
MODULE_AUTHOR("Kaan Aslan");

static irqreturn_t keyboard_irq_handler(int irq, void *dev_id);
static long keyboard_ioctl(struct file *filp, unsigned int cmd, unsigned long arg);

static dev_t g_dev;
static struct cdev *g_cdev;
static struct file_operations g_file_ops = {
    .owner = THIS_MODULE,
    .unlocked_ioctl = keyboard_ioctl,
};
static DECLARE_WAIT_QUEUE_HEAD(g_wq);
static int g_key;

static int __init generic_init(void)     
{
    int result;
    
    if ((result = alloc_chrdev_region(&g_dev, 0, 1, "keyboard-driver")) < 0) {
        printk(KERN_INFO "Cannot alloc char driver!...\n");
        return result; 
    }

    if ((g_cdev = cdev_alloc()) == NULL) {
        printk(KERN_INFO "Cannot allocate cdev!..\n");
        return -ENOMEM;
    }

    g_cdev->owner = THIS_MODULE;
    g_cdev->ops = &g_file_ops;
    
    if ((result = cdev_add(g_cdev, g_dev, 1)) != 0) {
        unregister_chrdev_region(g_dev, 1);
        printk(KERN_INFO "Cannot add charecter device driver!...\n");
        return result;
    }

    if ((result = request_irq(1, keyboard_irq_handler, IRQF_SHARED, "generic-char-driver-irq", &g_cdev)) != 0) {
        printk(KERN_ERR "interrupt couldn't registered!..\n");
        return result;
    }

    printk(KERN_INFO "Module initialized with %d:%d device number...\n", MAJOR(g_dev), MINOR(g_dev));

    return 0;
}

static irqreturn_t keyboard_irq_handler(int irq, void *dev_id)
{
    int key;

    if (g_key != 0)
        return IRQ_NONE;

    key = inb(0x60);
    if (key & 0x80)
        return IRQ_NONE;

    g_key = key;
    wake_up_all(&g_wq);

    return IRQ_HANDLED;
}

static long keyboard_ioctl(struct file *filp, unsigned int cmd, unsigned long arg)
{
    switch (cmd) {
        case IOC_GETKEY:
            g_key = 0;
            if (wait_event_interruptible(g_wq, g_key != 0))
                return -ERESTARTSYS;

            return g_key;
        default:
            return -ENOTTY;       
    }
}

static void __exit generic_exit(void)
{
    free_irq(1, &g_cdev);
    cdev_del(g_cdev);
    unregister_chrdev_region(g_dev, 1);
    printk(KERN_INFO "Goodbye...\n");
}

module_init(generic_init);  
module_exit(generic_exit);

obj-m += $(file).o

all: 
	make -C /lib/modules/$(shell uname -r)/build M=${PWD} modules
clean:
	make -C /lib/modules/$(shell uname -r)/build M=${PWD} clean

/* keyboard-ioctl.h */

#ifndef KEYBOARD_IOCTL_H_
#define KEYBOARD_IOCTL_H_

#define KEYBOARD_MAGIC       'k'
#define IOC_GETKEY           _IOR(KEYBOARD_MAGIC, 0, int)

#endif

/* sample.c */

#include <stdio.h>
#include <stdlib.h>
#include <fcntl.h>
#include <unistd.h>
#include <sys/ioctl.h>
#include "keyboard-ioctl.h"

void exit_sys(const char *msg);

int main(void)    
{
    int fd;
    ssize_t n;
    int scode;
    
    if ((fd = open("keyboard-driver", O_RDONLY)) == -1) 
        exit_sys("open");

    printf("press any key to continue...\n");
    if ((scode = ioctl(fd, IOC_GETKEY)) < 0) 
        exit_sys("ioctl");

    printf("Scan code: %d\n", scode);

    close(fd);

    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

#!/bin/bash

module=$1
mode=666

/sbin/insmod ./$module.ko ${@:2} || exit 1
major=$(awk "\$2 == \"$module\" {print \$1}" /proc/devices)
rm -f $module
mknod $module c $major 0
chmod $mode $module

/*--------------------------------------------------------------------------------------------------------------------------
    Aşağıdaki örnekte IOC_SETLIGHTS ioctl komutu ile 8042 klavye denetleyicine komut gönderme yoluyla klavye ışıkları yakılıp söndürülmektedir. 
    Klavyede üç ışıklı tuş vardır: Caps-Lock, Num-Lock ve Scroll_Lock. Bu ışıkları yakıp söndürebilmek için önce 60h portuna 0xED komutu gönderilir. 
    Sonra yine 60h portuna ışıkların durumunu belirten 1 byte gönderilir. Bu byte'ın düşükj anlamlı 3 biti sırasıyla Scroll-Lock, Num-Lock ve Caps-LOck
    tuşlarının ışıklarını belirtmektedir. 60h portuna kout göndermeden önce 64h portundan elde edilen değerin 2 numaralı bitinin 0 olması gerekmektedir. 
    Ayrıntılı bilgi için http://www.brokenthorn.com/Resources/OSDev19.html sayfasını inceleyebilirsiniz.
---------------------------------------------------------------------------------------------------------------------------*/

/* keyboard-driver.c */

#include <linux/module.h>
#include <linux/kernel.h>
#include <linux/fs.h>
#include <linux/cdev.h>
#include <linux/interrupt.h>

#define KEYBOARD_MAGIC       'k'
#define IOC_GETKEY           _IOR(KEYBOARD_MAGIC, 0, int)
#define IOC_SETLIGHTS        _IOR(KEYBOARD_MAGIC, 1, int)

MODULE_LICENSE("GPL");
MODULE_DESCRIPTION("General Character Device Driver");
MODULE_AUTHOR("Kaan Aslan");

static irqreturn_t keyboard_irq_handler(int irq, void *dev_id);
static long keyboard_ioctl(struct file *filp, unsigned int cmd, unsigned long arg);
static void keyboard_lights(long arg);

static dev_t g_dev;
static struct cdev *g_cdev;
static struct file_operations g_file_ops = {
    .owner = THIS_MODULE,
    .unlocked_ioctl = keyboard_ioctl,
};
static DECLARE_WAIT_QUEUE_HEAD(g_wq);
static int g_key;

static int __init generic_init(void)     
{
    int result;
    
    if ((result = alloc_chrdev_region(&g_dev, 0, 1, "keyboard-driver")) < 0) {
        printk(KERN_INFO "Cannot alloc char driver!...\n");
        return result; 
    }

    if ((g_cdev = cdev_alloc()) == NULL) {
        printk(KERN_INFO "Cannot allocate cdev!..\n");
        return -ENOMEM;
    }

    g_cdev->owner = THIS_MODULE;
    g_cdev->ops = &g_file_ops;
    
    if ((result = cdev_add(g_cdev, g_dev, 1)) != 0) {
        unregister_chrdev_region(g_dev, 1);
        printk(KERN_INFO "Cannot add charecter device driver!...\n");
        return result;
    }

    if ((result = request_irq(1, keyboard_irq_handler, IRQF_SHARED, "generic-char-driver-irq", &g_cdev)) != 0) {
        printk(KERN_ERR "interrupt couldn't registered!..\n");
        return result;
    }

    printk(KERN_INFO "Module initialized with %d:%d device number...\n", MAJOR(g_dev), MINOR(g_dev));

    return 0;
}

static irqreturn_t keyboard_irq_handler(int irq, void *dev_id)
{
    int key;

    if (g_key != 0)
        return IRQ_NONE;

    key = inb(0x60);
    if (key & 0x80)
        return IRQ_NONE;

    g_key = key;
    wake_up_all(&g_wq);

    return IRQ_HANDLED;
}

static long keyboard_ioctl(struct file *filp, unsigned int cmd, unsigned long arg)
{
    switch (cmd) {
        case IOC_GETKEY:
            g_key = 0;
            if (wait_event_interruptible(g_wq, g_key != 0))
                return -ERESTARTSYS;

            return g_key;
        case IOC_SETLIGHTS:
            keyboard_lights(arg);
            break;

        default:
            return -ENOTTY;       
    }
    return 0;
}

static void send_keyboard_encoder(uint8_t cmd) 
{
	while ((inb(0x64) & 2) != 0)
		;
	outb(cmd, 0x60);
}

static void keyboard_lights(long arg) 
{
	send_keyboard_encoder(0xED);
	send_keyboard_encoder((uint8_t) arg);
}

static void __exit generic_exit(void)
{
    free_irq(1, &g_cdev);
    cdev_del(g_cdev);
    unregister_chrdev_region(g_dev, 1);
    printk(KERN_INFO "Goodbye...\n");
}

module_init(generic_init);  
module_exit(generic_exit);

obj-m += $(file).o

all: 
	make -C /lib/modules/$(shell uname -r)/build M=${PWD} modules
clean:
	make -C /lib/modules/$(shell uname -r)/build M=${PWD} clean

/* keyboard-ioctl.h */

#ifndef KEYBOARD_IOCTL_H_
#define KEYBOARD_IOCTL_H_

#define KEYBOARD_MAGIC       'k'
#define IOC_GETKEY           _IOR(KEYBOARD_MAGIC, 0, int)
#define IOC_SETLIGHTS        _IOR(KEYBOARD_MAGIC, 1, int)

#endif

/* sample.c */

#include <stdio.h>
#include <stdlib.h>
#include <fcntl.h>
#include <unistd.h>
#include <sys/ioctl.h>
#include "keyboard-ioctl.h"

void exit_sys(const char *msg);

int main(void)    
{
    int fd;
    ssize_t n;
    
    if ((fd = open("keyboard-driver", O_RDONLY)) == -1) 
        exit_sys("open");

    if (ioctl(fd, IOC_SETLIGHTS, 0x7) != 0) 
        exit_sys("ioctl");

    close(fd);

    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}


#!/bin/bash

module=$1
mode=666

/sbin/insmod ./$module.ko ${@:2} || exit 1
major=$(awk "\$2 == \"$module\" {print \$1}" /proc/devices)
rm -f $module
mknod $module c $major 0
chmod $mode $module

/*--------------------------------------------------------------------------------------------------------------------------
  Aslında IO portları Linux sistemlerinde user mod programlar tarafından da /dev/port isimli karakter aygıt sürücüsü yoluyla da
  kullanılabilmektedir. Ancak bu aygıt sürücünün read ve/veya write modda açılabilmesi için prosrdin etkin kullanıcı id'sinin 0 olması 
  gerekmektedir. (Yani böyle programları sudo yaparak çalıştırmalıyız.)

  Bu kullanım için aygıt sürücü user moddan open fonksiyonuyla açılır. Her byte bir portu beirtmektedir. lseek fonksiyonu ile ilgili porta dosya göstericisi
  konumlandırılır. Sonra read/write işlemi uygulanır. 

  /dev/mem isimli karakter aygıt sürücüsü de fiziksel belleğe erişmek için kullanılmaktadır. Bu aygıt sürücü açılıp lseek ile belli bir offset'e konumlanılırsa
  okuma ya da yazma işlemi konumlandırılan offset fiziksel adres belirtecek biçimde doğrudan fiziksel RAM'e yapılmaktadır. /dev/kmem aygıt sürücüsü benzer biçimdedir. Ancak 
  adresler fiziksel değil sanal adres belirtmektedir. 
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Derleyiciler ve işlemciler tarafından yapılan önemli bir optimizasyon temasına "komutların yer değiştirilmesi (instruction reordering)"
    denilmektedir. Bu optimizasyon derleyici tarafından da bizzat işlemcinin kendisi tarafından da yapılabilmektedir. Burada biribirlerini normal
    bir durumda etkilemeyecek iki ya da daha fazla ayrı makine komutunun yerleri daha hızlı çalışma sağlamak için değiştirilmektedir. 
    Bu tür yer değiştirmeler normak user mod programlarda hiçbir davranış değişiklğine yol açmazlar. Ancak işletim sistemi ve aygıt sürücü kodlarında
    ve özellikle IO portlarına erişim söz konusu olduğunda bu optimizasyon olumsuz yan etkilere yol açabilmektedir. Örneğin birbirleriyle alakasız iki adrese
    yazma yapılması durumunda yazma komutlarının yer değiştirmesi işlemcinin bu işleri daha hızlı yapabilmesine yol açabilmektedir. Fakat IO portları ve Memory mapped IO 
    söz konusu olduğunda bu sıralama değişikliği istenmeyen olumsuz sonuçlar doğurabilmektedir. İşte bu yer dğeiştimeyi ortadan kaldırmak için bariyer koyma yöntemi
    uygulanmaktadır. Bariyerin yukarısı ve aşağısı derleyici ve işlemci tarafından yer değiştiremez. 

    void rmb(void);
    void wmb(void);
    void mb(oid);

    rmb fonksiyonun aşağısanki kodlar yukarısındaki okuma işlemleri yapıldıktan sonra yapılırlar. wmb fonksiyonun ise yukarısındaki yazma işlemleri yapıldıktan sonra aşağıdaki işlemler 
    yapılırlar. mb fonksiyonu ise hem okuma hem yazma için yukarıdaki ve aşağıaki kodları birbirlerinden ayırmaktadır. Örneğin PORT1 portuna yazma yapıldıktan sonra
    PORT2 portuna yazma yapılacak olsun. Şöyle bir bariyer kullanmalıyız:

    outb(cmd1, port1);
    wmb();
    outb(cmd2, port2);

---------------------------------------------------------------------------------------------------------------------------*/


/*--------------------------------------------------------------------------------------------------------------------------
    Memory Mapped IO işlemi pek çok mimaride göstericilerle yapılabilmektedir. Yani aslında bu mimarilerde bunlar için özel kernel fonksiyonlarının
    kullanılmasına gerek yoktur. Ancak bazı mimarilerde memory mapped io işlemi için özel bazı işlemlerin de yapılması gerekebilmektedir. Bu nedenle bu işlemlerin
    taşınabilir yapılabilmesi için özel kernel fonksiyonlarının kullanılması tavsiye edilir. 

    Tıpkı normal IO işlemlerinde olduğu gibi memory-mapped-io için de iki farklı aygıt aynı adres bölgesini kullanmasın diye bir registration işlemi
    yapılabilmektedir. Bu işlemler request_mem_region ve release_mem_region fonksiyonlarıyla yapılmaktadır:

    struct resource *request_mem_region(unsigned long start, unsigned long len, const char *name);

    Fonksiyonun birinci parametresi başlangıç bellek adresini, ikinci parametresi alanın uzunluğunu belitmektedir. Üçüncü parametre /proc/iomem dosyasında görüntülenecek isimdir. 
    Fonksiyon başarı durumunda resource isimli bir yapı adresine, başarısızlık durumunda NULL adrese geri dönmektedir. 

    void release_mem_region(unsigned long start, unsigned long len);

    Fonksiyon daha önce rgister ettirilmiş olan bellek bölgesini register ettirilmemiş hale getirmektedir. Mamory mapped IO ile belirtilen bellek 
    alanına erişmek için kullanılan fonksiyonlar da şunlardır:

    unsigned int ioread8(void *addr);
    unsigned int ioread16(void *addr);
    unsigned int ioread32(void *addr);

    Bu fonksiyonlar addr ile belirtilen bellek adresinde 1 byte, 2 byte ve 4 byte okurlar. 

    void iowrite8(u8 value, void *addr);
    void iowrite8(u16 value, void *addr);
    void iowrite8(u32 value, void *addr);

    Yukarıdaki fonksiyonların rep'li versyonları da vardır:

    void ioread8_rep(void *addr, void *buf, unsigned long count);
    void ioread16_rep(void *addr, void *buf, unsigned long count);
    void ioread32_rep(void *addr, void *buf, unsigned long count);

    Bu fonksiyonlar count kere aynı addr adresinden 1 byte, 2 byte ve 4 byte okuyarak buf adresine yerleştirme yapmaktadır. 

    void iowrite8_rep(void *addr, const void *buf, unsigned long count);
    void iowrite16_rep(void *addr, const void *buf, unsigned long count);
    void iowrite32_rep(void *addr, const void *buf, unsigned long count);

    Bu fonksiyonlar da ikinci parametreiyle belirtilen adresten başlayarak count kadar 1 byte, 2 byte, 4 byte'lık bilgileri hep birinci parametreyle belşrtşlen adrese 
    aktarmaktadır. Bir de blok kopyalaması yapan fonksiyonlar vardır:

    void memcpy_fromio(void *dest, const void *source, unsigned int count);
    void memcpy_toio(void *dest, const void *source, unsigned int count);

    Belli bir adresten itibaresn n byte dolduran fonksiyon da şöyledir:

    void memset_io(void *dest, u8 value, unsigned int count);

    Aygıtın kullandığı bellek adresi genellikle fiziksel adrestir. Örneğin aygıt 0xFFFF8000 gibi bir adresi kullanıyorsa bu genellikle fiziksel adrestir. Halbuki 
    aygıt sürücünün bu fiziksel adrese erişebilmesi için bu dönüşümü yapacak sayfa tablosu girişlerin olması gerekir. İşte bu girişleri elde edebilmek için şu fonksiyonlar
    bulundurulmuştur:

    void *ioremap(unsigned long physical_address, unsigned long size);

    Bu fonksiyon fiziksel adrese erişebilmek için gereken sayfa tablosu adresini bize verir. Gerçi genellikle fiziksel RAM daha önceden de belirtildiği gibi Linux'ta
    sanal belleğin PAGE_OFFSET ile belirtilen kısmından başlanarak map edilmiştir. 

    Bu işlemi geri almak için iounmap fonksiyonu kullanılmaktadır:

    void iounmap(voi,d *addr);

---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Derleyiciler ve işlemciler tarafından yapılan önemli bir optimizasyon temasına "komutların yer değiştirilmesi (instruction reordering)"
    denilmektedir. Bu optimizasyon derleyici tarafından da bizzat işlemcinin kendisi tarafından da yapılabilmektedir. Burada biribirlerini normal
    bir durumda etkilemeyecek iki ya da daha fazla ayrı makine komutunun yerleri daha hızlı çalışma sağlamak için değiştirilmektedir. 
    Bu tür yer değiştirmeler normak user mod programlarda hiçbir davranış değişiklğine yol açmazlar. Ancak işletim sistemi ve aygıt sürücü kodlarında
    ve özellikle IO portlarına erişim söz konusu olduğunda bu optimizasyon olumsuz yan etkilere yol açabilmektedir. Örneğin birbirleriyle alakasız iki adrese
    yazma yapılması durumunda yazma komutlarının yer değiştirmesi işlemcinin bu işleri daha hızlı yapabilmesine yol açabilmektedir. Fakat IO portları ve Memory mapped IO 
    söz konusu olduğunda bu sıralama değişikliği istenmeyen olumsuz sonuçlar doğurabilmektedir. İşte bu yer dğeiştimeyi ortadan kaldırmak için bariyer koyma yöntemi
    uygulanmaktadır. Bariyerin yukarısı ve aşağısı derleyici ve işlemci tarafından yer değiştiremez. 

    void rmb(void);
    void wmb(void);
    void mb(oid);

    rmb fonksiyonun aşağısanki kodlar yukarısındaki okuma işlemleri yapıldıktan sonra yapılırlar. wmb fonksiyonun ise yukarısındaki yazma işlemleri yapıldıktan sonra aşağıdaki işlemler 
    yapılırlar. mb fonksiyonu ise hem okuma hem yazma için yukarıdaki ve aşağıaki kodları birbirlerinden ayırmaktadır. Örneğin PORT1 portuna yazma yapıldıktan sonra
    PORT2 portuna yazma yapılacak olsun. Şöyle bir bariyer kullanmalıyız:

    outb(cmd1, port1);
    wmb();
    outb(cmd2, port2);

---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Blok aygıt sürücüleri (block device drivers) disk benzeri birimlerden bloklu okuma ve yazma yapabilmek için kullanılan özel aygıt sürücülerdir. 
    Disk benzeri birimlerden bir hamlede okunabilecek ya da yazılabilecek bilgi miktarına "sektör" denilmektedir. Yani bu tür aygıtlar transferi 
    byte byte değil blok blok yaparlar. Örneğin bir diskten 1 byte okuma bir şey yoktur. Ya da diske 1 yazma diye bir şey yoktur. Diskteki 1 byte dğeiştirilecekse
    önce onun bulunduğu sektör okunur, değişiklik RAM üzerinde yapılır. Sonra o sektör yeniden diske yazılır. Tipik transfer bu adımlardan geçilerek gerçekleştirilmektedir. 
    Bir sektör değişebilse de hemen her zaman 512 byte'tır. 

    İşletim sistemleri bloklu çalışan aygıtlarda erişimi hızlandırmak için ismine "IO çizelgelemesi (IO Scheduling)" denilen bir yöntem uygulamaktadır. 
    Çeşitli prosesler diskten çeşitli sektörleri okumak istediğinde ya da yazmak istediğinde bunlar işletim sistemi tarafından birleşitirlerek disk erişimleri azaltılmaktadır. 
    Disk bilgisayar sistemlerinin en yavaş kısmını oluşturmaktadır. SSD diskler bile yazma bakımından RAM'e göre binlerce kat yavaştır. İşte işletim sistemleri aslında ayrık olan
    birtakım okuma yazma işlemlerini diskte mümkğn olduğunda ardışıl hale getirerek disk erişiminden kaynaklanan zaman kaybını minimize etmeye çalışır. Disk sistemlerinde ayrık işlemler
    yerine peşi sıra blokların tek hamlede okunup yazılması ciddi hız kazancı sağlamaktadır. Farklı proseslerin sektör okuma istekleri aslında bazen birbirine yakın bölgelerde gerçekleşit.r
    İşte onların yniden sıralanması gibi faaliyetler IO çizelgeleycisinin önemli görevleerindendir. 

    Blok aygıt sürücüleri bazı bakımlardan karakter aygıt aygıt sürücülerine benzese de bu IO çizelgelemesi yüzünden tasarımsal farklılıklara sahiptir. Karakter aygıt sürücülerinde
    her read ve write işlemi için bir IO çizelgelemesi yapılmadan aygıt sürücünün fonksiyonları çağrılmaktadır. Çünkü karakter aygıt srücülerinde neticede disk gibi zaman alıcı birimler
    ile uğraşılmamaktadır. 
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Blok aygıt srücünde de ilk yapılacak işlem blok aygıt sürücüsünün bir isim altında aygıt numarası belirtilerek register ettirilmesidir. 
    Bu işlem register_blkdev fonkiyonuyla yapılmaktadır:

    int register_blkdev(unsigned int major, const char *name);

    Fonksiyonun birinci parametresi aygıtın majör numarasını belirtir. Eğer majör numara olarak 0 geçilirse fonksiyon boş bir majör numarayı kendisi tahsis etmektedir. 
    Fonksiyon başarı durumunda majör numaraya başarısızlık durumunda negatif error koduna geri dönmektedir. İkinci parametre aygıt sürücünün /proc/devices dosyasında görüntülenecek
    ismini belirtmektedir. 

    Modül boşaltılırken bu işlemin geri alınması için unregister_blkdev fonksiyonu kullanılmaktadır:

    void unregister_blkdev(unsigned int major, const char *name);

    Fonksiyonun parametrik yapısı register_blkdev fonksiyonuyla tamamen aynıdır. 

---------------------------------------------------------------------------------------------------------------------------*/

/* generic-bdriver.c */

#include <linux/module.h>
#include <linux/kernel.h>
#include <linux/fs.h>

MODULE_LICENSE("GPL");
MODULE_DESCRIPTION("General Block Device Driver");
MODULE_AUTHOR("Kaan Aslan");

int g_major = 0;

static int __init generic_init(void)     
{  
    if ((g_major = register_blkdev(g_major, "generic-bdriver")) < 0) {
        printk(KERN_ERR "Cannot register block driver!..\n");
        return g_major;
    }

    printk(KERN_INFO "Module initialized with major number %d...\n", g_major);

    return 0;
}

static void __exit generic_exit(void)
{
    unregister_blkdev(g_major, "generic-bdriver");

    printk(KERN_INFO "Goodbye...\n");
}

module_init(generic_init);  
module_exit(generic_exit);

obj-m += $(file).o

all: 
	make -C /lib/modules/$(shell uname -r)/build M=${PWD} modules
clean:
	make -C /lib/modules/$(shell uname -r)/build M=${PWD} clean


obj-m += $(file).o

all: 
	make -C /lib/modules/$(shell uname -r)/build M=${PWD} modules
clean:
	make -C /lib/modules/$(shell uname -r)/build M=${PWD} clean


/*--------------------------------------------------------------------------------------------------------------------------
    Blok aygıt sürücülerine deneme amaçlı verilebilecek en iyi örneklerden birisi "ramdisk"lerdir. Ramdisk pek çok sistemde bulunan
    RAM'in sanki disk gibi kullanılmasını sağlayan bir organizasyondur. Örneğin proc ve sys dosya sistemleri de aslında birer ramdisk gibidir. 
    Ramdisk'ler geçici dosyaların hızlı bir biçimde oluşturulabilmesi için özellikle tercih edilmektedir. Bazı UNIX sistemlerde geçici dosyaların
    yaratıldığı /temp dizinleri ramdisk biçiminde oluşturulmuştur. (Örneğin Linux sistemlerinde /tmp dizini tmpfs isimli bir blok aygıt sürücüsü ile kontrol edilmektedir. 
    Ramdisk'ler tipik blok aygıt sürücüleridir. Çünkü diski taklite etmektedirler. 
---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Blok aygıt sürücülerini tasarlarken aygıt sürücüye ilişkin bilgilerin yine bir yapı biçiminde organize edilmesi ve bilgilerin
    bu yapının elemanlarında saklanması uygun olur. Böylece birden fazla minör numara ile çalışılırken bu yapı nesneleri dinamik 
    bir biçimde tahsis edilebilir ve fonksiyonlara parametre yoluyla aktarılabilir. Örneğin bir Ramdisk uygulaması için blok aygıt sürücü bilgileri
    aşağıdaki bir yapıyla temsil edilebilir:

    struct BLOCKDEV {
        spinlock_t sl;
        struct gendisk *gdisk;
        struct request_queue rq;
        void *data;
        size_t capacity;
    };

    Bu yapı türünden nesne global olarak alınabileceği gibi kmalloc fonksiyonuyla da dinamik biçimde tahsis edilebilir. 

    Blok aygıt sürücüleri için en önemli nesne gendisk nesnesidir. Blok aygıt sürücüsünü kernel'da bu nesne ile temsil edilmektedir. 
    gendisk besbesi alloc_disk isimli fonksiyonla tahsis edilir:

    struct gendisk *alloc_disk(int minors);

    Fonksiyon parametre olarak aygıt sürücünün destekleyeceği minör numara sayısını almaktadır. Geri dönüş değeri de diski temsil eden gendisk isimli
    yapı nesnesinin adresidir. (Birden fazla minör numaranın söz konusu olduğu durumda geri döndürülen adres aslında bir dizi adresidir.) 

    alloc_disk fonksiyonu ile elde edilen nesne add_disk ile sisteme eklenmelidir:

    void add_disk(struct gendisk *disk);


    alloc_disk ve add_disk fonksiyonuyla tahsis edilen sisteme yerleştirilen gendisk nesnesi del_gendisk fonksiyonuyla serbest bırakılmaktadır:

    void del_gendisk(struct gendisk *gdisk);

    Örneğin:

    if ((g_bdev->gdisk = alloc_disk(1)) == NULL) {
        result = -ENOMEM;
        goto EXIT2;
    }
    ....

    add_disk(g_bdev->gdisk);
    
    alloc_disk ile elde edilen gendisk nesnesinin içinin doldurulması gerekmektedir. Bu yapının doldurulması gereken elemanları şunlardır:

    - Yapının major isimli elemanına aygıt sürücünün majör numarası yerleştirilmelidir. 
    - Yapının first_minor elemanına aygıt sürücünün minör numarası yerleştirilmelidir (Tipik olarak 0).
    - Yapının flags elemanına duruma göre bazı bayraklar girilebilmektedir. Öreğin ramdisk için bu bayrak GENHD_FL_NO_PART_SCAN biçiminde girilebilir. 
    - Yapının fops elemanına aygıt sürücü açıldığında, kapatıldığında, ioctl işlemi sırasında vs. çağrılacak fonksiyonların bulunduğuğu block_device_operations isimli yapının adresi 
    atanmalıdır. Bu yapı karakter aygıt sürücülerindeki file_operations yapısına benzetilebilir. Yapıının iki önemli elemanı open ve release elemanlarıdır. Burada belirtilen fonksiyonlar
    aygıt sürücü açıldığında ve her kapatıldığında çağrılmaktadır. 
    - Yapının queue elemanına programcı tarafından yaratılacak olan request_queue nesnesinin adresi atanmalıdır. request_queue aygıt sürücüden read/write işlemi yapıldığında
    kernel'ın IO çizelgeleyici alt sistemi tarafından optimize edilen işlemlerin yerleştirileceği kuyruk sistemidir. Programcı ileride görüleceği üzere bu kuyruk sisteminden 
    istekleri alarak yerine getirir. Maalesef bu kuyruğun yaratılması ve işleme sokulması için gerekli kernel fonksiyonları kernel'ın çeşitli versiyonlarında değiştirilmiştir. 
    Kurs 4.15 kernel'ı ile yapılmaktadır. Buradaki fonksiyonlar 5'li kernel'larda yeniden değiştirilmiş durumdadır. Fakat biz şimdilik burada mevcut kernel üzerinde işlem yapacağız.
    Bu kernel'larda kuyruk yaratmak için 2.6'dan beri blk_init_queue fonksiyonu kullanılmaktadır:

    struct request_queue *blk_init_queue(request_fn_proc *rfn, spinlock_t *lock);

    Fonksionun birinci parameresi kernel tarafından IO işlemi yapılacağı zaman çağrılacak fonksiyonun adresini almaktadır. Bu fonksiyonun parametrik yapısı şöyle olmalıdır:

    void request_proc(request_queue *rq)
    {
        ....
    }

    blk_init_queue fonksiyonunun ikinci paarametresi kernel'ın kuyruğa erişirken kullanacağı spinlock nesnesinin adresidir. Programcı bunesneyi kendisi oluişturup 
    initialize etmelidir. 

    blk_init_queue fonksiyonuyla yaratılan kuyruk nesnesinin kullanım bittikten sonra cleanup_queue fonksiyonuyla boşaltılması gerekmektedir:

    void blk_cleanup_queue(struct request_queue *rq);

    - Oluşturulan blok aygıtının (diskin) kapasitesinin de belirtilmesi gerekmektedir. Bu işlem doğrudan değil set_capacity fonksiyonuyla yapılmalıdır:

    void set_capacity(struct gendisk *disk, sector_t size);

    Fonksiyonun birinci parametresi gendisk yapısının adresini, ikinci parametresi aygıtın sektör uzunluğunu almaktadır. (Aslında bu fonksiyon gendisk yapısının ilgili elemanını
    set etmektedir.)

    - gendisk yapısının disk_name isimli elemanına disk isminin bulunduğu yazının başlangıç adresi atanmalıdır. Bu isim /sys/block dizinin de görüntülenecek dosya ismini belirtmektedir.

    - Nihayet gendisk yapısının private_data elemanına programcı kendi yapı nesnesinin adresini yerleştirebilir. 


    Aşağıdaki örnekte yukarıda anlatılan kısma kadar olan işlemleri içeren bir blok aygıt sürücü örneği verilmiştir. "load" scriptinde aygıt dosyasının "block" aygıt dosyası
    olarak yaratılması gerektiğine dikkat ediniz. 

---------------------------------------------------------------------------------------------------------------------------*/

/* generic-bdriver.c */

#include <linux/module.h>
#include <linux/kernel.h>
#include <linux/fs.h>
#include <linux/slab.h>
#include <linux/blkdev.h>

#define KERNEL_SECTOR_SIZE      512
#define CAPACITY               (KERNEL_SECTOR_SIZE * 1000)

MODULE_LICENSE("GPL");
MODULE_DESCRIPTION("General Block Device Driver");
MODULE_AUTHOR("Kaan Aslan");

int g_major = 0;

struct BLOCKDEV {
    spinlock_t sl;
    struct gendisk *gdisk;
    struct request_queue *rq;
    size_t capacity;
};

static int generic_open(struct block_device *bdev, fmode_t mode);
static void generic_release(struct gendisk *gdisk, fmode_t mode);
static void request_proc(struct request_queue *rq);

static struct block_device_operations g_devops = {
    .owner = THIS_MODULE,
    .open = generic_open,
    .release = generic_release
};

static struct BLOCKDEV *g_bdev;

static int __init generic_init(void)     
{  
    int result = 0;

    if ((g_major = register_blkdev(g_major, "generic-bdriver")) < 0) {
        printk(KERN_ERR "Cannot register block driver!..\n");
        return g_major;
    }

    if ((g_bdev = kmalloc(sizeof(struct BLOCKDEV), GFP_KERNEL)) == NULL) {
        printk(KERN_ERR "Cannot allocate memory!..\n");
        result = -ENOMEM;
        goto EXIT1;
    }
    memset(g_bdev, 0, sizeof(struct BLOCKDEV));
    g_bdev->capacity = CAPACITY;
    
    spin_lock_init(&g_bdev->sl);
    if ((g_bdev->rq = blk_init_queue(request_proc, &g_bdev->sl)) == NULL) {
        printk(KERN_ERR "Canno allocate queue!..\n");
        result = -ENOMEM;
        goto EXIT2;
    }
    g_bdev->rq->queuedata = g_bdev;
    if ((g_bdev->gdisk = alloc_disk(1)) == NULL) {
        result = -ENOMEM;
        goto EXIT3;
    }
    g_bdev->gdisk->major = g_major;
    g_bdev->gdisk->first_minor = 0;
    g_bdev->gdisk->flags = GENHD_FL_NO_PART_SCAN;
    g_bdev->gdisk->fops = &g_devops;
    g_bdev->gdisk->queue = g_bdev->rq;
    set_capacity(g_bdev->gdisk, g_bdev->capacity >> 9);
    g_bdev->gdisk->private_data = g_bdev;
    strcpy(g_bdev->gdisk->disk_name, "blockdev");

    add_disk(g_bdev->gdisk);

    printk(KERN_INFO "Module initialized with major number %d...\n", g_major);

    return result;

EXIT3:
    blk_cleanup_queue(g_bdev->rq);
EXIT2:
    kfree(g_bdev);
EXIT1:
    unregister_blkdev(g_major, "generic-bdriver");

    return result;
}

static int generic_open(struct block_device *bdev, fmode_t mode)
{
    printk(KERN_INFO "device opened...\n");

    return 0;
}

static void generic_release(struct gendisk *gdisk, fmode_t mode)
{
    printk(KERN_INFO "device closed...\n");
}

static void request_proc(struct request_queue *rq)
{
    /* ... */
}

static void __exit generic_exit(void)
{   
    del_gendisk(g_bdev->gdisk);
    blk_cleanup_queue(g_bdev->rq);
    kfree(g_bdev);
    unregister_blkdev(g_major, "generic-bdriver");

    printk(KERN_INFO "Goodbye...\n");
}

module_init(generic_init);  
module_exit(generic_exit);

obj-m += $(file).o

all: 
	make -C /lib/modules/$(shell uname -r)/build M=${PWD} modules
clean:
	make -C /lib/modules/$(shell uname -r)/build M=${PWD} clean

#!/bin/bash

module=$1
mode=666

/sbin/insmod ./$module.ko ${@:2} || exit 1
major=$(awk "\$2 == \"$module\" {print \$1}" /proc/devices)
rm -f $module
mknod $module b $major 0
chmod $mode $module

/* sample.c */

#include <stdio.h>
#include <stdlib.h>
#include <fcntl.h>
#include <unistd.h>
#include <sys/ioctl.h>
#include "keyboard-ioctl.h"

void exit_sys(const char *msg);

int main(void)    
{
    int fd;
    
    if ((fd = open("generic-bdriver", O_RDONLY)) == -1) 
        exit_sys("open");

    close(fd);

    return 0;
}

void exit_sys(const char *msg)
{
    perror(msg);

    exit(EXIT_FAILURE);
}

/*--------------------------------------------------------------------------------------------------------------------------
    Blok aygıt sürücülerinde yukarıda belirtilen işlemlerden sonra artık transfer işleminin yapılması için bulundurulan fonksiyonun
    (örneğimizde request_proc) yazılması aşamasına geldik. Anımsanacağı gibi user mode ya da kernel mode kodlar tarafından blok transferine yönelik
    bir istek oluşturğunda kernel IO çizelgeleyicisi bunları çizelgeleio uygun bir zamanda transfer edilebilmesi için bizim belirtitğimiz bu fonksiyonu çağırıyordu.
    Yani örneğimizdeki request_proc bizim tarafımızdan değil kernel tarafından callback fonksiyon olarak çağrılmaktadır. Bizim de bu fonksiyon içerisinde kuyruğa
    bırakılmış blok transfer isteklerini kuyruktan alarak gerçekleştirmemiz gerekir. 

    Örneğin bir blok aygıt sürücüsünü user modda open fonksiyonuyla açıp içerisinden 10 byte'ı read fonksiyonuyşa okumak isteyelim. Eğer bu aygıt sürücü karakter aygıt sürücüsü olsaydı 
    kernel doğrudan aygıt sürücünün read fonksiyonunu çağıracaktı. Aygı tüsürücü de tam belirlenen değer olan 10 byte'ı user moddaki adrese transfer edecekti. Halbuki blok aygıt
    sürücüsü durumunda kernel aygıt sürücüden 10 byte transfer istemeyecektir. İlgili 10 byte'ın blunduğu bloğun (block ardışıl n sektördür) transferini isteyecektir. User mod programa
    o bloğun içerisindeki 10 byte'ı vermek kernel'ın görevidir. Şüphesiz kernel 10 byte okuma isteğine konu olan yerin aygıttaki sektör numarasını hesap eder ve o sektörden itibaren
    blok transferi ister. 

    Kernel aygıt sürücünün transfer edeceği blokları bir kuyruk sistemine yerleştirir. Bu kuyruk sistemi request_queue denilen bir yapı ile temsil edilmiştir. Bu kuyruğun 
    içerisindeki kuyruk elemanları request isimli yapı nesnelerinden oluşmaktadır. (Yani request_queue aslında request yapılarının oluşturduğu bir kuyruk sistenidir.) 

    Her request nesnesi kendi içerisinde bio isimli yapı nesnelerinden oluşmaktadır. request nesnesinin içerisindeki bio nesnleri bir bağlı liste biçiminde tutulmaktadır. Her bio yapısının
    sonunda ise değişken sayıda (yani n tane) bio_vec yapıları bulunmaktadır. İşte transfer işini yapacak fonksiyon transfere ilişkin bilgileri bu bio_vec yapısındna elde etmektedir. 

    request_queue: request ---> request ---> request ---> request ....
    request: bio ---> bio ---> bio ---> bio ---> bio --> ...
    bio: bio_vec[N]

    İşte transfer fonksiyonunun kernel tarafından çağrıldığında "request_queue içersindeki request nesnelerine elde edip, bu request nesnelerinin içerisindeki bio nesnelerini elde edip,
    bio nesneleri içerisindeki bio_vec dizisinde belirtilen transfer bilgilerine ilişkin transfeleri" yapması gerekir. Şüphesiz bu işlem ancak açık ya da örtük iç içe 3 döngü ile
    yapılabilir. Yani bir döngü request nesnelerini elde etmeli, onun içerisindeki bir döngü bio nesnelerini elde etmeli, onun içerisindeki bir döngü de bio_vec nesleerini elde etmelidir. 

    request_queue içerisindeki request nesnelerinin elde edilmesi birkaç biçimde yapılabilmektedir. Yöntemlerden tipik olanı şöyledir:


    static void request_proc(struct request_queue *rq)
    {
        struct request *rqs;

        for (;;) {
            if ((rqs = blk_fetch_request(rq)) == NULL)
                break;

            if (blk_rq_is_passthrough(rqs)) {
                __blk_end_request_all(rqs, -EIO);
                continue;
            }

            ...
            
            __blk_end_request_all(rqs, 0);
        }
    }

    Burada blk_fetch_request fonksiyonu kuyruğun hemen başındaki request nesnesini alarak onu kuyruktan siler. Böylece döngü içerisinde tek tek request nesneleri elde dilmiştir. 
    blk_rq_is_passthrough fonksiyonu dosya sistemi ile alakıs olmayan request nesnelerini geçmek için kullanılır. Bazı request nesneleri transferle ilgili değildir. Bunların
    geçilmesi gerekmektedir. Bir request nesnesi kuyruktan alındıktan sonra akibeti konusunda kernel'a bilgi vermek gerekmektedir. İşte bu işlem __blk_end_request_all fonksiyonuyla
    yapılmaktadır. -EIO bu işlemin yapılmadığını 0 ise bu işlemin başarılı bir biçimde yapıldığını belirtmektedir. 

    Pekiyi kernel ne zaman kuyruğa request nesnesi yerleştirmektedir? Şüphesiz kernel'ın böyle bir nesneyi kuyruğua yerleştirmesi için aygıt üzerinde bir okuma ya da yazma olayının 
    gerçekleşmiş olması gerekir. Bunun tipik yolu aygıt dosyasının open fonksiyonuyla açılıp read ya da write yapılmasıdır. Tabii blok aygıt sürücüsü bir dosya sistemi yani bir disk bölümü
    haline getirilmiş olabilir. Bu durumda formatlama gibi, mount etme gibi eylemlerde de gizli bir okuma yazma işlemleri söz konusu olmaktadır. 

    Pekiyi kernel aygıt sürücü açılıp aşağıdaki gibi iki ayrı read işleminde iki ayrı request nesnesi mi oluşturmaktadır?

      if ((fd = open("generic-bdriver", O_RDONLY)) == -1) 
        exit_sys("open");

      if ((result = read(fd, buf, 10)) == -1)
            exit_sys("read");

      if ((result = read(fd, buf, 10)) == -1)
            exit_sys("read");

      Aslında kernel burada iki okumanın aynı blok içerisinde kaldığını anladığı için aygıttan yalnızca tek blokluk okuma talep edecektir. Çünkü okunan iki kısım da aynı blok içeisindedir. 
      Eğer bu iki okuma aşağıdaki gibi olsaydı bu durumda kernel iki farklı blok için iki farklı request nesnesi oluşturacaktı:

          
        if ((fd = open("generic-bdriver", O_RDONLY)) == -1) 
            exit_sys("open");

        if ((result = read(fd, buf, 10)) == -1)
            exit_sys("read");

        lseek(fd, 5000, 0);

        if ((result = read(fd, buf, 10)) == -1)
            exit_sys("read");

    Pekiyi kernel aygıt sürücüden kaç byte'lık bir bloğun transferini istemektedir? Bunun bir sektör olması gerektiğini düşünebilirsiniz. Ancak kernel sektör küçük olduğu için
    aygıt sürücüden bir "block" transfer istemektedir. Bir block ardışıl n tane sektörden oluşmaktadır (örneğin 8 sektör = 4K) ve bu durum kernel konfigürasyonuna bağlıdır. Ancak kernel
    transfer isteklrinde istenen bloğu her zaman sektör olarak ifade etmektedir. Başka bir deyişle kernel aygıt sürücüden "şu sektörden itibaren 4096 byte transfer et" gibi bir istekte
    bulunmaktadır. 

    Şimdi biz request nesnesinin içerisinden bio nesnelerini, bio nesnelerinin içerisinden de bio_vec nesnelerini elde edelim. Pekiyi kernel neden transfer bilgilerini doğrudan
    request nesnelerinin içerisine kodlamak yerine böylesi iç nesneler oluşturmuştur? İşte aslında bir request nesnesi ardışıl sektör transferi ile ilgildidir. Ancak bu ardışıl sektörler
    read ya da write biçimde olabilir. İşte bu read ve write yönleri o request nesnesinin ayrı bio nesnelerinde kodlanmıştır. Read ve write işlemleri ise aslında birdebn fazla tampon
    ile (yani aktarılacak hedef adres ile) ilgili olabilir. Bu bilgiler de bio_vec içerisine kodlanmıştır. Dolayısıyla aslında programcı tüm bio'lar içerisindeki 
    bio_vec'leri dolaşmalıdır. 

    Bir süre önceye kadar request içerisindeki bio nesnelerinin dolaşılması normal kabul ediliyordu. Ancak belli bir kernel'dan sonra bu tavsiye edilmemeye başlanmıştır. Fakat yine de
    request içerisindeki bio nesneleri şöyle dolaşılabilir:

    struct bio *bio;
    ...
    bio = rqs->bio;
    for_each_bio(bio) {
        ....
    }

    for_each_bio makrosunun artık doğrudan yukarıdaki biçimde kullanılması önerilmemektedir. 
    
    Artık bugünlerde bio nesnelerini dolaşmak yerine zaten bio nesnelerini ve onların içerisindeki bio-vec'leri dolaşan (yani içteki iki döngünün işlevini tek başına yapan) 
    rq_for_each_segment isimli makronun kullanılması tavsiye edilmektedir. Bu makro şöyle yzılmıştır:

   #define rq_for_each_segment(bvl, _rq, _iter)			\
	__rq_for_each_bio(_iter.bio, _rq)			        \
		bio_for_each_segment(bvl, _iter.bio, _iter.iter)

    Görüldüğü gibi aslında bu makro request nesnesi içerisindeki bio nesnelerini, bio nesneleri içerisindeki bio_vec nesnelerini dolaşmaktadır. rq_for_each_segment makrosunun birinci
    parametresi bio_vec tründen nesneyi almaktadır. Makronun ikinci parametresi request nesnesinin adresini almaktadır. Üçüncü parametre ise dolaşım sırasında kullanılacak bir iteratör
    nesnesidir.Bu nesne req_iterator isimli bir yapı türünden olmalıdır. Bu durumda transfer fonksiyonun yeni durumu aşağıdaki gibi olacaktır:

    static void request_proc(struct request_queue *rq)
    {
        struct request *rqs;
        struct bio_vec biov;
        struct req_iterator iterator;
        struct BLOCKDEV *bdev = (struct BLOCKDEV *) rq->queuedata;

        for (;;) {
            if ((rqs = blk_fetch_request(rq)) == NULL)
                break;

            if (blk_rq_is_passthrough(rqs)) {
                __blk_end_request_all(rqs, -EIO);
                continue;
            }

            rq_for_each_segment(biov, rqs, iterator) {
                ....    
            }
            
            __blk_end_request_all(rqs, 0);

            printk(KERN_INFO "new request object\n");
        }
    }

    Gerçek transfer bilgileri bio_vec yapılarının içerisinde olduğuna göre acaba bu yapı nasıldır? İşte bu yapı şöyle bildirilmiştir:

    struct bio_vec {
        struct page	*bv_page;
        unsigned int bv_len;
        unsigned int bv_offset;
    };

    Yapının bv_page elemanı transferin yapılacağı adresi belirtmektedir. Blok aygıt sürücüsü karakter aygıt sürücülerinin yaptığı gibi transferi user alanına kopyalamamaktadır. 
    Blok aygıt sürücüsü transferi  kernel tarafından tahsis edilen sayfalara (bu sayfaların oluşturduğu organizasyona "page cache" denilmektedir) yapar. Kernel o sayfalardaki bilgiyi
    user alanına transfer eder. Ancak bu sayfa adresinin özellikle 32 bit Linux sistemlerinde sayfa tablosunda girişi olmayabilir. Programcının bu girişi oluşturması gerekmektedir.
    Bu girişi oluşturmak için kmap_atomic isimli fonksiyon ve girişi boşaltmak için ise kunmap_atomic isimli fonksiyon kullanılmaktadır. Yapının ikinci elemanı elemanı olan bv_len transfer edilecek byte sayısını barındırmaktadır. (Bu elemanda transfer edilecek sektör sayısı değil doğrudan byte sayısı bulunmaktadır.) Nihayet yapının 
    üçüncü elemanı olan bv_offset birinci elemanında belirtilen adresten uzaklığı tutmaktadır. Yani aslında gerçek transfer adtesi bv_page değildir. bv_page + bv_offset'tir. 
    Bu yapıda en önemli bilgi olan transferin söz konusu olduğu sektör bilgisi yoktur. İşte aslında transfere konu olan sektör numarası bio yapısının içerisindedir. Her ne kadar biz
    yukarıdaki makroda bio yapısına erişemiyor olsak da buna dolaylı olarak iterator nesnesi yoluyla iterator.iter.bi_sect ifadesi ile erişilebilmektedir. 

    rq_for_each_segment fonksiyonu içerisinde transfer tipik olarak şöyle yapılmaktadır:

    rq_for_each_segment(biov, rqs, iterator) {
        sector_t sector = iterator.iter.bi_sector;
        char *buf = (char *)kmap_atomic(biov.bv_page);
        size_t len = biov.bv_len;
        int direction = bio_data_dir(iterator.bio);

        transfer_block(bdev, sector, buf + biov.bv_offset, len, direction);   

        kunmap_atomic(buf);
    }
 

    Burada transferin yapılacağı sektörün numarası bio_vec içerisinde bulunmadığında iterator yolu ile iterator.iter.bi_sector ifadesiyle alınmıuştır.
    Transfer adresi olan buf biov.bv_page adresinden biov.bv_offset kadar ileridedir. Yine transferin yönü doğrudan bio_vec yapısının içerisinde değildir. 
    Bu yön bilgisinin bio_data_dir makrosuyla iterator yoluyla alındığına dikkat ediniz. (Aslında yön bilgisi bio yapısının içeirsindedir. Bu makro onu buradan almaktadır.)
    Örneğimizde transferin transfer_block isimli fonksiyonla yapldığını görüyorsunuz. Bu fonksiyon bizim tarafımızdan yazılan gerçek transferin yapıldığı fonksiyondur. 
    Aygıt sürücünün en önemli bilgilerinin BLOCKDEV isimli yapıda tutulduğunu anımsayınız. Her ne kadar bu yapı nesnesinin adresi global g_bdev göstericisinde tutuluyorsa da 
    yine de o bilgi örneğimizde requeat_queue nesnesinin queuedata elemanından çekilerek alınıp transfer_block fonksiyonuna verilmiştir. Bu durum yukarıdaki örnek için gereksiz olsa da 
    birden fazla minör numarayla çalışıldığı durumda aygıt bilgilerinin yerinin belirlebilmesi için genel bir çözüm oluşturmak amacıyla transfer_block fonksiyonuna aktarılmıştır. 
    Aygıt bilgilerinin request_queue yapısının quedata elemanına nesne tahsis edildikten sonra yerleştirildiğini anımsayınız. 

   
    Buradaki transfer_block fonksiyonun parametrik yapısı şöyle olabilir:

    static void transfer_block(struct BLOCKDEV *bdev, sector_t sector, char *buf, size_t len, int direction);

    direction değeri READ (0) ve WRITE (1) sembolik sabitleriyle define edilmiştir. 

    Aşağıda RAMDISK block aygıt sürücüsünün tüm kodlarını görüyorsunuz

---------------------------------------------------------------------------------------------------------------------------*/

/* generic-bdriver.c */

#include <linux/module.h>
#include <linux/kernel.h>
#include <linux/fs.h>
#include <linux/slab.h>
#include <linux/blkdev.h>

#define KERNEL_SECTOR_SIZE      512
#define CAPACITY               (KERNEL_SECTOR_SIZE * 1000)

MODULE_LICENSE("GPL");
MODULE_DESCRIPTION("General Block Device Driver");
MODULE_AUTHOR("Kaan Aslan");

int g_major = 0;

struct BLOCKDEV {
    spinlock_t sl;
    struct gendisk *gdisk;
    struct request_queue *rq;
    size_t capacity;
    void *data;
};

static int generic_open(struct block_device *bdev, fmode_t mode);
static void generic_release(struct gendisk *gdisk, fmode_t mode);
static void request_proc(struct request_queue *rq);
static void transfer_block(struct BLOCKDEV *bdev, sector_t sector, char *buf, size_t len, int direction);


static struct block_device_operations g_devops = {
    .owner = THIS_MODULE,
    .open = generic_open,
    .release = generic_release
};

static struct BLOCKDEV *g_bdev;

static int __init generic_init(void)     
{  
    int result = 0;

    if ((g_major = register_blkdev(g_major, "generic-bdriver")) < 0) {
        printk(KERN_ERR "Cannot register block driver!..\n");
        return g_major;
    }

    if ((g_bdev = kmalloc(sizeof(struct BLOCKDEV), GFP_KERNEL)) == NULL) {
        printk(KERN_ERR "Cannot allocate memory!..\n");
        result = -ENOMEM;
        goto EXIT1;
    }
    memset(g_bdev, 0, sizeof(struct BLOCKDEV));
    g_bdev->capacity = CAPACITY;

    if ((g_bdev->data = vmalloc(CAPACITY)) == NULL) {
        printk(KERN_ERR "Cannot allocate memory!..\n");
        result = -ENOMEM;
        goto EXIT2;
    }
    
    spin_lock_init(&g_bdev->sl);
    if ((g_bdev->rq = blk_init_queue(request_proc, &g_bdev->sl)) == NULL) {
        printk(KERN_ERR "Canno allocate queue!..\n");
        result = -ENOMEM;
        goto EXIT3;
    }
    g_bdev->rq->queuedata = g_bdev;
    if ((g_bdev->gdisk = alloc_disk(1)) == NULL) {
        result = -ENOMEM;
        goto EXIT4;
    }
    g_bdev->gdisk->major = g_major;
    g_bdev->gdisk->first_minor = 0;
    g_bdev->gdisk->flags = GENHD_FL_NO_PART_SCAN;
    g_bdev->gdisk->fops = &g_devops;
    g_bdev->gdisk->queue = g_bdev->rq;
    set_capacity(g_bdev->gdisk, g_bdev->capacity >> 9);
    g_bdev->gdisk->private_data = g_bdev;
    strcpy(g_bdev->gdisk->disk_name, "blockdev");

    add_disk(g_bdev->gdisk);

    printk(KERN_INFO "Module initialized with major number %d...\n", g_major);

    return result;

EXIT4:
    blk_cleanup_queue(g_bdev->rq);
EXIT3:
    vfree(g_bdev->data);
EXIT2:
    kfree(g_bdev);
EXIT1:
    unregister_blkdev(g_major, "generic-bdriver");

    return result;
}

static int generic_open(struct block_device *bdev, fmode_t mode)
{
    printk(KERN_INFO "device opened...\n");

    return 0;
}

static void generic_release(struct gendisk *gdisk, fmode_t mode)
{
    printk(KERN_INFO "device closed...\n");
}

static void request_proc(struct request_queue *rq)
{
    struct request *rqs;
    struct bio_vec biov;
    struct req_iterator iterator;
    struct BLOCKDEV *bdev = (struct BLOCKDEV *)rq->queuedata;

    for (;;) {
        if ((rqs = blk_fetch_request(rq)) == NULL)
            break;

        if (blk_rq_is_passthrough(rqs)) {
            __blk_end_request_all(rqs, -EIO);
            continue;
        }

        rq_for_each_segment(biov, rqs, iterator) {
            sector_t sector = iterator.iter.bi_sector;
            char *buf = (char *)kmap_atomic(biov.bv_page);
            size_t len = biov.bv_len;
            int direction = bio_data_dir(iterator.bio);

            transfer_block(bdev, sector, buf + biov.bv_offset, len, direction);   

            kunmap_atomic(buf);
        }
   
        __blk_end_request_all(rqs, 0);
    }
}

 static void transfer_block(struct BLOCKDEV *bdev, sector_t sector, char *buf, size_t len, int direction)
 {
     if (direction == READ)
        memcpy(buf, (char *)bdev->data + sector * KERNEL_SECTOR_SIZE, len);
    else
        memcpy((char *)bdev->data + sector * KERNEL_SECTOR_SIZE, buf, len);
 }

static void __exit generic_exit(void)
{   
    del_gendisk(g_bdev->gdisk);
    blk_cleanup_queue(g_bdev->rq);
    vfree(g_bdev->data);
    kfree(g_bdev);
    unregister_blkdev(g_major, "generic-bdriver");

    printk(KERN_INFO "Goodbye...\n");
}

module_init(generic_init);  
module_exit(generic_exit);

obj-m += $(file).o

all: 
	make -C /lib/modules/$(shell uname -r)/build M=${PWD} modules
clean:
	make -C /lib/modules/$(shell uname -r)/build M=${PWD} clean

#!/bin/bash

module=$1
mode=666

/sbin/insmod ./$module.ko ${@:2} || exit 1
major=$(awk "\$2 == \"$module\" {print \$1}" /proc/devices)
rm -f $module
mknod $module b $major 0
chmod $mode $module

/*--------------------------------------------------------------------------------------------------------------------------
    Yukarıdaki blok aygıt sürücüsü bir dosya sistemi ile formatlanarak sanki bir disk bölümüymüş gibi de kullanılabilir. Bunun için
    önce aygıt sürücünün idare ettiği alanın formatlanması gerekir. Formatlama işlemi mkfs isili utility programla yapılmaktadır:

    sudo mkfs -t ext2 generic-bdriver

    Burada -t seçeneği volümün hangi dosya sistemi ile formatlanacağını belirtmektedir. Formatlama aslında volümdeki bazı sektörlerde
    özel meta alanlarının yaratılması anlamına gelmektedir. Dolayısıyla mkfs komutu aslında ilgili aygıt sürücüyü açıp onun bazı sektörlerine 
    bazı bilgileri yazmaktadır.

    Formatlama işleminden sonra artık blok aygıt sürücüsünün mount edilmesi gerekmektedir. mount işlemi bir dosya sisteminin dizin ağacının belli bir dizinine
    monte edilmesi anlamına gelmektedir. Dolayısıyla mount komutunda kullanıcı block aygıt sürücüsünü ve mount edilecek dizini girmektedir. Örneğin:

    sudo mount generic-bdriver /mnt/myblock

    Burada mount noktası (mount point) /ment dizinin altında myblock isimli dizindir. Bu dizinin kullanıcı tarafından önceden mkdir komutu ile
    yaratılması gerekir. Tabii mount noktalarının /mnt dizinin altında bulndurulması gibi zorunluluk yoktur. Mount noktasına ilişkin dizinin içinin
    boş olması da gerekmez. Fakat mount işleminden sonra artık o dizinin altı görünmez. Dosya sisteminin kök dizini o dizin olacak biçimde dosya sistemi
    ağaca monte edilmiş olur. mount komutu aslında mount isimli bir sistem fonksiyonu çağrılarak gerçekleştirilmektedir. Yani aslında bu işlem programlama
    yoluyla da yapılabilmektedir. 

    Aygıt sürücümüzü mount ettikten sonra artık onu unmount etmeden rmmod komutuyla boşaltamayız. mount edilen dosya sistemi umount komutuyla eski haline getirilmektedir. 
    Örneğin:

    sudo umount /mnt/myblock

    umount komutunun komutu argümanının mount noktasını belirten dizin olduğuna dikkat ediniz. Tabii aslında umount komutu da işlemini umount isimli sistem fonksiyonuyla
    yapmaktadır. 

---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Linux sistemlerinde /dev dizinini altında "loopN" (N burada bir sayıdır) isimli  "loopback aygıtı" denilen ilginç bir blok aygıt sürücüsü vardır. 
    Bu loopback aygıtı aslında bir dosyayı disk gibi kullanmak için düşünülmüştür. Bu aygıt sürücüün tipik kullanımı şöyledir:

    1) Önce aygıtı temsil eden bir dosya yaratılır. Mademki bu dosya bir disk yerine geçecektir. O zaman bu dosya belli bir sektör
    uzunluğunda dd komutuyla oluşturulabilir:

    dd if=/dev/zero of=mydisk.dat bs=512 count=2880

    Burada toplam 2880 * 512 byte uzunlukta içi 0'larla dolu bir dosya oluşturulmuştur.

    2) Şimdi losetup isimli programla bu dosyanın bir loopback aygıt sürücüsü ile ilişkilendirilmesi gerekmektedir. Örneğin:

    sudo losetup /dev/loop0 mydisk.dat

    Artık biz /dev/loop0 blok aygıt sürücüsü ile işlem yaptığımızda bu aygıt sürücü hedef olarak mydisk.dat dosyasını kullanacaktır.

    3) Artık dosya sistemini mkfs ile formatlayabiliriz:

    sudo mkfs -t ext2 /dev/loop0

    4) Artık mount işlemi yapabiliriz:

    mkdir mydisk
    sudo mount /dev/loop0 mydisk

    Artık mydisk dizini bizim için adeta bir disk volümü gibidir. Ancak orada yapacağımız işlemler aslında yalnızca mydisk.dat dosyasını etkileyecektir. 

    Bu işlemler şöyle geri alınmaktadır

    5) Önce volüm umont yapılır:
    
    sudo umount mydisk

    5) Şimdi /dev/loop0 ile dosya (yani mydisk.dat) arasında bağlantı losetup -d komutuyla koparılır 

    sudo losetup -d /dev/loop0

---------------------------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------------------------
    Linux kernel istenirse kaynak kodlarından yeniden derlenip (yani build edilip) elde edilen yeni kernel ile sistem başlatılabilir. 
    Pekiyi bu işlem neden yapılmak istenebilir? Tipik nedenleri şunlar olabilir:

    - Kernel'ın yükseltilmesi istenebilir. Yani örneğin kernel'ın yeni bir versiyonu çıkmış olabilir. Biz de bu yeni versiyonun kaynak 
    kodlarını indirip onu derleyerek kullanmak isteyebiliriz. 

    - Kernel kodlarının çeşitli yerleri çeşitli amaçlarla (deneysel olabilir, başka amaçlarla olabilir) değiştirilmek istenebilir. 
    Örneğin çizelgeleyici alt sistem değiştirilerek yeni sistem denenmek istenebilir. Dosya sisteminde değişiklikler yapılmak istenebilir. 
    Ya da mevcut kernel'daki çeşitli bug'lar düzeltilmek istenebilir (patch işlemi).

    - Kernel'dan çeşitli öğeler de çıkartılmak istenebilir. 
    
    - Kernel'a yeni kodlar ve dolayısıyla işlevsellikler eklenmek istenebilir. (Örneğin kernel'a yeni bir sistem fonksiyonu eklenmek istenebilir.) Ya da 
    bir kernel modül veya aygıt sürücü kernel'ınbir parçası haline getirilmek istenebilir. 

    Şüphesiz yukarıdaki amaçlar için kernel yeniden derlenecekse öncelikle onun kaynak kodlarının indirilmesi ve o kodlar üzerinde istenen 
    değişikliklerin yapılması gerekir. Sonra da bu yeni kodlar derlenmelidir. Derlendikten sonra da boot işleminde bu yeni kernel'ın devreye girmesi sağlanmalıdır. 

    Linux çekirdekleri resmi olarak kernel.org sitesinde tutulmaktadır. İndirme için ana dizin kernel.org/pub dizinidir. Bu dizinin 
    içerisinde  linux/kernel dizinleri bulunmaktadır. Kernel versiyonları bu dizinin altında dizinler biçiminde bulunur. Genellikle kaynak 
    kodlar .gz ve .xz biçiminde iki alternatif sıkıştırma formatı biçiminde burada bulundurulmaktadır. İşte ilk aşamada bir kernel 
    versiyonu yerel makineye indirilmelidir. İndirme işlemi doğrudan tarayıcı    yoluyla yapılabileceği gibi komut satırından wget 
    utility'si ile de yapılabilmektedir. Örneğin:

    wget https://www.kernel.org/pub/linux/kernel/v5.x/linux-5.0.10.tar.xz

    Kaynak kodlar indirildikten sonra bunlar açılır. Kaynak kodların bulundurulması için en normal yer /usr/src dizinidir. Bu dizine yazma hakkımız olmadığı 
    için açım işleminin sudo ile yapılması gerekir. Örneğin:

    sudo tar -xvf linux-5.0.10.tar.gz -C /usr/src

    Bu komutla artık kaynak kodlar /usr/src dizinin altına açılmıştır. 

    Artık /usr/src dizinin altında linux-5.0.10 biçiminde (tabii bunun ismi indirdiğimiz kernel versiyonuna göre değişecektir) bir dizin oluşturulmuştur. 
    Bu dizine cd komutuyla geçmek gerekir. Bu ana dizindeki Makefile dosyası ana make dosyasıdır. Bu dosya yüzlerce dizindeki make dosyalarını 
    çalıştırarak build işlemini yapmaktadır.  Kernel'ın build edilmesi için gereken başka yardımcı araçlar da bulunmaktadır. Dolayısıyla bu araçlar 
    eğer sistemimizde yoksa onları da indirip kurmalıyız. Genellikle olmayan araçlar şunlardır:

    sudo apt-get install libssl-dev
    sudo apt-get install libelf-dev

    Eğer build işleminde sorun çıkarsa sisteminizde başka gerekli araçların olmadığından şüphelenmelisiniz. Pek çok sistemde aşağıdaki 
    araçlar default durumda bulunmaktadır. Ancak eğer build işlemi başarısız olursa aşağıdaki araçların olmadığından şüphelenmelisiniz:

    sudo apt-get install libncurses5-dev
    sudo apt-get install flex
    sudo apt-get install bison

    Debian türevi sistemlerde ayrıca paket yöneticisinin repository dosyasının sudo apt-get update komutu ile güncellenmesi gerekebilmektedir.

    Artık build işlemi için gerekli olan tüm araçlar sağlanmış durumdadır. Şimdi bir "kernel konfigürasyon dosyasının" oluşturulması gerekir. 
    Bu konfigürasyon dosyası build işlemi sırasında okunup oluşturulacak olan kernel image dosyasının neleri içerip içermeyeceğini 
    belirtmektedir. Normal olarak kernel konfigürasyon dosyası utility'ler tarafında oluşturulmaktadır. Bu utility'ler bize onlarca 
    soru sormaktadır. Tipik utility'ler şunlardır:

    make config
    make menuconfig
    make xconfig

    Söz konusu konfigürasyon dosyasının ismi ".config" biçimindedir. Bu konf,igürasyon dosyasının oluşturulması biraz zahmetli olduğu 
    için daha çok mevcut bir .config dosyasını kullanma yöntemine gidilmektedir. Aslında aşağıdaki komutla default bir .config dosyası oluşturulabilir:

    sudo make defconfig

    Ancak daha sağlam bir yöntem /boot dizini içerisinde bulunan mevcut sistemin konfigürasyon dosyasını yeni kaynak kod dizinine 
    .config ismiyle kopyalamak olabilir. Örneğin:

    sudo cp /boot/config-4.15.0-20-generic .config 

    Kernel konfigürasyon dosyası bu biçimlerle elde edilmişse oluşturacağımız yeni kernel'a uyumunu sağlamak için aşağıdaki komut uygulanmalıdır:

    sudo make oldconfig

    Bu komut referans aldığımız .config dosyasının içine bakar. Versiyon uyuşmazlığı ile ilgili satırları siler. Bu komut uygulandığında biz 
    euyuşmazlıklarla ilgili birtakım sorular sorabilmektedir. Bu sorular default seçeneklerle geçilebilir. Tabii biz yine istersek bu .config 
    dosyası üzerinde yukarıda belirttiğimiz make mconfig, make menuconfig, make xconfig gibi komutlarla onun üzerinde güncellemeler yapabiliriz. 

    Artık tüm hazırlıklar yapılmıştır ve uzun bir zaman alabilen build işlemi yapılacaktır. Build işlemi aşağıdaki komut ile başlatılabilir:

    sudo make

    Ancak işlemi hızlandırmak içib birden fazla çekirdeğin kullanılmasını -j seçeneği ile sağlayabiliriz. Örneğin:

    sudo make -j 4

    Burada 4 çekirdek birlikte build işlemine katılacaktır. 

    Build işlemi bittikten sonra artık yeni sistem için son iki işlem yapılmalıdır. Bunlardan birincisi oluşturulan ama kernel image 
    içerisinde olmayan bazı aygıt sürücülerin uygun dizinlere çekilmesidir. Bu işlem aşağıdaki komutla yapılır:

    sudo make modules_install

    Böylece biz aygıt sürücüleri de yenilemiş olmaktayız. Burada söz konusu modüller kernel image içerisinde olmayan fakat çeşitli aşamalarda 
    yüklenen aygıt sürücü modülleridir. 

    Nihayet ikinci olarak gerçek kernel image dosyasının ve yardımcı birkaç dosyann /boot dizinine çekilip boot-loader'ın güncellenmesidir.
     Bu da şu komutla yapılmaktadır:

    sudo make install

    Linux işletim sisteminin boot edilmesi sırasında yüklenecekgerçek kernel image dosyasının /boot dizininde bulunması gerekmektedir. 
    Genellikle bu kernel image dosyası vmlinuz-xxxx biçiminde isimlendirilmiş durumadır. Ancak kernel'ın boot edilmesi için "kök dosya sistemini 
    (root file system)" geçici bir biçimde ramdisk olarak oluşturan bir geçici dosya sisteminin de /boot dizininde bulunması gerekmektedir. 
    Bu dosya da genel olarak initrd.img.xxxx ismiyle bulunur. Diğer bir dosya da genellikle System.map.xxx biçiminde isimlendirilen kernel sembol
     dosyasıdır. Bu dosyanın da boot işlemi sırasında /boot dizininde bulundurulması gerekmektedir. İşte make install komutu bu dosyaları /boot 
     dizinine kopyalamaktadır. Ayrıca make install komutu bunun yanı sıra boot-loader ayarlarını da yapar. İşletim sistemini asıl yükleyen 
     programa "boot-loader" denilmektedir. boot-loader sayesine biz bilgisayarımızı istediğimiz bir kernel ile açabilmekteyiz. Eskiden LILO 
     isimli boot-loader programı yoğun kullanılıyordu. Sonra GRUB isimli boot-loader daha popüler oldu. Şimdiki Linux sistemleri genellikle 
     GRUB isimli boot-loader'ı kullanmaktadır. İşte make install aynı zamanda GRUB boot-loader konfigürasyon dosyasını da güncelleyerek yeni
      sistemin de GRUB menüsünde gözükmesini sağlamaktadır. make install işlemi ile eski kernel'ın yok edilmediğini yeni 
      bir kenel'ın da /boot izininde bulundurulduğuna dikkat ediniz. Tabii artık programcı isterse eski kernel dosyalarını bu dizinden silebilir. 
      GRUB boot loader ayarlarını kendisi manuel yolla ya da yardımcı proogramlarla yapabilir. 

    GRUB boot-loader konfigürasyon dosyası normal olarak /boot/grub dizini içerisindedir. Yani boot-loader buradaki grub.cfg dosyası 
    temel alınarak ayarlanır. Ama bu dosyanın güncellenmesi zordur. Bunun için daha basit yöntem /etc/default/grub dosyası 
    üzerinde basit değişiklikler yapmak ama bunu yaptıktan sonra aşağıdkai komutu uygulamaktır:

     sudo update-grub

     Bu komutla birkte aslında /boot/grub/grub.cfg dosyası da güncellenmektedir. GRUB güncellemesinin diğer bir yolu da bunun için yazılmış olan GUI programlarını kullanmaktır. 
     Yaygın olanlardan biri grub-customizer isimli programdır. Bu program şöyle kurulabilir:

     sudo add-apt-repository ppa:danielrichter2007/grub-customizer
     sudo apt-get update
     sudo apt-get install grub-customizer

    Böylece artık grub-customizer yazıldığnda bir GUI program görüntülenecektir. 

    Kernel kodlarındaki bir dosya üzerinde değişiklik yaptıktan sonra yukarıdaki adımlar izlenirse artık yeni kernel o değişiklikleri içerecektir. Ancak çoğu kez amaç kernel 
    kaynak dosyalarına yeni bir dosya eklemektir. Bu durumda genel olarak şöyle bir yöntem izlenebilir:

    1) Ekleyeceğiniz dosya için ana kaynak dizininde bir dizin yaratabilirsiniz. Bu dizin mycode olsun. (Başka yerde de yaratılabilir. Ancak en basiti budur.)
    2) Ekleneceğiniz dosyaları bu dizine yerleştirebilirsiniz. Bu dosyaların x.c ve y.c olduğunu varsayalım. 
    3) Yarattınız dizinin içerisinde ana Makefile tarafından devreye sokulacak olan bir Makefile dosyası yaratmalısınız. Bu dosyanın içerisinde şu satırlar olmalıdır:

    obj-y := x.o
    obj-y := y.o

    4) Yarattığınız dizinin ana Makefile dosyası tarafından tanınabilmesi için o dosyada aşağıdaki satır bulunup o dizin de bu satıra eklenmelidir:

    core-y += kernel/ mm/ fs/ ipc/ security/ crypto/ block/ 

    Bu satır şu hale getirilmelidir:

    core-y += kernel/ mm/ fs/ ipc/ security/ crypto/ block/ mycode/

---------------------------------------------------------------------------------------------------------------------------*/