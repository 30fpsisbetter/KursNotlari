/*-----------------------------------------------------------------------------------------------------------------------------

                                        C ve Sistem Programcıları Derneği

                                   Gömülü Linux Sistemleri - Geliştirme ve Uygulama Kursu

                                        Sınıfta Yapılan Örnekler ve Özet Notlar

                                                  Eğitmen: Kaan ASLAN

          Bu notlar Kaan ASLAN tarafından oluşturulmuştur. Kaynak belirtmek koşulu ile her türlü alıntı yapılabilir.

                    (Notları okurken editörünüzün "Line Wrapping" özelliğini pasif hale getiriniz.)

                                                Son Güncelleme: 12/03/2024

-----------------------------------------------------------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------------------------------------------------------
												1. Ders 05/03/2024 - Salı
-----------------------------------------------------------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------------------------------------------------------
    Kurs için gerekli olabilecek malzemeler şunlardır:

    - Raspberry Pi SBC (Single Board Computer): Version 3, 4 ya da 5 olabilir. Yeni satın alacakların Raspberry Pi 5 almalarını 
    tavsiye ediyoruz.

    - Raspberry Pi 5 alınacaksa soğutucu ya da soğutuculu kılıf da alınmalı. Raspberry Pi 3 ve 4 için soğutucu alınmayabilir.

    - Raspberry Pi için Micso SD Kart: 64GB Yüksek Hızlı (SanDisk Extreme serisi olabilir). Micro SD kart 32 GB de olabilir.
    Ancak 32GB'den düşüğü tavsiye etmiyoruz.

    - Raspberry Pi 4 ve Raspberry Pi 5 için "Mikro HDMI -> HDMI kablosu", Raspberry Pi 3 için "HDMI -> HDMI" Kablosu.

    - USB Kombo Klavye + Mouse

    - Raspberry Pi için GPIO Breadboard Aktarma Kablosu

    - Raspberry Pi için Güç Kaynağı Adaptörü: Raspberry Pi 3 ve 4 için 5V/3A, Raspberry Pi 5 için 5V/5A (27W). Raspberry Pi 4 
    ve 5 USB Type C kullanıyor. Raspberry Pi 3 Micro USB kablosu kullanıyor.

    - BeagleBone Black SBC (Single Board Computer): BeagleBone Black 4G ya da BeagleBone Black Industrial ya da BeagleBone 
    Black Wireless yeni satın alacak olanlar "BeagleBone Black 4G" ya da BeagleBone Black Wireless" alabilirler. Stokları 
    kontrol etmek gerekiyor.

    - BeagleBone Black için Güç Kaynağı: Mini USB ile 5V/500mA güç adaptörü ya da yuvarlak girişli (DC Jack) 5V/1A güç adaptörü.

    - BeagleBone Black için Micro SD Kart (16GB olabilir).

    - BeagleBone Black için "Micro HDMI -> HDMI" Dönüştürücü.

    - Standart Boy Breadboard ve İsteğe Bağlı Küçük Boy Breadboard'lar da olabilir.

    - Jumper Kablo seti

    - "USB -> UART" Dönüştürücü (CP2102 olabilir)

    - USB Uzatma Kablosu Gerekebilir.

    - Ethernet RJ45 Kablosu: Eğer SBC'nin wireless özelliği varsa buna gerek duymayabilirsiniz.

-----------------------------------------------------------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------------------------------------------------------
												2. Ders 07/03/2024 - Perşembe
-----------------------------------------------------------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------------------------------------------------------
    Kursumuzun giriş bölümünde çeşitli kavramları ve terimleri açıklayacağız.
-----------------------------------------------------------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------------------------------------------------------
    Asıl amacı bilgisayar olmayan fakat bilgisayar sistemi içeren sistemlere genel olarak gömülü sistemler (embedded systems) 
    denilmektedir. Yani gömülü sistemler başka amaçları gerçekleştirmek için tasarlanmış olan aygıtların içerisindeki bilgisayar
    sistemleridir. Örneğin elektronik tartılar, biyomedikal aygıtlar, GPS cihazları, turnike geçiş sistemleri (validatörler), 
    müzik kutuları, kapı güvenlik aygıtları, otomobiller içerisindeki kontrol panelleri, birer gömülü sistemdir. Gömülü 
    sistemlerde en çok kullanılan programlama dili C'dir. Ancak genel amaçlı işletim sistemlerinin yüklenebildiği SBC'lerde 
    (Single Board Computer) diğer programlama dilleri de kullanılabilmektedir.

    Gömülü sistemler gömüldüğü aygıtta belli işlevleri sağlamak için kullanılmaktadır. Örneğin buzdolaplarının, çamaşır 
    makinelerinin içerisine yerleştirilen bilgisayar devreleri ve yazılımlar onların önemli etkinlerini yönetmekte, kullanıcı 
    ile arayüz oluşturabilmektedir. Günümüzde bilgisayar sistemi içeren aygıtlar artık her yeri sarmıştır. Bu nedenle üzerinde 
    geliştirme faaliyetleri de önemli bir iş alanı haline gelmiştir.

    Gömülü sistemlerin tipik özellikleri şunlardır:

    - Gömülü sistemler "genel değil belirli (specific) amaca yönelik" işlemleri gerçekleştirmektedir. Yani genel amaçlı değil 
    özel amaçlı donanım ve yazılım hizmeti sunmaktadır. Bu sistemlerdeki yazılımlar da genel amaçlı değil belli bir amacı 
    gerçekleştirmeyi hedeflemektedir.

    - Gömülü sistemler genellikle daha düşük bir bilgiişlem kapasaitesine sahip bilgisayar devreleridir. Örneğin bu sistemlerde 
    kullanılan işlemciler genel amaçlı masaüstü işlemcilerden genellikle daha yavaş olma eğilimindedir. Bu sistemlerdeki bellek
    miktarları (birincil ve ikinci bellekler) genel amaçlı bilgiayar sistemlerine göre daha düşük olma eğilimindedir. Dolayısıyla 
    gömülü sistemlerin maliyetleri de genel amaçlı bilgisayar sistemlerine göre çok düşüktür.

    - Gömülü sistemler genellikle (fakat her zaman değil) daha düşük güç harcamaktadır. Bu durum onların bataryalarla beslenebilmesini 
    dolayısıyla fiziksel taşınabilirliğini de artırmaktadır. Tabii genel olarak gömülü sistemler düşük güç harcama eğiliminde olan 
    sistemler olsalar da bu durum her zaman böyle olmak zorunda değildir. Bazı gömülü sistemlerin gömüldüğü sistemlerde bir güç kullanma
    sorunu yoktur. (Örneğin araba kantarı zaten bu işlevi gerçekleştirmek için önemli bir güç harcamaktadır. Dolayısıyla bu sistemdeki
    gömülü sisteminharcadığı gücün önemi olmayabilir.)

    - Gömülü sistemlerin önemli bir bölümü "gerçek zamanlı (real time)" olaylarla ilişkilidir. Bu sistemlerin belli bir bölümü 
    dış dünyadaki değişimlere karşı bir yanıt oluşturmaya çalışmaktadır. Örneğin bir gömülü sistem otamdaki ısı belli bir kritik 
    düzeye geldiğinde bir işlemi başlatabilir. Ya da bir gömülü sistem kalp ritmi bozulduğunda kalbe uyarılar göndererek ritm bozukluğunu
    düzeltmeye çalışabilir. Hava araçlarındak gömülü sistemler o anki hava şartlarına göre bir otomatik kumanda sistemi işlevini 
    görüyor olabilir. Tabii gömülü istemlerin bu gerçek zamanlı işlem doğası bazı uygulamalarda "çok katı (hard realtime)" olurken bazı 
    uygulamalarda "daha gevşek (soft realtime)" olabilmektedir.

    - Gömülü sistemlerin bazılarında hiç girdi/çıktı birimi olmayabilir. Bazılarında ise girdi/çıktı birimi olarak "düğmeler", basit tuş 
    takımları, küçük LCD'ler olabilir. Oysa genel amaçlı bilgisayar sistemlerinde genellikle girdi/çıktı birimi olarak klavye, fare ve 
    gelişmiş monitörler kullanılmaktadır. Başka bir deyişle gömülü sistemler kullanıcı arayüzü bakımından minimal olma eğilimindedir.

    - Gömülü sistemlerdeki donanım birimleri nispeten ucuz olma eğilimindedir. Genel amaçlı bilgisayarlara göre bunlar çok daha ucuz
    olarak temin edilebilmektedir.

    - Gömülü sistemler çeşitli kaynaklarda çeşitli ölçütlere göre de sınıflandırılabilmektedir.

    1) İşlevsel Gereksinime Göre Sınıflandırma:

        a) Gerçek zamanlı Olan ya da Gerçek Zamanlı Olmayan Gömülü Sistemler: Bunlar "hard" ya da "soft" real-time olabilmektedir.
        b) Bağımsız (Stand-Alone) olan Bağımısz Olmayan Sistemler: Bunlar belli bir amaca yönelik hazırlanmış gömülü sistemlerdir.
        Örneğin hesap makineleri, kapı güvenlik sistemleri, MP3 çalarlar gibi.
        c) Ağ (Network) Üzerinde İşlem Yapan Gömülü Sistemler: Bunlar ağ işlemleri yapmak için oluşturulmuş gömülü sisteemlerdir.
        ATM makineleri, ADSL Rouer cihazları gibi cihazları bunlara örnek verebiliriz.
        d) Mobil Aygıtlarda Kullanılan Gömülü Sistemler: Bunlar küçük, taşınabilir aygıtlarda kullanılan gönmülü sistemlerdir.
        Telefonlari GPS cihazları, dijital kameralar bunlara örnek verilebilir.

    2) Performans Gereksinimine Göre Sınıflandırma:

        a) Küçük Ölçekli (Small Scale) Gömülü Sistemler
        b) Orta Ölçekli (Medium Scale) Gömülü sisteemlerde
        c) Büyük Ölçekli (Large Scale) Gömülü Sistemler

    Biz burada "https://www.ultralibrarian.com/2022/06/28/types-of-embedded-systems-characteristics-classifications-ulc"
    bağlantısındaki sınıflandırmayı kullandık. Ancak başka kaynaklarda başka türlü sınıflandırmalar da yapılabilmektedir.

    Gömülü sistemlerde bilgisayar birimi olarak genellikle miktodenetleyiciler (microcontrollers) kullanılmaktadır. Ancak entegre
    devre teknolojisinin gelişmesiyle artık içlerine standart işletim sistemi yüklenebilen çok daha gelişmiş donanımlar da 
    gömülü sistemlerde kullanılabilmektedir.

    Gömülü sistem yazılımlarının önemli bir bölümü bir işletim sistemi olmadan çalışacak biçimde (bare-metal) olarak geliştirilmektedir. 
    Bunun önemli nedenlerinden biri bunların kapasitelerinin nispeten düşük olması diğeri de belirli bir amacı gerçekleştirecek
    biçimde tasarlanmış olmalarıdır. Gömülü sistemlerin bir bölümünde "gerçek zamanlı işletim sistemleri" bir bölümünde ise "genel 
    amaçlı işletim sistemleri" kullanılmaktadır.

    Gömülü sistemlerde genel olarak üç işlem birimi kullanılmaktadır:

    1) Mikrodenetleyiciler
    2) Mikroişlemcileri
    3) DSP'ler
-----------------------------------------------------------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------------------------------------------------------
    Bir bilgisayar sisteminde aritmetik, mantıksal, bitsel işlemler ve karşılaştırma gibi bilgiişlem faaliyetleri işlemleri 
    "mikroişlemci (microprocessor)" denilen birim tarafından yapılmaktadır. Mikroişlemciler entegre devre biçiminde üretilmişlerdir. 
    Mikroişlemcilere kavramsal olarak CPU (Centeral Processing Unit) de denilmektedir. Yani CPU mikroişlemcilerin kavramsal ismidir. 
    Aslında genel amaçlı bir bilgisayar sisteminde komut çalıştıran pek çok işlemci bulunabilmektedir. CPU bu işlemcileri de 
    programlayan "merkezi (central)" işlemcidir. Bilgisayar sisteminde yerel bazı işlemlerden sorumlu yardımcı işlemciler de vardır. 
    Örneğin "kesme denetleyicisi (interrupt controller)", "disk denetleyicisi (disk controller)", "DMA denetleyicisi (DMA controller)" 
    gibi.
-----------------------------------------------------------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------------------------------------------------------
    Mikrodenetleyiciler tek bir chip içerisine yerleştirilmiş bir bilgisayar sistemi gibi düşünülebilirler. Tipik olarak bir 
    mikrodenetleyicide bir "işlemci (processor)", kendi içerisinde "RAM ve Flash EPROM", dış dünya ile haberleşmek için kullanılan 
    "IO birimi" ve bazı "çevre birimleri (peripherals)" bulunmaktadır. Mikrodenetleycilere İngilizce "microcontroller" ya da 
    "microcontroller Unit (MCU)" da denilmektedir.

    Mikrodenetleyicilerin işlem kapasiteleri ve içerdikleri bellek miktarları düşük olma eğilimindedir. Ancak bunlar çok kolay 
    programlanıp uygulamaya sokulabilmektedir. Mikro denetleyicilere "tek çiplik bilgisayar (single chip computer)" da denilmektedir. 
    Mikrodenetleyiciler özellikle gömülü sistemlerde tercih edilmektedir. Bunların düşük güç harcaması ve ucuz olmaları en büyük 
    avantajlarındandır. Gömülü uygulamalarda kullanılan pek çok mikrodenetleyici ailesi vardır. Örneğin:

    - Microchip PIC Mikrodenetleyici Ailesi (Microchip)
    - Renesans Mikrodenetleyici Ailesi (Renesans)
    - ARM Mikrodenetleyici Ailesi (Tasarımcısı ARM Holding, ancak çok şeşitli firmalar tarafından üretiliyor)
    - AVR Mikrodenetleyici Ailesi (Atmel, ancak Atmel firması 2016'da Microchip tarafından satın alındı)
    - MSP Mikrodenetleyici Ailesi (Texas Instruments)
-----------------------------------------------------------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------------------------------------------------------
    Bazı firmalar ayrı birimler olarak tasarlanmış mikroişlemcileri, RAM'leri, ROM’ları ve diğer bazı çevre birimlerini tek bir 
    entegre devrenin içerisine sıkıştırmaktadır. Bunlara genel olarak "SoC (System on Chip)" denilmektedir. SoC mikrodenetleyicilere 
    benzese de aslında onlardan farklıdır. SoC’lar içerisindeki işlemcilerin ve belleklerin kapasiteleri yüksektir. Bunlar özel 
    amaçlı üretilirler ve bunların devrelerde kullanılmaları mikrodenetleyiciler kadar kolay değildir. Bunların en önemli avantajları 
    "az yer kaplamasıdır". Örneğin Raspberry Pi kitlerinde Broadcom isimli firmanın 2835, 2836, 2837, 2711, 2712 numaralı SOC 
    çipleri kullanılmıştır. SoC'ların RAM ve ROM bellek içermesi zorunlu değildir. Bazı SoC'lar RAM içerirken bazıları içermeyebilmektedir. 
    Örneğin Raspberry Pi 1, 2, 3 modellerinde kullanılan SoC'lar RAM içerirken Raspberry Pi 4 ve 5 modellerinde kullanılan SOC'lar 
    RAM içermemektedir.
-----------------------------------------------------------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------------------------------------------------------
    SoC kavramına benzer diğer bir kavram da "SoM Ssystem on Module)" kavramıdır. SoM bir işlemci ve onunla ilişkili bazı birimlerin
    monte edildiği kartları belirtmek için kullanılmaktadır. SoM'lar SoC'ları içerebilir. Ancak başka birimleri de içerebilir. 
    Örneğin bir SoM bir işlemci, buna ilişkin RAM, IO denetleyicisi (IO controllers içeren bir kart olabilir. Örneğin "Raspberry Pi
    Pico" ve "Raspberry Pi Compute Module" birer SBC'den ziyade birer SoM olarak ele alınabilir. SoM kavramını zihninizde SoM ile 
    SBC arasında bir yerde konumlandırabilirsiniz.
-----------------------------------------------------------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------------------------------------------------------
    Küçük bir kit (baskılı devre) üzerine monte edilmiş bilgisayarlara SBC (Single Board Computer) denilmektedir. Genellikle 
    bu kitlerde SOC'lar, RAM'ler ve başka çevre birimleri ve IO işlemleri için soketler bulunmaktadır. Örneğin Raspberry Pi, 
    Beagleboard SBC'lere örnek verilebilir. SBC'ler klavye, fare ve monitör takılarak bir masaüstü bilgisayar gibi kullanılabilmektedir.
    SBC'ler masaüstü bilgisayarlar gibi de kullanılabildiğinden bunlara Linux başta olmak üzere, Android ve Windows gibi işletim 
    sistemleri yüklenebilmektedir.
-----------------------------------------------------------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------------------------------------------------------
    Mikroişlemcileri tasarım mimarilerine göre iki CISC (Complex Instruction Set Computers) ve RISC (Reduced Instruction Set Computers)
    olmak üzere iki kısma ayırabiliriz. CISC ailesi işlemcilere Intel firmasının x86 ailesi işlemcilerini örnek verebiliriz. ARM, 
    MIPS, PowerPC, Itanium gibi işlemciler ise tipik RISC işlemcileridir. Her ne kadar CISC ve RISC isimleri komut kümesi ile 
    ilgili biçimde uydurulmuşsa da CISC ve RISC tasarımları başka bakımlardan da farklılık göstermektedir. 
    
    İşlemciler (makro ve mikro) ortaya çıktığında çok fazla makine komutunun bulunmasının bir avantaj olduğu düşünülüyordu. 
    Ancak daha sonraları bunun avantajdan ziyade dezavantaj oluşturduğu görüldü. Belli bir süreden sonra artık RISC mimarisinin
    CISC mimarisinden toplamda daha iyi bir tasarım olduğu kabul görmüştür. Bu nedenle son dönem mikroişlemci tasarımlarında hep 
    RISC mimarisi kullanılmıştır. 

    CISC ve RISC mimarisi arasındaki temel farklılklar şunlardır:

    1) CISC işlemcilerinde fazla sayıda makine komutu bulunmaktadır. Bu işlemcilerde bazı komutlar temel işlemleri yaparken 
    bazıları karmaşık işlemler yapmaktadır. Halbuki RISC işlemcilerinde az sayıda temel nmakine komutları bulunmaktadır. Bu 
    makine komutları da daha fazla transistör kullanılarak daha hızlı çalışacak biçime getirilmiştir. Dolayısla CISC işlemcilerindeki 
    bazı komutlar RISC işlemcilerinde birkaç komutla karşılanabilmektedir. Ancak bu durum sanıldığının tersine daha hızlı bir 
    çalışma sağlama potansiyelindedir. 

    2) CISC işlemcilerinde az sayıda yazmaç (register), RISC işlemcilerinde ise fazla sayıda yazmaç bulunma eğilimindedir. Yazmaç 
    sayıları az olunca yazmaçların tekrar tekrar aynı değerlerle yüklenmesi gerekebilmektedir. Bu da derleyicinin nesneleri 
    daha kısa sürede yazmaçlarda tutmasına yol açmaktadır. Yine CISC işlemcilerindeki bazı komutlar ancak bazı özel yazmaçlarla 
    kullanılmaktadır. (Örneğin Intel X86 şlemcilerinde MUL ve DIV gibi komutların bir operandı EAX ya da RAX yazmacında bulunmak 
    zorundadır.) Oysa RISC işlemcilerinde her işlem her yazmaçla yapılabilmektedir. 

    3) CISC işlemcilerinde komutlar farklı uzunluklarda olabilmektedir. Örneğin Intel'in x86 ailesinde 1 byte olan makine komutları 
    da vardır, 5 byte olan makine komutları da vardır, 11 byte olan hatta 15 byte olan makine komutları da vardır. Halbuki RISC 
    işlemcilerinde genel olarak tüm makine komutları eşit uzunluktadır. Örneğin ARM işlemcilerinde her makine komutu 4 byte 
    uzunluktadır. Böylece işlemci komutları bellekten daha etkin bir biçimde çekip (fetch işlemi) onları daha çabuk anlamlandırmaktadır
    ve n sonraki ya da önceki makine komutlarının yerini belirleyebilmektedir. 

    4) RISC işlemcilerinde pipeline mekanizması CISC işlemcilerine göre daha iyi gerçekleştirilmektedir. Pipeline işlemcinin
    bir makine komutunu çalıştırırken sonraki komutlar üzerinde hazırlık işlemlerini yapması anlamına gelmektedir. RISC tasarımı
    olarak pipleline mekanizmasının daha iyi yürütülmesine olanak sağlamaktadır.

    5) RISC İşlemcileri Load/Store tarzı makine komutları kullanmaktadır. Bu işlemcilerde belleğe erişim yapan makine komutlarıyla
    artimetik, mantıksal ve bitsel işlem yapan makine komutları birbirinden ayrılmıştır. Örneğin RISC işlemcilerinde ADD, SUB gibi
    makine komutlarının her iki operandı da yazmaç olmak zorundadır. Halbuki CISC işlemcilerinde bu tür makine komutlarının bir 
    operandı yazmaç bir operandı bellek olabilmektedir. Örneğin:

    a = b + c;

    gibi bir işlem CISC işlemcis ile şu makine komutlarıyla yapılabilmektedr:

    - b'yi yazmaca çeken makine komutu
    - Yazmaçtaki b ile bellekteki c'yi toplayan makine komutu
    - Yazmaçtaki toplamı a'ya yerleştiren makine komutu
   
    Oysa aynı işlem RISC işlemcilerinde şöyle gerçekleştirilmektedir:

    - b'yi yazmaca çeken makine komutu
    - c'yi yazmaca çeken makine komutu 
    - Yazmaçlardaki b ile c'yi toplayan makine komutu
    - Yazmaçtaki sonucu a'ya yerleştiren makine komutu

    Belleğe erişim komutlarıyla diğer komutların birbirinden ayrıldığı işlemcilere "load/store" işlemcileri ya da "register-register
    işlemcileri de denilmektedir. 

    6) RISC işlemcileri genel olarak (ancak hepsi değil) üç operandlı makine komutlarını kullanmaktadır. Oysa CISC işlemcileri 
    genellikle iki operand'lı makine komutlarını kullanır. İki operand'lı makine komutlarında işlemin sonucu operand olan yazmaçlardan
    birine yerleştirildiği için o yazmaç bozulmaktadır. Böylece derleyici o yazmaçtaki değeri yeniden kullanmak istediğinde 
    onu yeniden yüklemek zorunda kalmaktadır. Örneğin a = b + c işlemi 32 bit Intel işlemcilerinde tipik olarak şöyle 
    gerçekleştirilmektedir:

    MOV EAX, <a'nın adresi>
    ADD EAX, <b'nin adrei>
    MOV <c'bin adresi>, EAX

    Burada EAX işlemcinin bir yazmacıdır. ADD makine komutu bu yazmaçtaki değer ile bellekteki b'yi toplamakta ve sonucu yine
    EAX yazmacına yerleştirmektedir. Dolayısıyla EAX yazmacındaki a değeri artık kaybolacaktır. Bu değer yeniden kullanılmak 
    istendiğinde ise yeniden yüklemenin yapılması gerekecektir. Şimdi aynı işlemi ARM işlemcilerinde yapacak olalım:

    LDR R0, <a'nın bellek adresi>
    LDR R1, <b'nin bellek adresi>
    ADD R2, R1, R0
    STR R2, <c'nin bellek adresi>

    Burada R0, R1 ve R2 işlemcinin yazmaçlarıdır. Görüldüğü gibi ARM işlemcilerinde Load/Store komutları dışındaki komutlar 
    üç operand'lıdır. Bu da yazmaçlardaki değerlerin gerektiğinde bozulmamasına yol açmaktadır. 

    7) RISC işlemcileri yukarıda belirttiğimiz tasarım prensiplerinden dolayı toplamda daha az güç harcama eğilimindedir. Bu da
    onların mobil aygıtlarda kullanılmasının önemli bir gerekçesini oluşturmaktadır.

    8) RISC işlemcilerinde makine komutlarının çalışma süreleri birbirine yakındır. Ancak CISC işlemcilerinde makine komutlarının 
    çalışma süreleri arasında önemli farklılıklar olabilmektedir. Örneğin ARM işlemcilerinde toplama, çıkartma, çarpma gibi 
    makine komutları 1 cycle'da yapılmaktadır. Ancak load/store komutlarının, jump komutlarının ve özel bazı komutların çalışma 
    süreleri 1 cycle'dan fazla olabilmektedir. Oysa örneğin Intel x86 işlemcilerinde komut süreleri değişik faktörlere bağlı olarak
    biribirinden çok farklılaşmaktadır.

    RISC ve CISC mimarilerini bir spektrum olarak düşünmek gerekir. Örneğin MIPS işlemcileri ARM işlemcilerine göre bu spektrumun 
    daha fazla RISC tarafındadır. Intel'in x86 işlemcilerini kategori olarak CISC grubu işlemciler olarak ele alsak da Pentium 
    işlemcileri ile birlikte bu işlemcilerde de RISC prensipleri gittikçe daha fazla kullanılır hale gelmiştir. 
-----------------------------------------------------------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------------------------------------------------------
                                                3. Ders 12/03/2024 - Salı
-----------------------------------------------------------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------------------------------------------------------
    ARM işlemcilerinin tarihi "Acorn Computer" isimli İngiliz firmasına dayanmaktadır. Bu firma 80’li yılların başlarında 
    "BBC Micro" isimli 64K’lık ev bilgisayarlarını yapmıştı. Bu bilgisayarlarda Rockwell’in 8 bitlik 6502 işlemcileri kullanılıyordu. 
    Firma daha sonra "Berkeley RISC" projesinden etkilenerek kendi RISC işlemcilerini yapmaya odaklandı. Böylece ilk ARM modelleri 
    tasarlanmış oldu. Şirket 1990’da "Apple" ve "VLSI Technology" şirketleriyle ortaklıklar da kurarak ARM ismini aldı. (Eskiden 
    ARM "Acorn RISC Machine" isminden kısaltlıyordu. Fakat daha sonra bu firma kurulunca bu kısaltma "Advanced RISC Machine" haline 
    getirildi.) Apple firması bu yeni firmaya maddi destek sağlamıştır. "VLSI Technology" firması ise ekipman tedarik etmiştir.
    Acorn ise az sayıda tasarım mühendisini bu yeni firmaya aktarmıştır. 2016 yılında "SoftBank Group" ARM hisselerinin önemli bir 
    bölümünü aldı. 2018'de ARM'ın Çin şubesinin yarısından fazlasını "Chine Investment" şirketine sattı. 2020'de "NVidia" ARM'ı 
    SoftBank Group'tan satın almak istediyse de satış gerçekleşmedi. Bugün "SoftBank Group" ARM'ın %90 civarındaki hisselerine 
    sahiptir. Geri kalan hisseleri kurucu ortaklarda ve halka arzdadır.
-----------------------------------------------------------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------------------------------------------------------
    ARM bir tasarım firmasıdır. Yani fabrikalara sahip değildir. ARM yaptığı tasarımları lisanslandırarak üretici firmalara 
    satmaktadır. ARM'ın uyguladığı dört tür lisans vardır:

    Entegre Devre Lisansı (Full Custom License): Bu lisans müşterinin mikrodenetleyici tasarımını kendi özel ihtiyaçlarına 
    göre özelleştirmesine ve optimize etmesine olanak tanır. Örneğin Apple gibi, Qualcomm gibi, Samsung gibi firmalar bu 
    lisansa sahiptir.

    Mimari Lisans (Architecture License): Bu lisans ARM'nin genel mikroişlemci mimarisine erişim sağlayan bu lisanstır. Ancak, 
    bu lisans müşterinin mikrodenetleyiciyi özelleştirmesine izin vermez. Yani bu lisansa sahip olanlar işlemci tasarımını
    kullanarak üretim yapabilirler ancak onu özelleştiremezler.

    Çekirdek Lisansı (Processor IP License): Bu lisans ile ancak müşteri belli bir ARM işlemcisini (core) üretebilmektedir.

    Geliştirici Lisansı (Development License): Bu lisans ARM'nin tasarım araçlarına erişim sağlayan bir lisanstır. Müşteri 
    bu araçları kullanarak kendi işlemcilerini tasarlayabilir.
-----------------------------------------------------------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------------------------------------------------------
    ARM dünyasında çalışmak için bazı terimler hakkında bilgi sahibi olmak gerekir. ARM firması kendine özgü terimler uydurmuştur.
    Bu dünyada en çok karşılaşılan terimler "core", "cortex" ve "version" terimleridir. 

    ARM dünyasında "core" terimi belli bir mikroişlemci tasarımını belirtmektedir. Bu tasarım üretici firmalar tarafından 
    fiziksel hale getirilmektedir. Bir grup "core" bir araya getirildiğinde ve işlemciyle ilişkili birtakım birimler de bunlara 
    eklendiğinde "Cortex'ler" oluşmaktadır. ARM firması ARM'ın klasik versiyonlarında "cortex" terimini kullanmamıştır. Cortex
    terimi ARM11'den sonra kullanılmaya başlanmıştır. Bir cortex belli sayıda "core" içerebilir. Bu "core"lar noktalı sayılara
    (floating point) ilişkin işlem yapan birimlere sahip olabilirler. Cortex içerisindeki core'ların belli hızları vardır. Core 
    ve cortex terimleri daha çok çip düzeyindeki mimariyi belirtmektedir. Ancak cortex'lerde kullanılan işlemcilerin (core'ların) 
    sistem programcısını ilgilendiren "komut kümeleri (instruction sets)" de vardır. Böylece bir grup grup cortex belli bir komut
    kümesi ile kullanılabilecek biçimde tasarlanmıştır. Komut kümesi mimarisine "ARM Versiyonları" ya da İngilizcesiyle "ARM ISA
    (Instruction Set Architecture) Mimarisi" denilmektedir. Biz sistem programcısı olarak elimizdeki cortex'in hangi komut kümesini 
    kullanan ARM versiyonuna ilişkin olduğunu bilmek durumundayız. Burada dikkat edilmesi gereken nokta "Cortex teriminin donanımsal 
    mimariyi, versiyonun ise yazılımsal mimariyi belirtiyor" olmasıdır. O halde gömülü sistem geliştiricisi olarak bizim ilgilendiğimiz 
    ARM içeren kart ile ilgili şu iki özelliği biliyor olamamız gerekir:

    1) Kartımızda ARM'ın hangi cortex'i kullanılmıştır?
    2) Bu cortex'in ilişkin olduğu versiyon numarası nedir?

    Yukarıda da belirtitğimiz gibi farklı cortex'ler aynı version numarasını kullanabilmektedir. 

    ARM dünyasında üç mimari profili (profile) bulunmaktadır:

    1) A (Apllication) Profili 
    2) R  (Realtime) Profili
    3) M (Microcontroller) Profili 

    Bu profiller ilgili cortex'lerin hangi tür uygulamalarda ideal olarak kullanılabileceğini belirtmektedir. Profil isimleri 
    cortex'lerde ve versiyon numaralarında '-' karakterinden sonra A, R, M harfleriyle belirtilmektedir. Örneğin "Cortex-A8" ve 
    "ARMV7-A" gibi.A profilleri masasüstü işletim sistemlerinin çalıştırılabileceği, tamamen kişilsel bilgisayar olarak kullanılabilecek 
    cortex'leri belirtmektedir. Biz kursumuzda "gömülü Linux programcısı" olarak bu "A" profilleriyle çalışacağız. R profilleri
    "gerçek zamanlı (realtime)" uygulamalar için daha uygun olabilecek cortex'leri belirtmektedir. R profilleri ile A profilleri 
    birbirlerine benzemektedir. R profilleri A profillerine göre çok daha seyrek kullanılmaktadır. M profilleri ARM'ın mikrodenetleyici
    olarak kullanılan cortex'lerini belirtmektedir. Bu cortex'ler genel olarak Linux işletim sisteminin yüklenmesine izin vermemktedir. 
    Bu cortex'ler genellikle "bare-metal" programlarla ya da gerçek zamanlı işletim sistemleriyle kullanılmaktadır.

    ARM'ın iki önemli versiyonu ARMV7-A ve ARMV8'A dır. ARMV7 32 bitlik bir arayüz sunmaktadır. Dolayısıyla bu komut mimarisini 
    kullanan cortex'ler 32 bitlik işlemciler içermektedir. ARMV8-A versiyonları ise 64 bitlik arayüz sunmaktadır. Dolayısıyla bu 
    versiyonları kullanan cortex'ler 64 bitlik işlemcilere ilişkindir. Ancak ARM cortex'lerinin bir grubu hem 32 bit hem de 64 bit olarak 
    kullanılabilmektedir. Bu cortex'lerdeki işlemcileri kullanan işletim sistemleri 32 bitlik ve 64 bitlik programları zaman 
    paylaşımlı olarak bir arada çalıştırabilmektedir. 
-----------------------------------------------------------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------------------------------------------------------
    Mikroişlemciler ilk çıktığında 8 bit işlemleri yapabiliyordu (örneğin 8080, 6800 gibi işlemciler). Bunlara 8 bitlik mikroişlemci 
    deniyordu. Sonra 16 bitlik mikroişlemciler çıktı (örneğin Intel'in 8086, 8088 işlemcileri gibi). Bunu 32 bit işlemciler izledi. 
    Günümüzde artık ağırlıklı olarak 64 bit işlemciler kullanılmaktadır. Pekiyi bir işlemcinin N bitlik olmasının anlamı nedir? 
    Bu soruya yanıt verelim:

    - N bitlik bir işlemcide tek hamlede (yani tek bir makine komutuyla) N bit üzerinde işlem yapılabilmektedir. Örneğin 32 bitlik 
    bir mikroişlemcide tek bir makine komutu ile 32 bitlik iki sayısıyı toplayıp çarpabiliriz. 

    - N bitlik bir mikroişlemciler genellikle (ama her zaman değil) 2^N uzunlukta bir fiziksel RAM'i adresleyebilmektedir. Örneğin
    32 bitlik bir mikroişlemciye biz tipik olarak 2^32 = 4GB'lik bir RAM bağlaybiliriz. Elimizdeki RAM 64GB olsa bile 32 bit
    bir mikroişlemci bu RAM'in ancak ilk 4GB'sini kullanabilmektedir. Tabii bu durum her zmana böyle değildir. Örneğin 8086 
    işlemcisi 16 bit olduğu halde 2^16 değil 2^20 uzunlupunda (1MB) fiziksel belleği adresleyebiliyordu. Benzer biçimde bugünkü
    64 bitlik Intel ve AMD işlemcileri gereksiz olduğu gerekçesiyle 2^64 değil 2^48 uzuluğundaki RAM'leri adresleyebilmektedir. 

    - N bitlik bir mikroişlemcide genellikle işlemci ile RAM aarasında transfer N bit olarak yapılmaktadır. Örneğin 32 bitlik
    bir mikroişlemcide tek bir makine komutuyla RAM'den CPU'ya 32 bitlik bir veri transfer edilebilir.

    8 bitten 16 bite geçişte ve 16 bitten 32 bite geçişte çok farkedilir bir hızlanma yaşanmıştır. Ancak 32 bitten 64 bite geçişte 
    hızlanma öncekiler kadar olmamıştır. Bunun nedeni 64 bitlik işlemlerin aslında yoğun olarak yapılmadığındandır. Ancak 32 bitten
    64 bite geçişin en önemli etkisi işlemciye bağlanabilecek RAM miktarı üzerinde olmuştur. Örneğin elimizde 8 GB RAM'li 
    Raspberry Pi 5 olsun. Buradaki ARM cortex'i hem 32 bit hem de 64 bit işlemci gibi çalışabilmektedir. Dolayısıyla biz bu kartımıza
    32 bitlik de 64 bitlik de Linux yükleyebilriz. Ancak 32 bitlik Linux işletim sistemi işlemciyi 32 bit modda çalıştıracağı için 
    işletim sistemi 8GB RAM'in ancak 4GB'sini kullanabilecektir. Bu 8GB RAM'in tamamından istifade edebilmemiz için işlemcinin 
    64 bit modunda çalıştırılması dolayısıyla da işletim sisteminin 64 bit olması gerekecektir. 

    Pekiyi 128 bitlik işlemciler tasarlansa, bunlar daha hızlı bir çalışam sunmaz mı? Neden 128 bitlik işlemciler tasarlanmıyor? 
    İşte 128 bitlik tamsayı işlemlerine çok nadir gereksinim duyulmaktadır. 2^128 uzunlupunda RAM zaten şu an için erişilmesi 
    imkansız bir RAM miktarıdır. O halde işlemcilerin 64 bitten 128 bite çıkartılmasının şu an için önemli bir faydası olmayacaktır.
    Ancak tabii gelecekte böyle bir ihtiyaç ortaya çıkabilecektir.
-----------------------------------------------------------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------------------------------------------------------
    Popüler ürünlerde kullanılan ARM cortex'leri şunlardır:

    iPhone 14: Apple'ın A15 isimli SOC'unu kullanmaktadır. Bu SOC'un içerisinde Apple'ın ARMv8.6‑A versiyonunu kullanan Avalanche 
    Cortex'i vardır. Buradaki core'lar yalnızca 64 biti desteklemektedir. 
    
    iPhone 15: Apple'ın A16 isimli SOC'unu kullanmaktadır. Bu SOC'un içerisinde Apple'ın ARMv8.6‑A versiyonunu kullanan Evereset
    Cortex'i vardır. Buradaki core'lar yalnızca 64 biti desteklemektedir. 
    
    Apple M1 SOC: Apple'ın ARMv8.4‑A versiyonunu kullanan FireStorm isimli Cortex'i vardır. Buradaki core'lar yalnızca 64 biti 
    desteklemektedir. 
    
    Apple M2 SOC: Apple'ın ARMv8.6‑A versiyonunu kullanan Avalanche ve Blizzard isimli Cortex'leri vardır. Buradaki Core'lar
    yalnızca 64 biti desteklemektedir. 
    
    Apple M3 SOC: Apple'ın ARMv8.6‑A versiyonunu kullanan Avalanche ve Blizzard kullanan isimli Cortex'i vardır. Buradaki core'lar
    yalnızca 64 biti desteklemektedir. 
    
    Samsung Galaxy S24: Qualcomm firmasının Snapdragon-8 SOC'unu kullnamaktadır. Bu SOC içerisinde ARMv9-A versiyonunu kullanan 
    Cortex A715 bulunmaktadır.
    
    Redmi Note 11: Xiaomi firmasınn ürünüdür. Qualcomm Snapdragon-685 SOC'unu kullanmaktadır. Bu SOC'un içerisinde ARMV8.2-A 
    versiyonuna ilişkin Cortex A78 bulunmaktadır.
-----------------------------------------------------------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------------------------------------------------------
    Bu kursta kullanacğımız SBC'lerin üzerinde bulunan ARM cortex'leri ve bunların versiyon numaraları da şöyledir:
    
    Raspberry Pi 3: BCM2837 SOC'u kullanlmıştır. Bu SOC'un içerisinde ARMV8-A versiyonuna ilişkin Cortex-A53 bulunmaktadır. Bu 
    cortex'teki işlemciler hem 32 bit hem de 64 bit modda çalışabilmektedir. Dolayıyla bunlara 32 bit ve 64 bit Linux sistemleri 
    yüklenebilmektedir.
    
    Raspberry Pi 4: BCM2711 SOC kullanlmıştır. Bu SOC'un içerisinde ARMV8-A versiyonuna ilişkin Cortex-A72 bulunmaktadır.  Bu 
    cortex'teki işlemciler hem 32 bit hem de 64 bit modda çalışabilmektedir.  Dolayıyla bunlara 32 bit ve 64 bit Linux sistemleri 
    yüklenebilmektedir.
    
    Raspberry Pi 5: BCM2712 Bu SOC'un içerisinde ARMV8.2-A versiyonuna ilişkin Cortex-A76 bulunmaktadır. Bu cortex'teki 
    işelmciler hem 32 bit hem de 64 bit modda çalışabilmektedir. Dolayıyla bunlara 32 bit ve 64 bit Linux sistemleri 
    yüklenebilmektedir.
    
    BlackBone Black 4G ve BeagleBone Black Wireless: Texas Instruments firmasının Sitara-AM3358 SOC'unu kullanmaktadır. Bu SOC'un 
    içerisinde Cortex-A8 kullanılmıştır. Bu cortex 32 bit işlemcilerden oluşmaktadır. Bunların kullandığı komut mimarisi de 
    ARMV7-A'dır. BeagleBona Black'ler 32 bit ARM işlemcilerini kullandığı için bunlara yalnızca 32 bit Linux sistemleri
    yüklenebilmektedir.
-----------------------------------------------------------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------------------------------------------------------
                                                4. Ders 14/03/2024 - Perşembe
-----------------------------------------------------------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------------------------------------------------------
    Şimdi de Raspberry Pi 5 donanımını inceleyelim. Kartın üzerinde BCM2712 SOC'u heme dikkati çekmektedir. Bu SOC'un hemen 
    yanında RAM chip'i bulunmaktadır. Raspberyy Pi 5'in 1GB, 2GB, 4GB ve 8GB RAM'li modelleri bulunmaktadır. Raspberry Pi 5 
    modelinde toplam 4 USB soketi bulunmaktadır. Bunlardan iki tanesi USB 2.0, diğer 2 tanesi de USB 3.0'dır. Klavye ve fare gibi 
    yavaş aygıtları USB 2.0 girişlerine bağlayabilrsiniz. Bunların hemen yanında Ethernet girişi bulunmaktadır. KEnarlarda toplam 
    40 tane (20'lik iki sıra) GPIO uçları bulunmaktadır. Bu GPIO uçları aygıtın dış dünya ile elektrisksel olarak haberleşmesin
    için kullanılmaktadır. Raspberry Pi 5'te iki Micro HDMI girişi bulunmaktadır. Bu uçlardan birine monitörümüzü bağlamalıyız.
    Raspberry Pi 5 modelinde arka tarafta SD kart girişine yakın bir bölgede çok küçük OO/OFF düğmesi bulunmaktadır. Bu düğme 
    bilgisayarlarımızdaki Power Off düğmesi gibidir. Ayrıca kamera ve LCD bağlamak için iki adet MIP DSI/CSI bulunmaktadır. 
    Kartın arka tarafında bir Micro SD kart girişi bulunmaktadır. Buraya disk görevini görecek olan micro SD kartımızı takacağız.
    Giriş kısmında da belirttiğimiz gibi şu an için 64GB'lik SD kartlar fiyat bakımından uygun bir büyüklüktür. Ancak denemeler için 
    birden fazla (bunlar daha küçük de olabilir) SD kart kullanabilirsiniz. Kart üzerindeki diğer bileşenlerin bazılarını ilerleyen
    bölümlerde ayrıca ele alacağız.

    Kart üzerindeki bileşenleri inceleyebilmek için aşağıdaki bağlantıyı kullanabilirsiniz:

    https://grobotronics.com/raspberry-pi-5-4gb.html

    Raspberry Pi'ın resmi iki sitesi raspberrypi.com ve raspberrypi.org siteleridir. Raspberry Pi ile ilgili tüm dokümanlar 
    https://www.raspberrypi.com/documentation/ bağlantısından elde edilebilir. 
-----------------------------------------------------------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------------------------------------------------------
    Raspberry Pi bir proje olarak özellikle az gelişmiş ülkelerde düşük fiyatlı bilgisayar oluşturmayı hedeflemiştir. Dolayısıyla
    biz Raspberry Pi'ı tamamen Linux tabanlı bir kişisel bilgisayar olarak kullanabiliriz. Kursumuzda önce Raspberry Pi'ın 
    kişisel bilgisayar olarak nasıl kullanıldığı üzerinde duracağız. 
-----------------------------------------------------------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------------------------------------------------------
    Raspberry Pi için birkaç işletim sistemi oluşturulmuştur. Ancak bunlardan en yaygın kullanılan ikisi Linux'un "Raspberry Pi 
    OS (eski ismiyle Raspbian)" ve "Ubuntu" dağıtımlarıdır. Raspberry Pi ile tam uyum içind eolan ana dağıtım "Raspberry Pi OS"
    dağıtımıdır. Biz en azından "Raspberry Pi OS" ve "Ubuntu" dağıtımlarını ayrı micro SD kartlara yüklemenizi tavsiye ediyoruz. 

    Bir bilgisayar sistemini reset ettiğimizde işletim sisteminin (ya da bu görevdeki yazılımın) yüklenmesini sağlayan mekanizmalara
    "boot loader" denilmektedir. Gömülü sistemlerde kullanılan "boot loader" mekanizmaları kursumuzun ayrı bir konusunu oluşturmaktadır. 
    Ancak kabaca boot işlemi şöyle gerçekleşmektedir: Biz mikroişlemciyi reset ettiğimizda çalışma belli bir adresten başlatılmaktadır. 
    Yani işlemci reset edildiğinde çalıştırılacak kodun önceden hazır bir biçimde kalıcı bir bellekte (bugün bunlar için flash EPROM'lar
    kullanılmaktadır) bulunuyor olması gerekir. Buradaki kod çeşitli donanım birimlerini programlar ve onları kullanıma hazır hale 
    getirir. Sonra boot loader'ın işletim sisteminin yüklenmesinden sorumlu olan kısmı RAM'e yüklenir. Boot Loader'ın bu kısmı 
    işletim sistemini yükler. Zaten bu konular ileride ayrıntılarıyla ele alınacaktır. Bizim bu aşamada bilmemiz gereken şey 
    işletim sistemimizin micro SD karta nasıl yükleneceğidir. Çünkü bu işlem yapıldıktan sonra artık her şey otomatik gerçekleşmektedir. 
-----------------------------------------------------------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------------------------------------------------------
    Micro SD kartımıza işletim sisteminin yüklenmesi gelişi güzel yapılacak bir işlem değildir. Çünkü belli programların disk 
    üzerinde belli sektörlerde bulunuyor olması gerekmektedir. Bunu sağlamanın basit bir yolu önceden hazırlanmış bir imaj dosyasını 
    micro SD kartımıza aktarmaktır. Raspberry Pi için bu imaj dosyaları hazır bir biçimde zaten bulunmaktadır. O halde bizim 
    tek yapacağımız şey bu imaj dosyalarını indirip micro SD kartımızın içerisine aktarmaktır. Ancak son birkaç yıldır bu işlemin
    kolaylaştırılması için Raspberry Pi ekibi "Raspberry Pi Imager" denilen bir program geliştirmiştir. Bu program menüler
    eşliğinde kullanıcının istediği işletim sisteminin imaj dosyasını indirip micro SD karta bunları yazmaktadır. Dolayısıyla 
    bu program işimizi hepten kolaylaştırmaktadır. Raspberry Pi İmager programını aşağıdaki bağlantıdan indirebilirsiniz:

    https://www.raspberrypi.com/software/

    RaspberryImager programı indirilip kurulup çalıştırılınca program bize üç şey sormaktadır? 

    1) Hangi Rasperry Pi Modelini kullandığımızı
    2) Hangi işletim sistemini yükleyeceğimizi 
    3) Hangi micro SD karta yüklemeyi yapacağımızı

    Bu sorulara yanıt verdikten sonra yüklenecek Linux üzerinde bazı basit konfigürasyon işlemleri de "Edit Setting" seçeneği 
    yapılabilmektedir. Tabii bunları yüklemeden sonra da yapabiliriz. 

    Raspberry Pi Imager her şeyi kendisi yapmaktadır. Program önce ilgili imajı yerel makineye indirir, sonra da micro SD karta 
    yazma yapar. 

    Tabii biz Raspberry Pi Imager programını kullanmak zorunda değiliz. Zaten bu program eskiden yoktu. Eğer bu programı kullanmayacaksak
    işletim sistminin SD kart imajını indirip SD karta yazma yapan bir programla onu karta aktarmamız gerekir. SD karta aktarma 
    yapan pek çok bedava program vardır. Bunlşardan en popüler iki tanesi "Rufus" ve "Etcher" programlarıdır. Manuel kurulum 
    için işletim sistemi imajlarını aşağıdaki bağlantıdan indirebilirsiniz:

    https://www.raspberrypi.com/software/operating-systems/

    Artık her şey hazırdır. Bundan sonra şu bağlantıları yapmalısınız:

    1) SD kartınızı Raspberry Pi'ınıza yerleştiriniz.
    2) Monitörünüzü Raspberry Pi'ınızın micro HDMI soketine takınız.
    3) Klavye ve Farneinizi Raspberry Pi'ınızın USB soketlerine takınız.
    4) USB Type-C soketi ile Raspberry Pi'ınıza güç veriniz.
-----------------------------------------------------------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------------------------------------------------------
                                            5.Ders 19/03/2024 - Salı
-----------------------------------------------------------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------------------------------------------------------
    Gömülü sistemimize Linux'u kurduktan sonra ona başka bir makineden erişmek isteyebiliriz. Bunun çeşitli yolları varsa da 
    en tipik üç yöntem kullanılmaktadır:

    1) ssh protokolü ile erişim 
    2) VNC protokolü ile erişim
    3) Microsoft Remote Desktop Protokolü (RDP) ile erişim

    VNC ve RDP ile gömülü aygıtımızdaki Linux'a erişebilmemiz için orada bir pencere yönetici programın (yani masaüstü sisteminin)
    kurulu olması gerekir. RSapberry Pi güçlü bir donanıma sahip olduğu için ve kişisel bir bilgisayar gibi kullanılabildiği için
    buraya yüklediğimiz Linux sistemlerinde pencere yöneticisi zaten bulunuyor olacaktır. Ancak server sistemlerinde ve pek çok 
    gömülü Linux sisteminde bir pencere yöneticisi bulunmamaktadır. Bu durumda ssh protokolü ile erişim sağlanmakaktadır. Eskiden 
    ssh protokolünden önce telnet isimli benzer bir protokol vardı. Ancak telnet protokolünün güvenilirliği zayıf olduğu için 
    ssh protokolü geliştirildi. Bugün konsol tabanlı bir ortamda bir Linux sistemine uzaktan bağlanmak için genellikle ssh protokolü 
    kullanılmaktadır. 
    
    Her türlü TCP/IP uygulamalarında haberleşmenin yapılabilmesi için bir "server" program ile bir de "client" programın bulunuyor 
    olması gerekir. Bize erişimi sağlayan uzak makinedenki program "server" programdır. Bizim erişmek için kullandığımız program 
    ise "client" programdır. ssh server ve client programlar zaten işletim sistemlerinin pek çoğunun içinde default bir biçimde 
    bulunmaktadır. Biz Raspberry Pi'ımıza Raspberry OS işletim sistemini kurduğumuzda zaten ssh client ve server programlar yüklü 
    durumdadır. Ancak eğer gömülü sisteminizde ssh server program bulunmuyorsa onu şöyle kurabilirsiniz:

    $ sudo apt-get install openssh-server

    Bu işlem sshserver programının kurulup çalışır hale getirilmesini sağlamaktadır. client program da benzer biçime kurulabilir:

    $ sudo apt-get install openssh-client

    ssh client ptogramıyla bağlantı aşağıdaki gibi sağlanabilir:

    ssh user_name@host_name

    Bizim bağlantı sağlayabilmek için uzak makinede bir kullanıcının ismini ve parolasını biliyor olmamız gerekir. ssh client programı 
    benzer komut satırı argümanlarıyla Windows sistemlerinde ve macOS sistemlerinde de hazır bir biçimde bulunmaktadır. Dolayısıyla
    Windows ve macOS sistemlerinden de gömülü aygıtınıza benzer biçimde bağlanabilirsiniz. ssh programı ile bağlantı yapılırken kullanıcı 
    ismini "-l" seçeneği ile de belirtebilirsiniz. Örneğin:

    ssh -l user_name host_name

    VNC ile bağlantıda yine bir VNC server programıyla bir de VNC client programının karşılıklı makinelerde yüklü olması gerekmektedir. 
    Bizim bağlanmak istediğimiz makinede server programının çalışıyor olması, bağlantıyı sağlamak istediğimiz tarafta da client progmın 
    yüklü olması gerekir. Raspberry Pi'daki eski Raspbian işletim sisteminde VNC server hazır bir biçimde bulunmuyordu. Ancak belli süre 
    sonra artık Raspberry Pi OS içerisinde zaten VNC server programı hazır bir biçimde bulunmaktadır. Ancak VNC server hazır bir biçimde 
    bulunuyor olsa da onun çalışır getirilmesi gerekmektedir. Bu işlem pratik olarak ana menüden Preferences/Raspberry Pi Configurations/Interfaces 
    sekmensinden yapılabilir. Yukarıda da belirttiğimiz gibi VNC server için Linux sistemimizde bir pencere yöneticisinin çalışıyor olması 
    gerekir. Yani içerisine grafik arayüz yüklenmemiş olan bir Linux sistemine VNC ile bağlanmanın da bir anlamı yoktur. 

    VNC server ve client program olarak çeşitli programlar kullanılabilmektedir. Linux'ta en yaygın kullanılan VNC server program
    "tightvncserver" isimli programdır. Bunun kurulumu şöyle yapılabilir:

    $ sudo apt-get install tightvncserver

    Ancak server program kurulduktan sonra bazı ayarlamaların yapılması gerekmektedir. Bu konu ileride başka bir bölümde ele 
    alınacaktır. 

    Biz pencere yönetici sistemin bulunduğu bir Linux sistemine Microsoft'un "Remote Desktop Protocolünü (RDP)" kullanarak da 
    bağlanabiliriz. Tabii bunun için de bağlanacağımız makinede RDP server programının çalışıyor durumda olması gerekmektedir. 
    Bu protokol Microsoft'a ait olduğu için Linux sistemleri tarafından aktif bir biçimde kullanılmamaktadır. RDP server programı
    aşağıdaki gibi kurulabilir:

    $ sudo apt-get install xrdp

    RDP protokülü için client program olarak genellikle Windows'taki "Uzak Masaüstü Bağlantısı" kullanılmaktadır. Ancak bu 
    protokol için başka client programlar da bulunmaktadır.

    VNC ve RDP protokolleri hem Linux sistemlerinde hem de Windows ve macOS sistemlerinde kullanılabilmektedir. Windows dünyasında
    RDP programları hızlı bir biçimde çalışmaktadır. Ancak Linux'ta VNC programları RDP programlarına göre daha hızlıdır. Windows'ta 
    da RDP programları VNC programlarına göre daha hızlıdır. 
-----------------------------------------------------------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------------------------------------------------------
    BeagleBoard'lar en yaygın kullanılan SBC'ler arasındadır. Biz de kursumuz Beaglebone Black (BBB) kullanacağımızı söylemiştik.
    BBB'nin dokümantasyonuna aşağıdaki bağlantıdan erişilebilir:

    https://docs.beagleboard.org/latest/https://docs.beagleboard.org/latest/

    BBB kendi içerisinde ismine "eMMC (Embedded Multi-MEdia Card)" denilen on-board flash belleğe sahiptir. Zaten ürün satın 
    alındığında vu flash belleğin çerisinde bir Debian Linux dağıtımı yüklü durumdadır. Bu nedenle biz board'umuzu güç kaynağına 
    taktığmızda zaten default olarak bu on-board flash içerisindeki Linux boot edilmektedir. BBB'yi kullanıma hazır hale getirmek 
    için şunlar yapılmaldır:

    1) BBB'ye güç kaynağını bağlamak için iki soket kullanılabilmektedir. Birincisi eski tip yuvarlak sokettir (DC barrel jack). 
    İkincisi ise mini USB soketidir. Kullanıcılar genellikle güç kaynağını mini USB soketine bağlamaktadır. (Tabii bu mini USB 
    girişi doğrudan masaüstü bilgisayarımızın USB girişine bağlanabilir. Bu durumda gücü buradan alacaktır.)

    2) BBB üzerinde bir tane standart USB soket vardır. Genellikle bu sokete combo klavye fare bağlanmaktadır. Ancak birden fazla
    bağlantı için USB hub kullanılabilir. 

    3) BBB'nin klasik modellerinde Internet için "wireless" bağlantı yoktur. Dolayısıyla Internet bağlantısı sağlamak için ethernet
    soketi kullanılmaktadır. Ancak on-board flash üzerine yükllenmiş olan Debian içerisinde "Internet over USB" için gerekli aygıt
    sürücüler (device drivers) bulunmaktadır. Bu sayede biz örneğin mini USB kablosu ile BBB'yi Windows ya da Linux makinemize bağlayıp 
    BBB'nin oradaki Internet'i kullanmasını sağlayabiliriz. 

    4) BBB'de de Raspberry Pi'da olduğu gibi micro HDMI soketi vardır. Bu sokete doğrudan monitörümüzü bağlayabiliriz. 
    
    Tipik olarak BBB'yi ilk kez kullanırken mini USB soketini masaüstü bilgisayarımızın standart USB soketine takarız. Böylece
    masaüstü bilgisayarımız otomatik olarak BBB'nin on-board flash belleğindeki bir disk bölümünü bir sürücü biçiminde görür. 
    Bu sürücü içerisinde host sistem için gerekli olan aygıt sürücüler bulunmaktadır. Eğer host makine olarak Windows'ta çalışıyorsak 
    aygıt sürücüleri yüklerken "UEFI BIOS'tan imzasız aygıt sürücüleri için" izin vermemiz gerekir. Bunun için aşağıdaki bağlantıdaki 
    yönergeleri izleyebilirsiniz:

    https://www.terasic.com.tw/wiki/Disable_Driver_Signature_Enforcement_in_Windows10_x64
    
   Biz bu biçimde USB bağlantısı yaptığımızda artık IP ptotokol ailesini USB üzerinden kullanabilir duruma geliriz. Dolayısıyla
   ssh ile BBB'ye bağlanabiliriz. BBB'de yüklü olan Debian dağıtımının default kullanıcı ismi "debian" default parolası ise "temppwd"
   biçimindedir. Tabii hazır yüklü olan Linux dağıtımının klavye ayarları İngilizcedir. Türkçe klavye ile yazarken buna dikkat 
   ediniz. ssh bağlantısı için BBB'deki IPV4 adresi "192.168.7.2" biçimindedir. Yani bağlantı aşağıdaki gibi yapılabilir:

   $ ssh debian@192.168.7.2

   parola olarak da "temppwd" girilmelidir. On-board flash üzerine yüklenmiş olan Debian dağıtımında bir pencere yönetici program
   bulunmamaktadır. Zaten BBB'nin on-board flash belleği 4GB'dir. 

   Biz BBB'nin mini USB kablosunu host makinemize bağladığımızda artık host makinemizden BBB'ye ssh yoluyla erişebiliriz. Ancak
   BBB'deki Linux sisteminin masaüstü host makinemizdeki Internet'i kullanabilmesi için Windows ve Linux sistemlerinde bazı 
   ayarların da yapılması gerekmektedir. Tabii BBB'nin Internet'i kullanabilmesini sağlamanın en normal ve hızlı yolu doğrudan 
   ADSL Router'ımızdan gelen Ethernet RJ45 jakını BBB'ye takmaktır. Biz "Internet over USB" yerine bu yöntemi kullanmanızı 
   öneriririz.
-----------------------------------------------------------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------------------------------------------------------
                                                6. Ders 21/03/2024 - Perşembe
-----------------------------------------------------------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------------------------------------------------------
    BBB'ni on-board flash belleğine işletim sisteminin yeni bir sürümümü yerleştirebiliriz. Aslında Beagleboard için hazır imajlar
    zaten bulundurulmaktadır. Aşağıdaki bağlantıdan size uygun olan hazır imajları indirebilirsiniz:

    https://www.beagleboard.org/distros

    On-board flash belleğe işletim sistemini yüklemek için sırasıyla şu adımlardan geçilmelidir:

    1) Yukarıda belirttiğimiz sayfadan BBB için uygun sürüm indirilir. Bu sayfadaki hazır imajların bir bölümünde "Flasher" 
    ibaresi vardır. Bu "flasher" ibareli imajlardan biri indirilmelidir. Örneğin sınıftaki denemede aşağıdaki imaj indirilmiştir:
    
    AM335x 11.7 2023-09-02 4GB eMMC IoT Flasher

    Buradaki "IOT" sözcüğü indirilecek Debian dağıtımının IOT amaçla oluşturulmuş minimalist bir dağıtım olduğunu belirtmektedir. 
    Örneğin alternatif bir imaj da şu olabilir:

    AM335x 11.7 2023-09-02 4GB eMMC Xfce Flasher

    Burada "IOT" ibaresi yerine "Xfce" ibaresi bulunmaktadır. Xfce küçük bir pencere yöneticisidir. Ancak maalesef bu pencere 
    yöneticisi bile BBB'nin pek çok verisyonunda sistem kısıtları nedeniyle çok yavaş çalışma eğilinindedir. 

    2) İndirilen imaj zip'li olduğu için açılmalıdır. Açılan imajın uzantısının ".img" olması gerekir. 

    3) İmaj SD karta Rufus ya da Etcher benzeri bir programla yazılmalıdır. 

    4) SD karta yazma işlemi bittikten sonra SD kart BBB'nin SD kart yuvasına takılır. Sonra "Boot switch" denilen küçük düğmeciğe
    basılarak board'a güç verilir. Güç verildikten sonra 7, 8 saniye boot switch'e basılmaya devam edilmelidir. Sonra el boot 
    switch'ten çekilir. BBB'nin dört LED'i önce tamamen yanar. Sonra sırasıyla yanıp sönmeye başlar. Bu durum yazmanın başladığı
    anlamına gelmektedir. Yazma takriben 5 dakika civarında sürmektedir. Yazma bittikten sonra LED'ler tamamen söner. Boot switch
    Micro SD kartın yanındaki switch'tir.

    5) SD kart çıkartılarak sistem yeniden boot edilir. Artık on-board flash üzerine çektiğimiz işletim sistemi ile boot işlemini
    yapmış olduk. Ancak bizim indirdiğimiz imaj İngilizce (US) olarak ayarlanmıştır. Dolayısıyla default klavye ayarları da 
    İngilizce klavye biçimindedir.
-----------------------------------------------------------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------------------------------------------------------
    Debian türevi sistemlerde klavye ayarlarını değiştirmenin birkaç yolu vardır. Öncelikle locale ayarlarının Türkiye ve Türkçe 
    biçiminde yapılmasını tavsiye ederiz. Çünkü BBB için hazır bulundurulan Debian dağıtımında default locale ayarları Amerika 
    ve İngilizce biçimindedir. Bunu sağlamanın bir yolu aşağıdaki komutu kullanmaktadır:

    $ sudo dpkg-reconfigure locales 

    Karşımıza bir menü gelecektir. Bu menüden locale'i "tr_TR.UTF-8" biçiminde ayarlayabilirsiniz. Bu ayarlamadan sonra artık 
    /etc/default/locale dosyası aşağıdaki gibi olacaktır:

    #  File generated by update-locale
    LANG=tr_TR.UTF-8 

    Ancak locale'in ayarlanması klavye düzenini değiştirmemektedir. Locale'in ayarlanması birtakım mesajların Türkçe çıkmasını, 
    terminal aygıt sürücüsünün girdi ve çıktılarının encoding'ini belirlemektedir. Klavye düzeni manuel olarak "/etc/default/keyboard"
    dosyası üzerinde güncelleme  yapılarak ayarlanabilir. Bu dosyanın BBB'deki default içeriği şöyledir:

    # KEYBOARD CONFIGURATION FILE
    # Consult the keyboard(5) manual page.

    XKBMODEL="pc105"
    XKBLAYOUT="us"
    XKBVARIANT=""
    XKBOPTIONS=""
    BACKSPACE="guess"

    Bizim Türkçe klavye için buradaki XKBLAYOUT satırını aşağıdaki gibi değiştirmemiz gerekir:

    XKBLAYOUT="tr"

    Ancak bu dosyada değişiklik yapılması klavye düzeninin değişeceği anlamına gelmemektedir. Bu ve birkaç dosyaya bakarak klavye 
    düzenini ayarlayan bazı programlar vardır. Bunların çalıştırılması gerekir. Bunun için "setupcon" programı kullanılabilir:

    $ sudo setupcon

    Artık klavyemiz Türkçe olarak ayarlanmıştır. Ancak iki problem daha vardır. Birincisi BBB'deki Debian dağırtımındaki default 
    console fontu Türkçe'yi desteklememektedir. Yani klavyedeki tuşların yerleri doğru olarak ele alınmaktadır ama Türkçe 
    karakterler doğru görüntülenememektedir. İkinci sorun ise BBB'yi reboot ettiğimizde yaptığımız ayarların otomatik devreye 
    girmemesidir. 

    Console ekranının fontunu değiştirmek için "/etc/default/console-setup" dosyasının edit edilmesi gerekmektedir. Bu dosyasının 
    BBB'deki default durumu şöyledir:

    # CONFIGURATION FILE FOR SETUPCON
    # Consult the console-setup(5) manual page.

    ACTIVE_CONSOLES="/dev/tty[1-6]"
    CHARMAP="ISO_8859-15"
    CODESET="guess"
    FONTFACE="Fixed"
    FONTSIZE="8x16"
    VIDEOMODE=
    # The following is an example how to use a braille font
    # FONT='lat9w-08.psf.gz brl-8x8.psf'

    Bizim burada CHARMAP satırını aşağıdaki gibi UTF-8 olarak güncellememiz gerekir:

    CHARMAP="UTF-8"

    Şimdi artık sistemi reboot ettiğimizde login ekranındaki klavye düzeni İngilizce olsa da login olup "setupcon" programını 
    çalıştırdığımızda her şey Türkçe'ye göre ayarlanmış olacaktır. 

    Biz klavyeyi ve console fontlarını ayarlarken bazı dosyaları güncelledik. Aslında bu dosyaları manuel olarak edit etmek yerine 
    bunları güncelleyen küçük programlardan da faydalanılabilir. Örneğin aslında "sudo dpkg-reconfigure locales" komutu 
    "/etc/default/locale" dosyası üzerinde güncelleme yapmaktadır. Benzer biçimde "sudo dpkg-reconfigure console-data" komutu 
    da aslında "/etc/default/console-setup" dosyasını güncellemektedir. Bazen klavye ayaralarını çalışırken o anda başka bir dille 
    de değiştirmek isteyebiliriz. Bunun için "loadkeys" isimli program kullanılmaktadır. Bu program klavye düzenek dosyasını 
    argüman olarak alıp klavyeyi ona göre ayarlamaktadır. 

    Yukarıda da belirttiğimiz gibi biz Türkçe ayarlarını yapmış olsak da bu ayarları etkili hale getirmek için "setupcon" 
    programını çalıştırmamız gerekir. Bu nedenle BBB'mizi reboot ettiğimizde login ekranında yine klavye İngilizce'de kalacaktır. 
    Bunu kalıcı ayarlamanın bir yolu "sudo update-initramfs -u" işlemidir. Diğer yolu ise sistem boot edildiğinde otomatik olarak 
    bu "setupcon" programının çalıştırılmasını sağlamaktır. Bu konular ileride ele alınacaktır.
-----------------------------------------------------------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------------------------------------------------------
    Yukarıdaki ayarlama işlemlerinden de görüldüğü gibi aslında birtakım ayarlar "/etc" dizinini altındaki çeşitli dosyalarda 
    saklanmaktadır. Çeşitli programlar da ayarları bu dosyalara bakarak set etmektedir. Microsoft eskiden Linux'takilere benzer
    ismine "ini dosyaları" denilen ayar dosyalarını kullanıyordu. Daha sonra "registry" denilen tüm ayarların saklandığı mini 
    bir hiyerarişik veritabanı sistemine geçti. Ancak UNIX/Linux sistemlerinde böyle bir merkezi ayar sistemi kullanılmamaktadır. 
    Her ayar "/etc" dizininin altında belli formattaki dosyaların içerisinde saklanmaktadır. 
-----------------------------------------------------------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------------------------------------------------------
    Sizin de gördüğünüz gibi Raspberry Pi donanımı BBB'ye göre oldukça güçlüdür. Raspberry Pi'ın SD kartına yüklediğimiz 
    işletim sistemleri oldukça dolu bir biçimdedir. Çünkü bu sistemler tam bir bilgisayar gibi kullanılsın istenmiştir. Halbuki
    BBB'nin kaynakları zayıf olduğu için hazır imajlar genellikle dolu bir biçimde değildir. Örneğin UNIX/Linux sistemlerinde 
    yardım almak için kullanılan "man" programı BBB'nin default imajında bulunmamaktadır. man programını ve onun kullandığı 
    önemli veri dosyalarını aşağıdaki gibi yükleyebiliriz:

    $ sudo apt install man-db manpages-posix
    $ sudo apt install manpages-dev manpages-posix-dev
-----------------------------------------------------------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------------------------------------------------------
sudo apt-get install autoconf automake bison bzip2 cmake flex g++ gawk gcc gettext git gperf help2man libncurses5-dev \
libstdc++6 libtool libtool-bin make patch python3-dev rsync texinfo unzip wget xz-utils
-----------------------------------------------------------------------------------------------------------------------------*/

