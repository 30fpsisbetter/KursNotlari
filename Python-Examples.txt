/*--------------------------------------------------------------------------------------------------------------------------

                                               C ve Sistem Programcıları Derneği

                                                   Python Programlama Dili 

                                          Sınıfta Yapılan Örnekler ve Özet Notlar
        
                                                    Eğitmen: Kaan ASLAN
                                                    
                    Bu notlar Kaan ASLAN tarafından oluşturulmuştur. Kaynak belirtmek koşulu ile her türlü alıntı yapılabilir.

                              (Notları okurken editörünüzün "Line Wrapping" özelliğini pasif hale getiriniz.)
 
                                        
---------------------------------------------------------------------------------------------------------------------------*/

#------------------------------------------------------------------------------------------------------------------------
    REPL (Read and Evalutate and Print Loop) Ortamı için yaygın üç seçenek kullanılmaktadır:

    1) CPython dağıtımındaki IDLE
    2) Spyder IDE'sindeki IPython konsolu
    3) CPython yorumlayıcısı
#------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------
    Python'da "Merhaba Dünya" yazısını ekrana basan program aşağıdaki yazılabilir. Bir Python programını komut satırından 
    şöyle çalıştırabiliriz:

    python <dosya ismi>

    Örneğin:

    python sample.py

    Eğer python program isminden sonra çalıştrırılacak dosyanın ismi belirtilme<se Python yorumlayıcısı REPL ortamına girer.
    Bu ortamdan quit() yazarak çıkabilirsiniz.

    Mac OS X ve Linux sistemlerinde Python yorumlayıcısının iki versiyonu eşzamanlı biçimde bulundurulabilmektedir. Bu duruma
    dikkat ediniz. Genellikle "python" ismi Python'ın 2.7'li sürümlerini çalıştırmak için python3 ismi ise 3'lü sürümlerini
    çalıştırmak için kullanılmaktadır.

#------------------------------------------------------------------------------------------------------------------------

print('Merhaba Dünya')

#------------------------------------------------------------------------------------------------------------------------
    Python'da ifadelerden oluşan basit deyimler tek bir satırda yazılmak zorundadır. Eğer bir satıra birden fazla basit yerleştirilecekse
    bunların arasına ';' atomu getirilmelidir. Örneğin:

    a = 10; b = 20

    Burada satırın sonundaki basit deyimin sonuna da ';' getirilebilirdi. Ancak bu durum gereksizdir. Zaten Python'da Enter karakteri
    bir basit deyimin bitmiş olduğunu belirtir. 
#------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------
    Tür (type) bir nesnenin bellekte ne kadar yer kapladığını belirten, onun içerisindeki bilginin formatını belirten, 
    onun hangi operatörlerle işleme sokulabileceğini belirten temel bir özelliktir. Python tür bakımından minimalist biçimde
    tasarlanmıştır. Python'da 6 tane temel tür vardır: int, float, str, bool, complex, NoneType
#------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------
    Bir değişkene nokta içermeyen bir sayı atandığında o değişken artık int türünden olur. Bir değişkenin o andaki türünü type
    isimli built-in fonksiyonla elde edebiliriz. Python'da int türünün bir sınırı yoktur. Yani sınırsız bir biçimde basamak içerebilir. 
    Halbuki C, C++, Java ve C# gibi dillerde int türünün belli bir byte uzunluğu vardır. Dolayısıyla bu dillerde biz ancak belli aralıktaki
    sayıları int türden bir değişkenin içerisine yerleştirebiliriz. 
#------------------------------------------------------------------------------------------------------------------------

>>> a = 3928239847982347923749823749827349872398472983749823748982934234
>>> type(a)
<class 'int'>

#------------------------------------------------------------------------------------------------------------------------
    Aşağıdaki kodu bir program olarak çalıştırınız.
#------------------------------------------------------------------------------------------------------------------------

a = 10287364872364872348762348762

print(type(a))      # <class 'int'>

#------------------------------------------------------------------------------------------------------------------------
    Python'da noktalı sayılar "float" isimli türle temsil edilmiştir. float türü 8 byte uzunlukta kayan noktalı (IEEE 754 
    long real format) bir formata sahiptir. Python'daki float türü C, C++, Java ve C# gibi dillerdeki double türü ile aynıdır.
    Noktalı sayıların tutuluş formatından kaynaklanan ve ismine "yuvarlama hatası (rounding error)" denilen bir olgu vardır. 
    Yuvarlama hatası bir noktalı sayının tam olarak ifade edilemeyip ona yakın bir sayının ifade edilmesiyle oluşan bir hatadır. 
    Yuvarlama hataları sayıyı ilk kez depolarken de oluşabilir. Aritmetik işlemler sonucunda da oluşabilir. 
#------------------------------------------------------------------------------------------------------------------------

>>> f = 123.456789
>>> f
123.456789
>>> type(f)
<class 'float'>

#------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------
    Yuvarlama hataları her noktalı sayıda ortaya çıkmaz bazı noktalı sayılarda ortaya çıkar. Yuvarlama hataları sayı ilk kez depolanırken
    ortaya çıkabildiği gibi, bir işlem sonucunda da ortaya çıkabilmektedir. Bugün işlemcilerin kullandığı IEEE 754 numaralı fırmatta 
    yuvarlama hatalarını ortadan kaldırmanın bir yolu yoktur. Eğer yuvarlama hataları istenmiyorsa bu durumda özel başka türler tercih edilebilir. 
    Örneğin Pyton Standart Kütüphanesindeki "decimal" türü yapay bir tür olsa da yuvarlama hatalarına olanak vermemktedir. Programlama dillerinde
    yuvarlama hataları yüzünden iki noktalı sayının tam eşitliğinin karşılaştırılması uygun kabul edilmemektedir. Çünkü iki noktalı 
    sayı yuvarlama hatalarından dolayı biribirine eşit olacakken olmayabilir. 
    
    Aşağıda yuvarlama hatasına bir örnek verilmiştir.
#------------------------------------------------------------------------------------------------------------------------

>>> a = 0.3
>>> b = 0.1
>>> c = a - b
>>> c
0.19999999999999998

#------------------------------------------------------------------------------------------------------------------------
    Bir değişkene True ya da False anahtar sözcükleri atanırsa o değişken "bool" türünden olur. bool türü True ve False
    biçiminde yalnızca iki değer tutabilmektedir. Programcılar "doğru-yanlış", "olumsu-olumsuz", "evet-hayır" gibi iki 
    değer içeren olguları genellikle bool türü ile temsil ederler. Tabii yalnızca Pyton'da değil diğer programlama dillerinin 
    çoğunda aslında bool türden bir değişken 0 ya da 1 gibi bir sayı tutmaktadır. Yani biz bir değişkene True değerini atasak bile
    aslında bu değişken içsel olarak muhtemelen bu değeri 1 sayısı biçiminde tutmaktadır. Diğer programlama dillerinden geçenlerin 
    dikkat etmesi gereken bir nokta Python'da True ve False anahtar sözcüklerinin ilk harfinin büyük harf olmasıdır. Halbuki pek çok dilde
    bu anahtar sözcükler küçük harflerle oluşturulmaktadır.   
#------------------------------------------------------------------------------------------------------------------------

>>> b = True
>>> b
True
>>> type(b)
<class 'bool'>
>>> b = False
>>> b
False
>>> type(b)
<class 'bool'>

#------------------------------------------------------------------------------------------------------------------------
    Python'da yazıları tutan türe "str" denilmektedir. Bu türün ismi str olsa da biz bu türe "string" de diyeceğiz. String
    oluşturmak için tek tırnak ya da çift tırnak kullanılır. Bu bağlamda tek tırnakla çift tırnak arasında Python'da hiçbir
    farklılık yoktur. Bazı programlama dillerinde tek tırnak ile çift tırnak tamamen farklı anlamlara gelmektedir. Bu dillerden 
    geçen kişiler Python'da tek tırmak ile çift tırnak arasında bir fark olmadığına dikkat etmelidir.
    
    Biz kursumuzda ağırlıklı olarak tek tırnak kullanımını tercih edeceğiz. Pek çok programlama dilinde tek bir karakteri 
    tutmakta kullanılan "char" isimli bir tür de bulunmaktadır. Ancak Python'da böyle bir tür yoktur. Tek karakterli string'ler bu gereksinimi
    karşılamaktadır. Örneğin C, C++, Java ve C# dillerinde tek bir karakter tek tırnakla bireden fazla karakterden oluşan yazılar da çift 
    tırnakla ifade edilmektedir. Oysa Python'da karakter ve string biçiminde ikşi ayrı tür yoktur. Karakterler terk karakterden olulan string'lerle
    ifade edilmektedir. Dolayısıyla Python'da tek tırnakla çift tırnak arasında da bir farklılık kalmamaktadır. 
#------------------------------------------------------------------------------------------------------------------------

>>> s = 'Ankara'
>>> s
'Ankara'
>>> type(s)
<class 'str'>
>>> k = "Ankara"
>>> k
'Ankara'
>>> type(k)
<class 'str'>

#------------------------------------------------------------------------------------------------------------------------
    Python'da "complex" isimli bir tür de vardır. Bir complex nesne oluşturmak için 'j' harfi kullanılır. Ancak j harfinden önce 
    ona bitişik olan bir sayı getirilmesi zorunludur. Bu sayı genel olarak float olabilir. Complex sayılara '+' ya da '-' operatörü ile bir gerçek kısım 
    da ekleyebiliriz. 
#------------------------------------------------------------------------------------------------------------------------

>>> a = 1 + 2j
>>> b = 3j
>>> c = a + b
>>> a
(1+2j)
>>> b
3j
>>> c
(1+5j)
>>> type(a)
<class 'complex'>
>>> type(b)
<class 'complex'>
>>> type(c)
<class 'complex'>

#------------------------------------------------------------------------------------------------------------------------
    i sayısını ifade etmek için yalnızca j kullanılamaz. Çünkü yalnızca j bir değişken anlamına gelmektedir. Dolayısıyla 
    i sayısı 1j biçiminde ifade edilmelidir. 
#------------------------------------------------------------------------------------------------------------------------

>>> a = 1j
>>> a
1j
>>> type(a)
<class 'complex'>

#------------------------------------------------------------------------------------------------------------------------
    Python'da None anahtar sözcüğü ile temsil edilen  özel bir değer vardır. Bu None değeri "NoneType" isimli bir türdendir. 
    None değeri "yokluk", "boşluk", "hiçlik", "öylesinelik" ve başarısızlık gibi durumları ifade etmek için kullanılmaktadır.
    Biz bir değişkenin içerisine None değerini atadığımızda artık o değişken NoneType türünden olur. (None sşzcüğündeki ilk 'N'nin
    büyük harf olduğuna dikkat ediniz.) Komut satırında içerisinde None bulunan bir değişkenin ismini yazdığımızda ekrana bir şey 
    basılmaz. Ancak print fonksiyonuyla bu değişken yazdırılmak istendiğinde "None" yazısı görüntülenmektedir. 
#------------------------------------------------------------------------------------------------------------------------

>>> a = None
>>> a
>>> print(a)
None
>>> type(a)
<class 'NoneType'>

#------------------------------------------------------------------------------------------------------------------------
    Statik tür sistemine sahip programlama dillerinde bir değişken kullanılmadan önce derleyiciye tanıtılmak zorundadır. 
    Bu tanıtma eylemine "bildirim (declaration)" denilmektedir. Fakat Python gibi dinamik tür sistemine sahip programlama dillerinde
    bildirim diye bir işlem yoktur. Zaten bu tür dillerde bildirim işleminin bir anlamı da olamaz. Python'da bir değişken ona 
    ilk kez değer atandığında yaratılmaktadır. (Halbuki statik tür sistemine sahip programlama dillerinde değişkenler bildirim sırasında yaratılırlar.)

    Henüz yaratılmamış olan bir değişkeni ifadelerde kullanamayız. Tabii onu yaratma amacıyla atama operatörünün solunda kullanabiliriz.
    Bir değişken yaratılırken ona bir sabit, bir değişken genel olarak bir ifade atanabilir. 
#------------------------------------------------------------------------------------------------------------------------

a = 12.3
b = a + 1       # geçerli a yaratılmış, b de yaratılıyor
c = x + 2       # x yaratılmamış error oluşur


#------------------------------------------------------------------------------------------------------------------------
    Yukarıda da ifade ettiğimiz gibi Python'da bir değişken ona ilk kez değer atandığında yaratılır ve değişkenin türü de 
    ona atanan değerin türünden olur. Eninde sonunda değişkenlere bir biçimde sabitlerin atanması gerekmektedir. O halde 
    sabitlerin de türleri vardır. Şimdi sabit türleri üzerinde duracağız.
#------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------
    Programlarda doğrudan yazdığımız sayılara ya da yazılara "sabit (literals)" denilmektedir. Sabitler işin başında değişkenleri yaratmak için
    kullanılırlar. Sabitlerin türleri vardır. Sabitler bir değişkene atandığında değişken de o sabitin türünden olur. 

    1) Sayı nokta içermiyorsa böyle sayılar int türden sabit belirtir. int türden sabitler 0x ya da 0X ile başlatılarak 16'lık sistemde de
    yazılabilirler. int bir sabit 0o ya da 0O önekiyle başlatılarak yazılırsa 8'lik sistemde (octal system) yazıldığı 
    kabul edilmektedir. Nihayet int bir sabit 0b ya da 0B ile başlatılarak 2'lik sistemde (binary system) yazılabilir. 
#------------------------------------------------------------------------------------------------------------------------

>>> a = 123
>>> a
123
>>> type(a)
<class 'int'>
>>> a = 0o123
>>> a
83
>>> type(a)
<class 'int'>
>>> a = 0x123
>>> a
291
>>> type(a)
<class 'int'>
>>> a = 0b101010
>>> a
42
>>> type(a)
<class 'int'>

#------------------------------------------------------------------------------------------------------------------------
    Python'da int türden sabitler yazılırken sayıların aralarına alt tire karakteri konulabilir. Bu kural uzun tamsayılarda 
    okunabilirliği artırmak amacıyla dile sokulmuştur. Ancak iki tane alt tire yan yana bulundurulamaz ve sayının başında ve sonunda sonunda 
    alt tire bulundurulamaz. Alt tire 10'luk, 16'lık, 8'lik ve 2'lik sistemlerdeki yazımlarda da kullanılabilmektedir.
#------------------------------------------------------------------------------------------------------------------------

>>> a = 1_000_000_000
>>> a
1000000000
>>> a = 0x1234_5678
>>> a
305419896
>>> a = 0B1010_0101
>>> a
165
>>> a = 1_0_0_0
>>> a
1000

#------------------------------------------------------------------------------------------------------------------------
    2) Bir sayı nokta içeriyorsa sabit float türdendir. Noktanın soluna ya da sağına bir şey yazılmanışsa 0 yazılmış olduğu 
    varsayılır. float sabitlerde de alt tire benzer amaçla kullanılabilmektedir. float sabitler tıpkı diğer programlama dillerinde
    olduğu gibi üstel biçimde de belirtilebilmektedir. Bunun için önce nokta içeren ya da içermeyen bir sayısal kısım sonra 'e' ya da 'E' 
    harfi sonra da on üzeri anlamına gelen kuvvet değeri bulundurulur. Örneğin 1.2e-3 değeri 1.2 x 10^-3 anlamına gelmektedir. Tabii 
    üstel biçimdeki sayıda hiç nokta olmasa bile (1e3 örneğindeki gibi) sabit float kabul edilir. float sabitlerde de basamaklamak için 
    alt tire kullanılabilmektedir.
#------------------------------------------------------------------------------------------------------------------------

>>> a = 2.3
>>> type(a)
<class 'float'>
>>> b = .28
>>> type(b)
<class 'float'>
>>> c = 12.
>>> type(c)
<class 'float'>
>>> d = 10_3.23_45_57
>>> type(d)
<class 'float'>
>>> e = 1e40
>>> type(e)
<class 'float'>
>>> f = -1.2e-2
>>> type(f)
<class 'float'>
>>> g = 1.23_45e2_3
>>> type(g)
<class 'float'>

#------------------------------------------------------------------------------------------------------------------------
    Bir int sabiti pratik bir biçimde float sabit yapmak için sonuna nokta konulması yeterlidir. Örneğin:

    >>> a = 123
    >>> type(a)
    <class 'int'>
    >>> a = 123.
    >>> type(a)
    <class 'float'>

    C, C++, Java ve C# gibi dillerde sabitlerin sonlarına bazı sonekler getirilebilmektedir. Python'da böyle bir sonek getirme 
    durumu yoktur. 
#------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------
    3) bool türden iki sabit vardır: True ve False. Python'da bool türü aritmetik işlemlere sokulabilmektedir. Bu durumda True 
    1 olarak False 0 olarak işleme girmektedir. İki bool değeri kendi aralarında işleme sokarsak sonuç int türden elde edilmektedir. 
    Python'daki bool sabitlerin ilk harflerinin büyük harf olduğuna dikkat ediniz. 
#------------------------------------------------------------------------------------------------------------------------

>>> a = True
>>> type(a)
<class 'bool'>
>>> b = False
>>> type(b)
<class 'bool'>
>>> c = a * 3
>>> c
3
>>> type(c)
<class 'int'>
>>> d = True + True
>>> d
2
>>> type(d)
<class 'int'>

#------------------------------------------------------------------------------------------------------------------------
    4) Python'da bir yazı tek tırnak ya da çift tırnak arasına alınırsa bu ifade str türünden sabit belirtir. Bu bağlamda
    tek tırnakla çift tırnak arasında hiçbir farklılık yoktur. Python'ın 2'li versiyonları stringleri ASCII karakterleri biçiminde
    saklıyordu. Ancak 3'lü versiyonlarla birlikte Python'da tüm string'ler UNICODE tablo esas alınarak tutulmaya başlandı. UNICODE 
    tabloda her karakter 2 byte ile temsil edilmektedir. Böylece Python stringlerinin içerisinde biz dünyanın bütün karakterlerini 
    yerleştirebiliriz. Boş bir string oluşturmak da geçerlidir. 
#------------------------------------------------------------------------------------------------------------------------

>>> a = 'ankara'
>>> a
'ankara'
>>> type(a)
<class 'str'>
>>> b = 'ağrı dağı'
>>> b
'ağrı dağı'
>>> type(b)
<class 'str'>
>>> c = "burdur"
>>> c
'burdur'
>>> type(c)
<class 'str'>
>>> d = ''
>>> d
''
>>> type(d)
<class 'str'>

#------------------------------------------------------------------------------------------------------------------------
    UNICODE tablonun ilk 128 karakteri standart ASCII tablosu ile aynıdır. İkinci 128'lik karakteri ASCII Latin-1 (ISO 8859-1)
    code page'i ile aynıdır. ASCII ve UNICODE tablonun ilk 32 karakteri görüntülenemeyen (nonprintable) kontrol karakterlerinden oluşmaktadır. 
    Bu karakterleri yazdırmaya çalıştığımızda ekranda bir şey görmeyiz. Ancak bir eylem oluşur. Bu özel karakterlerin bazıları ters bölü
    tekniği ile kullanıma sunulmuştur. Ters bölü karakterlerinin listesi şöyledir:

    \a      Alert                   (beep sesi çıkar)
    \b      Backspace               (imleç backspace tuluna basılmış gibi bir geri gider)
    \f      Form feed               (bu karakter yazıcıya gönderilirse bir sayfa atar)
    \n      New Line                (imleç aşağı satırın başına geçirilir)
    \r      Carriage Return         (imleç bulunulan satırın aşağısına geçirilir)
    \t      (Horizontal) Tab        (imleç yatay olarak ilk tab stop'a atlar)
    \v      Vertical Tab            (İmleç düşey olarak bir tab atlar)

    Bu ters bölü karakterleri stringlerin içerisinde tek bir karakter olarak değerlendirilmektedir. Örneğin:

    s = 'Ali\nVeli'
    print(s)

    Burada şöyle bir görüntü oluşacaktır:

    Ali
    Veli

    Buradaki \n karakteri tek bir karakter olarak ele alınmaktadır. 

    Python'da tek tırnak içerisindeki tek tırnak, çift tırnak içerisindeki çift tırnak soruna yol açmaktadır. Bu nedenle tek tırnak
    içerisinde tek tırnak karakteri \' biçiminde yazılır. Benzer biçimde çift tırnak içerisindeki çift tırnak karakteri de \" biçiminde yazılmaktadır. 
    Ancak tek tırnak içerisindeki çift tırnak, çift tırnak içerisindeki tek tırnak bir soruna yol açmamaktadır. Örneğin:

    s = "Türkiye'nin başkenti Ankara'dır"
    print(s)

    k = 'Bu konuyu "vurgulamak" istiyorum'
    print(k)

#------------------------------------------------------------------------------------------------------------------------

>>> a = 'ankara'
>>> a
'ankara'
>>> type(a)
<class 'str'>
>>> b = 'ağrı dağı'
>>> b
'ağrı dağı'
>>> type(b)
<class 'str'>
>>> c = "burdur"
>>> c
'burdur'
>>> type(c)
<class 'str'>
>>> d = ''
>>> d
''
>>> type(d)
<class 'str'>
>>> e = 'Türkiye\'nin başkenti Anraka\'dır'
>>> print(e)
Türkiye'nin başkenti Anraka'dır
>>> f = "Türkiye'nin başkenti Ankara'dır"
>>> print(f)
Türkiye'nin başkenti Ankara'dır
>>> g = "Bu konuyu \"vurgulamak\" istiyorum"
>>> print(g)
Bu konuyu "vurgulamak" istiyorum
>>> h = 'Bu konuyu "vurgulamak" istiyorum'
>>> print(h)
Bu konuyu "vurgulamak" istiyorum

#------------------------------------------------------------------------------------------------------------------------
    String içerisindeki ters bölü karakterinin kendisini ters bölü biçiminde yazarsak o karakter yanındaki karakterle birlikte 
    tek bir karakter olarak ele alınabilir. Örneğin:

    path = 'C:\temp\a.dat'

    Burada \t karakteri TAB karakter ve \a karakteri de ALERT karakteri olarak ele alınacaktır. Bu karakterlerin gerçekten ters 
    bölü karakteri olarak ele alınabilmesi için \\ biçiminde yazılması gerekir. Örneğin:

    path = 'C:\\temp\\a.dat'

    C, C++, Java ve C# gibi dillerde ters bölü karakterinin yanındaki karakter ters bölü karakterlerinden biri değilse bu durum 
    sentaks bakımından geçerli kabul edilmemektedir. Halbuki Python'da ters bölü karakterinin yanındaki karakter yukarıda listesini verdiğimiz
    ters bölü karakterlerinden biri değilse artık orada ters bölü karakteri gerçekten ters bölü karakteri olarak ele alınmaktadır. Örneğin:

    path = "C:\day\month";      

    Bu string C'de geçersizdir. Ancak Python'da geçerlidir. Çünkü \d ve \m biçiminde bir ters bölü karakteri yoktur. Dolayısıyla \d karakterleri 
    gerçekten ters bölü karakteri ve d karakteri olarak ele alınmaktadır. Fakat programcının yine de ters bölü karakterinin kendisini 
    iki ters bölü karakteri ile yazması tavsiye edilmektedir. Örneğin:

    path = "C:\\day\\month";      

    Komut satırında str türünden bir değişkeni print fonksiyonu ile yazdırdığımızda gerçekten ters bölü karakterleri kendi işlevleri ile
    işlem görmektedir. Ancak str türünden değişkenin ismini yazıp ENTER tuşuna bastığımızda bu durumda ilgili yazı programcıların kolay anlaması 
    için ters bölülü biçimde görüntülenmektedir. Örneğin:

    >>> s = 'ali\nveli'
    >>> print(s)
    ali
    veli
    >>> s
    'ali\nveli'

#------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------
    Bir string'in önüne (yani soluna) onunla yapışık 'r' ya da 'R' karakteri getirilirse (Buradaki r "regular" sözcüğünden geliyor) bu string'ler içerisindeki
    ters bölü karakterleri gerçekten ters bölü karakterleri anlamına gelmektedir. Tabii içinde hiç ters bölü olmayan string'lerin başına r getirmenin 
    bir anlamı yoktur. Ancak yasak da değildir. 
#------------------------------------------------------------------------------------------------------------------------

>>> path = 'C:\temp\a.dat'
>>> print(path)
C:      emp.dat
>>> path = 'C:\\temp\\a.dat'
>>> print(path)
C:\temp\a.dat
>>> path = r'C:\temp\a.dat'
>>> print(path)
C:\temp\a.dat
>>> path = R'C:\temp\a.dat'
>>> print(path)
C:\temp\a.dat
>>> s = r'ali, veli, selami'  # başına r getirmenin bir anlamı yok
>>> print(s)
ali, veli, selami

#------------------------------------------------------------------------------------------------------------------------
    Python'da tek tırnak ve çift tırnak içerisindeki yazılar tek satıra (aynı satıra) yazılmak zorundadır. Örneğin:

    s = 'ali veli
    selami'

    Bu yazım geçersizdir. 
#------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------
    Python'da string'ler tek tırnağın ve çift tırnağın yanı sıra üç tek tırnak ve üç çift tırnakla da belirtilebilirler. (İki tek tırnak 
    ya da iki çift tırnak biçiminde bir belirtme yoktur.)
#------------------------------------------------------------------------------------------------------------------------

s = '''This is a test'''
print(s)

s = """This is a test"""
print(s)

#------------------------------------------------------------------------------------------------------------------------
    Üç tek tırnak ile üç çift tırnak arasında bir farklılık yoktur. Üçlü tırnakların tekli tırnaklardan iki farlılığı vardır:

    1) Normalde tek tırnak içerisindeki yazılar tek bir satırda yazılmak zorundadır. Ancak üç tırnaklı yazılar farklı satırlara bölünerek yazılabilir. 
    2) Üç tek tırnak içerisinde tek tırnak, üç çift tırnak içerisinde çift tırnak bir soruna yol açmaz.

    String'in tek tırnak ya da üç tırnak ile ifade edilmesi arasında ters bölü karakter sabitleri bakımından bir farklılık yoktur. 
    Yine üç tırnaklı string'lerin başına 'r' ya da 'R' öneki getirilebilir. Bu durumda yine buradaki ters bölü karakterleri gerçekten 
    ters bölü karakteri olarak değerlendirilir. 
#------------------------------------------------------------------------------------------------------------------------

s = '''Bugün hava 
çok güzel'''
print(s)

s = '''Türkiye'nin başkenti Ankara'dır'''
print(s)

s = '''c:\temp\a.dat'''
print(s)

s = r'''c:\temp\a.dat'''
print(s)

s = """"Türkiye'nin başkenti Ankara'dır. "Ankara" büyük bir şehirdir"""
print(s)

s = '''Türkiye'nin başkenti Ankara'dır. "Ankara" büyük bir şehirdir'''
print(s)

#------------------------------------------------------------------------------------------------------------------------
    Üç tek tırnağın ya da üç çift tırnağın içerisindeki tek tırnak ya da çift tırnak yazının başında olabilir. Ancak istisna olarak 
    sonunda olamaz. Çünkü Python'da ardışıl en uzun karakterlerden atom yapılmaktadır. Örneğin:

    s = """"ankara""""

    Burada iki tırnak içerisinde "ankara" yazılmak istenmiştir. Bunu Python yorumlayıcısı şöyle ayrıştıracaktır ayıracaktır:

    s
    =
    """
    "ankara
    """
    "       (burada tek kalıyor)

#------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------
    Python'un 2'li versiyonlarında bir byte'lık ASCII tablosunu kullanılıyordu. Bu versiyonlarda UNICODE string'ler için string'lere yapışık 
    'u' ya da 'U' önekleri kullanılıyordu. Ancak Python'ın stringleri zaten üçlü versiınlarla birlikte default UNICODE haline getirilmiştir. 
    Bugün hala bu 'u' ya da 'U' öneki geçerli olsa da artık bunun bir işlevi kalmamıştır. 
#------------------------------------------------------------------------------------------------------------------------

s = u'Ağrı Dağı çok yüksek'             # artık u önekine hiç gerek yok
print(s)

s = 'Ağrı Dağı çok yüksek'  
print(s)

#------------------------------------------------------------------------------------------------------------------------
    Tek tırnak ya da üç tırnağın önüne onunla yapışık 'b' ya da 'B' öneki getirilirse elde edilen nesne "bytes" denilen bir türden olur. 
    Yani artık bu nesne bir string değildir. Bu konu ileride ele alınacaktır. 
#------------------------------------------------------------------------------------------------------------------------

s = b'Bu bir denemedir'
print(s)
print(type(s))

#------------------------------------------------------------------------------------------------------------------------
    Python'da (tıpkı C Programlama Dilinde olduğu gibi) aralarında hiç bir atom olmayan yan yana iki string otomatik olarak birleştirilmektedir.
    Tabii bu iki string'in aynı satır üzerinde olması gerekir. Örneğin:

    s = 'ali'    'veli'

    ile,

    s = 'aliveli'

    aynı anlamdadır. 
#------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------
    5) None anahtar sözcüğü NoneType türünden sabit belirtmektedir. Zaten bu türden tek sabit None anahtar sözcüğüdür. None 
    değeri REPL ortamında ekrana bir şey basmamaktadır. None değeri print edilirse ekrana None yazısı çıkar.
#------------------------------------------------------------------------------------------------------------------------

>>> a = None
>>> a
>>> print(a)
None
>>> type(a)
<class 'NoneType'>

#------------------------------------------------------------------------------------------------------------------------
    6) Python'da 'j' harfi önünde yapışık bir float ya da int değerle kullanıldığında Complex türden sabit anlamına gelir. Complex sabitler
    'j' nin yanı sıra + ya da - operatörü ile bir gerçek kısma da sahip olabilirler. Yalızca j değerine sahip karmaşık sayı oluşturmak için 1j
    ifadesini kullanmak gerekir. Çünü tek başına j bir değişken ismi olarak ele alınmaktadır. 
#------------------------------------------------------------------------------------------------------------------------

z = 1j 
print(z)

z = -2j + 5
print(z)

z = 0j + 2
print(z)

#------------------------------------------------------------------------------------------------------------------------
    Python'da açıklama yazıları oluşturmak için (comment/remark) # kullanılmaktadır. # karakterinden satır sonuna kadarki 
    karakterler yorumlayıcı tarafından dikkate alınmamaktadır.
#------------------------------------------------------------------------------------------------------------------------

pi = 3.14159
radius = 2

area = pi *  radius * radius        # dairenin alanı

#------------------------------------------------------------------------------------------------------------------------
    Python'da etkisiz kod oluşturmak geçersiz değildir. Örneğin:

    10 + 20

    Böyle bir kodun bir anlamı yoktur. Çünkü bu kod program içerisinde bir durum değişikliği (side effect) oluşturmaz. Bu bağlamda bir değişkene
    atanmamış string'ler de etkisiz koddur ve geçerlidir. O halde Python'da birden fazla satır üzerinde yorumlama yapabilek için üç tırnaklı 
    string'ler kullanılabilir. Gerçekten de Python programcıları birden fazla satıra yayılmış yorumlamaları üç tırnaklı string'lerle yaparlar. 
#------------------------------------------------------------------------------------------------------------------------

"""
Merhaba Dünya 
Programı
"""

print('Hello World')

#------------------------------------------------------------------------------------------------------------------------
    Python'da bir değişken ona ilk kez değer atandaığında yaratılmaktadır. Değişken isimlendirmesinde diğer programlama dillerinin 
    çoğunda söz konusu olan kurallar geçerlidir:

    - Değişken ismi sayısal karakterlerle başlatılamaz, ancak alfabetik karakterlerle başlatılıp sayısal karakterlerle devam ettirilebilir. 
    - Değişken isimleri anahtar sözcüklerden oluşturulamaz. 
    - Değişken isimleri boşluk karakterlerini içeremez.
    - Değişken isimleri operatör karakterlerini içermez.
    - Python "büyük harf-küçük harf duyarlılığı olan (case sensitive)" bir programlama dilidir. Yani değişken isimlerindeki büyük harflerle küçük harfler
    birbirinden farklıdır. C, C++, Java ve C# dilleri de böyledir. Ancak Pascal, Basic gibi dillerde büyük harf küçük harf duyarlılığı yoktur (case insensitive).
    - Python 3'lü versiyonlarla birlikte UNICODE karakter tablosunu kullanmaya başlamıştır. Dolayısıyla değişken isimlendirmede UNICODE tablodaki
    bütün dillerin alfabetik karakterleri kullanılabilmektedir. Örneğin aşağıdaki gibi bir değişken ismi geçerlidir:

    ağrı_dağının_yüksekliği = 5137

    - Python Language Reference içerisinde değişkenlerin maksimum uzunluğu konusunda bir şey söylenmemiştir. Bu durum 
    değişkenlerin yeterince uzun olabileceği ancak bu limitin yorumlayıcıyı yazanların isteğine bırakılmış olduğu anlamına gelir. 

    Birden fazla sözcükten oluşan değişkenlerin harflendirilmesinde üç yöntem sıklıkla kullanılmaktadır:

    1) Klasik C tarxı harflendirme (yılan notasyonu da denilmektedir): Burada sözcüklerin arasına alt tire getirilir. Örneğin:

    number_of_students
    loop_count

    2) Deve Notasyonu (Camel Casting): Burada ilk sözcüğün tamamı küçük harflerle yazılır. Sonraki her sözcüğün yalnızca ilk harfi büyük harfle yazılır. 
    Örneğin:

    numberOfStudents
    loopCount

    3) Pascal Notasyonu (Pascal Casting): Pascal dilinde tercih edilen notasyon olduğu için bu isim verilmiştir. Burada her sözcüğün ilk harfi 
    büyük yazılır. Örneğin:

    NumberOfStudents
    LoopCount

    Her ne kadar Python büyük harf-küçük harf duyarlılığı olan bir dil ise de Python'da küçük harf yoğun bir harflendirme tercih edilmektedir. 


    Biz kursumuzda en yaygın harflandirme biçimi olan klasik C tarzı harflendirmeyi (yani sözcüklerin arasına alt tire getirme yöntemini) kullanacağzı.
#------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------
    CPU'ya elektriksel olarak doğrudan bağlı belleklere "ana bellek (main memory)" ya da "birincil bellek (primary memory") 
    ya da halk arasında "RAM" denilmektedir. RAM'deki her byte'a ilk byte 0 olmak üzere artan sırada bir sayı karşılık düşürülmüştür.
    Bu sayıya "ilgili byte'ın adresi" denilmektedir. Bellekte erişilebilen bölgere "nesne (object)" denilmektedir. Nesneler bir byte 
    ya da daha uzun olabilirler. 1 byte'tan daha uzun nesnelerin adresleri onların en küçük adresiyle ifade edilir. 

    Programlama dillerindeki değişkenler birer nesne belirtmektedir. Yani onların da adresleri vardır. c = a + b gibi bir işlemde
    a, b, c aslında RAM'de bulunur. CPU a ile b'yi kendi içine çeker. İşlem CPU tarafından elektrik devrelerle yapılmaktadır. Sonuç yeniden RAM'e 
    aktarılmaktadır. CPU nesnelerin isimleriyle değil adresleriyle çalışmaktadır.

    Bir nesnenin içerisinde tipik olarak bir değer tutulur. Ancak bazı nesnelerin içerisinde başka nesnelerin adresleri vardır. İşte başka nesnelerin
    adreslerini tutan nesnelere C Programlama Dİlinde "pointer", Java ve C# gibi dillerde ise "reference" denilmektedir. 
#------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------
    Python'da değişkenler her zaman adres tutarlar. Bir değişkene bir değer atandığında aslında yorumlayıcı değişkene o değerin bulunduğu 
    yeri adresini atamaktadır. Örneğin:

    a = 123

    Burada yorumlayıcı RAM'de bir int nesne yaratır. Onun içerisine 123 değerini yerleştirir. Onun adresini a'ya atar. Birazdan biz şöyle yapmış olalım:

    a = 3.14

    Şimdi derleyici RAM'de bir float nesne oluşturur. Onun içerisine 3.14 değerini yerleştirir. Bu kez onun adresini a'ya atar. 
    Python'da tüm atamalar adres atamasıdır. Biz Python'da "değişken" terimini adres tutan nesneler için kullanıyoruz. Ancak nesne terimini 
    değişkenlerin gösterdiği yer için kullanıyoruz. Aslında C, C++ gibi programlama dillerinin terminolojisinde hem değişkenler hem de 
    onların gösterdikleri yerdeki değerler birer nesnedir. Ancak Python'da biz değişken demekle içerisinde adres olan isimli varlıkları kastedeceğiz. 
    Değişkenlerin gösterdiği yerlere nesne diyeceğiz. 

    Dinamik tür sistemine sahip programlama dillerinde genel olarak tür bilgisi değişkenin içerisinde değil nesnenin içerisinde turulmaktadır. 
    Yani değişken o anda hangi nesneyi gösteriyorsa o türden olmaktadır. 
#------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------
    Bir değişkenin içerisindeki adres id isimli built-in bir fonksiyonla elde edilebilir. (Aslında Python referans kitabına göre 
    id fonksiyonu nesne ile ilgili tek (unique) bir değer vermelidir. Anack tipik olarak bu değer o nesnenin adresidir.)

    Aşağıdaki örnekte değişkene farklı değerler atandığında onun içerisindeki adresin değiştiğini göreceksiniz. 
#------------------------------------------------------------------------------------------------------------------------

a = 123
print(id(a))

a = 'this is a test'
print(id(a))

a = 12.3
print(id(a))

#------------------------------------------------------------------------------------------------------------------------
    Python'da tüm atamalar aslında adres atamasıdır. Ancak bir değişken atama dışında kullanıldığında o değişkenin içindeki adresteki nesne kullanılır. 
    Örneğin:

    a = 10
    b = 20
    c = a + b

    Burada aslında a'nın ve b'nin içerisinde birer adres vardır. Ancak a + b işleminde bu adresler değil bu adreslerin gösterdiği yerdeki int nesnelerin değerleri 
    toplanır. Toplama sonucunda yeni int nesne yaratılır. c'ye yeni yaratılmış olan int nesnenin adresi atanır. Örneğin:

    >>> a = 10
    >>> b = 20
    >>> c = a + b
    >>> id(a)
    140711499592776
    >>> id(b)
    140711499593096
    >>> id(c)
    140711499593416
#------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------
    Python'da tür bilgisi değişkenin içerisinde saklanmaz. Nensenin içerisinde saklanır. Örneğin:

    a = 123

    Burada a değişkeni içerisinde 123 olan int bir nesnenin adresini tutulmaktadır. Bu int nesnenin içerisinde yalnızca 123 değeri yoktur. 
    Bu nesnenin tür bilgisi de vardır. Ancak biz kursumunda çizimlerde nesnenin içerisindeki tür bilgisi alanını göstermeyeceğiz.
#------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------
    Python'da tüm atamalar adres atamalarıdır. Bir değişkeni bir değişkene atadığımızda biz aslında o değişkenin içindeki adresi diğer değişkene atamış oluruz.
    Örneğin:

    a = 10
    b = a

    Burada b = a işlemi ile aslında biz a değişkeninin içerisindeki adresi b değişkenine atamış olduk. Yani burada hem a hem de b
    aynı nesneyi göstermektedir. Örneğin:

    >>> a = 100
    >>> b = a
    >>> id(a)
    140711499595656
    >>> id(b)
    140711499595656

    Python'da bir değişken bir değişkene atandığında aslında o değişkenin içerisindeki adres diğer değişkene atanmaktadır. Atama sonrasında 
    her iki değişken de aynı nesneyi gösteriyor durumda olur. Örneğin:

    a = b

    Burada artık b de a da aynı nesneyi gösterecektir. 
#------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------
    Python'da türler (types), "değiştirilebilir (mutable)" ve "değiştirilemez (immutable)" olmak üzere ikiye ayrılmaktadır. 
    Değiştirilebilir türler türünden bir nesne yaratıldığında o nesnenin içerisindeki değer herhangi bir zaman değiştirilebilir. 
    Değiştirilemez türler türünden bir nesne yaratıldığında ise o nesnenin içerisindeki değerler nesne yaratılırken onun içerisine yerleştirilir. 
    Bir daha da değiştirilemez. Python'ın 6 temel türü de kategorik olarak "değiştirilemez" türlerdir. Daha açık bir biçimde belirtirsek:

    int türü değiştirilemezdir
    float türü değiştirilemezdir
    str türü değiştirilemezdir
    bool türü değiştirilemezdir
    complex türü değiştirilemezdir
    NoneType türü değiştirilemezdir

    Programcının değiştirilemez türden bir nesne yaratılırken belli bir değerle yaratıldığını bir daha da o değerin asla değişmeyeceğini
    biliyor olması gerekir. 
#------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------
    int, float, str, bool, complex, NoneType türlerinin "değiştirilemez" olmasının ilginç bazı sonuçları söz konusudur. Örneğin:

    >>> a = 10
    >>> id(a)
    140711499592776
    >>> a = 20
    >>> id(a)
    140711499593096

    Burada a değişkeni int türdendir. int nesne de kategorik olarak "değiştirilemez" bir türdür. O halde a'ya ikinci kez 
    değer atandığı durumda a = 20 işlemi için önceki nesnenin içerisindeki 10 değiştirilemeyeceğinden dolayı içerisinde
    20 olan farklı bir int nesne yaratılacak ve a artık o int nesneyi gösterecektir. 
#------------------------------------------------------------------------------------------------------------------------

a = 10
print(id(a))

a = 20
print(id(a))

#------------------------------------------------------------------------------------------------------------------------
    Bu durumda örneğin iki değişken aynı int nesneyi gösteriyor durumda olsun. Bunlardan birine atama yapıldığında diğerinin değeri 
    değişmez. Örneğin:

    a = 10
    b = a

    Burada a ve b aslında aynı nesneyi göstermektedir. Şimdi şu işlemi yapmış olalım:

    a = 20

    Burada int türü değiştirilemez olduğu için yeni bir int nesne yaratılacak onun içerisine 20 yerleştirilecek ve a da artık bu 
    yeni nesneyi gösterecektir. Halbuki b içerisinde 10 olan eski nesneyi göstermektedir. Yani buradaki semantik
    C, C++, Java ve C# gibi dillerdekiyle sonuç itibariyle aynı olacaktır. 

#------------------------------------------------------------------------------------------------------------------------

a = 10
b = a
a = 20

print(a)            # 20
print(b)            # 10

#------------------------------------------------------------------------------------------------------------------------
    Temel türlerin değiştirlemez olması Python'a geçen pek çok kişi tarafından yadırganmaktadır. Çünkü böylesi bir tasarım 
    bazı basit işlemlerde bile yavaşlığa yol açabilmektedir. Örneğin bir döngü içerisinde sürekli bir değişkeni 1 artırdığımızı 
    düşünelim. Döngünün her yinelenmesinde yeni bir nesne yaratılacak belki de eski nesne çöp toplayıcı tarafından silinecektir. 
    Bunun yavaşlığa yol açacağı muhakkaktır. Her ne kadar döngüleri bilmiyor olsak da aşağıda böyle bir örnek veriyoruz:

    a = 0

    for i in range(10):
        print(a, id(a))
        a = a + 1 

    Burada a değişkeninin id'sinin sürekli değiştirğini göreceksiniz:

    0 2172851716304
    1 2172851716336
    2 2172851716368
    3 2172851716400
    4 2172851716432
    5 2172851716464
    6 2172851716496
    7 2172851716528
    8 2172851716560
    9 2172851716592
#------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------
    Python'ın geniş bir standart kütüphanesi vardır. Bu standart kütüphanede neredeyse pek çok konuya ilişkin fonksiyonlar 
    ve sınıflar hazır bir biçimde bulunmaktadır.

    Standrat kütüphanedeki fonksiyonların ve sınıfların önemli bir bölümü çeşitli modüllerin içerisine yerleştirilmiştir. 
    Bu fonksiyonları ve sınıfları kullanmadan önce o modülün "import edilmesi" gerekmektedir. Örneğin karekök almakta kullanılan 
    sqrt fonksiyonu "math" isimli bir modülün içerisindedir. O halde sqrt kullanılmadan önce bu modülün aşağıdaki gibi import edilmesi gerekir:

    import math

    Modülün içerisindeki fonksiyonlar ve sınıflar modül ismi ve '.' operatörüyle niteliklendirilerek kullanılırlar. Örneğin:

    a = math.sqrt(10)

    gibi. Burada biz sqrt fonksiyonunu doğurdan değil math.sqrt biçiminde kullandık. Ancak önce math modülünü import ettik. 
    import etmenin ne anlama geldiğini ileride ayrı bir başlık altında ele alacağız. 

    Python'ın standart kütüphanesi python.org sitesinde "Python Standcart Library" ismiyle dokmante edilmiştir. Bu dokümana 
    aşağıdaki bağlantıdan erişebilirsiniz:

    https://docs.python.org/3/library/index.html

    O halde Python için iki önemli doküman vardır:

    1) Python dilinin resmi anlatımını yapan doküman: Python Language Reference

    https://docs.python.org/3/reference/index.html

    2) Python'ın standart kütüphanesini açıklayan doküman: Python Standard Library

    https://docs.python.org/3/library/index.html

    Tüm Python dokümanları da aşağıdaki bağlantıda bulunmaktadır:

    https://docs.python.org/3/
#------------------------------------------------------------------------------------------------------------------------

import math

result = math.sqrt(10)
print(result)

#------------------------------------------------------------------------------------------------------------------------
    Standart kütüphane içerisindeki bazı fonksiyonları ve sınıfları hiç import işlemi yapmadan doğrudan kullanabilmekteyiz. 
    İşte bu fonksiyonlara ve sınıflara "built-in" fonksiyonlar ve sınıflar denilmektedir. Örneğin print ve id fonksiyonları built-in 
    fonksiyonlardır. 
#------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------
    Python'da ekrana (yani stdout dosyasına) yazan tek bir print fonksiyonu vardır. Benzer biçimde klavyeden (yani stdin dosyasından)
    okuyan da tek bir input isimli fonksiyon vardır. input fonksiyonu yazı parametresi alır. Önce yazıyı ekrana basar. Sonra giriş ister. 
    Kullanıcı bir yazı girerek ENTER tuşuna basar. input fonksiyonu da girilmiş olan yazıyı bize str nesnesi oalrak verir. 
    input parantezleri boş bırakılabilir. 
#------------------------------------------------------------------------------------------------------------------------

s = input('Bir yazı giriniz:')
print(type(s))
print(s)

#------------------------------------------------------------------------------------------------------------------------
    Tabii Python'da her türlü atama "adres ataması" anlamına geldiğine göre aslında biz input fonksiyonunun geri dönüş değerini
    bir değişkene atadığımızda string nesnesinin adresini o değişkene atamış oluru. Örneğin:

    s = input('Bir yazı giriniz:')

    Burada s değişkenine bir str nesnesinin adresi atanmaktadır. 
#------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------
    input fonksiyonu her zaman okunan yazıyı string olarak verir. Eğer biz int ya da float ya da diğer türlerden okuma yapmak istiyorsak bu yazıyı 
    int türüne, float türüne ya da diğer türlere dönüştürmeliyiz. Bu dönüştürma aşağıdaki gibi yapılmaktadır:

    a = int(input('Bir sayı giriniz:))

    Burada input fonksiyonundan alınan yazı int fonksiyonuna sokulmuştur. Buradaki int fonksiyonu yazıyı int türüne dönüştürmektedir. 
#------------------------------------------------------------------------------------------------------------------------

a = int(input('Bir değer giriniz:'))

print(a * a)

b = float(input('Bir değer giriniz:'))
print(b * b)

#------------------------------------------------------------------------------------------------------------------------
    Programın çalışma zamanı sırasında ortaya çıkan ciddi hatalara "exception" denilmektedir. Bir exception oluştuğunda 
    programcı oluşan bu exception'ı yakalayıp programın çalışmasını devam ettirebilir. Ancak programcı exception'ı yakalamazsa
    program çöker. Exception işlemleri ileride ayrıntılarıyla ele alınacaktır. Örneğin biz klavyeden int bir değer okumak isterken 
    klavyeden girdiğimiz karakterler uygun değilse exception oluşur. Oluşan exception'ların bir türü vardır. Bu tür genellikle 
    XXXError biçiminde isimlendirilmiştir. Örneğin ValueError, TypeError gibi.

    Aşağıdaki örnekte bir sayı yerine bir isim girerek exception oluşturunuz.
#------------------------------------------------------------------------------------------------------------------------

a = int(input('Bir değer giriniz:'))

print(a * a)

#------------------------------------------------------------------------------------------------------------------------
    Python'da altprogramlara "fonksiyon (function)" denilmektedir. Küçük olmayan bir programın tek parça halinde yazılması iyi bir 
    teknik değildir. Programlar prosedürel teknikte mantıksal bakımdan parçalara ayrılır. Parçalar fonksiyonlar biçimin de yazılır. 
    Sonra da bu fonksiyonlar çağrılarak program çalıştırılır. Bir işin parçalara bölünüp parçalardan bütünün oluşturulması yalnızca 
    programlamada değil pek çok mühendislik faaliyette uygulanan bir tekniktir. 
#------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------
    Bir fonksiyon ya bir sınıfın içerisindedir ya da sınıfın içerisinde değildir. Python dünyasında sınıfın içerisindeki fonksiyonlara 
    "metot (method)" denilmektedir. Yani Python dünyasında "fonksiyon (function)" sınıfın içerisinde olmayan yordamlar için "metot (method)" 
    ise sınıfın içerisinde bulunan yordamlar için kullanılmaktadır. 

    Bir fonksiyon çağrıldığında onun içerisindeki kod çalıştırılır. Fonksiyonun çalışması bitince akış kalınan yerden devam eder. Fonksiyon 
    çağırma işleminin genel biçimi şöyledir:

    <fonksiyon ismi>([argüman listesi])

    Görüldüğü gibi fonksiyon isminden sonra (...) bulunmakta ve onların içlerine de "argümanlar" yazılmaktadır. Argümanlar herhangi birer ifade 
    olabilir. Eğer argümanlar birden fazla ise ',' atomu ile ayrılmaktadır. Örneğin:

    print(a)

    Burada a bir argümandır. Örneğin:

    print(a, b, c)

    Burada birden fazla argüman kullanılmıştır. Bir arüman ifadelerden oluşabilir. Örneğin:

    print(a + b, c + d)

    Burada iki argüman vardır. Argümanlardan biri a + b diğeri ise c + d biçimindedir. 

    Bir fonksiyon bir modülün içerisindeyse o fonksiyonu çağırmak için modülün ismi de kullanılmaktadır. Örneğin:

    math.sqrt(10)

    gibi.

    Ancak bir metodun çağrılması için o metodun içinde bulunduğu sınıf türünden bir değişkenin bulunuyor olması gerekir. Metot çağırma işleminin 
    genel biçimi de şöyledir:

    <sınıf türünde değişken>.<metodun ismi>([argüman listesi])

    Bir modül içerisindeki fonksiyonu çağırma biçimiyle bir metodu çağırma biçimi birbirne benzemektedir. 
#------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------
    Son 20 yıldır programalama anlatan dokümanlarda öylesine uydurulmuş fonksiyon isimleri için "foo", "bar", "tar" gibi 
    isimler kullanılmaktadır. Biz de kursumuzda çeşitli örneklerde bu isimleri kullanacağız. Bu isimlerin hiçbir özel anlamı 
    yoktur. Öylesine uydurulmuş isimlerdir. Örneğin:

    foo()
    bar()
    tar()

#------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------
    Python'da is operatörü iki değişkenin aynı nesneyi gösterip göstermediğini anlamak için kullanılmaktadır. Bu operatör bool bir değer
    üretmektedir. Eğer bu operatör True değer üretirse iki değişken aynı nesneyi gösteriyor durumdadır (yani onların içerisinde aynı adres vardır). False
    değer üretirse bu durum iki değişkenin aynı nesneyi göstermediği anlamına gelir. Bu durumda a is b ile id(a) == id(b) aynı anlamdadır. 
#------------------------------------------------------------------------------------------------------------------------

a = 10
b = 20

result = a is b
print(result)       # False

a = 100
b = a

result = a is b
print(result)       # True

#------------------------------------------------------------------------------------------------------------------------
    is not operatörü de is operatörünün tersi işlemi yapmaktadır. Yani a is not b işlemi eğer a'nın içerisindeki adres b'nin içerisindeki
    adresten farklıysa True değerini, aynısya False değerini üretmektedir. 
#------------------------------------------------------------------------------------------------------------------------

a = 10
b = 20

result = a is not b
print(result)       # True

a = 100
b = a

result = a is not  b
print(result)       # False

#------------------------------------------------------------------------------------------------------------------------
    Python'da None değerini içeren tek bir nesne vardır. Dolayısıyla biz farklı değişkenlere None değerini atadığımızda 
    aslında bu değişkenlere aynı adresi atamış oluruz. Örneğin:

    a = None
    b = None

    Burada a is b her zaman True değerini verecektir.     
#------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------
    Derleyiciler ve yorumlayıcılar kodu daha hızlı çalışacak ve/veya daha az yer kaplayacak biçimde yeniden düzenleyebilmektedir. 
    Buna "kod optimizasyonu" denilmektedir. Optimizasyon kodun anlamı değişmeyecek biçimde özenle yapılmaktadır. Örneğin 
    Python'da farklı değikenlere aynı sabitleri atadığımızda temel türler değiştirilebilir olmadığı için aslında yorumlayıcı 
    bu sabitler için tek bir yer ayırıp değişkenlere aynı nesnenin adresini atayabilmektedir. Örneğin:

    >>> a = 10
    >>> b = 10
    >>> c = 8 + 2
    >>> a is b
    True
    >>> a is c
    True
    >>> b is c
    True
    >>> id(a)
    140732013605960
    >>> id(b)
    140732013605960
    >>> id(c)
    140732013605960

    Kod optimizasyonları tamamen çalışmakta olduğunuz derleyici ya da yorumlayıcıya hatta bazen onların versiyonlarına bağlı 
    biçimde yapılmaktadır. Bir optimizasyonu bir Python yorumlayıcısı yaparken diğeri yapmayabilir. Önemli olan böyle bir 
    kodu yeniden düzenleme hakkının yorumlayıcıya verilmiş olmasıdır.
#------------------------------------------------------------------------------------------------------------------------

a = 12345
b = 12345

result = a is b
print(result)

s = 'ali'
k = 'ali'

result = s is k
print(result)

#------------------------------------------------------------------------------------------------------------------------
    Bir işleme yol açan işlem sonucunda bir değerin üretilmesini sağlayan atomlara operatör (operator) denilmektedir. Operatörler 
    genellikle üç biçimde sınıflandırılmaktadır:

    1) İşlevlerine Göre 
    2) Operand Sayılarına Göre
    3) Operatörün Konumuna Göre

    İşlevlerine göre sınıflandırma operatörün hangi konu ile ile ilgili işlem yaptığı ile ilgilidir. Tipik sınıflar şunlardır:
    
    - Artitmetik Operatörler (Aritmetic Op.)
    - Karşışaltırma Operatörleri (Comparision Op.)
    - Mantıksal Operatörler (Logical Op.)
    - Bit Operatörleri (Bitwise Op.)
    - Özel Amaçlı Operatörler (Special Pupose Op.)

    Operatörün işleme soktuğu atomlara operand denilmektedir. Operatörler "tek operandlı (unary)", "iki operandlı (binary)" ve "üç operandlı (ternary)" olabilirler. 
    Örneğin / operatörü "iki opendlı (binary)" bir operatördür. Çünkü a / b biçiminde iki değeri işleme sokmaktadır. Ancak örneğin "not" operatörü 
    tek operandlı (unary) bir operatördür. not a biçiminde tek bir değeri işleme sokmaktadır. Programlama dillerinde üç operandlı operatörler 
    seyrek bir biçimde bulunurlar. Python'da üç operandlı tek bir operatör vardır. 

    Operatör operandlarının önüne getirilerek kullanılıyorsa bunlara "önek (prefix)", sonuna getirilerek kullanılıyorsa bunlara "sonek (postfix)" 
    ve arasına getirilerek kullanılıyorsa bunlara da "araek (infix)" operatörler denilmektedir. Örneğin / operatörü araek bir operatördür. Ancak not 
    operatörü önek bir operatördür. 

    Bir operatörü ele alırken bu üç dınıflandırmada da nereye düştüğünün belirtilmesi gerekir. Örneğin "/ operatörü iki openadlı araek (binary infix) 
    aritmetik operatördür". Ya da örneğin "not operatörü tek operandlı önek (unary prefix)" bir mantıksal operatördür" gibi.
#------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------
    Bir ifadede birden fazla operatör varsa bu operatörler belli bir sırada yapılır. Buna "operatörler arasındaki öncelik ilişkisi 
    (operator precedency)" denilmektedir. Örneğin:

    a = b + c * d

    Burada üç operatör vardır. İşlemler şu sırada yapılacaktır:

    İ1: c * d
    İ2: b + İ1
    İ3: a = İ2

    Çünkü * operatörü + operatörüne göre daha önceliklidir. Öncelik sırasını değiştirmek için parantezlerden faydalanılmaktadır. Örneğin:

    a = (b + c) * d

    İ1: (b + c)
    İ2 = İ1 * d
    İ3: a = İ2

    Python'da pek çok operatör bulunduğu için programcının hangi operatörün hangi operatörden daha öncelikli olduğunu bilmesi gerekmektedir. 

    Operatörler arasındaki öncelik ilişkisi "operatörlerin öncelik tablosu" denilen bir tabloyla betimlenmektedir. Bu tablo satırlardan oluşur.
    Her satırın yanında "soldan-sağa" ya da "sağdan sola" ibaresi vardır. Tabloda üst satırdaki operatörler alt satırdaki operatörlerden
    daha yüksek önceliklidir. Aynı satırda bulunan operatörler "ifade içerisindeki (tablodaki değil) konumlarına göre soldan sağa ya da sağdan sola öncelikli" 
    yapılmaktadır. Aşağıda öncelik stablosunun yalın bir biçimi görünmektedir:

    ()      soldan sağa
    * /     soldan sağa
    + -     soldan sağa
    =       sağdan sola

    Bu durumda örneğin:

    a = b - c * d + e

    İ1: c * d
    İ2: b - İ1
    İ3: İ2 + e
    İ4: a = İ3

    Öncelik tablosunda bir satırdaki operatörlerin sırasının hiçbir önemi yoktur. Çünkü "soldan sağa ya da sağdan sola ibaresi
    ifadedeki sırayı belirtmektedir, tablodaki sırayı belirtmemektedir."
#------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------
    *, /, + ve - operatörleri iki operand'lı araek aritmetik operatörlerdir. Bunlar temel dört işlemi yaparlar. Öncelik tablosounda 
    * ve / operatörleri + ve - operatörlerinden daha yüksek önceliklidir. 

    ()      soldan sağa
    * /     soldan sağa
    + -     soldan sağa
    =       sağdan sola

#------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------
    Python'da / operatörünün her iki operandı int olsa bile bu operatör float bir değer üretmektedir. Bu anlamda / operatörünün
    davranışı C, C++, Java ve C#'takinden farklıdır.
#------------------------------------------------------------------------------------------------------------------------

result = 10 / 4

print(result, type(result))     # 2.5, <class 'float'>

#------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------
    Python'da noktadan sonraki kısmı atan // biçiminde ayrı bir operatör de vardır. Bu operatöre "floordiv" operatörü denilmektedir. 
    Bu operatörde elde edilen sonuç pozitifse sayının noktadan sonraki kısmı atılır. Tam kısmı elde edilir. Operandların her ikisi de int ise
    sonuç int türden olur. Operand'ların en az biri float türdense sonuç float olur. 
#------------------------------------------------------------------------------------------------------------------------

result = 10 // 4
print(result, type(result))         # 2 <class 'int'>

result = 10. // 4
print(result, type(result))         # 2.0 <class 'float'>

#------------------------------------------------------------------------------------------------------------------------
    // operatörü sonuç üzerinde "floor" işlemi uygulamaktadır. floor işlemi bir noktalı sayının kendisinden küçük ya da ona eşit olan 
    en yakın tamsayıya dönüştürülmesine denilmektedir. Bu davranış C, C++, Java ve C#'takinden farklıdır. Örneği Python'da 10 // 4 bize 2 verir. 
    Çünkü 2.5 değerinin floor işlemine sokulmasından 2 değeri elde edilmektedir. Ancak -10 // 4 bize -3 verir. Çünkü -2.5 değerinin
    floor işlemine sokulmasından -3 elde edilmektedir. C, C++, Java ve C#'taki davranışa "truncation toward zero" denilmektedir. 
#------------------------------------------------------------------------------------------------------------------------

result = -10 // 4
print(result, type(result))         # -3 <class 'int'>

#------------------------------------------------------------------------------------------------------------------------

    // operatörü öncelik tablosunda * ve / ile soldan sağa öncelikli satırda bulunmaktadır. 

    ()          soldan sağa
    *  /  //    soldan sağa
    +  -        soldan sağa
    =           sağdan sola

#------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------
    % operatörü iki operandlı araek bir aritmetik operatördür. Bu operatör soldaki operandın sağdaki operanda bölümünden elde edilen 
    kalan değerini üretir. Operatörün her iki operandı da int türündense sonuç int türünden elde edilir. Operandlardan en az biri float ise
    sonuç float türden olur.  % operatörü de öncelik tablosunda * , / ve // operatörü ile aynı satırda bulunmaktadır:

    ()              soldan sağa
    *  /  //  %     soldan sağa
    +  -            soldan sağa
    =               sağdan sola

#------------------------------------------------------------------------------------------------------------------------

result = 20 % 3
print(result, type(result))     # 2 <class 'int'>

result = 20.5 % 3
print(result)                   # 2.5 <class 'float'>

#------------------------------------------------------------------------------------------------------------------------
    a sayısını b ye böldüğümüzde bölüm c kalan d ise aslında a = b * c + d ilişkisi söz konusudur. Bu nedenle Python'da negatif bir sayının
    pozitif  bir sayıya bölümünden elde edilen kalan pozitif olmaktadır. Yani örneğin -10 % 4 işleminin sonucu 2'dir. Çünkü -4 * 3 + 2 = -10'dur.
    Bu opratörden elde edilen kalan her zaman sağ tarafındaki operandın işartindendir. Operatör yukarıda da belirttiğimiz şu eşitliği 
    sağlamaktadır: a == (a // b) * b + d.
#------------------------------------------------------------------------------------------------------------------------

result = -10 % 4
print(result, type(result))      # 2 <class 'int'>

result = 10 % -4
print(result, type(result))      # -2 <class 'int'>

#------------------------------------------------------------------------------------------------------------------------
    İşaret + ve işaret - operatörleri tek operandlı önek (unary prefix) aritmetik operatörlerdir. İşaret - operatörü operandının negatif 
    değerini üretir. İşaret + operatörü operandı ile aynı değeri üretir. Bu iki operatör de öncelik tablosunda diğer aritmetik operatörlerden
    yüksek öncelikli biçimde "sağdan sola" grupta bulunmaktadır:

    ()              soldan sağa
    +  -            sağdan sola
    *  /  //  %     soldan sağa
    +  -            soldan sağa
    =               sağdan sola

    Örneğin:

    a = ----1

    Burada - operatörlerinin hepsi işaret - operatörüdür. İşlemler sağdan sola şöyle yapılır:

    İ1: -1      => -1
    İ2: -İ1     => 1
    İ3: -İ2     => -1
    İ4: -İ3     => 1
    İ5: a = İ4  => 1

    Örneğin:

    a = 3----1

    Hu ifadenin anlamlı olabilmei için ilk - operatörünün çıkartma operatörü diğer - operatörlerinin işaret - operatörü pşması gerekir. 
    İşlemler şöyle yapılacaktır:

    İ1: -1      => -1
    İ2: -İ1     => 1
    İ3: -İ2     => -1
    İ4: 3 - İ2  => 4
    İ5: a = İ4  => 4

#------------------------------------------------------------------------------------------------------------------------

a = 3----1
print(a)        # 4

#------------------------------------------------------------------------------------------------------------------------
    Python'da üs almak için ** operatörü bulundurulmuştur. ** iki operandlı araek bir operatördür. Bu operatör soldaki operandının sağdaki 
    kuvvetini elde eder. Sayının 0.5'inci kuvvetinin karekök anlamına geldiğini anımsayınız. Sayının negatif kuvvetlerinin de geçerli olduğuna dikkat ediniz. 
#------------------------------------------------------------------------------------------------------------------------

result = 3 ** 3
print(result)       # 27

result = 3 ** 1.7
print(result)       # 6.473007839923779

result = 3 ** 0.5
print(result)       # 1.7320508075688772

result = 2 ** -2
print(result)       # 0.25

#------------------------------------------------------------------------------------------------------------------------
    ** operatörü öncelik tablosunda işaret + ve işaret - operatörlerinden daha yüksek öncelikli sağdan sola bir grupta bulunmaktadır. 
    Bu operatörün öncelik tablosundaki yeri matematiksel alana uygun olsa da programlama dillerine göre biraz yadırganmaktadır:

    ()              soldan sağa
    **              sağdan sola
    +  -            sağdan sola
    *  /  //  %     soldan sağa
    +  -            soldan sağa
    =               sağdan sola

#------------------------------------------------------------------------------------------------------------------------

result = -3 ** 2
print(result)               # -9    

result = (-3) ** 2
print(result)               # 9    

#------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------
    ** operatörünün sağdan sola öncelikli grupta olduğuna dikkat ediniz. Yani ifade içerisinde birden fazla ** operatörü varsa 
    önce sağdaki yapılmaktadır.
#------------------------------------------------------------------------------------------------------------------------

result = 2 ** 3 ** 2    
print(result)       # 512

result = (2 ** 3) ** 2    
print(result)       # 64

#------------------------------------------------------------------------------------------------------------------------
    Python'da 6 karşılaştırma operatörü vardır. Karşılaştırma operatörlerinin hepsi iki operandlı araek (binary infix) operatörlerdir:

    < > <= >= == != 

    "Eşit mi" karşılaştırmasının == operatörü ile "eşit değil mi" karşılaştırmasının ise != operatörü ile yapıldığına dikkat ediniz. 

    Karşılaştırma operatörleri artimetik operatörlerden daha düşük önceliklidir. Bu operatörler bool türden değer üretirler. 
#------------------------------------------------------------------------------------------------------------------------

result = 3 > 2
print(result)       # True

#------------------------------------------------------------------------------------------------------------------------
    bool türünden değerler karşılaştırma operatörleri de dahil olmak üzere diğer türlerle işleme sokulursa önce int türüne dönüştürülürler
    sonra karşılaştırma işlemine girerler. bool değerler int türüne dünüştürülürken True 1 olarak, False ise 0 olarak dönüştürülmektedir. 
    Örneğin:

    result = True > 0

    Bu işlemde operandlardan biri bool diğeri int türdendir. Bu durumda True int türüne 1 olarak dönüştürülecek ve sonuç True olarak 
    elde edilecektir. Benzer biçimde iki bool türü de kendi aralarında karşılaştırma işlemine sokulursa önce operand'lar int türüne 
    dönüştürülür, sonra karşılaştırma yapılır. Örneğin:

    result = True > False

    Burada aslında 1 > 0 gibi bir karşılaştırma yapılmıştır. Dolayısıyla bu işlem True sonucunu verecektir. 
#------------------------------------------------------------------------------------------------------------------------

result = True > 0
print(result)       # True

result = True > False
print(result)       # True

#------------------------------------------------------------------------------------------------------------------------
    Python'da karşılaştırma operatörleri kombine edildiğinde "and" etkisi oluşur. Örneğin a < b < c işlemi geçerlidir ve bu işlem
    a < b and b < c anlamına gelmektedir. Ya da örneğin a == b != c geçerlidir. Bu işlem a == b and b != c anlamına gelmektedir. Örneğin:

    a == b == c

    işlemi a == b and b == c anlamına gelmektedir. 

    Tabii ikiden fazla karşılaştırma operatörü de bu biçimde kombine edilebilir. Örneğin a > b < c > d işleminin eşdeğeri 
    a > b and b < c and c > b biçimindedir. 
#------------------------------------------------------------------------------------------------------------------------

val = int(input('Bir değer giriniz:'))

result = 10 < val < 20      # eşdeğeri: 10 < val and val < 20
print(result)

#------------------------------------------------------------------------------------------------------------------------
    Karşılaştırma operatörleri öncelik tablosunda aritmetik operatörlerdne düşük öncelikli gruplardadır.
    
    ()                  soldan sağa
    **                  sağdan sola
    +  -                sağdan sola
    *  /  //  %         soldan sağa
    +  -                soldan sağa
    <  >  <=  >= == !=  soldan sağa
    =                   sağdan sola

    Yani örneğin:

    result = a + b > c + d

    gibi bir işlemde a + b ile c + d karşılaştırılmaktadır.

#------------------------------------------------------------------------------------------------------------------------
    Python'da üç mantıksal operatör vardır: and, or ve not operatörleri. and ve or operatörleri iki operandlı araek (binary infix), 
    not operatörü ise tek operandlı önek (unary prefix) operatörlerdir. 

    Python'da mantıksal operatörlerin operandları herhangi bir türden olabilir. Halbuki Java ve C# gibi bazı dillerde mantıksal operatörlerin operandları 
    bool türden olmak zorundadır. Yani örneğin Python'da aşağıdaki gibi bir işlem geçerlidir:

    result = 3 and -3.5

    Python'da mantıksal operatörler karşılaştırma operatörlerinden daha düşük önceliklidir. Ancak mantıksal not operatörü pek çok 
    programlama dilinde yüksek bir önceliğe sahipken Python'da o dillere göre düşük bir önceliğe sahiptir:

    ()                  soldan sağa
    **                  sağdan sola
    +  -                sağdan sola
    *  /  //  %         soldan sağa
    +  -                soldan sağa
    <  >  <=  >= == !=  soldan sağa
    not                 sağdan sola
    and                 soldan sağa
    or                  soldan sağa
    =                   sağdan sola

    Genellikle mantıksal operatörler karşılaştırma operatörlerinin çıktıları üzerinde işlem yapmak için kullanılırlar. 
    Örneğin:

    result = a > b and c > d

    Burada a > b ve c > d koşılunun aynı anda sağlanıp sağlanmadığına bakılmaktadır. 

    and ve or operatörleri şöyle çalışmaktadır: Bu operatörlerin diğer programlama dillerinde olduğu gibi "kısa devre (short circuit)" 
    özellikleri vardır. Bu operatörlerin önce her zaman sol tarafındaki ifade yapılır. Sağ tarafında ne kadar yüksek öncelikli operatör olursa
    olsun önce yalnızca sol tarafları yapılır. Bu operatörler operandlarını True/False olarak yorumlarlar. int ve float operandlarda sıfır değeri False, 
    sıfır dışı herhangi bir değer True anlamına gelmektedir. and operatörünün sol tarafındaki ifade False ise bu operatörün sağ 
    tarafındaki ifade hiç yapılmaz, operatör sol tarafındaki değeri üretir. and operatörünün sol tarafındaki ifade True ise bu kez sağ 
    tarafındaki ifade yapılır. Operatör sağ tarafındaki ifadenin değerini üretir. or operatörü de benzerdir. Bu operatörün de önce sol tarafındaki
    ifade yapılır. Bu ifade True ise sağ tarafındaki ifade hiç yapılmaz operatör sol tarafındaki değeri üretir, eğer bu ifade False ise bu kez
    sağ tarafındaki ifade yapılır. Operatör sağ tarafındaki değeri üretir. Bu operatörlerin sol tarfındaki ya da sağ tarafındaki değeri ürettiğine dikkat ediniz. 
    Örneğin:

    result = -3 and 6.7
    print(result)       # 6.7

    Örneğin:

    result = 0 and 6.7
    print(result)       # 0

    Örneğin:

    result = 3 + 2 or False
    print(result)               # 5

    Örneğin:

    result = 3 > 2 and 5 < 0
    print(result)               # False     

    Örneğin:

    result = 1.2 and 0
    print(result)       # 0

    Örneğin:

    result = 10 and 20
    print(result)       # 20
    
#------------------------------------------------------------------------------------------------------------------------
    and ve or operatörleri aynı ifadede kullanıldığında her zaman sol taraftaki operatörün sol tarafı önce yapılmaktadır. 
    Örneğin:

    ifade1 and ifade2 or ifade3

    Burada önce ifade1 yapılır eğer ifade1 True ise ifade2 yapılır ve and operatmründen ifade2 elde edilir. ifade2 True
    ise ifade3 yapılmaz sonuç olarak ifade2 elde edilir. Örneğin:

    ifade1 or ifade2 and ifade3

    Burada ifade aslında aşağıdaki sonucu vermelidir:

    ifade1 or (ifade2 and ifade3)

    Yani bu ifade aslında ifade1 ile (ifade and ifade3)'ün or'lanması anlamına gelmektedir. and ve or operatörlerinin her zaman sol tarafı 
    önce yapılacağına göre burada önce ifade1 yapılır. Eğer ifade1 True ise doğurdan ifade1'in değeri elde edilir. Eğer ifade1 
    False ise bu kez ifade2 yapılır. ifade2 False ise ifade3 hiç yapılmaz, ifade2'nin sonucu elde edilir. Eğer ifade1 False ancak 
    ifade2 True ise ifade3'ün sonucu elde edilir. Özetle and ve or operatörleri kombine edildiğinde her zaman en soldaki operatörün en solu
    önce yapılacaktır. 
#------------------------------------------------------------------------------------------------------------------------

result = 10 and 0 or 5
print(result)       # 5

result = 0 and -5 or 5
print(result)       # 5

result = 100 or -5 and 5
print(result)       # 100

result = 0 or 0 and 5
print(result)       # 0
#------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------
    not operatörü tek operandlı önek (unary prefix) mantıksal operatördür. Bu operatör True değerini False, False değerini True yapar. 
    Operatörün ürettiği değer her zaman bool türdendir. Bu operatörün de operandları int ya da float türünden olabilir. Sıfır dışı değerler 
    (nonzero değerler) True olarak sıfır değeri False olarak ele alınır. 
#------------------------------------------------------------------------------------------------------------------------

result = not 23.4
print(result)        # False

result = not False
print(result)       # True

result = not 0
print(result)       # True

#------------------------------------------------------------------------------------------------------------------------
    not operatörü öncelik tablosunda and ve or operatörlerinden daha yüksek önceliklidir ve kandi içerisinde sağdan sola 
    grupta bulunmaktadır.

    ()                  soldan sağa
    **                  sağdan sola
    +  -                sağdan sola
    *  /  //  %         soldan sağa
    +  -                soldan sağa
    <  >  <=  >= == !=  soldan sağa
    not                 sağdan sola
    and                 soldan sağa
    or                  soldan sağa
    =                   sağdan sola

#------------------------------------------------------------------------------------------------------------------------

result = not not not not True
print(result)           # True

#------------------------------------------------------------------------------------------------------------------------
    Python'da mantıksal not operatörü C, C++, Java ve C# gibi dillerle kıyaslandığında düşük önceliklidir. Özellikle bu dillerden geçen 
    kişiler Python'da not operatörünün aritmetik ve karşılaştırma operatörlerinden daha düşük öncelikli olduğuna dikkat etmelidir. Örneğin:

    result = not a + b 
    
    işleminde ya da:

    result = not a < b

    işleminde önce toplama ve karşılaştırma oeratörleri yapılıp sonra not operetörü yapılır. Halbuki C, C++ gibi dillerde önce not işlemi 
    yapılmaktadır:

    result = !a < b;

#------------------------------------------------------------------------------------------------------------------------
    Python'da boş olmayan bir string mantıksal olarak True, boş bir string False biçiminde ele alınmaktadır. Başka bir deyişle
    dolu string'ler bool türüne True olarak boş string'ler False olarak dönüştürülmektedir.
#------------------------------------------------------------------------------------------------------------------------

result = 'ankara' or 12.3
print(result)           # 'ankara'

result = 'istanbul' and 'ankara'
print(result)           # 'ankara'

result = not ''
print(result)           # True

result = not '0'
print(result)           # False

#------------------------------------------------------------------------------------------------------------------------
    Python'da None değeri mantıksal olarak ele alınacağı zaman her zaman False biçimde ele alınır. Bşka bir deyişle 
    None değeri bool türüne her zaman False olarak dönüştürülür.
#------------------------------------------------------------------------------------------------------------------------

result = not None
print(result)           # True

result = None or 'ankara'
print(result)           # 'ankara'

#------------------------------------------------------------------------------------------------------------------------
    Ayrıca henüz görmemiş olsak da önemli türler bool türüne şöyle dönüştürülmektedir:

    - Dolu bir liste True olarak, boş liste False olarak.
    - Dolu bir demet True olarak, boş bir demet False olarak.
    - Dolu bir sözlük True olarak, boş bir sözlük False olarak.
    - Dolu bir küme True olarak, boş bir küme False olarak.
#------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------
    Python'da atama işlemi aslında bir operatör değil bir deyim statüsündedir. Ancak biz geleneksel olarak burada atama işlemi için 
    "operatör" terimini kullanacağız. Bir operatör olarak atama operatörü iki operandlı araek bir operatördür. Anımsanacağı gibi Python'da 
    tüm atama işlemleri aslında adres ataması anlamına gelmektedir. Örneğin:

    a = b

    Burada b'nin içerisindeki değer a'ya atanmamaktadır. b'nin içerisindeki adres a'ya atanmaktadır. Çünkü bütün değişkenler adres tutmaktadır.
    Bu işlemin sonucunda a is b ifadesi True değerini verecektir. 
    Örneğin:

    a = 10

    Burada a'nın içerisine 10 atanmamaktadır. 10 bir int nesneye yerleştirilip a'ya o int nesnenin adresi atanmaktadır. Atama operatörü öncelik 
    tablosunun en düşük düzeyinde ve sağdan sola öncelikli gruptadır. 

    ()                  soldan sağa
    **                  sağdan sola
    +  -                sağdan sola
    *  /  //  %         soldan sağa
    +  -                soldan sağa
    <  >  <=  >= == !=  soldan sağa
    not                 sağdan sola
    and                 soldan sağa
    or                  soldan sağa
    =                   sağdan sola

    Örneğin:

    a = b = 10

    İ1: b = 10
    İ2: a = İ1

    Yani burada 10 değeri bir nesneye yerleştirilecek, o nesnenin adresi hem b'ye hem de a'ya atanacaktır.
#------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------
    Python'da atama işlemi aslında bir operatör olarak değil deyim olarak değerlendirilmektedir. Dolayısıyla atama işleminden bir değer elde edilmez. 
    Örneğin biz C, C++, Java ve C# gibi dillerde atama operatörünü parantez içerisine alıp oradan elde edilen değeri diğer operatörlerle
    işleme sokabiliriz. Ancak Python'da bunu yapamayız.
#------------------------------------------------------------------------------------------------------------------------

a = (b = 10) + 20       # C, C++, Java ve C#'ta geçerli, Python'da geçersiz!

#------------------------------------------------------------------------------------------------------------------------
    Atama işleminden Python'da bir değer elde edilememesi yüzünden diğer dillerde yapılan bazı faydalı işlemler Python'da 
    atama işlemiyle yapılamamaktadır. Örneğin:

    while (a = int(input())) != 0:      # Python'da geçersiz, ama benzeri diğer dillerde geçerli
        pass

#------------------------------------------------------------------------------------------------------------------------
    Python'a 3.8 versiyonu ile birlikte (2019 Ekim) "Walrus operatörü" diye isimlendirilen değer üreten bir atama operatörü de eklenmiştir. 
    Bu operatör sayesinde yukarıda belirttiğimiz diğer dillerde yapamadığımız işlemleri yapabiliriz. Walrus operatörü := sembolü ile
    temsil edilmektedir. İki operandlı araek bir operatördür. 
#------------------------------------------------------------------------------------------------------------------------

a = (b := 10) + 20       
print(a, b)     # 30 10

#------------------------------------------------------------------------------------------------------------------------
    Python'da gereksiz bir biçimde Walrus operatörünün kullanılması konusunda programcının cesaretini kırmak için gereksiz 
    Walrus operatörünün kullanılması error oluşturmaktadır. Örneğin:

    a := 10

    Burada Walrus operatörüne hiç gerek yoktur. Bu nedenle bu kullanım error oluşturur. Ancak örneğin:

    a = (b := 10) + 20

    Burada Walrus operatörü yerine atama operatörünü kullanamayız. Buradaki Walrus operatörü doğru kullanılmıştır ve error oluşturmayacaktır. 
    Örneğin:
    
    a := b := 10

    Burada Walrus operatörü gereksiz kullanılmıştır. Error oluşacaktır. Çünkü bu işlem atama operatörleriyle de yaılabilmektedir.  Walrus operatörü 
    yukarıda geçersiz durumlarda paranteze alınırsa geçerli hale gelmektedir. Örneğin:

    (a := 10)

    Bu işlem geçerlidir. Parantezlerin "elde edilen değerin kullanılşması anlamına geldiğine dikkat ediniz.). Örneğin:

    a := 10          # error!
    (a := 10)       #geçerli

    Örneğin:

    b := (a := 10)      # error!

    Fakat örneğin:

    b = (a := 10)           # geçerli
    (b := (a := 10))        # geçerli
    
    Örneğin:

    print(a := 10)          # geçerli parantez zaten vardır

    Buı kod aşağıdaki ile eşdeğerdir:

    a = 10
    print(a)

    Özetle atama operatörü ile yapabileceğimiz bir işlemi Walrus operatörü ile yapmaya çalışırsak bu durum error oluşturur. Ancak error oluşturmasın istiyorsak
    paranteze almalıyız. Ancak atama operatörü ile yapamadığımız bir şeyi Walrus operatörüyle yapabiliyorsak bu durum error oluşturmaz. Örneğin:

    print(a := 10)

    Biz bu işlemi atama operatör ile yapamazdık. O halde burada Walrus operatörünün kullanılması geçerlidir. Ancak örneğin:

    a := 10     # error!

    Biz bu işlemi atama operatörü ile yapabilirdik. Burada paranteze alınmadan Walrus operatörünün kullanılması error oluşturur.

    if, while gibi deyimlerde zaten atama operatörü kullanılamadığı için Walrus operatörünün paranteze alınması gerekmez. Bu tür deyimlerde
    atanan değer doğrudan işleme sokulmaktadır. Örneğin :

    while s := input():
        pass

    Biz burada Walrus operatörü yerine atama operatörünü kullanamayız. Bu örnekte Walrus operatörünün en dıştan ayrıca paranteze alınması gerekmemektedir. 

    Walrus opeeratörü öncelik tablosunda atama opeeatör ile aynı gruptadır:

    ()                  soldan sağa
    **                  sağdan sola
    +  -                sağdan sola
    *  /  //  %         soldan sağa
    +  -                soldan sağa
    <  >  <=  >= == !=  soldan sağa
    not                 sağdan sola
    and                 soldan sağa
    or                  soldan sağa
    =  :=               sağdan sola

    Bu nedenle aşağıdaki gibi bir kodda parantez gereklidir:

    while (a := int(input('Bir değer giriniz:'))) != 0:
        print(a * a)

#------------------------------------------------------------------------------------------------------------------------
    Python'da ++ ve -- biçiminde operatörler yoktur. ++ ve -- operatörleri C, C++, Java ve C# gibi dillerde vardır ve çok kullanılmaktadır. 
    Bu dillerde ++ operatörü değişkenin içerisindeki değeri 1 artıtmak için, -- operatörü değişken içerisindeki değeri 1 eksiltmek için
    kullanılmaktadır. Python'da değişkenin içerisindeki değeri 1 artırmak ve 1 eksiltmek için sonraki paragrafta açıklayacak olduğumuz 
    += ve -= gibi işlemli atama operatörleri (augmented assignment operators) ile yapılmaktadır. 
#------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------
    Python'da +=, -=, *=, /=, //=, %= gibi bir grup işlemli atama operatörü (augmented assignment statments) vardır. Bu operatörler iki operandlı araek 
    operatörlerdir. op bir operatör belirtmek üzere:

    a op= b

    işlemi aşağıdakiyle eşdeğerdir:

    a = a op b

    Bu durumda a += 2 işlemi a = a + 2 ile, a *= 10 işlemi a = a * 10 ile eşdeğerdir. and, or ve not operatörlerinin işlemli biçimi yoktur.
    Python'da bir değişkeni 1 artırmak için en pratik yöntem += operatörünü kullanmaktadır. Örneğin:

    a += 1

    Benzer biçimde bir değişkeni 1 eksiltmek için en pratik yok -= operatörünü kullanmaktır:

    a -= 1

    Tabii işlemli atama operatörleri temel türlerle kullanıldığında bu temel türler "değiştirilemez (immutable)" olduğu 
    için yine yeni nesnelerin yaratılmasına yol açacaktır. Örneğin:

    >>> a = 10
    >>> id(a)
    140712253256776
    >>> a += 1
    >>> a
    11
    >>> id(a)
    140712253256808

    Biz kursumuzda atama işlemi için kullanılan = sembolünü ve işlemli atamalar için kullanılan op= sembollerini birer "operatör"
    olarak ele alıyoruz. Halbuki bu semboller aslında "Python Language Reference" içerisinde operatör değil "deyim (statement)" 
    olarak ele alınmaktadır. 

#------------------------------------------------------------------------------------------------------------------------
    İşlemli atama operatörleri atama operatörleriyle sağdan sola aynı öncelik grubunda bulunmaktadır:

    ()                          soldan sağa
    **                          sağdan sola
    +  -                        sağdan sola
    *  /  //  %                 soldan sağa
    +  -                        soldan sağa
    <  >  <=  >= == !=          soldan sağa
    not                         sağdan sola
    and                         soldan sağa
    or                          soldan sağa
    =  := , +=, -=, *=, ...     sağdan sola

#------------------------------------------------------------------------------------------------------------------------
    *=, /= ve //= operatörlerinin atama operatörü önceliğinde olduğuna dikkat ediniz. 
#------------------------------------------------------------------------------------------------------------------------

a = 10

a *= 2 + 1
    
print(a)        # 30

#------------------------------------------------------------------------------------------------------------------------
    Anımsanacağı gibi print fonksiyonu çıktıları imlecin bulunduğu yerden itibaresn ekrana (stdout dosyasına) yazdırıp imleci
    aşağıda satırın başına geçirmektedir. print fonksiyonu değişken sayıda argüman alabilmektedir. Yani biz print sonksiyonu 
    ile birden fazla ifadeyi yazdırabiliriz. Bu durumda print fonksiyonu her argümanın değerini yazdırdıktan sonra bir 
    SPACE boşluk bırakır. print fonksiyonu tüm işlemini bitirince '\n' karakterini ekrana (stdout dosyasına) yazdırmaktadır. 
    Yani print işleminden sonra imleç aşağı satırın başına geçmektedir. 
#------------------------------------------------------------------------------------------------------------------------

print('ali', 'veli', 'selami')  # ali veli selami

a = 10; b = 20; c = 30
print(a, b, c)                  # 10 20 30

#------------------------------------------------------------------------------------------------------------------------
    print fonksiyonuyla birden fazla argümanı yazdırırken her argümandan sonra print araya bir SPACE karakteri bırakmaktadır. 
    Ancak programcı isterse "sep" isimli parametreyle boşluk yerine argümanlar arasında istenilen yazının bastırılmasını sağlayabilir. 
    sep için girilen yazının tek karakter olması gerekmemektedir. 
#------------------------------------------------------------------------------------------------------------------------

a = 10
b = 20
c = 30

print(a, b, c, sep='***')     # 10***20***30
print('Ok')

#------------------------------------------------------------------------------------------------------------------------
    sep aparemtresinin hiç girilmemesiyle bunun sep=' ' biçiminde girilmesi arasında bir fark olmadığına dikkat ediniz. 
    Yani sep parametresinin default değerini ' ' olarak düşünebilirsiniz. 
   
    Aşağıdaki örnekte her argümandan sonra print ", " yazısını ekrana (stdout dosyasına) bastırmaktadır.
#------------------------------------------------------------------------------------------------------------------------

a = 10
b = 20
c = 30

print(a, b, c, sep=', ')        # 10, 20, 30
print('Ok')

#------------------------------------------------------------------------------------------------------------------------
    Aşağıdaki örnekte her argüman yazdırıldıktan sonra imleç aşağıda staırın başına geçirilecek ve dolayısıyla argümanlar
    satır satır alt alta yazdırılmış olacaktır. 
#------------------------------------------------------------------------------------------------------------------------

a = 10
b = 20
c = 30

print(a, b, c, sep='\n')

#------------------------------------------------------------------------------------------------------------------------
    print fonksiyonunun "end" isimli parametresi tüm yazdırma işlemi bittiğinde ekrana basılacak yazıyı belirtmektedir. Default durumda 
    bu yazı '\n' biçimindedir. Yani imleç aşağı satırın başına geçirilir. Ancak biz end parametresi yoluyla print fonksiyonunun işlemini bitirdikten 
    sonra istediğimiz bir yazıyı ekrana bastırmasını isteyebiliriz. Örneğin:

    print(10, 20, 30, sep='*', end='---')
    print('ankara)

    Burada ekranda şunları göreceğiz:

    10*20*30---ankara
#------------------------------------------------------------------------------------------------------------------------

a = 10
b = 20
c = 30

print(a, b, c, sep='xxx', end='yyy')        
print('Ok')

# # 10xxx20xxx30yyyOk

#------------------------------------------------------------------------------------------------------------------------
    Bilindiği gibi bir değişkenin içerisinde belli bir türden nesnenin adresi olabilir. Örneğin:

    a = 12.3

    Burada a değişkeninin içerisinde float bir nesnenin adresi vardır. Yani biz a'yı kullandığımızda float bir değeri işleme sokmuş oluruz.
    İşte bir nesnenin içerisindeki değeri değiştirerek başka bir türden bir nesne biçiminde elde etme işlemine programlama dillerinde 
    "tür dönüştürmesi (type conversion / type cast)" denilmektedir. Örneğin biz yukarıdaki a değişkeninin gösterdiği nesnenin içerisindeki değeri 
    int bir nesne biçiminde elde etmek isteyebiliriz. 

    Tür dönüştürme işleminin genel biçimi şöyledir:

    <dönüştürülecek tür>(<ifade>)

    Örneğin:

    a = 13.2

    b = int(a)

    Tür dönüştürme işlemiyle yeni bir nesne yaratılmaktadır. Her tür dönüştürme işlemi yeni bir nesnenin yaratılmasına yol açmaktadır. Yani tür 
    dönüştürmesi mevcut nesnesinin türünü değiştirmemektedir. Mevcut nesnenin değerindne hareketle arzu edilen türden yeni bir nesnenin yaratılmasını
    sağlamaktadır. Örneğin:

    a = 13.2
    b = int(a)

    Burada a'nın türü değiştirilkmemiştir. Yeni bir int nesne yaratılmış ve onun adresi b'ye atanmıştır.

    Aslında T bir tür belirtmek üzere T türünden bir nesnenin yaratılması T(...) biçiminde bir ifadeyle yapılmaktadır. 
    Bu konu ileride "sınıflar" konusunda ayrıntılarıyla ele alınacaktır.

#------------------------------------------------------------------------------------------------------------------------
    float bir değer int türüne dönüştürüldüğünde noktadan sonraki kısmı atılmış olan bir int değer elde edilir. Burada yuvarlama
    yapılmadığına float değer negatif de olsa pozitif de olsa noktadan sonraki kısmın atıldığına dikkat ediniz.
#------------------------------------------------------------------------------------------------------------------------

a = 13.99

print(id(a))       

b = int(a)

print(id(b))

print(a)        # 13.99
print(b)        # 13

a = -13.99

b = int(a)
print(b)        # -13

#------------------------------------------------------------------------------------------------------------------------
    bool bir değer int türüne dönüştürülürse eğer değer True ise 1, False ise 0 elde edilir. 
#------------------------------------------------------------------------------------------------------------------------

a = True

b = int(a)

print(b)        # 1

a = False

b = int(a)

print(b)        # 0

#------------------------------------------------------------------------------------------------------------------------
    Bir string'i int türüne dönüştürürken string içerisindeki yazı int türü için anlamlı sayısal karakterlerden oluşuyorsa 
    yeni bir int nesne yaratılır ve yazı int bir nesne biçiminde ifade edilir. Ancak yazının içerisindeki karakterler int 
    türü için anlamlı değilse bu durumda exception (ValueError) oluşur. Daha önceden de belirttiğimiz gibi bir exception oluştuğunda eğer
    exception programcı tarafından ele alınmadıysa program çökmektedir. String'in başındaki boşluk karakterlerine "leading space", string'in 
    sonundaki boşluk karakterlerine "trailing space" denilmektedir. Dönüştürme sırasında yazının başındaki ve sonundaki boşluk karakterleri 
    dikkate alınmamaktadır. Örneğin:

    >>> a = '123'
    >>> b = int(a)
    >>> b
    123
    >>> a = '12.3'
    >>> b = int(a)
    Traceback (most recent call last):
    File "<stdin>", line 1, in <module>
    ValueError: invalid literal for int() with base 10: '12.3'
    >>> a = '     -123    '
    >>> b = int(a)
    >>> b
    -123
#------------------------------------------------------------------------------------------------------------------------

a = '123'

b = int(a)

print(b)        # 123

a = 'ali'

b = int(a)      # exception oluşur!

print('unreachable code')

#------------------------------------------------------------------------------------------------------------------------
    Bir string'i int türüne dönüştürürken string içerisindeki yazının kaçlık sistemde bir sayı belirttiğini de int fonksiyonunun
    ikinci parametresiyle ifade edebiliriz. Örneğin:

    a = '100'

    b = int(a)

    Default durumda a içerisindeki yazının 10'luk sistemde bir sayı belirttiği varsayılmaktadır. Fakat örneğin:

    a = '100'

    b = int(a, 16)

    Burada artık biz '100' yazısında belirtilen sayının 16'lık sistemde bir sayı olması gerektiğini belirtiyoruz. Örneğin:

    a = '100'

    b = int(a, 2)

    Burada a yazısının belirttiği sayının 2'lik sistemde yorumlanması gerektiği belirtilmektedir. 16'lık, 8'lik ya da 16'lık
    sistemden yazı dönüştürürken yazının başında taban belirten önekler bulunabilir. Örneğin:

    >>> s = '0x1234'
    >>> a = int(s, 16)
    >>> a
    4660
    >>> s = '0o1234'
    >>> a = int(s, 8)
    >>> a
    668
    >>> s = '0b10101'
    >>> a = int(s, 2)
    >>> a
    21

#------------------------------------------------------------------------------------------------------------------------

a = '0x10'

b = int(a, 16)
print(b)            # 16


a = '0b1010'

b = int(a, 2)
print(b)            # 10

a = '0x10'
b = int(a)          # exception oluşur!

print(b)

#------------------------------------------------------------------------------------------------------------------------
    Complex türünden int türüne dönüştürme geçerli kabul edilmemektedir. Böyle bir dönüşüm yapılmak istendiğinde exception (TypeError)
    oluşmaktadır.
#------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------
    None değerinin int türüne dönüştürülmesi de Python'da geçerli kabul edilmemektedir. Bu dönüştürme de exception'a (TypeError) yol açmaktadır.
#------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------
    int bir ifadenin int türüne dönüştürülmesi geçerlidir ancak anlamsızdır. Bu durumda dönüştürüleek ifade ile aynı değer 
    elde edilir. 
#------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------
    O halde int türüne dönüştürme özetle şöyle yürütülmektedir:

    1) float bir değer int türüne dönüştürüldüğünde noktandan sonraki kısım atılırç
    
    2) str türü int türüne dönüştürüldüğünde eğer yaqzının içerisindeki karakterler int türü için geçerliyse dönüştürme yapılır
    değilse exception (ValueError) oluşur.
    
    3) bool bir değer int türüne dönüştürüldüğünde False için 0, True için 1 elde edilmektedir. 
    
    4) complex türü int türüne dnüştürülemez. Dönüştürülmeye çalışılırsa exception (TypeError) oluşur.
    
    5) None değeri (NoneType türü) int türüne dönüştürülemez. Dümüştürülmek istenirse exception (TypeError) olulur.
#------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------
    int bir değer float türüne dönüştürülürken eğer int değer float formatıyla (IEEE 754 long real format) tam olarak ifade 
    edilebiliyorsa .0 biçiminde float türüne kayıp olmadan dönüştürülür. Ancak Python'da int değerlerin bir sınırının olmadığını anımsayınız. 
    Bu durumda çok büyük int değerler float türüne dönüştürülemeyecektir. İşte bu tür durumlarda exception (OverrlowError) oluşmaktadır. 
    Bazı int değerler mantis kayıplarıyla basamaksal bir kayıp olmadan float türe dönüştürülebilmektedir. Bu durumda bir exception
    oluşmaz. Sayı float türüyle tam olarak ifade edilemese bile mantis kaybıyla ona en yakın büyük ya da ona en yakın küüçük 
    sayı elde edilmektedir. Ancak basamaksal kayıplar exception'a (OverflowError) yol açmaktadır. Örneğin:

    >>> a = 12345678901234567890123456789
    >>> b = float(a)
    >>> b
    1.2345678901234568e+28
    >>> int(b)
    12345678901234568227576610816

    >>> a = 1817236817263817263871263871263871263871623876123876128736187263871263817263871263871623812638716238716238761238
    761283761827361872368712638172638712638712638712638172638126387126387123618723618273618273618723681723618236182361827361
    283612836128361872361872361823681726381726387126387126381723687126381726387126387126381723618276387126387126387123
    >>> b = float(a)
    Traceback (most recent call last):
    File "<stdin>", line 1, in <module>
    OverflowError: int too large to convert to float
#------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------
    Bir string float türüne dönüştürülebilir. Bu durumda string float ile ifade edilebiliyorsa (yani string'i oluşturan karakterler
    float sayı için anlamlıysa) dönüştürme yapılır. String float türüyle ifade edilemiyorsa exception (ValueError) oluşur. 
    float fonksiyonu her zaman tek parametrelidir. flaot türü ile ifade edilemeyecek çok büyük büyük ya da küçük yazısal değerlerin
    float türüne dönüştürülmesi sırasında ne olacağı konusunda "Python Standard Library Reference" açık bir şey söylememiştir. 
    Mevcut CPythob gerçekleştirimi bu durumda +inf ya da -inf değerlerini üretmektedir. 
#------------------------------------------------------------------------------------------------------------------------

a = '  123.45   '

b = float(a)
print(b)

a = '123.23ali'

b = float(a)        # exception oluşur
print(b)

#------------------------------------------------------------------------------------------------------------------------
    bool türünden bir ifade float türüne dönüştürüldüğünde eğer bool değer True ise 1.0 biçiminde false ise 0.0 biçiminde 
    float bir değer elde edilir.
#------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------
    Complex bir ifade float türüne dönüştürülemez. Dönüştürülmek istenirse exception (TypeError) oluşur. Benzer biçimde None değeri de 
    flaot türüne döüştürülememektedir. Dönüştürülmek istenirse yine exception (TypeError) oluşmaktadır.
#------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------
    O halde float türüne dönüştürme özetle şöyle yürütülmektedir:

    1) int bir değer float türüne bilgi kaybı olmadan, mantissel kayıp ile dönüştürülebilir. Ancak basamaksal bir kayıp 
    oluşacaksa dönüştürme exception (OverflowError) ile sonuçlanır.

    2) str türü float türüne dönüştürülebilir. Tabii bunun için yazının karakterlerinin float türü için anlamlı olması gerekir. 
    Aksi takdirde dönüştürme exception (ValueError) ile sonuçlanır.

    3) bool türü float türüne dönüştürülürse True için 1.0, False için 0.0 değeri elde edilir.

    4) Complex türü float türüne dönüştürülemez. Dönüştürülmek istenirse exception (TypeError) oluşur. 

    5) None değeri (NoneType türü)  türü float türüne dönüştürülemez. Dönüştürülmek istenirse exception (TypeError) oluşur. 
#------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------
    Bir int değer bool türüne dönüştürülürken eğer değer sıfır dışı bir değerse True olarak 0 değeri ise False olarak dönüştürülür.
    Benzer biçimde float bir değer de bool türüne aynı biçimde dönüştürülmektedir. (Sıfır dışı değer demekle 0'ın dışında pozitif ya da
    negatif herhangi bir değer kastedilmektedir.) None değer bool türüne her zaman False olarak dönüştürülmektedir. 
#------------------------------------------------------------------------------------------------------------------------

a = 123801928309123

b = bool(a)     
print(b)            # True

a = -12.34

b = bool(a)     
print(b)            # True

a = None

b = bool(a)
print(b)            # False

#------------------------------------------------------------------------------------------------------------------------
    Bir string bool türüne dönüştürülürken string'in içerisindeki yazıya bakılmaz. String'in boş mu dolu mu olduğuna bakılır. 
    Dolu bir string bool türüne True olarak, boş bir string False olarak dönüştürülmektedir. Örneğin aşağıdaki dönüştürme 
    True değerini verecektir:

    s = 'False'
    b = bool(s)
    print(b)                # True

#------------------------------------------------------------------------------------------------------------------------

a = 'ankara'

b = bool(a)     
print(b)            # True

a = 'False'

b = bool(a)     
print(b)            # True

a = ''

b = bool(a)     
print(b)            # False

#------------------------------------------------------------------------------------------------------------------------
    Ayrıca boş listeler, demetler, sözlükler, kümeler bool türüne False biçiminde, dolu listeler, demetler, sözlükler ve kümeler de True biçiminde 
    dönüştürülürler. Listeler, demetler, sözlükler, kümeler konusu izleyen bölümlerde ele alınmaktadırç
#------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------
    Bir int değer ya da bir float değer complex türüne dönüştürülebilir. Bu durumda sanal kısmı 0 olan bir complex sayı elde edilir. 
    bool bir değer complex türüne dönüştürülürse gerçek kısmı 1 ya da 0 olan sanal kısmı 0 olan bir complex sayı elde edilmektedir.
    Dönüştürülecek tür ne olursa olsun complex türünün gerçek ve sanal kısımları float türdendir. Örneğin:

    >>> z = 3j+1
    >>> z.real
    1.0
    >>> z.imag
    3.0
    >>> a = 10
    >>> z = complex(a)
    >>> z
    (10+0j)
    >>> z.real
    10.0
    >>> z.imag
    0.0

    complex sayılar print edilirken her gerçek ve sanal kısımları tamsayı ise güzel bir görünüt oluşturmak için nokta kullanılmamaktadır. 
    Ancak aslında her durumda complex türünün gerçek ve sanal kısımları float bir sayı biçimindedir. 
#------------------------------------------------------------------------------------------------------------------------

a = 10

b = complex(a)
print(b)            # (10+0j)

a = 10.5

b = complex(a)
print(b)            # (10.5+0j)

a = True

b = complex(a)
print(b)           # (1+0j)

#------------------------------------------------------------------------------------------------------------------------
    Bir string de complex türüne dönüştürülebilir. 'a+bj' biçimindeki bir yazının başında ve sonunda boşluk karakterleri bulunabilir. 
    Ancak arasında bulunamaz. Ayrıca yazı 'aj+b' biçiminde de belirtilemektedir. Örneğin:

    >>> s = '2+3j'
>>> z = complex(s)
>>> print(z)
(2+3j)
>>> s = '10'
>>> z = complex(s)
>>> print(z)
(10+0j)
>>> s = '3j-2'
>>> z = complex(s)
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
ValueError: complex() arg is a malformed string 

#------------------------------------------------------------------------------------------------------------------------

a = '3+2j'

b = complex(a)
print(b)            # (3+2j)

a = '10'

b = complex(a)
print(b)            # (10+0j)

a = 10.5

b = complex(a)
print(b)            # (10.5+0j)

#------------------------------------------------------------------------------------------------------------------------
    Temel türlerin hepsi str türüne dönüştürülebilir. Yani örneğin int bir değer, float bir değer, bool bir değer, complex bir değer,
    None değeri str türüne dönüştürülebilmektedir. Dönüştürme sonucunda o değere ilişkin bir yazı elde edilmektedir. Örneğin:

    >>> a = 10
    >>> s = str(a)
    >>> s
    '10'
    >>> a = 12.34
    >>> s = str(a)
    >>> s
    '12.34'
    >>> a = True
    >>> s = str(a)
    >>> s
    'True'
    >>> a = None
    >>> s = str(a)
    >>> s
    'None'
    >>> a = 3j+2
    >>> s = str(a)
    >>> s
    '(2+3j)'
#------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------
    Python'da klavyeden (stdin dosyasından) okuma yapan input isimli tek bir fonksiyon vardır. input fonksiyonun da str türünden
    bir değer verdiğini anımsayınız. Bu durumda biz kalvyeden int, float gibi okumalar yapmak için aslında string'i bu türlere dönüştürmekteyiz.
    Örneğin:

    a = int(input('Bir sayı giriniz:'))

    print(a * a)

    Ya da örneğin:

    a = float(input('Bir sayı giriniz:'))

    print(a * a)
#------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------
    Programlama dillerinde farklı türler ile işlem yapıldığında nasıl bir sonucun elde edileceği programcı tarafından biliniyor 
    olması gerekir. C, C++, Java, C# ve Python gibi dillerde farklı türlerle işlem yapılabilmektedir. Ancak Swift gibi bazı dillerde
    farklı türlerle işlemler yapılamamaktadır.
#------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------
    Python'da iki int değeri aritmetik işleme sokarsak sonuç int türden çıkar. Benzer biçimde iki float değeri aritmetik işleme sokarsak 
    sonuc float türden çıkar. Ancak int bir değer ile float bir değeri aritmetik işleme sokarsak sonuç float türünden çıkacaktır. 
    Tabii özel bir durum olarak / operatörünün her zaman float değer ürettiğine dikkat ediniz. Yani biz iki int değeri / operatörüyle 
    işleme sokarsak sonuç int türden değil float türden çıkacaktır. Mantıksal operatörlerin de her zaman bool türden değer ürettiğine dikkat 
    ediniz. 
#------------------------------------------------------------------------------------------------------------------------

a = 10
b = 3.14
c = a + b
print(c, type(c))       # 13.14 <class 'float'>

#------------------------------------------------------------------------------------------------------------------------
    bool türü ile int türü işleme sokulursa sonuç int türünden, bool türü ile float türü işleme sokulursa sonuç float türünden, 
    bool türü ile complex türü işleme sokulursa sonuç complex türünden elde edilmektedir. Bu tür işlemlerde bool değer True ise
    1 olarak, False ise 0 olarak işleme sokulmaktadır. 
#------------------------------------------------------------------------------------------------------------------------

a = 10
b = True
c = a + b
print(c, type(c))       # 11 <class 'int'>

a = 12.34
c = a + b
print(c, type(c))       # 13.34 <class 'float'>

a = 3j+2
c = a + b
print(c, type(c))       # (3+3j) <class 'complex'>

#------------------------------------------------------------------------------------------------------------------------
    iki bool değer kendi aralarında işleme sokulduğunda sonuç int türünden çıkmaktadır. 
#------------------------------------------------------------------------------------------------------------------------

a = True
b = False
c = a + b

print(c, type(c))       # 1 <class 'int'>

#------------------------------------------------------------------------------------------------------------------------
    int bir değerle float bir değer işleme sokulduğunda sonuç float çıkacaktır ancak sonuç üzerinde bir kayıp oluşabilir. 
    Eğer oluşan kayıp basamaksal değilse bu bir hata olarak değerlendirilmez. Gerçek değer en yakın ondan büyük olan ya da küçük olan değer 
    elde edilir. Ancak basamaksal bir kayıp söz konusu olursa exception (OverflowError) oluşmaktadır. Örneğin:

    >>> a = 1987239812739817239817239871293871928371987239817239817239871293871298371982739812379812739182739812739
    817239817239871239871293871298371982379182739817239817239871298371928379182739817239817298379827349827349872349
    87239847293847928374982734982734982734987239847293847928374982374982374982374982374982374982371234234234234
    >>> b = a * 2.0
    Traceback (most recent call last):
    File "<stdin>", line 1, in <module>
    OverflowError: int too large to convert to float
#------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------
    complex türü ile int türü, float türü ve bool türü aritmetik işleme sokulursa sonuç complex türünden elde edilmektedir. Örneğin:

    >>> a = 3j+2
    >>> b = 1
    >>> c = a + b
    >>> c
    (3+3j)
    >>> b = 1.2
    >>> c = a + b
    >>> c
    (3.2+3j)
    >>> b = True
    >>> c = a + b
    >>> c
    (3+3j)
#------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------
    Python'da iki str türündne değişken toplama işlemine sokulduğunda işlem sonucunda yine bir str nesnesi elde edilir. 
    Elde edilen string iki string'in birleşiminden oluşur. Java, C# gibi pek çok dilde de bu özellik benzer biçimde vardır. 
    Örneğin:

    >>> s = 'ankara'
    >>> k = 'istanbul'
    >>> result = s + k
    >>> result
    'ankaraistanbul'

    Ancak str türünden bir değişkenle diğer türden bir değer toplanamaz. Oysa Java ve C# gibi bazı dillerde bu durum mümkündür. 
    O dillerde bu toplama işlemi yapılırken string olmayan tür otomatik olarak string türüne dönüştürülüp sonuç string türünden elde 
    edilmektedir. Ancak yukarıda da belirttiğimiz gibi Python'da bu durum geçerli değildir. Özellikle diğer dillerden geçen kişilerin
    bu duruma dikkat etmesi gerekir. Örneğin:

    >>> s = 'Ankara'
    >>> a = 6
    >>> b = s + a
    Traceback (most recent call last):
    File "<stdin>", line 1, in <module>
    TypeError: can only concatenate str (not "int") to str

    Tabii programcı böyle bir şeyi yapmak isterse diğer operandı kendisi str türüne dönüştürmelidir. Örneğin:

    >>> s = 'Ankara'
    >>> a = 6
    >>> b = s + str(a)
    >>> b
    'Ankara6'

    String'lerle ilgili diğer özellikler izleyen bölümlerde ele alınmaktadır. 
#------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------
    Aralarında fiziksel ya da mantıksal ilişki olan bir grup nesneden oluşan topluluğa "veri yapısı (data structure)" denilmektedir. 
    Veri yapısı çoğul bir anlam ifade etmektedir. Python'da da built-in çeşitli veri yapıları vardır. Bunlar "listeler", "demetler", 
    "sözlükler", "kümeler" ve "stringler"dir. Python'daki bu built-in bu veri yapıları doğrudan dilin sentaksıyla desteklenmiş durumdadır. 
    Bu da programlamayı oldukça kolaylaştırmaktadır. 
#------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------
    Dolaşılabilir (iterable) nesne demek bu nesne dolaşıldığında birtakım değerlerin elde edilmesi demektir. Yani dolaşılabilir nesneler
    üzerinde dolaşım (iteration) işlemi yapılabilir. Dolaşım işlemi sırasında biz dolaşılabilir nesneden birtakım değerler elde ederiz. 
    Dolaşılabilir nesneler genellikle kendi içlerinde birtakım nesneleri tutarlar. Başka nesneleri tutan nesnelere Java, C# gibi fillerde
    "collection", C++'da ise "container" denilmektedir. Örneğin str türü dolaşılabilir (iterable) bir türdür. Bu durumda str nesnesi de dolaşılabilir 
    bir nesnedir. Bir string nesnesi dolaşıldığında tek tek stirng'in karakterleri elde edilmektedir. (Tabii string'in karakterleri de 
    aslında birer string belirtmektedir.) Özetle:

    - Bir nesne dolaşılabilir ise o nesne dolaşıldığında bize nesneler vermektedir. 
    - Dolaşılabilir nesnelerin dolaşıldığında bize hangi nesneleri vereceği o dolaşılabilir nesne öğrenilirken öğrenilmelidir. 
    Örneğin string nesneleri dolaşıldığında yazının karakterleri elde edilmektedir. 

    Dolaşım (iterator) nesneleri de aynı zamanda dolaşılabilir nesnelerdir. Dolaşılabilir nesnelerle dolaşım nesneleri arasında küçük
    bir fark vardır. Bir dolaşılabilir nesne dolaşıldıktan sonra yeniden dolaşılabilir. Biz ondan yine aynı nesneleri elde ederiz. 
    Ancak bir dolaşım (iiterator) nesnesi bir kez dolaşıldıktan sonra artık biter. Biz onu bir daha dolaşmak istesek bir şey elde edemeyiz. 
#------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------
    Listeler Python'da en çok kullanılan veri yapısıdır. Listeler diğer programlama dillerindeki "dizilere (arrays)" 
    benzetilebilir. Bir liste yaratmanın çeşitli yolları vardır. Liste yaratmak için en çok kullanılan yöntem köşeli parantez sentaksıdır. 
    Köşeli parantezler içerisine ',' atomu ile ayrlmış değerler girilirse bir liste nesnesi yaratılmaktadır. Örneğin:

    a = [10, 'ali', 2.3, True, 20]

#------------------------------------------------------------------------------------------------------------------------

a = [10, 20, 30, 40, 50]
print(a)                    # [10, 20, 30, 40, 50]
print(type(a))              # <class 'list'>

#------------------------------------------------------------------------------------------------------------------------
    Liste elemanları aynı türden olmak zorunda değildir. (Halbuki C, C++, Java ve C# gibi bazı dillerde diziler aynı türden
    elemanlara sahip olmak zorundadır.)
#------------------------------------------------------------------------------------------------------------------------

a = [1, 3.14, 'ankara', False]
print(a)                # [1, 3.14, 'ankara', False]

#------------------------------------------------------------------------------------------------------------------------
    Listenin belli bir elemanına [] operatörü ile erişebiliriz. Yani listelerin elemanları bu sayede sanki bağımsız nesnelermiş gibi 
    kullanılabilmektedir. Listenin ilk elemanı 0'ıncı indekslş elemanıdır. Bu durumda n elemanlı bir listenin son elemanı (n - 1)'nci 
    indekste olacaktır. Köşeli parantez içerisine bir ifade yerleştirilebilir. Örneğin a bir liste belirtmek üzere a[2], a[i + 2], 
    a[i + k - 1] gibi kullanımlar geçerlidir. Bu duurmda önce köşeli parantezin içerisindeki ifadenin sayısal değeri hesaplanır. 
    Sonra o değerdeki indekse erişilir. 
#------------------------------------------------------------------------------------------------------------------------

a = [10, 20, 30, 40, 50]

val = a[2] + 100
print(val)          # 130

#------------------------------------------------------------------------------------------------------------------------
    Köşeli parantez içerisindeki ifade int türden olma zorundadır. 
#------------------------------------------------------------------------------------------------------------------------

a = [10, 20, 30, 40, 50]

i = 1

val = a[i + 1]      # köşeli parantez içerisindeki ifade int türden geçerli
print(val)

i = 1.0
val = a[i]          # exception! köşeli parantez içerisindeki ifade int türden olmak zorunda

i = 1

val = a[i + 2.]     #exception! köşeli parantez içerisindeki ifade int türden olmak zorunda

#------------------------------------------------------------------------------------------------------------------------
    Bir listenin olmayan bir elemanına erişmeye çalışırsak IndexError isimli bir exception oluşur. 
#------------------------------------------------------------------------------------------------------------------------

a = [10, 20, 30, 40, 50]

val = a[100]            # IndexError oluşur

#------------------------------------------------------------------------------------------------------------------------
    Listeler "değiştirilebilir (mutable)" türlerdir. Bir türün değiştirilebilir olması demek o türdne bir nesnenin içeriğinde
    değişiklik yapılabilmesi demektir. Yani list türü değiştirilebilir olduğu iiçin biz bir listenin elemanlarını atama yoluyla değiştebiliriz. 
    Örneğin:

    a = [10, 20, 30, 40, 50]
    print(a[0])                 # 10
    a[0] = 'ali'
    print(a[0])                 # ali
    print(a)                    # ['ali', 20, 30, 40, 50]
               
#------------------------------------------------------------------------------------------------------------------------

a = [10, 20, 30, 40, 50]

print(a)         # [10, 20, 30, 40, 50]   

a[2] = 'ali'

print(a)         # [10, 20, 'ali', 40, 50]

#------------------------------------------------------------------------------------------------------------------------
    Bir listedeki eleman sayısı built-in len isimli fonksiyonla elde edilebilir. len fonksiyonu bize listenin eleman sayısını 
    int bir değer olarak vermektedir. 
#------------------------------------------------------------------------------------------------------------------------

a = [10, 20, 30, 40, 50]

n = len(a)
print(n)            # 5

#------------------------------------------------------------------------------------------------------------------------
    Boş liste de söz konusu olabilir. Boş bir liste 0 eleman uzunluğundadır. 
#------------------------------------------------------------------------------------------------------------------------

a = []

n = len(a)
print(n)            # 0

#------------------------------------------------------------------------------------------------------------------------
    Daha önceden de belirttiğimiz gibi T bir tür belirtmek üzere T(...) hem T türüne dönüştürme anlamına gelir hem de T türünden 
    nesne yaratma anlamına gelir. Örneğin int() ifadesinden içinde 0 olan bir int nesne, float() ifadesinden içinde 0 olan bir float nesne elde ederiz. 
    bool() ifadesi bize False bir nesne verir. İşte list() ifadesi de içi boş bir listeyi bize vermektedir. Yani aşağıdaki iki ifade eşdeğerdir:
    
    a = list()
    a = []
    
    Örneğin:

    >>> a = int()
    >>> a
    0
    >>> b = float()
    >>> b
    0.0
    >>> c = bool()
    >>> c
    False
    >>> d = str()
    >>> d
    ''
    >>> e = complex()
    >>> e
    0j
    >>> f = list()
    >>> f
    []

#------------------------------------------------------------------------------------------------------------------------

a = list()

n = len(a)
print(n)            # 0

#------------------------------------------------------------------------------------------------------------------------
    list sınıfının tür fonksiyonu olan list fonksiyonuna biz dolaşılabilir bir nesne verebiliriz. Bu durumda bu nesne dolaşılır. 
    Dolaşım sonucunda elde edilen değerlerden liste oluşturulur. Örneğin str nesneleri dolaşılabilir nesnelerdir. Yani str sınıfı dolaşılabilir 
    bir sınıftır. Bir str nesnesi dolaşıldığında tek tek string'in karakterleri elde edilmektedir. O halde bir list fonksiyonuna 
    bir string nesnesi verirsek list o string'i dolaşıp o string'in karakterlerini elde edecek ve o karakterlerden liste oluşturacaktır. Örneğin:

    s = 'ankara'
    a = list(s)

    Burada s string'i dolaşıldığında sırasıyla 'a', 'n', 'k', 'a', 'r', 'a' str nesneleri elde edilmektedir. İşte bu nesnelerden 
    liste oluşturulmuştur. 

    int türü, float türü, bool türü, complex türü, NonType türü "dolaşılabilir (iterable)" türler değildir. 
    Bu nedenle biz list fonksiyonuna argüman olarak bu türden değerler veremeyiz. Eğer bunu yaparsak exception (TypeError) oluşur. 
    Örneğin:

    >>> s = 'ankara'
    >>> a = list(s)
    >>> a
    ['a', 'n', 'k', 'a', 'r', 'a']
    >>> k = 123
    >>> a = list(k)
    Traceback (most recent call last):
    File "<stdin>", line 1, in <module>
    TypeError: 'int' object is not iterable
#------------------------------------------------------------------------------------------------------------------------

s = 'ankara'

a = list(s)
print(a)            # ['a', 'n', 'k', 'a', 'r', 'a']

#------------------------------------------------------------------------------------------------------------------------
    list sınıfı da dolaşılabilir bir sınıftır. Yani list nesneleri de dolaşılabilir nesnelerdir. Bir list nesnesi dolaşıldığında 
    tek tek liste içerisindeki değerler elde edilmektedir. Örneğin:

    a = [1, 2, 3, 4, 5]
    b = list(a)

    Burada a listesi dolaşıldığında sırasıyla 1, 2, 3, 4, 5 değerleri elde edilecektir. İşte bu değerlerden yeni bir list nesnesi 
    oluşturulmuştur. 
#------------------------------------------------------------------------------------------------------------------------

a = [1, 2, 3, 4, 5]
b = list(a)

print(a, id(a))
print(b, id(b))

#------------------------------------------------------------------------------------------------------------------------
    Bir list nesnesi elemanların kendilerini değil adreslerini tutmaktadır. Örneğin:

    a = [10, 'ali', 12.3]

    aslında burada bu listenin ilk elemanı (yani a[0] elemanı) içerisinde 10 değeri bulunan nesnenin adresini tutar. Diğer elemanlar da 
    bu bimimdedir. Örneğin:

    >>> a = [10, 'ali', 12.3]
    >>> id(a[1])
    1667401777200
    >>> val = a[1]
    >>> id(val)
    1667401777200
    >>> print(a[1])
    ali
    >>> print(val)
    ali

    Biz listenin bir elemanını değiştirdiğimizde aslında yeni bir nesne yaratıp o nesnenin adresini o elemana yerleştiririz. Örneğin:

    >>> a = [10, 'ali', 12.3]
    >>> id(a[0])
    1667362351696
    >>> a[0] = 11
    >>> id(a[0])
    1667362351728

#------------------------------------------------------------------------------------------------------------------------
   
#------------------------------------------------------------------------------------------------------------------------
     Listelerin değiştirilebilir olması demek liste elemanlarına başka adreslerin atanabilmesi demektir. Örneğin:

    a = [1, 2, 3]
    
    Burada biz listenin 1'inci indisli elemanını değiştirelim:

    a[1] = 100

    Burada biz içerisinde 2 değeri olan int nesneyi değiştirmedik. Listenin 1'inci indisli elemanındaki adresi değiştirdik. 
    Yani artık listenin 1'inci indisli elemanı içerisinde 100 olan başka bir int nesneyi göstermektedir. Örneğin:

    >>> a = [1, 2, 3]
    >>> id(a[1])
    1667362351440
    >>> a[1] = 100
    >>> id(a[1])
    1667362543056
#------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------
    Bir listenin bir elemanı başka bir liste olabilir. Örneğin:

    a = [10, [20, 30, 40], 50]

    Burada bu listenin 1'inci indisli elemanı başka bir list nesnesini göstermektedir. Bir listenin içerisindeki listenin elemanlarına 
    ikinci bir köşeli parantez ile erişebiliriz. Yani yukarıdaki örnekte a[1]'in türü list biçimindedir. O halde örneğin
    a[1][2] gibi bir ifade ile biz 40 değerine erişiriz. Tabii aslında listenin 1'inci indisli elemanı diğer listenin adresini tutmaktadır. Örneğin:

    >>> a = [10, [20, 30, 40], 50]
    >>> a[1][2]
    40
    >>> a[1][0]
    20

#------------------------------------------------------------------------------------------------------------------------
    Python'da matrissel bir veri yapısı listenin içerisinde liste ile oluşturulur. Bunun başka bir yolu yoktur. Örneğin biz
    3x3'lük bir matris oluşturmak isteyelim:

    a = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]

    Tabii matrisel bir listenin elemanları aynı uzunlukta listelerden oluşmak zorunda değildir. Örneğin:

    a = [[1, 2, 3, 4], [5, 6, 7], [8, 9]]
#------------------------------------------------------------------------------------------------------------------------

a = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]

print(a)            # [[1, 2, 3], [4, 5, 6], [7, 8, 9]]

val = a[2][1]
print(val)          # 8

val = a[1][2]
print(val)          # 6

#------------------------------------------------------------------------------------------------------------------------
    liste elemanlarına erişirken köşeli parantez içerisindeki değer negatif olabilir. Eğer köşeli parantez içerisindeki indeks belirten 
    ifade negatif ise bu özel bir anlam ifade etmektedir. Bu durumda efektif indeks (yani gerçek indeks) bu negatif değerle listenin 
    uzunluğu toplanarak elde edilir ve erişim bu efektif indekse yapılır. a[i] gibi bir erişimde i'nin negatif bir değerde olduğunu varsayalım.
    Bu durumda a[i] ile a[i + len(a)] tamamen eşdeğerdir. Örneğin:

    a = [10, 20, 30, 40, 50]

    Burada a[-1] ile aslında a[-1 + len(a)] aynı anlamdadır. -1 + len(a) burada 4 değerini verir. O zaman a[-1] ifadesi aslında 
    listenin son elemanını belirtmektedir. O halde a[-2] ifadesi listenin sondan bir önceki elemanını belirtecektir. Yani negatif indeksler
    sondan başa doğru listeyi indekslemektedir. n elemanlı bir listenin son negatif indeksinin -n olduğuna ancak son pozitif indeksinin
    n - 1 olduğuna dikkat ediniz.  
#------------------------------------------------------------------------------------------------------------------------

a = [10, 20, 30, 40, 50]

print(a[-1])    # 50
print(a[-2])    # 40
print(a[-3])    # 30
print(a[-4])    # 20
print(a[-5])    # 10

#------------------------------------------------------------------------------------------------------------------------
    Köşeli parantez içerisindeki negatif değer büyük olursa bu durumda efektif indeks gerçekten negatif olur. Yani bu durum dizide 
    olmayan bir elemana erişmek znlamına gelir. Böylesi durumlarda exception (IndexError) oluşmaktadır. Örneğin:

    a = [10, 20, 30, 40, 50]

    Burada köşeli parantez içerisine yazabileceğimiz mutlak değerce en büyük negatif değer -5'tir. Bundan daha küçük negatif değerler
    exception oluşmasına (IndexError) yol açacaktır. Yani biz büyük negatif değerler vererek dizinin başından daha önceki yerlere erişemeyiz.  
#------------------------------------------------------------------------------------------------------------------------

a = [10, 20, 30, 40, 50]

print(a[-10])    # exception oluşur! efektif indeks (yani gerçek indeks) -5

#------------------------------------------------------------------------------------------------------------------------
    Listenin elemanı liste olduğu durumda da negatif indeksler benzer biçimde kullanılabilir. 
#------------------------------------------------------------------------------------------------------------------------

a = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]

val = a[-2][1]      # 5

print(val)

val = a[-2][-1]     # 6
print(val)  

#------------------------------------------------------------------------------------------------------------------------
    Listelerin negatif indekslenmesi onun son elemanlarına erişme işlemini kolaylaştırmaktadır. Yine bazı algoritmalarda 
    bu durum daha okunabilir ve kısa yazımlar sağlamaktadır.
#------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------
    Bir liste içinde bir grup elemanı bir liste olarak elde edebiliriz. Bunun için "dilimleme (slicing)" denilen bir sentaks 
    kullanılmaktadır. Dilimleme sentaksının genel biçimi şöyledir:

    a[start:stop]
    a[start:stop:step]

    Görüldüğü gibi dilimlemede step kısmı hiç belirtilmeyebilir. Dilimleme ile listenin start indeksli elemanı dahil olacak biçimde ancak
    stop indeksli elemanı dahil olmayacak biçimde elemanları yine bir liste olarak elde ederiz. start, stop ve step int türden ifadeler olmak zorundadır.
#------------------------------------------------------------------------------------------------------------------------

a = [10, 20, 30, 40, 50, 60, 70, 80, 90, 100]

b = a[2:7]
print(b)            # [30, 40, 50, 60, 70]

#------------------------------------------------------------------------------------------------------------------------
    Dilimleme sırasında start ya da stop indeks liste uzunluğundan büyük olursa liste uzunluğuna çekilir. Yani bu durum bir 
    exception oluşturmaz. Dilimleme sırasında start ile stop aynı değerdeyse ya da start stop değerinden büyükse boş liste elde 
    edilmektedir. 
#------------------------------------------------------------------------------------------------------------------------

a = [10, 20, 30, 40, 50, 60, 70, 80, 90, 100]

b = a[3:4]
print(b)            # [40]

b = a[3:3]          
print(b)            # []

b = a[5:2]          
print(b)            # start stop ile aynı olursa ya da stop'tan büyük olursa boş liste elde edilir

b = a[2:10]         
print(b)            # [30, 40, 50, 60, 70, 80, 90, 100]

b = a[2:20]
print(b)            # [30, 40, 50, 60, 70, 80, 90, 100]

#------------------------------------------------------------------------------------------------------------------------
    Dilimlemede start ve stop ifadelerinde negatif indeksler kullanılabilir. 
#------------------------------------------------------------------------------------------------------------------------

a = [10, 20, 30, 40, 50, 60, 70, 80, 90, 100]

b = a[5:-2]
print(b)            # [60, 70, 80]

b = a[-5:-1]
print(b)            # [60, 70, 80, 90]

#------------------------------------------------------------------------------------------------------------------------
    Dilimlemede start ve stop ifadelerinde negatif indeks girildikten sonra efektif indeks hesaplandığında (yani bu değer len(a) ile toplandığında)
    eğer negatif çıkıyorsa 0 olarak işleme girer. Bu durumda bir exeption oluşmaz. 
#------------------------------------------------------------------------------------------------------------------------

a = [10, 20, 30, 40, 50, 60, 70, 80, 90, 100]

b = a[-20:3]        # efektif indekx -10 ama 0 olarak ele alınacak
print(b)            #  [10, 20, 30]

#------------------------------------------------------------------------------------------------------------------------
    Dilimlemede start belirtilmezse start değerinin 0 olarak belirtildiği girildiği gelir, stop belirtilmezse stop değerinin listenin uzunlu biçiminde 
    girildiği anlamına gelir. Örneğin a[:n] ifadesi a[0:n] ile eşdeğerdir. a[n:] ifadesi ise a[n:len(a)] ile eşdeğerdir. Başka bir deyişle dilimlemde start 
    belirtilmezse "baştan itibaren", stop belirtilmezse "geri kalan hepsi" anlamına gelmektedir. Tabii start da stop da belirtilmeyebilir. 
    Bu durumda listenin tüm elemanlardna liste oluşturulur. Yani a[:] ifadesi a[0:len(a)] eşdeğerdir. 
#------------------------------------------------------------------------------------------------------------------------

a = [10, 20, 30, 40, 50, 60, 70, 80, 90, 100]

b = a[:7]       # eğer start belirtilmezse 0 belirtilmiş gibi işlem yapılır.
print(b)        #  [10, 20, 30, 40, 50, 60, 70]

b = a[2:]       # stop değeri yazılmazsa listenin uzunluğu yazılmış gibi kabul edilir (yani geri kalan hepsi)
print(b)        # [30, 40, 50, 60, 70, 80, 90, 100]

b = a[:]        # start ve stop yazılmazsa listenin hepsi elde edilir
print(b)        # [10, 20, 30, 40, 50, 60, 70, 80, 90, 100]

#------------------------------------------------------------------------------------------------------------------------
    Dilimlemede step atlama miktarını belirtir. step hiç belirtilmezse sanki 1 olarak belirtilmiş gibi kabul edilir. 
    Tabii elde edilecek değerlere hiçbir zaman stop dahil olmaz. 
#------------------------------------------------------------------------------------------------------------------------

a = [10, 20, 30, 40, 50, 60, 70, 80, 90, 100]

b = a[2:9:2]
print(b)            # [30, 50, 70, 90]

b = a[:8:3]       
print(b)            # [10, 40, 70]

#------------------------------------------------------------------------------------------------------------------------
    step değeri negatif de olabilir. Ancak bu durumda ilerleme yönü ters olur. İlerleme ters olduğu için start indeksinin, 
    stop indeksinden daha büyük olması gerekir. Yine start indeksi dahil stop indeksi dahil değildir. step negatif ise 
    bu durumda start indeksin boş bırakılması "listenin uzunluğı - 1" anlamına stop indeksin boş bırakılması efektif -1 anlamına (yani ilk 
    eleman dahil olacak biçimde) gelmektedir. Örneğin a[:2:-1] ifadesinde ilerleme yönü terstir. start yazılmamıştır. Bu durumde sanki start 
    yerine len(a) - 1 yazılmış gibi işlem yapılır. Başka bir deyişle ifadenin eşdeğeri a[len(a) - 1:2:-1] biçimindedir. Örneğin a[4::-1] 
    ifadesinde ilerleme yönü yine terstir. stop belirtilmemiştir. Bu durumda sanki efektif -1 gibi baka bir deyişle atop inswka "-len(a) - 1" 
    gibi ele alınmaktadır. İfadenin eşdeğeri a[4:-len(a)-1:-1] biçimindedir. 
#------------------------------------------------------------------------------------------------------------------------

a = [10, 20, 30, 40, 50, 60, 70, 80, 90, 100]

b = a[8:2:-1]       # 8 dahil 2 dahil değil ters yönde hareket
print(b)            # [90, 80, 70, 60, 50, 40]

b = a[:2:-1]
print(b)            # [100, 90, 80, 70, 60, 50, 40]

b = a[4::-1]        # 4'üncü indeksten başa kadar hepsi
print(b)            # [50, 40, 30, 20, 10]

#------------------------------------------------------------------------------------------------------------------------
    Bir listeyi tersyüz etmek için a[::-1] kalıbı kullanılmaktdır. 
#------------------------------------------------------------------------------------------------------------------------

a = [10, 20, 30, 40, 50, 60, 70, 80, 90, 100]

b = a[::-1]       # listeyi ters olarak elde ederiz
print(b)          # [100, 90, 80, 70, 60, 50, 40, 30, 20, 10]

#------------------------------------------------------------------------------------------------------------------------
    Dilimleme yoluyla liste elemanları güncellenebilir. Eğer step belirtilmezsa bu işlemin genel sentaksı şöyledir:

    a[start:stop] = <dolaşılabilir nesne>

    Bu durumda önce dilimlenen elemanlar silinir, sonra onların yerine dolaşılabilir nesnedeki elemanlar start indeksten itibaren insert edilir. 
    Burada silinen eleman sayısı ile dolaşılabilir nesnedeki eleman sayısının aynı olması gerekmemektedir. (Burada atama operatörü yerine
    Walrus operatörünü kullanamayız.)
#------------------------------------------------------------------------------------------------------------------------

a = [10, 20, 30, 40, 50, 60, 70, 80, 90, 100]

a[2:6] = [1, 2, 3, 4, 5, 6, 7]
print(a)                    # [10, 20, 1, 2, 3, 4, 5, 6, 7, 70, 80, 90, 100]

#------------------------------------------------------------------------------------------------------------------------
    String'lerin de dolaşılabilir nesneler olduğunu anımsayınız.
#------------------------------------------------------------------------------------------------------------------------

a = [10, 20, 30, 40, 50, 60, 70, 80, 90, 100]

a[2:6] = 'ankara'
print(a)        # [10, 20, 'a', 'n', 'k', 'a', 'r', 'a', 70, 80, 90, 100]

#------------------------------------------------------------------------------------------------------------------------
    Dolaşılabilir nesnede hiç eleman yoksa bu durum bir silme anlamına gelecektir. 
#------------------------------------------------------------------------------------------------------------------------

a = [10, 20, 30, 40, 50, 60, 70, 80, 90, 100]

a[2:6] = []
print(a)        # [10, 20, 70, 80, 90, 100]

#------------------------------------------------------------------------------------------------------------------------
    Dilimleme yoluyla liste elemanları güncellenirken eğer step belirtilirse bu durumda ona atanan dolaşılabilir
    nesnenin eleman sayısı dilimleme yoluyla silinecek eleman sayısı ile aynı olmak zorundadır. (Python standard kütüphane dokümanlarında
    step değerinin 1 olması durumunda da atanan dolaşılabilir nesnenin eleman sayısının dilimlemedne elde edilen eleman sayısı ile aynı olması gerektiği
    dolaylı olarak belirtilmektedir. Ancak CPython gerçekleştirimi step değeri 1 ise sanki step değeri hiç belirtilmemiş gibi işlem yapmaktadır.)
#------------------------------------------------------------------------------------------------------------------------

a = [10, 20, 30, 40, 50, 60, 70, 80, 90, 100]

a[2:6:2] = [1, 2, 3]        # exception oluşur! dilimlemeden 2 eleman elde edildi, ancak dolaşılabilir nesnede 3 eleman var

print(a)        

#------------------------------------------------------------------------------------------------------------------------
    Dilimleme yoluyla atama yapılırken dilimleme sonucunda hiçbir eleman seçilmiyorsa bu durum start indeks'ten itibaren insert işlemi 
    anlamına gelmektedir. Örneğin:

    >>> a = [10, 20, 30, 40, 50, 60, 70, 80, 90, 100]
    >>> a[3:3] = 'ali'
    >>> a
    [10, 20, 30, 'a', 'l', 'i', 40, 50, 60, 70, 80, 90, 100]
    >>> a = [10, 20, 30, 40, 50, 60, 70, 80, 90, 100]
    >>> a[4:3] = 'ali'
    >>> a
    [10, 20, 30, 40, 'a', 'l', 'i', 50, 60, 70, 80, 90, 100]
#------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------
    Listenin belli bir elemanına atama yapmak ile dilimleme yoluyla atama yapmak arasındaki farklılığa dikkat ediniz:

    >>> a = [10, 20, 30, 40, 50, 60, 70, 80, 90, 100]
    >>> a[0] = [1, 2, 3, 4, 5]
    >>> a
    [[1, 2, 3, 4, 5], 20, 30, 40, 50, 60, 70, 80, 90, 100]
    >>> a = [10, 20, 30, 40, 50, 60, 70, 80, 90, 100]
    >>> a[0:1] = [1, 2, 3, 4, 5]
    >>> a
    [1, 2, 3, 4, 5, 20, 30, 40, 50, 60, 70, 80, 90, 100]

    Biz dilimleme yapmadan bir dolaşılabilir nesneyi belli bir indekse atadığımızda listenin o indeksinde dolaşılabilir nesne olur. 
    Halbuki dilimleme yoluyla atama yapıldığında dolaşılabilir nesnenin elemanları dilimlenen elemanların yerlerine insert edilmektedir. 
#------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------
    Dilimleme yoluyla güncelleme yapılırken step değeri negatif ise yine dolaşılabilir nesnedeki eleman sayısı dilimlenen 
    eleman sayısı kadar olmak zorundadır. Ancak elemanlar ters yönde insert edilecektir. Örneğin:

    >>> a = [10, 20, 30, 40, 50, 60, 70, 80, 90, 100]
    >>> a[7:2:-1] = [100, 200, 300, 400, 500]
    >>> a
    [10, 20, 30, 500, 400, 300, 200, 100, 90, 100]
    >>> a = [10, 20, 30, 40, 50, 60, 70, 80, 90, 100]
    >>> a[7:2:-2] = [100, 200, 300]
    >>> a
    [10, 20, 30, 300, 50, 200, 70, 100, 90, 100]
#------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------
    Listeyi dilimlediğimizde biz yeni bir list nesnesi oluştururuz. Ancak bu yeni oluşturulan list nesnesi aslında dilimlenen list nesnesindeki 
    dilimlenen elemanların adreslerinden oluşmaktadır. Yani dilimleme işlemi "sığ kopyalama (shallow copy)" biçiminde yapılmaktadır. 
    Sığ kopyalama demek yerni oluşturulan listenin elemanlarının dilimlene listenin dilimlenen elemanlarıyla aynı nesneleri göstermesi demektir. 
    Sığ kopyaalama sırasında dilimlenen listedeki adresler yeni oluşturulan listeye kopyalanmaktadır. Böylece dilimlenen listenin ilgili elemanlarıyla
    yeni oluşturulan listenin elemanları aynı nesneleri gösterir hale gelmektedir. Aşağıdaki örneği inceleyiniz:

    >>> a = [10, 20, 30, 40, 50]
    >>> b = a[2:4]
    >>> id(a)
    1620015142592
    >>> id(b)
    1620015144768
    >>> id(a[2])
    1619975761104
    >>> id(b[0])
    1619975761104
     >>> id(a[3])
    1619975761424
    >>> id(b[1])
    1619975761424

    Burada a[2] elemanın gösterdiği nesne ile b[0] elemanının gösterdiği nesnenin, a[3] elemanının gösteridği nesne ile b[1] elemanının 
    gösteridiği nesnenin aynı nesneler olduğuna dikkat ediniz. 
#------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------
    Listeler değiştirilebilir (mutable) nesneler olduğuna göre listenin elemanı bir liste ise dilimlemede yeni oluşturulan listeye
    bu eleman olan listenin adresi kopyalanacaktır. Bu durumda bu eleman olan listede yapılacak değişiklik her iki listede de
    görünür olacaktır. Aşağıdaki örneğe dikkat ediniz:

    >>> a = [10, [20, 30, 40], 50]
    >>> b = a[0:2]
    >>> b[1][0] = 100
    >>> a
    [10, [100, 30, 40], 50]
    >>> b
    [10, [100, 30, 40]]
    >>> a[1][1] = 200
    >>> a
    [10, [100, 200, 40], 50]
    >>> b
    [10, [100, 200, 40]]

    Bu örnekte id(a[1]) ile id(b[1])'in aynı olduğuna dikkat ediniz:

    >>> b = a[0:2]
    >>> id(a[1])
    2644868980608
    >>> id(b[1])
    2644868980608
    >>> a[1] is b[1]
    True
#------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------
    Anımsanacağı gibi bir sınıf içerisindeki fonksiyonlara Python'da "metot (method)" denilmekteydi. Bir metodun aynı sınıf türünden 
    bir değişkenle "." operatörü kullanılarak çağrılması gerektiğini anımsayınız. Örneğin:

    a.foo()

    Burada a hangi sınıf türündense foo da o sınıfın bir metodudur. Metotlar belli bir nesne üzerinde işlem yapan fonksiyonlardır. Dolayısıyla
    a.foo() ifadesinde foo metodu a nesnesi üzerinde (a değişkeninin gösterdiği nesne üzerinde) işlem yapmaktadır. Örneğin:

    x = [1, 2, 3, 4, 5]

    Burada x list sınıfı türünden bir değişkendir. foo list sınıfının bir metodu olsun:

    x.foo(...)

    Burada foo bu x nesnesi üzerinde onun elemanları ile ilgili bir işlem yapacaktır. eğer fonksiyonlar bir sınıf içerisinde değilse
    belli bir nesne üzerinde işlem yapmak yerine genel işlemleri yapmak üzere yazılmış olurlar.
#------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------
    list sınıfının append isimli metodu list nesnesinin sonuna yeni bir eleman ekler. Örneğin:

    a = [1, 2, 3, 4, 5]             # [1, 2, 3, 4, 5]

    print(a)           
    a.append('ankara')              # [1, 2, 3, 4, 5, 'ankara']
    print(a)

#------------------------------------------------------------------------------------------------------------------------

a = [10, 20, 30]
print(a)                # [10, 20, 30]

a.append(100)              
print(a)                # [10, 20, 30, 100]

a.append('ali')
print(a)                # [10, 20, 30, 100, 'ali']

a.append(12.4)
print(a)                # [10, 20, 30, 100, 'ali', 12.4]

#------------------------------------------------------------------------------------------------------------------------
    append her zaman tek bir nesnenin eklenmesine yol açmaktadır. Yani append ile biz listeye liste eklemek istesek listenin içerisindekiler
    eklenmeyecektir. Listenin kendisi tek bir eleman olarak eklenecektir. 
#------------------------------------------------------------------------------------------------------------------------

a = [10, 20, 30]
print(a)                # [10, 20, 30]

a.append([100, 200, 300])   
print(a)                # [10, 20, 30, [100, 200, 300]]     

#------------------------------------------------------------------------------------------------------------------------
    Bir listenin sonuna birden fazla eleman extend metoduyla eklenmektedir. extend metodu bizden dolaşılabilir bir nesne alır. 
    O nesneyi dolaşarak elde ettiği tüm nesneleri listeye ekler. Listelerin ve string'lerin dolaşılabilir nesneler olduğunu anımsayınız.
    Eğer extend metoduna dolaşılabilir olmayan bir argüman gireresek exception (TypeError) oluşacaktır. extend metodu tek bir argüman almaktadır.
#------------------------------------------------------------------------------------------------------------------------

a = [10, 20, 30]
print(a)            # [10, 20, 30]

a.extend([1, 2, 3, 4, 5])
print(a)            # [10, 20, 30, 1, 2, 3, 4, 5]

#------------------------------------------------------------------------------------------------------------------------
    str dolaşılabilir bir sınıf olduğuna göre bir string'in karakterlerini extend metodu ile listeye ekleyebiliriz. 
#------------------------------------------------------------------------------------------------------------------------

a = [10, 20, 30]
print(a)            # [10, 20, 30]

a.extend('ankara')
print(a)            # [10, 20, 30, 'a', 'n', 'k', 'a', 'r', 'a']

#------------------------------------------------------------------------------------------------------------------------
    list sınfının index isimli metodu parametresiyle aldığı nesneyi listede arar. Eğer bulursa ilk bulduğu yerin indeks numarasıyla
    geri döner. Eğer bulamazsa exception (ValueError) oluşmaktadır. (Dolayısıyla bu metot genellikle zaten var olduğunu bildiğimiz bir elemanın yerini 
    aramak için kullanılmaktadır.) Bu metot bize int türünden index belirten bir değer vermektedir. Örneğin:

    >>> a = [10, 2, 7, 8, 19, 41]
    >>> result = a.index(19)
    >>> result
    4
    >>> result = a.index(30)
    Traceback (most recent call last):
    File "<stdin>", line 1, in <module>
    ValueError: 30 is not in list

    İleride ayrı bir konuda ele alınacak olsa da şimdiden bir noktayı belirtmek istiyoruz: Python'da farklı sınıflar türünden (int, float ve bool 
    haricinde) değişkenler == ve != operatörleriyle karşılaştırıldığında == işlemi her zaman False, != işlemi her zaman True vermektedir. Örneğin:

    >>> 'ali' == 19
    False

    DOlayısıyla index metoduyla arama yapılırken liste içerisinde farklı türlerden nesneler varsa bunlar asla aradığımız değere 
    eşit olamayacağı için geçilmektedir. index metodunun her eleman için == karşılaştırması yaptığını düşünebilirsiniz. Örneğin:

    >>> a = [10, 5, 'ali', 43, 21]
    >>> result = a.index(43)
    >>> result
    3
    >>> result = a.index('ali')
    >>> result
    2

    Eğer değer liste içerisinde birden fazla yerde varsa list metodu değerin listede ilk bulunduğu indeksi vermektedir. Örneğin:

    >>> a = [1, 4, 7, 8, 4, 7]
    >>> result = a.index(4)
    >>> result
    1

    index metodu asında iki argüman ve üç argüman da alabilir. Eğer metodu biz iki argümanlı kullanırsak birinci argüman aranacak 
    değeri, ikinci argüman ise aramanın başlatılacağı indeksi belirtir. Örneğin:

    >>> a = [10, 4, 5, 8, 9, 4, 8]
    >>> result = a.index(4, 2)
    >>> result
    5

    Burada 4 değeri aranmıştır. Ancak arama baştan itibaren değil 2'inci indeksten itibaren başlatılmıştır. Eğer index üç argümanla 
    kullanılırsa üçüncü argüman aramanın bitirileceği indeksi belirtir. Ancak bu indeks aramaya dahil değildir. Örneğin:

    >>> a = [10, 4, 5, 8, 9, 4, 8]
    >>> result = a.index(4, 2, 5)
    Traceback (most recent call last):
    File "<stdin>", line 1, in <module>
    ValueError: 4 is not in list

    Burada 4 değeri aranmak istenmiştir. Ancak arama 2'inci indeksten başlatılıp 5'inci indekse kadar devam ettirilmiştir. 5'indeks
    aramaya dahil olmadığı için exception oluşmuştur. Burada aramanın başlatılacağı ve bitirileceği indeks negatif indeks olarak belirtilebilir. 

#------------------------------------------------------------------------------------------------------------------------

a = [1, 3, 5, 'ali', 'veli', 7, 'veli']

result = a.index('veli')     
print(result)               # 4

#------------------------------------------------------------------------------------------------------------------------
    list sınıfının count isimli metodu bizden bir değer alır. Liste içerisinde o değerden kaç tane olduğunu bize verir. Örneğin:

    >>> a = [1, 3, 7, 4, 3, 8, 3, 4, 3]
    >>> result = a.count(3)
    >>> result
    4
    >>> result = a.count(10)
    >>> result
    0
    >>> result = a.count('ali')
    >>> result
    0
#------------------------------------------------------------------------------------------------------------------------

a = [3, 5, 7, 7, 4, 7, 9, 7] 

result = a.count(7)
print(result)           # 4

result = a.count(5)
print(result)           # 1

result = a.count(70)
print(result)           # 0

#------------------------------------------------------------------------------------------------------------------------
    Bir listeden tek bir elemanı silmek için pop isimli metot kullanılabilir. Bu metot argümansız kullanılırsa son eleman silinir.
    Argümanlı kullanılırsa belirtilen indeksteki eleman silinir. Yani metot argümanlı ya da argümansız kullanılabilmektedir. 
    Argümanlı kullanılacaksa argüman index belirtmelidir. pop silinen elemanın kendisini de bize geri dönüş değeri olarak vermektedir. 
    pop metoduna verilen index sınır dışındaysa ya da liste boşsa exception (IndexError) oluşmaktadır. index metodu negatif indeksleri 
    kabul etmektedir. Bu durumda negatif değerler yine list uzunluğu ile toplanıp efektif indeks elde edilmektedir. Yani örneğin a.pop(-2)
    işlemi son elemandan bir önceki elenı siler. Örneğin:

    >>> a = [10, 20, 30, 40, 50]
    >>> result = a.pop()
    >>> result
    50
    >>> a
    [10, 20, 30, 40]
    >>> result = a.pop(2)
    >>> result
    30
    >>> a
    [10, 20, 40]
    >>> result = a.pop(-2)
    >>> result
    20
    >>> a
    [10, 40]
    >>> a.pop(10)
    Traceback (most recent call last):
    File "<stdin>", line 1, in <module>
    IndexError: pop index out of range

#------------------------------------------------------------------------------------------------------------------------

a = [10, 20, 30, 40, 50]
print(a)                    # [10, 20, 30, 40, 50]

a.pop()

print(a)                    # [10, 20, 30, 40]

a = [10, 20, 30, 40, 50]
a.pop(2)

print(a)                    # [10, 20, 40, 50]

#------------------------------------------------------------------------------------------------------------------------
    list sınıfının remove metodu da silme yapar. Ancak silinecek eleman pop metodunda olduğu gibi indeks numarasıyla değil
    bizzat değeriyle belirtilmektedir. remove parametresiyle belirtilen değer, liste içerisinde arar. Eğer bulursa yalnızca ilk 
    bulduğunu siler, eğer bulamazsa exception (ValueError) oluşur. remove metodu bize herhangi bir geri dönüş değeri vermez. 
    Örneğin:

    >>> a = [3, 7, 9, 'ali', 3]
    >>> a.remove('ali')
    >>> a
    [3, 7, 9, 3]
    >>> a.remove(3)
    >>> a
    [7, 9, 3]
    >>> a.remove('veli')
    Traceback (most recent call last):
    File "<stdin>", line 1, in <module>
    ValueError: list.remove(x): x not in list

#------------------------------------------------------------------------------------------------------------------------

a = [10, 20, 30, 40, 50, 40]
print(a)                    # [10, 20, 30, 40, 50, 40]

a.remove(40)
print(a)                    # [10, 20, 30, 50, 40]

#------------------------------------------------------------------------------------------------------------------------
    clear isimli metot listenin tüm elemanlarını siler. Yani liste 0 elemanlı boş bir liste haline gelir. clear metodunun 
    parametresi yoktur.
#------------------------------------------------------------------------------------------------------------------------

a = [10, 20, 30, 40, 50]
print(a)                    # [10, 20, 30, 40, 50]

a.clear()
print(a)                    # []

#------------------------------------------------------------------------------------------------------------------------
    reverse metodu listeyi ters yüz eder. Bu metot bize bir geri dönüş değeri vermez. Ters yüz etme işlemi nesnenin üzerinde (in place)
    yapılmaktadır. a bir liste belirtmek üzere a[::-1] işlemi de listeyi ters yüz eder. Ancak bu işlem ters yüz edilmiş yeni bir liste 
    vermektedir. Bu işlem sonucunda a listesinde bir değişiklik olmamaktadır. 
#------------------------------------------------------------------------------------------------------------------------

a = [10, 20, 30, 40, 50]
print(a)                    # [10, 20, 30, 40, 50]

b = a[::-1]                 # [10, 20, 30, 40, 50]
print(a)                     
print(b)                    # [50, 40, 30, 20, 10]

a.reverse()
print(a)                    # [50, 40, 30, 20, 10]

#------------------------------------------------------------------------------------------------------------------------
    Bir veri yapısının (list, dict vs.) bir metodu işlemi veri yapısının üzerinde yapıyorsa buna "in place" işlem denilmektedir.
    Tabii her metot işlemini in place yapmayabilir. Metot işlem yapılmış yeni bir veri yapısını bize verebilir. Bu "in place" bir işlem değildir. 
    Örneğin a.reverse() ile biz "in place" bir işlem yapmış olduk. Ancak a[::-1] işlemi "in place" bir işlem değildir.  
#------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------
    list sınıfının sort isimli metodu liste elemanlarını sıraya dizmektedir. Default durum küçükten byüğe sıraya dizmedir. 
    sort bize bir değer vermez. Bizzat elemanları sıraya dizer (in place işlem). sort metodu "stable" sort yapmaktadır. 
    Stable sort aynı elemanların sort edilmiş listede orijinal listedeki sırasına göre yan yana sıraya dizilmesi anlamına gelmektedir. 
    Örneğin:

    >>> a = [4, 17, 2, 21, 8, -4]
    >>> a.sort()
    >>> a
    [-4, 2, 4, 8, 17, 21]
#------------------------------------------------------------------------------------------------------------------------

a = [3, 6, 2, 8, 16, -4, 9, 22]

a.sort()
print(a)            #  [-4, 2, 3, 6, 8, 9, 16, 22]

#------------------------------------------------------------------------------------------------------------------------
    sort metodu sıraya dizme işleminde listenin elemanları arasında < karşılaştırması yapmaktadır. Eğer listenin herhangi iki 
    elemanı arasında < karşılaştırması yapılamazsa bu durumda exception (TypeError) oluşur. Örneğin listenin bir elemanı str bir elemanı int
    türden olsun. Bu iki eleman < operatöryüyle karşılaştırılamaz. Bu durumda sort işlemi exception'a yol açacaktır. Tabii 
    string'ler kendi aralarında < operatörü ile karşılaştırılabilmektedir:

    >>> a = ['veli', 'ali', 'sacit', 'ayşe', 'talat']
    >>> a.sort()
    >>> a
    ['ali', 'ayşe', 'sacit', 'talat', 'veli']
#------------------------------------------------------------------------------------------------------------------------

a = [3, 6, 'ali', 8, 16.2, -4, True, 'veli']

a.sort()            # exception oluşur!

#------------------------------------------------------------------------------------------------------------------------
    Yukarıda da belirttiğimiz gibi string'ler kendi aralarında karşılaştırılabilmektedir. Dolayısıyla string'lerden 
    oluşmuş bir liste sort edilebilr. 
#------------------------------------------------------------------------------------------------------------------------

a = ['izmir', 'adana', 'samsun', 'kayseri', 'sivas']
print(a)            # ['izmir', 'adana', 'samsun', 'kayseri', 'sivas']

a.sort()           
print(a)            # ['adana', 'izmir', 'kayseri', 'samsun', 'sivas']

#------------------------------------------------------------------------------------------------------------------------
    sort metodu default durumda listeyi küçükten büyüğe (ascending) sıraya dizmektedir. Listeyi büyükten küçüğe (descending)
    sıraya dizmek için reverse=True isimli parametresinin kullanılması gerekir. (Yani a.sort() ile a.sort(reverse=False) aynı 
    anlamdadır.)
#------------------------------------------------------------------------------------------------------------------------

a = ['izmir', 'adana', 'samsun', 'kayseri', 'sivas']
print(a)                    # ['izmir', 'adana', 'samsun', 'kayseri', 'sivas']

a.sort(reverse=True)        # büyükten küçüğe
print(a)                    # ['sivas', 'samsun', 'kayseri', 'izmir', 'adana']

a.sort()            
print(a)                    # ['adana', 'izmir', 'kayseri', 'samsun', 'sivas']

#------------------------------------------------------------------------------------------------------------------------
    list sınıfının reverse metodunun yanı sıra ayrıca reversed  isimli bir built-in bir fonksiyon (metot değil) da vardır. 
    Bu reversed fonksiyonu bizden dolaşılabilir bir nesne alır.  Onun ters yüz edilmiş halini bize dolaşılabilir (iterable) 
    bir nesne biçiminde verir. reversed fonksiyonu "in place" bir işlem yapmaz. reversed fonksiyonu bize bir liste değil dolaşılabilir 
    bir nesne vermektedir. Yani biz ters yüz edilmiş değerleri o dolaşılabilir nesneyi dolaşarak elde edebiliriz. list fonksiyonunun 
    dolaşılabilir nesneyi dolaşarak bir liste yaptığını anımsayınız. Örneğin:

    >>> a = [1, 2, 3, 4, 5]
    >>> result = reversed(a)
    >>> type(result)
    <class 'list_reverseiterator'>
    >>> b = list(result)
    >>> b
    [5, 4, 3, 2, 1]
    >>> a
    [1, 2, 3, 4, 5]

    reversed fonksiyonu argüman olarak yalnızca liste almaz. Aslında dolaşılabilir herhangi bir nesneyi argüman alabilmektedir. 
    Örneğin:

    >>> s = 'ankara'
    >>> result = reversed(s)
    >>> type(result)
    <class 'reversed'>
    >>> b = list(result)
    >>> b
    ['a', 'r', 'a', 'k', 'n', 'a']

#------------------------------------------------------------------------------------------------------------------------

a = ['izmir', 'adana', 'samsun', 'kayseri', 'sivas']
print(a)                    # ['izmir', 'adana', 'samsun', 'kayseri', 'sivas']

b = reversed(a)
c = list(b)

print(c)                    # ['sivas', 'kayseri', 'samsun', 'adana', 'izmir']
print(a)                    # ['izmir', 'adana', 'samsun', 'kayseri', 'sivas']

#------------------------------------------------------------------------------------------------------------------------
    Aslında biz reversed fonksiyonunu her "dolaşılabilir" nesneyle kullanamayız. reversed fonksiyonu "tersten dolaşılabilir (reverse iterable)" 
    nesneler ile kullanılabilmektedir. Bu bağlamda listeler, stringler aynı zamanda tersten dolaşılabilir biçimdedir. Bu nedenle biz 
    reverse fonksiyonunu listeler ve string'lerle kullanabilmekteyiz.
#------------------------------------------------------------------------------------------------------------------------

s = list(reversed('ankara'))
print(s)            # ['a', 'r', 'a', 'k', 'n', 'a']

#------------------------------------------------------------------------------------------------------------------------
    sort işlemi için sorted isimli global built-in bir fonksiyon da bulunmaktadır. Bu fonksiyon bize her zaman sort edilmiş yeni bir liste vermektedir. 
    Fonksiyon dolaşılabilir herhangi bir nesneyi parametre olarak alabilmektedir. Örneğin:

    >>> a = [5, 4, 3, 2, 1]
    >>> b = sorted(a)
    >>> a
    [5, 4, 3, 2, 1]
    >>> b
    [1, 2, 3, 4, 5]
    >>> a = sorted('ankara')
    >>> a
    ['a', 'a', 'a', 'k', 'n', 'r']
#------------------------------------------------------------------------------------------------------------------------

a = [3, 6, 1, 34, 51, 23, 10]
print(a)            # [3, 6, 1, 34, 51, 23, 10]

b = sorted(a)
print(b)            # [1, 3, 6, 10, 23, 34, 51]

a = 'ankara'
b = sorted(a)
print(b)            # ['a', 'a', 'a', 'k', 'n', 'r']

#------------------------------------------------------------------------------------------------------------------------
    Python'da pek çok veri yapısı ile kullanılabilen "in" isimli iki operandlı araek özel amaçlı bir operatör bulunmaktadır. 
    in operatörünün sol tarafındaki operand olup olmadığı kontrol edilecek değeri belirtir. Sağ tarafındaki operand ise arama 
    yapılacak nesneyi belirtir. Bu operatör eğer sol tarafındaki operand ile belirtilen değer sağ tarafındaki operand ile belirtilen 
    veri yapısında var ise True değer, yok ise False üretmektedir. Yani in operatörü bool bir değer üretmektedir. Örneğin:

    >>> a = [10, 4, 7, 'ali', 5]
    >>> 5 in a
    True
    >>> 8 in a
    False
    >>> s = 'istanbul'
    >>> 'i' in s
    True
    >>> 'k' in s
    False
#------------------------------------------------------------------------------------------------------------------------

a = [3, 6, 1, 34, 51, 23, 10]

result = 34 in a            # 34 değeri a içinde var mı?
print(result)               # True

result = 'ali' in a         # 'ali' değeri a içinde var mı?
print(result)               # False        

#------------------------------------------------------------------------------------------------------------------------
    Biz bir liste içerisinde başka bir liste var mı diye in operatörü ile bakabiliriz. in operatörü == karşıalştırması yapmaktadır. 
    İki listenin bu biçimde karşılaştırılması ileride ele alınacaktır. Örneğin:

    >>> a = [1, 2, [3, 4], 5, 6]
    >>> [3, 4] in a
    True
    >>> [4, 3] in a

#------------------------------------------------------------------------------------------------------------------------

a = [3, 6, 1, [34, 51], 23, 10]

result = 34 in a
print(result)           # False

result = [34, 51] in a
print(result)           # True

result = [51, 34] in a
print(result)           # False

#------------------------------------------------------------------------------------------------------------------------
    not in operatörü ise bir elemanın bir listede olmadığını sorgulamak için kullanılmaktadır. Yani in operatörünün tersini yapmaktadır.
    Örneğin:

    >>> a = [1, 2, 3, 4, 5]
    >>> 5 in a
    True
    >>> 5 not in a
    False
#------------------------------------------------------------------------------------------------------------------------

a = [10, 20, 30, 40, 50] 

result = 30 not in a
print(result)           # False

result = 15 not in a
print(result)           # True

#------------------------------------------------------------------------------------------------------------------------
    Veri yapılarından eleman silmek için genel amaçlı "del" isiminde bir deyim de kullanılmaktadır. 
    del deyimi yalnızca listelerde  değil "değiştirilebilir (mutable)" başka nesnelerde de kullanılabilmektedir. del deyimi
    listelerle kullanılırken listenin belli bir elemanı köşeli parantezler ile belirtilir. Örneğin del a[3] gibi. Örneğin:

    >>> a = [10, 20, 30, 40, 50]
    >>> del a[2]
    >>> a
    [10, 20, 40, 50]

    Bu örnekte biz aynı işlemi pop metoduyla da yapabilirdik. Yine biz del deyimi ile listenin olmayan bir elemnanını silmek istersek 
    del deyimi exception (IndexError) oluşturur. Örneğin:

    >>> a = [10, 20, 30, 40, 50]
    >>> del a[30]
    Traceback (most recent call last):
    File "<stdin>", line 1, in <module>
    IndexError: list assignment index out of range
#------------------------------------------------------------------------------------------------------------------------

a = ['ali', 3, 'veli', 45, 73, 'ali', 21, 16, 7]
print(a)            # ['ali', 3, 'veli', 45, 73, 'ali', 21, 16, 7]   

del a[0]
print(a)            # [3, 'veli', 45, 73, 'ali', 21, 16, 7]

#------------------------------------------------------------------------------------------------------------------------
    del deyimi ile listelerde silme yapılırken silinecek elemanlar dilimleme ile de belirtilebilmektedir. Bu durumda önce dilimlenen 
    elemanlar belirlenir sonra hepsi tek hamlede silinir. Örneğin:

    >>> a = [10, 20, 30, 40, 50, 60, 70]
    >>> del a[1:6:2]
    >>> a
    [10, 30, 50, 70]
    
#------------------------------------------------------------------------------------------------------------------------
 
a = ['ali', 3, 'veli', 45, 73, 'ali', 21, 16, 7]
print(a)            # ['ali', 3, 'veli', 45, 73, 'ali', 21, 16, 7]   

del a[::2]
print(a)            # [3, 45, 'ali', 16]

#------------------------------------------------------------------------------------------------------------------------
    del deyimi ile ',' atomuyla ayrılmış birden fazla silme işlemi yapılabilir. Bu durumda silme ayrı ayrı soldan sağa biçimde yapılmaktadır. 
    Örneğin:

    >>> a = [10, 20, 30, 40, 50, 60, 70]
    >>> del a[2], a[3]
    >>> a
    [10, 20, 40, 60, 70]

    Burada önce 2'inci indeksli eleman silinmiştir. Bu durumda 3'üncü indeksli eleman artık başlangıçtaki 4'üncü indeksli eleman
    durumuna gelmiştir. Halbuki dilimleme yoluyla eleman silerken önce elemanlar belirlenmekte sonra hepsi tek hamlede silinmektedir. 
#------------------------------------------------------------------------------------------------------------------------

a = ['ali', 3, 'veli', 45, 73, 'ali', 21, 16, 7]
b = [4, 8, 2]
print(a)            # ['ali', 3, 'veli', 45, 73, 'ali', 21, 16, 7]   


del a[3], b[0]
print(a)            # ['ali', 3, 'veli', 73, 'ali', 21, 16, 7]
print(b)            #  [8, 2]

#------------------------------------------------------------------------------------------------------------------------
    Aynı liste üzerinde silme yapılırken ilk silmeden sonra elemanların indeks numaralarının değişeceğine dikkat ediniz.
    Yani:

    del a[i], a[k]

    işlemi aşağıdaki ile eşdeğerdir:

    del a[i]
    del a[k]
#------------------------------------------------------------------------------------------------------------------------

a = ['ali', 3, 'veli', 45, 73, 'ali', 21, 16, 7]

print(a)                # ['ali', 3, 'veli', 45, 73, 'ali', 21, 16, 7]   
del a[0], a[1]
print(a)                # [3, 45, 73, 'ali', 21, 16, 7]

#------------------------------------------------------------------------------------------------------------------------
    Python'da iki liste nesnesi + operatörü ile toplanabilir. Ancak çıkartılamaz, çarpılamaz ve bölünemez. İki liste toplandığında 
    bu işlemden yeni bir liste edilmektedir. Bu yeni listenin elemanları + operatörünün solundaki liste elemanlarına sağındaki liste elemanlarının 
    eklenmesiyle oluşturulmuş bir liste olur. a + b işleminde önce len(a) + len(b) kadar uzunlukta yeni bir liste yaratılır. Bu listeye
    önce a listesindeki adresler, sonra b listesindeki adresler eklenir. Böylece c listesi aslında a listesindeki adreslerden ve 
    b listesindeki adreslerden oluşuyor durumda olur. Bu da bir çeşit sığ kopyalama anlamına gelmekteir. 

    Aşağıdaki örnekte aslında id(b[2]) ile id(c[5]) aynı değerleri vermektedir. Çünkü bunlar aslında aynı nesneyi gösterirler. 
#------------------------------------------------------------------------------------------------------------------------

a = [10, 'ali', 20]
b = [30, 'veli', 40]

c = a + b
print(c)            #  [10, 'ali', 20, 30, 'veli', 40]
           
print(id(b[2]))
print(id(c[5]))     #  b[2] ile c[5] aynı nesnesyi gösteriyorlar

#------------------------------------------------------------------------------------------------------------------------
    İki list nesnesi toplanırken oluşturulan liste toplanan iki list nesnesinin tuttukları adreslerden oluştuğuna göre list nesnesinin 
    bir elemanu "değiştirilebilir (mutable)" bir nesne ise orada yapılan değişiklik dolaylı biçimde toplama işlemiyle elde edilen nesnede de
    gözükecektir. Aşağıdaki örneği izleyiniz:

    >>> a = [1, 2, [3, 4]]
    >>> b = [10, 20]
    >>> c = a + b
    >>> c
    [1, 2, [3, 4], 10, 20]
    >>> a[2][0] = 100
    >>> c
    [1, 2, [100, 4], 10, 20]

    Aşağıda da benzer bir örnek verilmiştir. Burada b listesinin 1'inci indisli elemanı başka bir listenin adresini tutmaktadır. 
    Toplama sonucunda c listesinin 4'üncü indisli elemanı da aynı listeyi gösteriyor durumda olur. Listeler değiştirilebilir (mutable) 
    olduğuna göre biz hem b hem de c tarafından gösterilen bu listeyi her iki liste yoluyla değiştirebiliriz. Örneğin:
#------------------------------------------------------------------------------------------------------------------------

a = [10, 20, 30]
b = [40, [50, 60], 70]

c = a + b
print(c)            # [10, 20, 30, 40, [50, 60], 70]

c[4][0] = 100
print(b)            # [40, [100, 60], 70]

#------------------------------------------------------------------------------------------------------------------------
    İki listeyi toplarken yeni oluşturulan liste her zaman iki listenin uzunlukları toplamı kadar uzunluğa sahip olur.
#------------------------------------------------------------------------------------------------------------------------

a = [[10, 20, 30]]
b = [[40, 50, 60]]

c = a + b
         
print(c)        # [[10, 20, 30], [40, 50, 60]]

#------------------------------------------------------------------------------------------------------------------------
    İki listenin toplanması durumunda listelerden biri ya da her ikisi boş liste olsa bile yine de toplama işlemi sonucunda
    yeni bir liste yaratılmaktadır. Tabii genel olarak bir programda "gözlemlenebilir bir yan etki (observable side effects)" oluşmadıktan 
    sonra derleyiciler ve yorumlayıcılar kodu daha hızlı çalışacak biçimde ya da daha az yer kaplayacak biçimde yeniden düzenleyebilirler. 
    Yani aşağıdaki örnekte aslında yorumlayıcı bu toplama işlemini hiç yapmayabilir. Çünkü yorumlayıcının bu toplama işlemini yapıp 
    yapmadığı program içerisinde anlaşılamamaktadır. Başka bir deyişle yorumlayıcı bu toplama işlemini yapsa da yapmasa da biz 
    bunun yapılıp yapılmadığını gözlemleyemeyiz:

    c = [10, 20, 30] + []

    print(c)

    Benzer biçimde aşağıdaki örnekte de yorumlayıcı önce iki listeyi oluşturup sonra onları toplamak yerine doğrudan 
    toplama ilişkin listeyi oluşturabilir. Yorumlayıcı bunu yaptiığında bzim kodumuz bundan hiçbir biçimde etkilenmeyecektir:

    a = [1, 2, 3] + [4, 5]

    Burada belki de yorumlayıcı doğurdan [1, 2, 3, 4, 5] elemanlarına sahip bir liste oluşturup bu listenin adresini a'ya 
    atamıştır. 
#------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------
    Anımsanacağı gibi a += b işlemi a = a + b anlamına gelmektedir. Ancak listelerde bu eşdeğerlik söz konusu değildir. a ve b birer liste
    olmak üzere a += b aslında b listesinin lemanlarının mevcut a listesinin sonuna eklenmesi anlamına gelmektedir. Dolayısıyla a += b aslında
    listelerde adeta a.extend(b) gibi bir etki yaratmaktadır. Örneğin:

    >>> a = [1, 2, 3]
    >>> b = [4, 5]
    >>> id(a)
    1570379741824
    >>> a = a + b
    >>> a
    [1, 2, 3, 4, 5]
    >>> id(a)
    1570379772992
    >>> a = [1, 2, 3]
    >>> b = [3, 4]
    >>> id(a)
    1570379782464
    >>> a += b
    >>> a
    [1, 2, 3, 3, 4]
    >>> id(a)
    1570379782464

    Burada listeler için a = a + b işlemi ile a += b işleminin aynı olmadığını görmekteyiz. 
#------------------------------------------------------------------------------------------------------------------------

a = [10, 20, 30]
b = [40, 50]

print(id(a))
a = a + b
print(a)
print(id(a))        # a'nın id'si değişiyor, çünkü a artık yeni bir listeyi gösteriyor

a = [10, 20, 30]
print(id(a))

a += b
print(a)
print(id(a))        #  a'nın id'si değişmiyor. Çünkü ekleme a'ya yapılıyor

#------------------------------------------------------------------------------------------------------------------------
    Python dokümanlarına göre (Python Library Reference) a list türünden olmak üzere a.extend(b) ile a += b tamamen eşdeğerdir. 
    extend metodunda metodun parametresinin herhangi bir dolaşılabilir nesne olabileceğini belirtmiştik. Aynı durum a += b operatöründe de 
    geçerlidir. Bu işlemde a list türündense b aslında dolaşılabilir herhangi bir nesne belirtebilir. Örneğin:

    >>> a = [1, 2, 3]
    >>> a.extend('ali')
    >>> a
    [1, 2, 3, 'a', 'l', 'i']
    >>> a = [1, 2, 3]
    >>> a += 'ali'
    >>> a
    [1, 2, 3, 'a', 'l', 'i']

#------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------
    Bir liste int bir değerle çarpılabilir. (İki liste çarpılamaz, bölünemez ve çıkartılamaz. Ayrıca bir liste int bir toplanamaz ve bölünemez.) 
    Bu işleme Python'da "yineleme (repitition)" denilmektedir. a bir liste, n de int bir değer belirtmek üzere a * n ya da n * a tamamen 
    n defa a yı kendisiyle toplamaya eşdeğerdir. Örneğin a * 3 tamamen a + a + a anlamına gelmektedir. Yani a içerisindeki değerler üç kere yinelenmektedir. 
    Listeler toplanırken oluşturulan yeni listeye operand olarak kullanılan listelerdekş adreslerin kopyalandığını anımsayınız. Örneğin:

    >>> a = [1, 2, 3]
    >>> b = a * 2
    >>> a
    [1, 2, 3]
    >>> b
    [1, 2, 3, 1, 2, 3]
    >>> id(a[0])
    1570340235568
    >>> id(b[0])
    1570340235568
    >>> id(b[3])
    1570340235568
    >>> b = a + a
    >>> b
    [1, 2, 3, 1, 2, 3]

#------------------------------------------------------------------------------------------------------------------------

a = [10, 20, 30]

b = a * 3       # eşdeğeri a + a + a
print(b)        # [10, 20, 30, 10, 20, 30, 10, 20, 30]

b = 3 * a
print(b)        # [10, 20, 30, 10, 20, 30, 10, 20, 30]

b = [0] * 10    
print(b)        # [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]

#------------------------------------------------------------------------------------------------------------------------
    a * 3 gibi bir ifade a + a + a anlamına geldiğine göre aslında burada yeni yaratılacak listenin elemanları tekrarlı bir biçimde
    a listesinin elemanlarındaki adresleri tutacaktır. Yani yineleme işlemi aslında yinelen listenin (örneğimzde a) adreslerinin yinelenmesiyle 
    oluşturulmaktadır. Sonuçta bir "sığ kopyalama (shallow copy)" durumu oluşur. Yani yineleme liste elemanlarının gösterdiği nesnelerin kopyasını oluşturmamaktadır. Örneğin:

    a = [10, 20]
    b = a * 3

    gibi bir işlemde b listesinin elemanları üç kere a listesinin elemanlarındaki adreslerden oluşmaktadır. Örneğin:

    >>> a = [10, 20]
    >>> b = a * 3
    >>> id(a[0])
    1672940513872
    >>> id(a[1])
    1672940514192
    >>> id(b[0])
    1672940513872
    >>> id(b[1])
    1672940514192
    >>> id(b[2])
    1672940513872
    >>> id(b[3])
    1672940514192
    >>> id(b[4])
    1672940513872
    >>> id(b[5])
    1672940514192
#------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------
    Yineleme eişlemi bazı durumlarda çok pratik olanaklar sağlamaktadır. Örneğin biz her elemanı 0 olan 100 elemanlık bir listeyi 
    kolay bir biçimde yineleme ile oluşturabiliriz:

    >>> a = [0] * 100

    Burada a 100 elemanlı bir listedir ve bu listenin her elemanında 0 vardır. Tabii aslında a listesinin her elemanı içerisinde 
    0 olan aynı int nesnenin adresini tutuyor durumdadır:

    >>> id(a[0])
    1570340235536
    >>> id(a[1])
    1570340235536
    >>> id(a[99])
    1570340235536

    Bu durum bir sorun oluşturmaz. Nasıl olsa int "değiştirilemez (immutable)" bir türdür. Biz listeninin bir elemanına değer 
    atadığımızda diğer elemanların değeri değişmeyecektir. Örneğin:

    >>> a[0] = 100
    >>> id(a[0])
    1570340427216
    >>> id(a[1])
    1570340235536
    >>> id(a[2])
    1570340235536

#------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------
    Yineleme işleminde çarpılan değer 0 ya da negatif bir değerse yineleme işleminden boş bir liste elde edilmektedir. Örneğin:

    >>> a = [1, 2, 3]
    >>> a * 0
    []
    >>> a * -3
    []
#------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------
    Biz Python'da ne zaman bir köşeli parantez açsak yeni bir liste yaratılmaktadır. Örneğin:

    a = [[1, 2], [1, 2], [1, 2]]

    Burada a listesinin elemanları farklı listeleri göstermektedir:

    >>> a = [[1, 2], [1, 2], [1, 2]]
    >>> id(a[0])
    1570379740736
    >>> id(a[1])
    1570379741760
    >>> id(a[2])
    1570379739776

    Ancak aşağıdaki gibi bir listenin her elemanının aynı listeyi göstermesini de saplayabiliriz:

    a = [1, 2]
    b = [a, a, a]

    Burada b listesinin her elemanı a'yı göstermektedir:

    >>> a = [1, 2]
    >>> b = [a, a, a]
    >>> id(b[0])
    1570379735488
    >>> id(b[1])
    1570379735488
    >>> id(b[2])
    1570379735488

    O halde burada biz a listesi üzerinde değişilik yaparsak bu durumda b'nin elemanları aynı a listesini gösterdiğine göre sanki
    onlar üzerinde de eğişiklik yapılmış gibi bir etki oluşacaktır. Örneğin:

    >>> a[1] = 100
    >>> b
    [[1, 100], [1, 100], [1, 100]]
    
#------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------
    Aşağıdaki gibi boş bir listemiz olsun:

    a = []

    Şimdi biz aşağıdaki gibi bir liste oluşturalım:

    b = [a, a, a]

    Burada b'nin ilk üç elemanına aslında a listesinin adresi yerleştirilmiştir. Dolayısıyla aslında b listesinin elemanlarının hepsi 
    aynı a listesini göstermektedir. Şimdi aşağıdaki gibi bir işlem uygulayalım:

    b[0].append(100)

    biz aslında bu 100 değerini a listesine eklemiş olduk o zaman b'yi yazdırdığımızda şöyle bir görüntü ile karşılaşırız:

    [[100], [100], [100]]

    Yani biz bir listenin elemanına bir değer yerleştirdiğimzde aslında o değeri liste elemanına yerleştirmeyiz. O elemanın belirttiği nesnenin
    adresini liste elemanına yerleştirmiş oluruz. 

    >>> a = []
    >>> id(a)
    1672976339968
    >>> b = [a, a, a]
    >>> id(b[0])
    1672976339968
    >>> id(b[1])
    1672976339968
    >>> id(b[2])
    1672976339968
    >>> b[0].append(100)
    >>> a
    [100]
    >>> b
    [[100], [100], [100]]
    >>> a.append(200)
    >>> b
    [[100, 200], [100, 200], [100, 200]]

#------------------------------------------------------------------------------------------------------------------------
    Aşağıdaki koda dikkat ediniz:

    a = [[], [], []]

    Burada her köşeli parantez yeni bir listenin yaratılmasına yol açtığı için a'nın elemanları farklı boş listeleri gösterecektir. 
    Ancak örneğin:

    a = [[]] * 3

    Burada yinelemeden dolayı oluşturulan a listesinin elemanları aynı boş listeyi gösterecektir. Bunu ispatlayalım:

    >>> a = [[], [], []]
    >>> id(a[0])
    1570379711424
    >>> id(a[1])
    1570379736832
    >>> id(a[2])
    1570379738880
    >>> a = [[]] * 3
    >>> id(a[0])
    1570379700800
    >>> id(a[1])
    1570379700800
    >>> id(a[2])
    1570379700800   
   
#------------------------------------------------------------------------------------------------------------------------

a = [[]] 
b = a * 3   
print(b)    

b[0].append(100)
print(b)            # [[100], [100], [100]]

b[1].append(200)
print(b)            # [[100, 200], [100, 200], [100, 200]]

#------------------------------------------------------------------------------------------------------------------------
    *  operatörü soldan sağa öncelikli olduğuna göre a bir liste olmak üzere aşağıdaki ifade de geçerlidir:

    b = a * 2 * 3

    Burada önce a * 2 işlemi yapılacak buradan bir liste elde edilecek sonra elde edilen bu liste 3 ile çarpılacaktır. Yani sonuçta
    a'nın elemanlarından 6 kez oluşturulmuş olacaktır. Örneğin:

    >>> a = [1, 2, 3]
    >>> b = a * 2 * 3
    >>> b
    [1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3]

    Dolayısıyla Python'da çarpmanın değişme özelliği ve birleşme özelliği muhafaza edilmiştir. Örneğin bu işlem aşağıdakiyl eşdeğerdir:

    b = a * (2 * 3) 
#------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------
    Listelerde a = a * n ile a *= n işlemi de aynı anlama gelmemektedir. a = a * n işleminde a * n ile yeni bir liste yaratılır,
    a artık bu yeni listeyi gösterir. Halbuki a *= n işleminde (n - 1) tane a, a'nın sonuna eklenmektedir. Örneğin:

    >>> a = [1, 2, 3]
    >>> id(a)
    1570379775488
    >>> a = a * 2
    >>> a
    [1, 2, 3, 1, 2, 3]
    >>> id(a)
    1570379885120
    >>> a = [1, 2, 3]
    >>> id(a)
    1570379931200
    >>> a *= 2
    >>> id(a)
    1570379931200
    >>> a
    [1, 2, 3, 1, 2, 3]
#------------------------------------------------------------------------------------------------------------------------

a = [10, 20, 30]

print(a, id(a))
a = a * 3
print(a, id(a))     # a'nın adresi değişiyor, a artık a * 3 ile yaratılan listeyi gösteriyor

a = [10, 20, 30]

print(a, id(a))
a *= 3
print(a, id(a))     # a'nın adresi değişmiyor, ekleme a'nın sonuna yapılıyor

#------------------------------------------------------------------------------------------------------------------------
    Demetler (tuples) listelere benzeyen önemli diğer bir veri yapısıdır. Bir demet normal parantezler kullanılarak yaratılabilir. 
    Örneğin:

    t = (10, 20, 30)

    Demetler tuple isimli sınıfla temsil edilmektedir. ("tuple" sözcüğü "tyupıl" gibi de "tapl" gibi de okunabilmektedir.)
#------------------------------------------------------------------------------------------------------------------------

t = (10, 20, 30)
print(t)            # (10, 20, 30)

print(type(t))      # <class 'tuple'>

#------------------------------------------------------------------------------------------------------------------------
    Bir demet tuple sınıfının tür fonksiyonu olan tuple fonksiyonu ile de yaratılabilir. tuple fonksiyonuna argüman girilmezse
    boş bir demet yaratılır. Eğer tuple fonksiyonuna dolaşılabilir bir nesne argüman olarak verilirse tuple fonksiyonu bu nesneyi dolaşarak
    onun elemanlarından demet oluşturmaktadır. Örneğin:

    >>> t = tuple()
    >>> t
    ()
    >>> a = [1, 2, 3, 4, 5]
    >>> t = tuple(a)
    >>> t
    (1, 2, 3, 4, 5)
    >>> t = tuple('ankara')
    >>> t
    ('a', 'n', 'k', 'a', 'r', 'a')

#------------------------------------------------------------------------------------------------------------------------

t = tuple()
print(t)            # ()

t = tuple('ankara')
print(t)            # ('a', 'n', 'k', 'a', 'r', 'a')

a = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
t = tuple(a)
print(t)            # (1, 2, 3, 4, 5, 6, 7, 8, 9, 10)

#------------------------------------------------------------------------------------------------------------------------
    Demetler listelere pek çok bakımdan benzemektedir. Örneğin:

    - Demetlerin elemanlarına da [] operatörüyle erişilir.
    - Demetlerde de elemana erişirken negatif indeksler listelerdeki gibi anlam taşır.
    - Demetlerde de tamamen listelerde olduğu gibi dilimleme yapılabilir.  Tabii dilimleme işleminden demet elde edilir.
    - Demetler de dolaşılabilir (iterable) nesnelerdir. 
#------------------------------------------------------------------------------------------------------------------------
    
t = (10, 20, 30, 40, 50, 60, 70, 80, 90, 100)

val = t[3]
print(val)              # 40

val = t[-3]
print(val)              # 80

result = t[1:6]
print(result)              # (20, 30, 40, 50, 60)

result = t[1:6:2]
print(result)              # (20, 40, 60)

result = t[::-1]
print(result)

#------------------------------------------------------------------------------------------------------------------------
    Demetler dolaşılabilir nesnelerdir. Demetler dolaşıldığında sırasıyla demetin elemanları elde edilir. Örneğin:

    >>> t = (1, 2, 3, 4, 5)
    >>> a = list(t)
    >>> a
    [1, 2, 3, 4, 5]
#------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------
    Demetlerde de eleman uzunluğu built-in len fonksiyonuyla elde edilebilir. 
#------------------------------------------------------------------------------------------------------------------------

t = (10, 20, 30, 40, 50, 60, 70, 80, 90, 100)

n = len(t)
print(n)            # 10

#------------------------------------------------------------------------------------------------------------------------
    Boş bir demet içi boş bir parantezle oluşturulmaktadır. Örneğin:

    >>> t = ()
    >>> type(t)
    <class 'tuple'>
    >>> len(t)
    0

    Burada yorumlayıcı bu parantezleri öncelik parantezi olarak değerlendirmez. Ancak tek elemanlı demetleri oluştururken dikkat etmek gerekir. 
    Çünkü (10) gibi bir sentaks demet belirtmez. Buradaki parantezler öncelik parantezi anlamına gelir. Tek elemanlı demetleri oluştururken 
    parantez içerisine ekstra bir ',' eklemek gerekir. Örneğin:

    t = (10, )

    Aslında listelerde ve demetlerde son elemandan sonra boş virgül bırakılabilmektedir:

    a = [10, 20, 30, ]          # geçerli
    print(len(a))               # 3

    Tabii buradaki son ',' atomunun hiçbir işlevi yoktur. Ancak sentaks bakımından bu son ',' geçerlidir. Yani buradaki son ','
    boş bir eleman oluşturmamaktadır. 
#------------------------------------------------------------------------------------------------------------------------

t = (10)
print(t, type(t))   # 10 <class 'int'>

t = (10, )
print(t, type(t))   # (10,) <class 'tuple'>

#------------------------------------------------------------------------------------------------------------------------
    Demetler de tamamen listelerde oluduğu gibi heterojen yani farklı türlerden elemanlara sahip olabilir. Örneğin:

    >>> t = (10, 'ali', True, 20.5)
    >>> t
    (10, 'ali', True, 20.5)
#------------------------------------------------------------------------------------------------------------------------

t = ('ali', 12, None, 'velli', 3.14, True)
print(t)        # ('ali', 12, None, 'velli', 3.14, True)

#------------------------------------------------------------------------------------------------------------------------
    Bir listenin elemanı bir demet, bir demetin elemanı da bir liste olabilir. Örneğin:

    a = [10, 'ali', ('veli', 20), True]
    t = (10, 'veli', [20, 30], 40)

#------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------
    Demet elemanları da tıpkı listelerde olduğu gibi adreslerden oluşmaktadır. Yani bir demet elemanların kendisini değil 
    onların adreslerini tutmaktadır. Örneğin:

    t = ('ali', 12)

    Burada t demetinin ilk elemanı içerisinde 'ali' yazısının bulunduğu str nesnesinin adresini, ikinci elemanı içerisinde 12 değerinin 
    bulunduğu int nesnesinin adresini turmaktadır. 

#------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------
    Listelerle demetler arasındaki en önemli farklılı (aslında tek farklılık, diğer farklılıklar bu farklılığın bir sonucu) 
    listelerin "değiştirilebilir (mutable)", demetlerin ise "değiştirilemez (immuatable)" olmasıdır. Bir demet yaratıldıktan 
    sonra artık onun elemanları bir daha değiştirilemez. Örneğin:

    t = (10, 20, 30)
    t[0] = 100          # geçersiz! exception oluşur

    Burada demetin bir elemanı değiştirilmeye çalışılmıştır. Demet nesnesi "değiştirilebilir (mutable)" değildir. Dolayısıyla bir demet
    yaratıldıktan sonra biz onun herhangi bir elemanını değiştiremeyiz. (Yani onun herhangi bir elemanına başka bir nesnenin adresini
    atayamayız.)

    tuple sınıfının da çeşitli metotları vardır. Ancak list sınıfında bulunan elemanlar üzerinde değişiklik yapan metotlara tuple 
    sınıfı sahip değildir. Bir demet nesnesi bir kez yaratılır. Sonra onun üzerinde değişiklik yapılamaz. Ona eleman da eklenemez, ondan 
    eleman da silinemez. 

    Bu nedenle demetlerde listelerde bulunan aşağıdaki işlemler ve metotlar yoktur:

    - Sona eleman ekleme işlemi (append metodu) demetlerde yoktur.
    - Sona dolaşılabilir nesnenin elemanlarını ekleme işlemi (extend) demetlerde yoktur.
    - Belli bir elemanın silinmesi işlemi (pop ve remove) demetlerde yoktur.
    - Tüm elemanların silinmesi işlemi (clear) demetlerde yoktur.
    - Araya eleman ekleme işlemi (insert) demetlerde yoktur.
    - In-place Sıraya dizme işlemi (sort metodu) demetlerde yoktur.
    - In-place ters yüz etme işlemi (reverse) demetlerde yoktur. 
    - Demetlerde dilimleme yoluyla atama da yapılamamaktadır.

    Ancak demetlerde eleman değişikliği yapmayan index ve count metotları bulunmaktadır. Örneğin:

    >>> t = (10, 'ali', 20, 'veli', 10)
    >>> t.index(20)
    2
    >>> t.count(10)
    2

#------------------------------------------------------------------------------------------------------------------------

t = (10, 20, 'ali', 20, 40, 'veli')

result = t.index('veli')
print(result)                # 5

result = t.count(20)
print(result)               # 2

#------------------------------------------------------------------------------------------------------------------------
    Tabii demetlerin elemanları da aslında nesnelerin adreslerini tutmaktadır. Bu konuda listelerle bir farklı yoktur. 

    >>> t = (10, 'ali', 20)
    >>> id(t)
    1672976258432
    >>> id(t[0])
    1672940513872
    >>> id(t[1])
    1672976339248
    >>> id(t[2])
    1672940514192

#------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------
    Bir grup bilgiden elde edilen onu temsil eden kısa bir bilgiye hash denilmektedir. Bir grup bilgiden bir hash 
    değerinin elde edilmesi çeşitli amaçlarla kullanılabilmektedir. Örneğin hash değerleri bazı veri yapıları için 
    anahtar olarak kullanılırlar. Yine hash değerleri bozulmayı tespit etmek için de bazı bilgi güvenliği ve şifreleme gibi 
    bazı aalanlarda kullanılmaktadır. 
    
    Python'da bazı türler "hash'lenebilir (hashable)" iken bazı türler "hash'lenemez (unshable)" biçimdedir. Genel olarak değiştirilebilir türler
    hash'lenebilir değildir. Bu nedenle listeler elemanları ne olursa olsun hash'lenebilir değildir. Öte yandan demetler değiştirilemez 
    türler olduğu için hash'lenebilir türlerdir. Ancak her demet nesnesi de hash'lenebilir değildir. Bir demetin hash'lenebilir olması 
    için onun bütün elemanlarının hash'lenebilir olması gerekir. int, float, str, bool, complex, None türleri hash'lenebilirdir. Bu durumda
    örneğin bir demetin bir elemanı bir liste ise o demet hash'lenebilir olmaz. Ancak listeler hiçbir durumda "hash'lenebilir" değildir. 

    Bir nesnenin içerisindeki değerin hash değeri hash isimli built-in fonksiyonla elde edilebilir. Örneğin:

    >>> a = 'ali'
    >>> hash(a)
    3186741938407899844
    >>> t = (1, 2, 3, 4)
    >>> hash(t)
    590899387183067792

    Aşağıdaki demet hash'lenebilir değildir:

    t = (1, 2, [3, 4], 5)

    Çünkü bu demet bir liste elemanına sahiptir. Bu liste de hash'lenebilir değildir:

    >>> t = (1, 2, [3, 4], 5)
    >>> hash(t)
    Traceback (most recent call last):
    File "<stdin>", line 1, in <module>
    TypeError: unhashable type: 'list'

    Aşağıdaki demet hash'lenebilirdir:

    >>> t = (1, 2, (3, 4), 5)
    >>> hash(t)
    -2963430713186267524

    Aşağıdaki demet de hash'lenebilir değildir:

    >>> t = (1, 2, (3, 4, [5, 6]), 7)
    >>> hash(t)
    Traceback (most recent call last):
    File "<stdin>", line 1, in <module>
    TypeError: unhashable type: 'list'

#------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------
    Demetin bir elemanı bir liste olsun:

    t = (1, [2, 3], 4)

    Biz şimdi bu listenin elemanlarını değiştirebiliriz:

    t[1][1] = 100

    Burada bu demeti yazdırdığımızda şöyle bir sonuç göreceğiz:

    (1, [2, 100], 4)

    Aslında bu durum demetin değiştirildiği anlamına gelmemektedir. Çünkü bu işlemle biz aslında demetin elemanlarında değişiklik
    yapmış olmuyoruz. Yani demetin elemanları yine aynı adresleri tutmaktadır. Biz burada değişikliği demetin elemanı olan liste üzerinde
    yapmış oluyoruz. Bu durum yanlış yorumlanmamalıdır. 
#------------------------------------------------------------------------------------------------------------------------

t = (1, [2, 3], 4)
print(t)        # (1, [2, 3], 4)

t[1][1] = 100
print(t)        # (1, [2, 100], 4)

#------------------------------------------------------------------------------------------------------------------------
                                            15. Ders - 30/05/2021-Pazartesi
#------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------
    Demetler oluşturulurken bazı zorunlu durumlar dışında parantezler kullanılmayabilir. Örneğin:

    t = (1, 2, 3)

    ile,

    t = 1, 2, 3

    aynı anlamdadır. Örneğin:

    t = 10, 

    ile,
    
    t = (10, )

    aynı anlamdadır. Demet oluştururken pek çok durumda parantez gerekmediğine göre biz de örneklerimizde bazen parantezleri 
    kullanacağız bazen de kullanmayacağız. 

#------------------------------------------------------------------------------------------------------------------------

t = 10, 20, 30

print(t)

t = 10, [20, 30, 40], 50
print(t)

#------------------------------------------------------------------------------------------------------------------------
    Tabii bazı durumlarda demeti yaratırken parantezleri mecburen kullanırız. Örneğin listenin ya da demetin bir elemanı demet olacaksa 
    mecburen demet parantezleri kullanılmak zorundadır. 

    a = [10, (20, 30, 40), 50]
    print(a)

    t = 10, (30, 40, 50), 50
    print(t)

    Örneğin bir fonksiyona argüman olarak bir demet göndermek istiyorsak yine mecburen demet parantezini kullanmak zorundayız:

    print(10, 20)
    print((10, 20))

    Boş bir demet oluştururken boş parantezlerin kullanılması ya da tuple sınıfının tür fonksiyonun kullanılması gerekir. Örneğin:

    t = ()
    print(t)

    t = tuple()
    print(t)

    Yani aşağıdaki gibi bir sentaks geçerli değildir:

    t = ,

#------------------------------------------------------------------------------------------------------------------------
  
#------------------------------------------------------------------------------------------------------------------------
    Tek elemanlı bir demeti parantezsiz de oluşturabiliriz. Tabii bu durumda değerden sonra bir ',' atomu gerekir. Örneğin:

    t = 10, 
    print(t)
#------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------
    İki demet + operatörü ile toplanabilir. Toplama işleminden yeni bir demet nesnesi elde edilir. Bu yeni demet nesnesi 
    iki demet nesnesinin elemanlarının uç uca eklenmesinden oluşmaktadır. Yine tıpkı listelerde olduğu gibi yeni yaratılan 
    demete bu demetlerin içerisindeki adresler kopyalanmaktadır.
#------------------------------------------------------------------------------------------------------------------------

a = (10, 20, 30)
b = (40, 50, 60)

c = a + b
print(c)

print(id(c[3]), id(b[0]))       # aynı adresler

#------------------------------------------------------------------------------------------------------------------------
    Listelerde a = a + b ile a += b farklı anlamlara geliyordu. Ancak demetlerde bu iki ifade tamamen aynı anlama gelmektedir.
    Çünkü demetlerde sona ekleme biçiminde bir işlem yoktur. Örneğin:

    >>> a = 1, 2, 3
    >>> id(a)
    1486505308992
    >>> b = 4, 5, 6
    >>> a += b
    >>> id(a)
    1486504943872
    >>> a
    (1, 2, 3, 4, 5, 6)
#------------------------------------------------------------------------------------------------------------------------

a = 10, 20, 30
b = 40, 50

print(a, id(a))
a = a + b
print(a, id(a))

a = 10, 20, 30
print(a, id(a))
a += b
print(a, id(a))     # id farklı çıkacak, çünkü demetlerde sona ekleme mümkün değil

#------------------------------------------------------------------------------------------------------------------------
    Demetlerde de yineleme (repitition) işlemi yapılabilmektedir. Yani bir demet int bir değerle çarpılabilir. Bu durumda yine bir 
    demet nesnesi yaratılır. Bu demet nesnesi çarpılan demetin elemanlarının yinelenmesinden oluşur. Tabii iki demeti çarpamayız, 
    çıkartamayız, bölemeyiz. Yine yineleme işleminde çarpılan değer 0 ya da negatif bir değerse boş bir demet elde edilmektedir. 
    Operand'lar yine çarpma işlemimde yer değiştirebilir. 
#------------------------------------------------------------------------------------------------------------------------

a = (10, 20, 30)

b = 3 * a               # a * 3 de yazılabilirdi

print(b)

#------------------------------------------------------------------------------------------------------------------------
    Listelerde a = a * n ile a *= n farklı anlamlara geliyordu. Ancak demetlerde sona ekleme işlemi olmadığı için bu iki ifade
    de tamamen aynı anlama gelmektedir. Örneğin:

    >>> a = 1, 2, 3
    >>> id(a)
    1486505308992
    >>> a *= 2
    >>> id(a)
    1486504943872
    >>> a
    (1, 2, 3, 1, 2, 3)
#------------------------------------------------------------------------------------------------------------------------

a = 10, 20, 30

print(a, id(a))
a = a * 3
print(a, id(a))

a = 10, 20, 30
print(a, id(a))
a *= 3
print(a, id(a))     # id farklı çıkacak, çünkü demetlerde sona ekleme mümkün değil

#------------------------------------------------------------------------------------------------------------------------
    Demetlerle listeler kullanım bakımından birbirine benzemektedir. Pekiyi ne zaman listeleri ne zaman demetleri tercih
    etmeliyiz?

    1) Eğer veri yapısı üzerinde onu yarattıktan sonra ekleme, silme gibi değişikler yapılacaksa mecburen listeleri kullanırız. 
    Çünkü demetlerde yaratıldıktan sonra değişiklik yapılamamaktadır. 

    2) Liste türünden nesneler demet türünden nesnelere göre daha fazla yer kaplama eğilimindedir. Çünkü onların değiştirilebilir, 
    büyütülebilir ve küçültülebilir olmaları nedeniyle nesne içerisinde bu işlemler için  bazı bilgilerin bulundurulması gerekmektedir. 
    Bu nedenle eğer veri yapısı içerisindeki elemanlar üzerinde bir değişiklik yapmayacaksak, veri yapısına eleman ekleyip ondan bir şeyler
    silmeyeceksek demetleri tercih etmeliyiz.
    
    3) Demetler değiştirilebilir olmadığı için eğer onların elemanları hash'lenebilir (hashable) ise hashable nesnelerdir. Bu da onların
    sözlük gibi, küme gibi veri yapılarında kullanılabilmesi anlamına gelir. Listeler hiçbir durumda hashable değildir. 

    Her ne kadar veri yapısı üzerinde değişlik yapılmayacaksa liste yerine demetlerin kullanılması daha uygunsa da Python programcıları
    yine de bu tür durumlarda demet yerine liste kullanabilmektedir. Çünkü pek çok uygulamada demetlerle listelerin kapladıkları yerin
    farklı büyüklekte olmasının önemi yoktur. Bazen programcılar "değişikliğin yapılmasının istenmediğini vurgulamak" için de demet kullanabilmektedir. 
    Örneğin ileride de göreceğimiz gibi bir fonksiyonun birden fazla değeri çağıran fonksiyona iletmesi gerektiği durumda listeler yerine 
    demetler hem etkinlik bakımından hem de okunabilirlik bakımından daha uygun bir seçenektir. 
#------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------
    Dolaşılabilir bir nesnenin elemanları "açım (unpacking)" denilen bir sentaksla değişkenlere atanabilmektedir. Açım (unpacking)
    işlemi Ruby' Python gibi dillerde eskiden beri vardı. Daha sonraları C# gibi, Swift gibi dillere ve hatta C++'a bile bu özellik
    eklenmiştir. Açım işlemi eskiden yalnızca demetler üzerinde yapılabiliyordu. Ancak daha sonra dolaşılabilir her nesne açılabilir
    yapıldı. Dolayısıyla açım sentaksı da genelleştirildi. Açım için aşağıdaki üç sentaks tamamen aynı anlama gelmektedir:

    1) (x, y, z, ...) = <dolaşılabilir nesne>
    2) x, y, z, ... = <dolaşılabilir nesne>
    3) [x, y, z ...] = <dolaşılabilir nesne>

    Açım sırasında = operatörünün sağ tarafında "dolaşılabilir (iterable)" bir nesne bulunmak zorundadır. Açım sırasında bu 
    nesne dolaşılır, elde edilen değerler sol taraftaki değişkenlere sırasıyla atanır. Örneğin:

    t = 10, 20, 30

    x, y, z = t

    bu işlem tamamen aşağıdaki eşdeğerdir:

    x = t[0]
    y = t[1]
    z = t[2]

    Örneğin:

    [x, y, z] = 'ali'

    bu işlem tamamen aşağıdaki ile eşdeğerdir:

    x = 'a'
    y = 'l'
    z = 'i'

    Açım işleminde sol taraftaki sentaksın bir önemi yoktur. Üç sentaks biçimi de tamamen birbirleriyle eşdeğerdir.    
#------------------------------------------------------------------------------------------------------------------------

t = (10, 20, 30)

(x, y, z) = t

print(x, y, z)      # 10 20 30

x, y, z = t

print(x, y, z)      # 10 20 30

[x, y, z] = t

print(x, y, z)      # 10 20 30

x, y, z = 'van'
print(x, y, z)      # v a n

#------------------------------------------------------------------------------------------------------------------------
    Açım (unpacking) yapılırken = operatörünün sağındaki dolaşılabilir nesnenin eleman sayısının açımdaki değişken sayısı 
    ile tamamen aynı olması gerekir. Aksi takdirde exception oluşmaktadır. 
#------------------------------------------------------------------------------------------------------------------------

t = (10, 20, 30)

x, y = t            # geçersiz! exception oluşur

x, y, z, k = t      # geçersiz! exception oluşur

#------------------------------------------------------------------------------------------------------------------------
    Açılacak dolaşılabilir nesnedeki elemanlardan bazıları liste, demet gibi başka bir dolaşılabilir nesne olabilir. Örneğin:

    >>> a, b, c = [10, [20, 30], 40]
    >>> a
    10
    >>> b
    [20, 30]
    >>> c
    40
    >>> a, b, c = 100, 'ankara', 200
    >>> a
    100
    >>> b
    'ankara'
    >>> c
    200

#------------------------------------------------------------------------------------------------------------------------

a = [10, (20, 30), 40]

x, y, z = a

print(x, y, z)      # 10 (20, 30) 40

#------------------------------------------------------------------------------------------------------------------------
    Açım işlemi özyinelemeli (recursive) bir biçimde de yapılabilir. Yani açılan bir eleman dolaşılabilir bir nesne ise o da açılabilir. 
    Tabii bu durumda ek parantezler kullanılmalıdır. Ancak bu parantezlerin demet parantezi ya da liste parantezi olması arasında
    bir farklılık yoktur. Örneğin:

    >>> a, (b, c), d = [10, [20, 30], 40]
    >>> a
    10
    >>> b
    20
    >>> c
    30
    >>> d
    40
    >>> a, [b, c], d = [10, [20, 30], 40]
    >>> a
    10
    >>> b
    20
    >>> c
    30
    >>> d
    40

    Örneğin:

    >>> a, (b, (c, d, e), f), g = [10, [20, (30, 40, 50), 60], 70]
    >>> a, b, c, d, e, f, g
    (10, 20, 30, 40, 50, 60, 70)

    Tabii özyinelemenin sonuna kadar devam ettirilmesi gerekmez. Örneğin:

    >>> a, b, c  = [10, [20, (30, 40, 50), 60], 70]
    >>> a, (b, c, d), e  = [10, [20, (30, 40, 50), 60], 70]
    >>> print(a, b, c, d, e)
    10 20 (30, 40, 50) 60 70
    >>> a, (b, (c, d, e), f), g  = [10, [20, (30, 40, 50), 60], 70]
    >>> print(a, b, c, d, e, f, g)
    10 20 30 40 50 60 70

#------------------------------------------------------------------------------------------------------------------------

a = [10, 20, 30]

x, y, z = a

print(x, y, z)

#------------------------------------------------------------------------------------------------------------------------
    Tabii açım işlemi aslında bir çeşit atama işlemidir. Yani açım sonucunda değişkenlere aslında dolaşılabilir nesnenin elemanlarının
    adresi yerleştirilmektedir. 
#------------------------------------------------------------------------------------------------------------------------

a = [10, 20, 30]

x, y, z = a

print(id(a[0]), id(a[1]), id(a[2]))
print(id(x), id(y), id(z))              # id'ler aynı

#------------------------------------------------------------------------------------------------------------------------
    Python'da iki değişkenin değerinin yer değiştirilmesi açım (unpacking) işlemi ile kolay bir biçimde yapılabilmektedir.
    Örneğin:

    >>> a = 10
    >>> b = 20
    >>> a, b = b, a
    >>> print(a, b)
    20 10

#------------------------------------------------------------------------------------------------------------------------

a = 10
b = 20

print(a, b)     # 10 20

a, b = b, a

print(a, b)     # 20 10

#------------------------------------------------------------------------------------------------------------------------
    range isimli fonksiyon bize range isimli dolaşılabilir bir sınıf nesnesi vermektedir. range fonksiyonunun bize verdiği 
    dolaşılabilir nesne dolaşıldığında start değerinden başlayarak stop değerine kadar (start dahil stop dahil değil) 
    step miktarı artırımlarla int değerler elde edilmektedir. range fonksiyonu tek argümanlı, iki argümanlı ya da üç argümanlı 
    kullanılabilmektedir:

    range(stop)
    range(start, stop)
    range(start, stop, step)
        
    Tek argümanlı kullanımda dolaşım sırasında 0'dan argümanla belirtilen değere kadar int değerler elde edilir. 
    Örneğin:

    >>> r = range(10)
    >>> a = list(r)
    >>> a
    [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]

    Yani tek argümanlı kullanımsa aslında start değeri 0, step değeri 1 gibiymiş gibi işlem uygulanmaktadır. Bu durumda tek 
    argümanlı kullanımda biz aslında argüman olarak stop değerini vermiş oluruz. Dolaşım sırasında start değeri her zaman dolaşıma
    dahildir ancak stop değeri dahil değildir. 
#------------------------------------------------------------------------------------------------------------------------

r = range(10)       # start = 0, stop = 10, step = 1

a = list(r)
print(a)            # [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]

#------------------------------------------------------------------------------------------------------------------------
    range fonksiyonunu iki argümanla çağırırsak birinci argüman start değerini ikinci argüman stop değerini belirtir. 
    (start dahil stop dahil değildir.) Örneğin:

    >>> a = list(range(10, 20))
    >>> a
    [10, 11, 12, 13, 14, 15, 16, 17, 18, 19]

#------------------------------------------------------------------------------------------------------------------------

r = range(10, 20)       # start = 10, stop = 20, step = 1

a = list(r)
print(a)                # [10, 11, 12, 13, 14, 15, 16, 17, 18, 19]

#------------------------------------------------------------------------------------------------------------------------
    range fonksiyonu üç argümanla kullanıldığında birinci argüman start değerini, ikinci argüman stop değerini ve üçüncü 
    argüman da step değerini belirtir. Örneğin:

    >>> a = list(range(10, 20, 3))
    >>> a
    [10, 13, 16, 19]

#------------------------------------------------------------------------------------------------------------------------

r = range(10, 20, 2)       # start = 10, stop = 20, step = 2

a = list(r)
print(a)            # [10, 12, 14, 16, 18]

#------------------------------------------------------------------------------------------------------------------------
    range fonksiyonunun üç parametresi de int türden olmak zorundadır. Böylece range nesnesi dolaşıldığında nesne her zaman bize 
    int değerler verir. Bu durum range fonksiyonu ile noktalı artırımlar yapamayacağımız anlamına da gelmektedir. Örneğin:

    r = range(0, 1, 0.1)

    Böyle range nesnesi yaratmak istersek step değeri float olduğu için exception oluşacaktır. Yuvarlama hataları ile kararsız
    durumların oluşmaması noktalı artırımlara, float türden start ve stop değerlerine izin verilmemiştir. Örneğin eğer noktalı 
    artırımlara izin verilseydi şöyle sorunlar ortaya çıkabilirdi:

    a = list(range(a, b, 0.1))      # bu durum geçersizdir, biz burada "geçerli olsaydı" durumunu değerlendiriyoruz

    Burada a değerinden başlanarak b değerine kadar 0.1 artırımlarla değerler elde edilmek istenmiştir. Elde edilen değerlere 
    b değeri dahil olmayacaktır. İşte eğer bir yuvarlama hatası olursa ve son değer b'ye çok yakın ama yuvarlama hatasından dolayı
    b'den küçük olursa bu da dolaşılma dahil edilecektir. Bu durum da farklı uzunluklarda listelerin elde edilmesine yol açabilecektir. 
    
    Fakat örneğin yaygın kullanılan "NumPy" isimli kütüphanede arange isimli noktalı artırım yapan bir dolaşılabilir sınıf vardır.
    NumPy kütüphanesi "Python Uygulamaları" kursunda ayrıntılı biçimde ele alınmaktadır. Örneğin:

    >>> import numpy
    >>> a = numpy.arange(0, 1, 0.1)
    >>> a
    array([0. , 0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9])

    NumPy sayısal analiz, istatistik, matematik ve makine öğrenmesinde çok yaygın kullanılan üçüncü parti bir kütüphanedir. 
    Python'ın standart kütüphanesi içerisinde değildir. Aşağıdaki gibi install edilebilir:

    pip install numpy

    Anaconda dağıtımı default olarak NumPy kütüphanesini barındırmaktadır. 
#------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------
    range fonksiyonunda step değeri negatif verilebilir. Bu durumda dolaşım sırasında büyükten küçüğe değerler elde edilir. 
    Tabii eğer step değeri negatif ise start değerinin stop değerinden daha büyük olması gerekir. Yine stop değeri dahil değildir. 
    Örneğin:

    >>> a = list(range(10, 0, -1))
    >>> a
    [10, 9, 8, 7, 6, 5, 4, 3, 2, 1]
    >>> a = list(range(10, -1, -1))
    >>> a
    [10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0]
        
#------------------------------------------------------------------------------------------------------------------------

r = range(10, 0, -1)       # start = 10, stop = 0, step = -1

a = list(r)
print(a)                    # [10, 9, 8, 7, 6, 5, 4, 3, 2, 1]

r = range(10, -1, -1)       # start = 10, stop = -1, step = -1

a = list(r)
print(a)                    # [10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0]

#------------------------------------------------------------------------------------------------------------------------
                                            16. Ders - 01/06/2022-Çarşamba
#------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------
    Tabii range fonksiyonunun step parametresi 0 olamaz. Eğer bu parametre 0 girilirse exception (ValueError) oluşacaktır.
    Örneğin:

    >>> r = range(0, 10, 0)
    Traceback (most recent call last):
    File "<stdin>", line 1, in <module>
    ValueError: range() arg 3 must not be zero

#------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------
    range sınıfı Python Standart Kütüphanesinde bir "sequence container" olarak ele alınmıştır. "Sequence container" terimi Python'da
    elemanlar arasında öncelik sonralık ilişkisi olan ve elemanlarına [...] operatörü ile erişilen veri yapılarına betimlemektedir. 
    
    range sınıfı bir "sequence container" belirttiği için listeler ve demetler üzerinde yapılabilen bazı işlemler range nesneleri 
    üzerinde de yapılabilmektedir. Örneğin bir range nesnesi dilimlenebilir. Bu işlemden yeni bir range nesnesi elde edilir:

    >>> r = range(100)
    >>> k = r[30:60:3]
    >>> k
    range(30, 60, 3)

    Burada biz r range nesnesini dilimleyerek ondan başka bir range nesnesi elde ettik. range nesnelerinin dilimlenmesine seyrek 
    bir biçimde gereksinim duyulmaktadır. 

#------------------------------------------------------------------------------------------------------------------------

r = range(100)

k = r[30:60:3]
a = list(k)
print(a)            # [30, 33, 36, 39, 42, 45, 48, 51, 54, 57]

#------------------------------------------------------------------------------------------------------------------------
    range nesnesinin belli bir elemanına [...] operatör ile erişebiliriz. Ancak range nesnesinin elemanları değiştirilememektedir. 
    Örneğin:

    >>> r = range(100)
    >>> r[23]
    23
    >>> r[23] = 100
    Traceback (most recent call last):
    File "<stdin>", line 1, in <module>
    TypeError: 'range' object does not support item assignment

#------------------------------------------------------------------------------------------------------------------------

r = range(10, 20)

val = r[3]
print(val)      # 13

#------------------------------------------------------------------------------------------------------------------------
    Listelerde ve demetlerde kullandığımız in ve not in operatörleri range nesnelerinde de kullanılabilmektedir. Örneğin:

    >>> r = range(30, 60, 3)
    >>> 39 in r
    True
    >>> 40 in r
    False
    >>> 41 not in r
    True

#------------------------------------------------------------------------------------------------------------------------

r = range(10, 20)

result = 15 in r
print(result)           # True

result = 25 in r
print(result)           # False

#------------------------------------------------------------------------------------------------------------------------
    Teknik olarak range sınıfı "değiştirilemez (immutable)" bir sınıftır. Dolayısıyla bu sınıfta append, extend, remove gibi
    metotlar bulunmaz. Ancak index ve count metotları sınıfta bulunmaktadır. Örneğin:

    >>> r = range(100)
    >>> r.count(67)
    1
    >>> r = range(30, 60, 3)
    >>> r.index(39)
    3

#------------------------------------------------------------------------------------------------------------------------

r = range(10, 20)

result = r.index(15)
print(result)           # 5

result = r.count(12)
print(result)           # 1

#------------------------------------------------------------------------------------------------------------------------
    range nesnelerinin dolaşıldıkları takdirde kaç eleman verecekleri yine built-in len fonksiyonuyla elde edilebilir. 
    Örneğin:

    >>> r = range(30, 60, 3)
    >>> len(r)
    10

#------------------------------------------------------------------------------------------------------------------------

r = range(10, 20)

result = len(r)
print(result)       # 10

#------------------------------------------------------------------------------------------------------------------------
    range nesnesinde belirtilen start, stop ve step değerleri sınıfın "start", "stop" ve "step" örnek öznitelikleri (instance attibutes)
    ile elde edilebilmektedir. Örneğin:

    >>> r = range(30, 60, 3)
    >>> r.start
    30
    >>> r.stop
    60
    >>> r.step
    3

#------------------------------------------------------------------------------------------------------------------------

r = range(10, 20, 3)

print(r.start, r.stop, r.step)      # 10 20 3

#------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------
    Anımsanacağı gibi "dolaşılabilir (iterable)" nesne her dolaşıldığında yeniden aynı değerleri verebilen nesnelerdi. 
    Oysa "dolaşım (iterator)" nesneleri bir kez dolaşıldığında biten, yani ikinci kez dolaşıldığında bittiği için artık 
    bir değer vermeyen nesnelerdir. Teknik olarak her dolaşım nesnesi dolaşılabilir bir nesne gibidir. Ancak dolaşım bitince 
    artık bir daha dolaşılsa da değer vermez. Özetle bir dolaşılabilir nesne dolaşıldığında bitiyorsa o nesneye özel olarak 
    "dolaşım (iterator)" nesnesi denilmektedir. 

    range nesnei "dolaşılabilir bir nesnedir, dolaşım nesnesi değildir"  . Dolayısıyla aynı range nesnesini her dolaştığımızda 
    aynı elemanlarını yeniden elde ederiz. Örneğin:

    >>> r = range(10)
    >>> a = list(r)
    >>> a
    [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
    >>> b = list(r)
    >>> b
    [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]

#------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------
    Bir değeri doğrudan fonksiyona argüman olarak vermekle önce onu bir değişkene atayıp değişkeni argüman olarak vermek arasında 
    işlevsel bir farklılk yoktur. Örneğin:

    r = range(10)
    a = list(r)

    Biz bu işlemi kısaca şöyle de yapabilirdik:

    a = list(range(10))

    Bu durumda yine bir range nesnesi yaratılacak ve o nesne (yani onun adresi) list fonksiyonuna geçirilecektir. Örneğin:

    a = list((1, 2, 3, 5))

    Burada da önce bir demet nesnesi yaratılacak o demet nesnesi list fonksiyonuna geçirilecektir. 
#------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------
    Matematikte farklı (distinct) elemanların oluşturduğu topluluğa küme (set) denilmektedir. Python'da da bu matematiksel anlamı
    destekleyecek biçimde bir küme veri yapısı bulunmaktadır. 

    Bir küme küme parantezleri içerisinde eleman listesi girilerek oluşturulmaktadır. Örneğin:

    >>> s = {'ali', 'ankara', 100, 3.4}
    >>> s
    {'ali', 'ankara', 3.4, 100}

    Kümeler set isimli sınıfla temsil edilmiştir. Kğme türünden bir değişkene type fonksiyonunu uyguladığımızda onun set 
    isimli bir sınıf türünden olduğunu görürüz. Örneğin:

    >>> type(s)
    <class 'set'>

#------------------------------------------------------------------------------------------------------------------------

s = {10, 'ali', 20, True, 30.2}

print(s, type(s))       # {True, 'ali', 20, 10, 30.2} <class 'set'>

#------------------------------------------------------------------------------------------------------------------------
    Kümelerde elemanlar arasında öncelik sonralık ilişkisi yoktur. Yani kümelerde bir sıra yoktur. (Matematikteki kümelerde de 
    bir sıra kavramı yktur). Dolayısıyla biz kümenin elemanlarına [...] operatörü ile erişemeyiz. Küme elemanlarını [...] operatörü ile 
    dilimleyemeyiz. Bir küme print fonksiyonu ile yazdırıldığında onun elemanlarının hangi sırada yazdırıldığının bir önemi yoktur. 
    Örneğin:

    >>> s = {'ali', 'ankara', 100, 3.4}
    >>> print(s)
    {'ali', 'ankara', 3.4, 100}
    >>> s
    {'ali', 'ankara', 3.4, 100}
    >>> s[1]
    Traceback (most recent call last):
    File "<stdin>", line 1, in <module>
    TypeError: 'set' object is not subscriptable

    Küme elemanlarında bir sıra olmadığı için küme elemanlarını yazdırdığımızdaki sıranın da bir önemi yoktur. Bir kümeyi 
    yazdırırken elemanların bizim girdiğimiz sırada yazdırılması gerekmemektedir. 
#------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------
    Kümelerde [...] operatörü kullanılmadığı için kümeler üzerinde dilimleme (slicing) işlemleri de yapılamamaktadır. Örneğin:

    >>> s = {'ali', 'veli', 'selami', 'ayşe', 'fatma'}
    >>> s[2:5]
    Traceback (most recent call last):
    File "<stdin>", line 1, in <module>
    TypeError: 'set' object is not subscriptable
#------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------
    Kümelerin eleman sayısı built-in len fonksiyonuyla elde edilebilmektedir. Örneğin:

    >>> s = {'ali', 'ankara', 'veli', 123}
    >>> len(s)
    4
#------------------------------------------------------------------------------------------------------------------------

s = {10, 'ali', 20, True, 30.2}

result = len(s)
print(result)           # 5

#------------------------------------------------------------------------------------------------------------------------
    Bir kümeye zaten onda var olan bir elemanı eklemeye çalışmak exception oluşturmaz. Eleman ekleneceği zaman elaman zaten varsa
    eklenmez. Dolayısıyla aşağıdaki küme oluşturma işlemi tamamen geçerlidir:

    a = {10, 20, 10, 30, 20}

    Burada 10 elemanı ve 20 elemanı olduğu halde yine küme parantezlerinin içerisinde bulunmaktadır. Bu durum bir exception oluşturmaz. 
    Örneğin:

    >>> s = {1, 2, 1, 1, 3, 4, 1, 5, 2, 3}
    >>> print(s)
    {1, 2, 3, 4, 5}

#------------------------------------------------------------------------------------------------------------------------

s = {10, 'ali', 20, 'ali', 10}

print(s)        # {10, 'ali', 20}

#------------------------------------------------------------------------------------------------------------------------
    Boş bir küme söz konusu olabilir. Ancak boş bir küme {} biçiminde oluşturulmaz. Buradaki {} ifadesi boş bir küme değil
    boş bir sözlük (dicitonary) oluşturmaktadır. Sözlükler konusu izleyen bölümde ele alınacaktır. 
    
    Sözlüklerle kğmeler benzer sentakslarla oluşturulmaktadır. Ancak sözlüklere kümelerden daha fazla gereksinim duyulmaktadır. 
    Bu nedenle boş küme parantezinin boş küme değil boş sözlük belirtmesinin daha anlamlı olduğu düşünülmüştür. Örneğin:

    >>> d = {}
    >>> type(d)
    <class 'dict'>

#------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------
    Kümeler set isimli sınıfla temsil edilmektedir. Boş bir küme set fonksiyonunun argümansız çağrılmasıyla oluşturulabilmektedir. 
    Örneğin:

    >>> s = set()
    >>> type(s)
    <class 'set'>
    >>> s
    set()
    >>> len(s)
    0

#------------------------------------------------------------------------------------------------------------------------

a = {}

print(a, type(a))       # {} <class 'dict'>

s = set()
print(s, type(s))       # set() <class 'set'>

#------------------------------------------------------------------------------------------------------------------------
    set fonksiyonu da tıpkı list ve tuple fonksiyonlarında olduğu gibi argüman olarak bizden dolaşılabilir bir nesne alıp 
    o nesneyi dolaşarak o değerlerden bir küme oluşturabilmektedir. Örneğin:

    >>> a = [1, 2, 1, 4, 8, 2, 5, 8, 1]
    >>> s = set(a)
    >>> s
    {1, 2, 4, 5, 8}

    Örneğin:

    >>> s = set('ankara')
    >>> s
    {'n', 'a', 'k', 'r'}

#------------------------------------------------------------------------------------------------------------------------

a = [10, 'ali', 'veli', 20]
s = set(a)

print(s)        # {10, 'ali', 20, 'veli'}

s = set(range(10))
print(s)        # {0, 1, 2, 3, 4, 5, 6, 7, 8, 9}

s = set('ankara')
print(s)        # {'r', 'k', 'a', 'n'}

#------------------------------------------------------------------------------------------------------------------------
    Kümeler yinelenenn elemanları atmak için iyi bir araç olabilmektedir.

    Aşağıdaki örnekte klavyeden girilen bir yazıdaki farklı karakterlerin sayısı yazdırılmaktadır.
#------------------------------------------------------------------------------------------------------------------------

s = input('Bir yazı giriniz:')

result = len(set(s))
print(result)

#------------------------------------------------------------------------------------------------------------------------
    Kümeler de "dolaşılabilir (iterable)" nesnelerdir. Bir kümeyi dolaştığımızda onun elemanlarını elde ederiz. Ancak elemanların
    hangi sırada elde edileceği hakkında bir belirleme yapılmamıştır. Yani biz kümeyi dolaştığımızda onun tüm elemanlarını elde ederiz 
    ancak sırası konusunda bir garanti verilmemektedir. Örneğin:

    >>> s = {'ali', 'ankara', 12, 5, 'istanbul'}
    >>> a = list(s)
    >>> a
    ['istanbul', 'ali', 5, 'ankara', 12]

#------------------------------------------------------------------------------------------------------------------------

s = {'ankara', 10, 20.5, False}
a = list(s)

print(a)        # listedeki sıra herhangi bir biçimde olabilir

#------------------------------------------------------------------------------------------------------------------------
    Bir elemanın küme içerisinde olup olmadığının belirlenmesi için yine "in" ve "not in" operatörleri kullanılmaktadır. 
    Genel olarak kümeler gibi veri yapıları arka planda "hash tabloları (hash tables)" ya da "ikili ağaçlarla (binary trees)" denilen 
    algoritmik veri yapılarıyla gerçekleştirilmektedir. Örneğin CPython yorumlayıcısında kümeler algoritmik olarak "hash tabloları" 
    ile gerçekleştirilmiştir. Bu veri yapıları özellikle algoritmik aramalarda en çok tercih edilen veri yapılarındandır. 
    Bu nedenle kümelerde "var mı yok mu" testi listeler ve demetlere göre çok daha hızlı yapılabilmektedir. Çok sayıda elemandan 
    oluşan toplulukta in ve not in operatörleriyle "var mı yok mu" testi yapacaksak listeleri ve demetleri değil kümeleri tercih 
    etmeliyiz. Az sayıda eleman için böyle bir hız farkı anlamlı değildir. Listeler ve demetlerde "var mı yok mu" testi ancak 
    "sıralı arama (sequential search)" denilen yöntemle yapılabilmektedir. Bunun ise zaman maliyeti yüksektir. 
#------------------------------------------------------------------------------------------------------------------------

s = {'ankara', 10, 20.5, False}

result = 10 in s
print(result)       # True

result = 10 not in s
print(result)       # False

#------------------------------------------------------------------------------------------------------------------------
    set nesnesindne hash tablosu oluşturabilmek için set elemanlarının "hashlenebilir (hashable)" olması gerekmektedir. 
    Temel türlerin hash'lenabilir olduğunu, demetlerin hash'lenebilir olduğunu ancak listelerin hash'lenebilir olmadığını 
    anımsayınız. Bu durumda bir liste bir kümenin elemanı yapılamamaktadır. Kümelerin kendisi de hash'lenebilir değildir. 
    Bu nedenle kümenin bir elemanı bir küme de olamaz. Eğer biz bir kümeye eleman olarak bir liste ya da küme verirsek bu durumda 
    exception (TypeError) oluşur. Örneğin:

    >>> s = {1, (2, 3), 'ankara', 12.3}
    >>> s
    {(2, 3), 1, 'ankara', 12.3}
    >>> k = {'ankara', [1, 2, 3], 'izmir'}
    Traceback (most recent call last):
    File "<stdin>", line 1, in <module>
    TypeError: unhashable type: 'list'
    >>> m = {'ali', 12, {'veli', 'selami'}}
    Traceback (most recent call last):
    File "<stdin>", line 1, in <module>
    TypeError: unhashable type: 'set'

#------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------
    Anımsanacağı gibi bir liste (ve küme) hiçbir zaman hash'lenebilir değildir. Ancak demetler "eğer onların elemanları 
    hash'lenebilir ise" hash'lenebilir. olmaktadır. Yani örneğin bir demetin elemanı bir liste ise artık demet hash'lenebilir  
    olmaz:

    >>> s = {1, (2, 3, [4, 5]), 6}
    Traceback (most recent call last):
    File "<stdin>", line 1, in <module>
    TypeError: unhashable type: 'list'

#------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------
    Python'da bool değerlerden hash değeri elde edilirken True için 1, False için 0 değeri elde edilmektedir. Örneğin:

    >>> hash(b)
    1
    >>> b = False
    >>> hash(b)
    0

    Dolayısıyla bool bir değer bir küme elemanı yapılırken bu hash değeri kullanılacağı için dikkat etmek gerekir. Örneğin:

    >>> s = {'ali', True}
    >>> s
    {True, 'ali'}
    >>> s = {1, 'ali', True}
    >>> s
    {1, 'ali'}

    Aynı durum float ve int nesneler için de benzer biçimde söz konusudur:

    >>> s = {1.0, 'ali', 1}
    >>> s
    {1.0, 'ali'}

    Aslında hash tablolarında aynı hash değerine ilişkin elemanlar tabloda bir arada bulunabilmektedir. Yukarıdaki problem aslında
    hash değeri ile karşılaştırma sırasında ortaya çıkmaktadır. Çünkü aşağıdaki karşılaştırmalar True değerini vermektedir:

    >>> 1 == True
    True
    >>> 1.0 == 1
    True

#------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------
    Kümeler değiştirilebilir türlerdir. Yani biz bir set nesnesi içerisindeki değeri kümeden çıkartabiliriz. Yeni bir değeri kümeye 
    ekleyebiliriz. 

    set sınıfının add isimli metodu tek bir elemanı kümeye eklemek için kullanılmaktadır. Örneğin :

    >>> s = {'ali', 'veli', 10, 20}
    >>> s.add('istanbul')
    >>> s
    {'istanbul', 'ali', 10, 20, 'veli'}

    Anımsanacağı gibi listelerde tek bir elemanın eklenmesi append isimli metotla yapılıyordu. "append" sözcüğü sona ekleme 
    anlamında listeler için daha uygun olabilir. Kümelerde "sona ekleme" diye bir kavram olmadığı için "append" ismi yerine
    "add" ismi tercih edilmiştir. 
#------------------------------------------------------------------------------------------------------------------------

s = {10, 20, 30, 40, 50}

s.add(60)
print(s)        # {50, 20, 40, 10, 60, 30}

s.add((100, 200, 300))

print(s)        # {50, 20, (100, 200, 300), 40, 10, 60, 30}

#------------------------------------------------------------------------------------------------------------------------
    Bir grup elemanı kümeye tek hamlede eklemek için update metodu kullanılmaktadır. (bu metodu mantıksal olarak listelerdeki extend 
    metoduna benzetebiliriz. Tabii extend sona ekleme yapmaktadır. Kümelerede sıra olmadığına göre update metodu sona eklemez.)
    update metodu "dolaşılabilir bir nesneyi parametre olarak alır. Nesneyi dolaşarak elde edilen değerleri kümeye ekler. 
    Örneğin:

    >>> s = {'ali', 10, 'veli', 'istanbul'}
    >>> s.update([30, 'izmir', 'selami'])
    >>> s
    {'istanbul', 'selami', 'ali', 10, 'izmir', 'veli', 30}
    >>> s.update('sakarya')
    >>> s
    {'istanbul', 's', 'selami', 'ali', 'r', 'y', 10, 'a', 'izmir', 'k', 'veli', 30}

#------------------------------------------------------------------------------------------------------------------------

s = {10, 20, 30, 40, 50}

print(s)        # {50, 20, 40, 10, 30}

s.update((100, 200, 300))

print(s)        # {50, 20, 100, 40, 10, 300, 30, 200}

s.update('ankara')

print(s)        # {200, 10, 'a', 'k', 20, 30, 'n', 100, 'r', 40, 300, 50}

#------------------------------------------------------------------------------------------------------------------------
    Tabii daha önceden de belirttiğimiz gibi zaten var olan bir elemanın yeniden kümeye eklenmeye çalışılması bir exception'a yol
    açmayacaktır. 
#------------------------------------------------------------------------------------------------------------------------

>>> s = {10, 20, 30}
>>> s.add(20)
>>> s
{10, 20, 30}

#------------------------------------------------------------------------------------------------------------------------
    Kümedeki bir elemanı silmek için remove metodu kullanılmaktadır. remove ile silinecek eleman listede yoksa exception (KeyError)
    oluşmaktadır. Örneğin:

    >>> s = {'ali', 10, 'veli', 20}
    >>> s.remove(10)
    >>> s
    {'veli', 20, 'ali'}
    >>> s.remove('sacit')
    Traceback (most recent call last):
    File "<stdin>", line 1, in <module>
    KeyError: 'sacit'
#------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------
    Kümelerden eleman silmek için discard isimli bir metot da bulunmaktadır. discard metodu silinmek istenen eleman yoksa 
    exception oluşturmaz. Sadece silme işlemini yapmaz. remove  metodundan tek farkı budur. Örneğin:

    >>> s = {10, 'ali', 20, 'veli'}
    >>> s.discard('veli')
    >>> s
    {'ali', 10, 20}
    >>> s.discard('can')
    >>> s
    {'ali', 10, 20}

#------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------
    set sınıfında eleman silme ile ilgili pop isimli bir metot da vardır. Ancak set sınıfının pop isimli metodu parametresizdir. 
    Bu metot her çağrıldığında kümeden gelişigüzel bir elemanı siler ve sildiği elemanı bize geri dönüş değeri olarak verir. 
    Ancak küme boşsa exception (KeyError) oluşmaktadır. Örneğin:

    >>> s = {'ali', 10, 'selami', 5}
    >>> s.pop()
    10
    >>> s.pop()
    'selami'
    >>> s
    {5, 'ali'}
    >>> s.pop()
    5
    >>> s
    {'ali'}
    >>> s.pop()
    'ali'
    >>> s
    set()
    >>> s.pop()
    Traceback (most recent call last):
    File "<stdin>", line 1, in <module>
    KeyError: 'pop from an empty set'

#------------------------------------------------------------------------------------------------------------------------

s = {10, 'ali', 20, 'veli'}

val = s.pop()
print(val)

val = s.pop()
print(val)

val = s.pop()
print(val)

val = s.pop()
print(val)

print(s)        # set()

#------------------------------------------------------------------------------------------------------------------------
    Kümelerde eleman silme işlemi listelere göre çok daha hızlı yapılmaktadır. Listelerde bir eleman silinmesi sırasında listenin 
    elemanlarının kaydırılması gerekmektedir. Halbuki kümelerde böyle bir kaydırma yapılmadan çok hızlı bir biçimde eleman 
    silinebilmektedir. Hash tablolarında eleman silme işlemi çok hızlı yapılmaktadır. 
#------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------
    set sınıfının clear metodu kümedeki tüm elemanları silmek için kullanılmaktadır. Metot parametreye sahip değildir. Örneğin:

    >>> s = set(range(10))
    >>> s
    {0, 1, 2, 3, 4, 5, 6, 7, 8, 9}
    >>> s.clear()
    >>> s
    set()

#------------------------------------------------------------------------------------------------------------------------

s = {10, 'ali', 20, 'veli'}

print(s)        # {10, 'ali', 20, 'veli'}

s.clear()

print(s)        # set()

#------------------------------------------------------------------------------------------------------------------------
    set sınıfının copy isimli metodu kümenin bir kopyasını oluşturmak için kullanılmaktadır. Tabii buradaki kopyalama da aslında 
    yine "sığ kopyalama (shallow copy)" biçiminde yapılmaktadır. Yani aslında küme elemanları da asıl nesnelerin adreslerini tutmaktadır.
    Dolayısıyla kopyalamada aslında adresler kopyalanmaktadır. Asıl nesneler kopyalanmamaktadır. Örneğin:

    >>> s = set(range(10))
    >>> s
    {0, 1, 2, 3, 4, 5, 6, 7, 8, 9}
    >>> s.clear()
    >>> s
    set()
    >>> s = set(range(10))
    >>> s
    {0, 1, 2, 3, 4, 5, 6, 7, 8, 9}
    >>> k = s.copy()
    >>> k
    {0, 1, 2, 3, 4, 5, 6, 7, 8, 9}
    >>> id(s)
    2567818069376
    >>> id(k)
    2567817420576

#------------------------------------------------------------------------------------------------------------------------

s = {10, 'ali', 20, 'veli'}    
k = s.copy()                    

print(s)            # {10, 'ali', 20, 'veli'}
print(k)            # {10, 'ali', 20, 'veli'}

s.add(100)

print(s)            # {100, 'ali', 10, 20, 'veli'}
print(k)            # {10, 'ali', 20, 'veli'}

#------------------------------------------------------------------------------------------------------------------------
    Biz bir set değişkenini başka bir değişkene atarsak iki farklı değişken aslında aynı nesneyi gösteriyor durumda olur.
    Bu durum bir kopyalama anlamına gelmemektedir. Örneğin:

    >>> s = set(range(10))
    >>> s
    {0, 1, 2, 3, 4, 5, 6, 7, 8, 9}
    >>> k = s
    >>> k
    {0, 1, 2, 3, 4, 5, 6, 7, 8, 9}
    >>> id(s)
    2567818070048
    >>> id(k)
    2567818070048
    >>> s.add(100)
    >>> s
    {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 100}
    >>> k
    {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 100}

#------------------------------------------------------------------------------------------------------------------------

s = {10, 'ali', 20, 'veli'}    
k = s                   

print(s, id(s))            # {'ali', 10, 20, 'veli'} 2594897135872
print(k, id(k))            # {'ali', 10, 20, 'veli'} 2594897135872

s.add(100)

print(s)            # {100, 'ali', 10, 20, 'veli'}
print(k)            # {100, 'ali', 10, 20, 'veli'}

#------------------------------------------------------------------------------------------------------------------------
                                            17. Ders - 06/06/2022-Pazartesi
#------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------
    İki kümenin ortak elemanlarının bulunması işlemine "kesişim (intersection)" denilmektedir. Kesişim işlemi set sınıfının intersection
    metoduyla ya da & operatörüyle yapılabilmektedir. a ve b iki küme olmak üzere:

    c = a.intersection(b)
    
    işlemi ile

    c = a & b

    işlemi aynı sonucu verecektir. Arada şöyle bir farklılık vardır: & operatöründe sağ taraftaki operand yalnızca set ya da ileride görecek olduğumuz
    frozenset türünden olmak zorundadır. Ancak intersection metodunun parametresi herhangi bir dolaşılabilir nesne olabilir. 
    Örneğin:

    >>> s = {'ali', 10, 'veli', 'eskişehir'}
    >>> k = {10, 'eskişehir', 'adana', 20}
    >>> result = s.intersection(k)
    >>> result
    {10, 'eskişehir'}
    >>> result = s.intersection(['ali', 'adana', 'eskişehir'])
    >>> result
    {'ali', 'eskişehir'}
    >>> result = s & k
    >>> result
    {10, 'eskişehir'}

#------------------------------------------------------------------------------------------------------------------------

a = {10, 'ali', 20, 'veli', 'selami', 30}
b = {30, 'veli', 'ayşe', 40, 20, 'fatma'}

c = a & b
print(c)        # {'veli', 20, 30}

c = a.intersection(b)
print(c)        # {'veli', 20, 30}

x = [10, 'ali', 100, 200, 'sibel']

c = a.intersection(x)       # parametre dolaşılabilir nesne olabilir
print(c)                    # {10, 'ali'}

#------------------------------------------------------------------------------------------------------------------------
    Aşağıdaki örnekte klavyeden (stdin dosyasından) iki sözcük okunmuştur. Bu iki sözcüğün ortak karakterleri ekrana yazdırılmıştır. 
#------------------------------------------------------------------------------------------------------------------------

word1 = input('Bir sözcük giriniz:')
word2 = input('Bir sözcük daha giriniz:')

s = set(word1)

result = s.intersection(word2)
print(result)

#------------------------------------------------------------------------------------------------------------------------
    Aslında intersection metodunda biz birden fazla dolaşılabilir nesnesyi de agüman olarak verebiliriz. Bu durumda sol 
    taraftaki nesneyle argüman olarak verilmiş dolaşılabilir nesnelerin kesişimleri bulunmaktadır. Örneğin:

    >>> s = {'ali', 'veli', 'selami', 'ayşe', 'fatma'}
    >>> k = ['ali', 'fatma', 'hüseyin', 'ayşe']
    >>> m = ['ayşe', 'ali', 'fatma', 'can']
    >>> result = s.intersection(k, m)
    >>> result
    {'ali', 'ayşe', 'fatma'}

    Biz aslında s.intersection(k, m) işlemiyle s, k ve m'nin kesişimlerini bulmuş olduk. Yani yapmaya çalıştığımız şey
    s & k & m ile aynıdır. 
#------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------
    İki kümenin birleşimi '|' operatörü ile ya da set sınıfının union metodu ile elde edilebilmektedir. Burada da yine '|'
    operatörünün sağ tarafındaki operand set ya da frozenset türünden olabilir. Ancak union metodunun parametresi herhangi bir dolaşılabilir
    nesne olabilir. Yine union metoduna birden fazla dolaşılabilir nesneyi argüman olarak verebiliriz. Örneğin:

    >>> s = {'ali', 'veli', 'selami', 'ayşe', 'fatma'}
    >>> k = {'ali', 'can', 'veli', 'hüseyin', 'sibel'}
    >>> result = s.union(k)
    >>> result
    {'veli', 'fatma', 'sibel', 'can', 'ayşe', 'ali', 'hüseyin', 'selami'}
    >>> result = s | k
    >>> result
    {'veli', 'fatma', 'sibel', 'can', 'ayşe', 'ali', 'hüseyin', 'selami'}
    >>> result = s.union(['kaan', 'ali', 'sacit'])
    >>> result
    {'veli', 'kaan', 'ayşe', 'fatma', 'ali', 'selami', 'sacit'}
    >>> result = s.union(['kaan', 'ali', 'sacit'], ['umut', 'şükran'])
    >>> result
    {'veli', 'şükran', 'fatma', 'kaan', 'ali', 'sacit', 'umut', 'ayşe', 'selami'}

#------------------------------------------------------------------------------------------------------------------------

a = {10, 'ali', 20, 'veli', 'selami', 30}
b = {30, 'veli', 'ayşe', 40, 20, 'fatma'}

c = a | b
print(c)                    # {'ayşe', 'veli', 40, 10, 'selami', 20, 'fatma', 30, 'ali'}

c = a.union(b)
print(c)                    # {'ayşe', 'veli', 40, 10, 'selami', 20, 'fatma', 30, 'ali'}

x = [10, 'ali', 100, 200, 'sibel']

c = a.union(x)              # parametre dolaşılabilir nesne olabilir
print(c)                    # {200, 10, 20, 'sibel', 'ali', 30, 'veli', 100, 'selami'}

c = a.union('ankara')
print(c)                    # {'k', 10, 20, 'a', 'ali', 30, 'n', 'veli', 'r', 'selami'}

#------------------------------------------------------------------------------------------------------------------------
    İki kümenin farkı '-' operatörü ile ya da difference metodu ile elde edilebilir. Yine diğerlerinde olduğu gibi '-' operatörünün
    sağ tarafındaki operand set ya da frozenset türünden olmak zorundadır. Ancak difference metodunun parametresi herhangi bir dolaşılabilir
    nesne türünden olabilir.  Örneğin:

    >>> s = {'ali', 'veli', 'selami', 'ayşe', 'fatma'}
    >>> s
    {'veli', 'ayşe', 'fatma', 'ali', 'selami'}
    >>> k = {'ali', 'sacit', 'fatma', 'hüseyin', 'bora'}
    >>> k
    {'fatma', 'bora', 'ali', 'hüseyin', 'sacit'}
    >>> result = s - k
    >>> s
    {'veli', 'ayşe', 'fatma', 'ali', 'selami'}
    >>> result = s.difference(k)
    >>> result
    {'veli', 'ayşe', 'selami'}

    Yine difference metodunda birdne fazla dolaşılabilir nesne argüman olarak verilebilir. 
#------------------------------------------------------------------------------------------------------------------------

a = {10, 'ali', 20, 'veli', 'selami', 30}
b = {30, 'veli', 'ayşe', 40, 20, 'fatma'}

c = a - b
print(c)            # {'selami', 10, 'ali'}

c = a.difference(b)
print(c)            # {'selami', 10, 'ali'}

x = [10, 'ali', 'selami']
c = a.difference(x)

print(c)            # {'veli', 20, 30}

#------------------------------------------------------------------------------------------------------------------------
    İki kümenin ortak olmayan elemanlarının elde edilmesine "exor" işlemi denilmektedir. Exor işlemi '^' operatörü ile ya da 
    symmetric_diffrence isimli metotla yapılmaktadır. Yine '^' operatörünün sağ tafındaki operand set ya da frozenset türünden 
    olabilir. Ancak symmetric_difference metodunun parametresi herhangi bir dolaşılabilir nesne türünden olabilmektedir. 
    Örneğin:

    >>> s = {'ali', 'veli', 'selami', 'ayşe', 'fatma'}
    >>> s
    {'veli', 'ayşe', 'fatma', 'ali', 'selami'}
    >>> k = {'hüseyin', 'ali', 'sacit', 'selami'}
    >>> k
    {'ali', 'hüseyin', 'selami', 'sacit'}
    >>> result = s ^ k
    >>> result
    {'veli', 'fatma', 'sacit', 'ayşe', 'hüseyin'}
    >>> result = s.symmetric_difference(['ali', 'jale', 'mahmut'])
    >>> result
    {'veli', 'fatma', 'jale', 'mahmut', 'ayşe', 'selami'}

symmetric_difference metodunda argüman olarak tek bir dolaşılabilir nesne verilebilmektedir. 

#------------------------------------------------------------------------------------------------------------------------

a = {10, 'ali', 20, 'veli', 'selami', 30}
b = {30, 'veli', 'ayşe', 40, 20, 'fatma'}

c = a ^ b
print(c)        # {'ayşe', 40, 10, 'selami', 'fatma', 'ali'}

c = a.symmetric_difference(b)
print(c)        # {'ayşe', 40, 10, 'selami', 'fatma', 'ali'}

x = 'ali', 10, 20, 'ayşe'

c = a.symmetric_difference(x)
print(c)        # {'ayşe', 'veli', 'selami', 30}

#------------------------------------------------------------------------------------------------------------------------
    Yukarıda görmüş olduğumuz temel küme işlemlerinin update'li versyonları da vardır. Bunlar aşağıda listelenmiştir:

    a &= b ya da a.intersection_update(b)
    a |= b ya da a.update(b)
    a -= b ya da a.diffrence_update(b)
    a ^= b ya da a.symmetric_difference_update(b)

    Burada yine operatör versiyonlarının sağ tarafındaki operand set ya da frozenset türünden olmak zorundadır. Metot versiyonlarının parametreleri ise
    herhangi bir dolaşılabilir nesne olabilmektedir. Yine metotlu versiyonlarda symmmetric_difference_update dışındaki metotlara birden fazla 
    dolaşılabilir nesne argüman olarak verilebilmektedir. 

    Yukarıdaki işlemlerde sonuç başka bir nesne olarak elde edilmemektedir. Sonuç soldaki nesne değiştirilerek elde edilmektedir. 
    Yani bu işlemler sonucunda yeni bir nesne yaratılmamaktadır. Örneğin:

    >>> a = {10, 'ali', 20, 'veli', 'selami', 30}
    >>> b = {30, 'veli', 'ayşe', 40, 20, 'fatma'}
    >>> id(a)
    4373858784
    >>> id(b)
    4373859008
    >>> a &= b
    >>> a
    {'veli', 20, 30}
    >>> id(a)
    4373858784

    Burada aslında a |= b işlemi ile a.update(b) işlemi aynıdır. Bu nedenle union_update isimli bir metot yoktur. Onun yerine 
    update isimli metot vardır. Örneğin:

    c = a.intersection(b) 
       
    işleminde a ve b değişmemektedir. Bu işlemden yeni bir set nesnesi elde edilmektedir. Halbuki örneğin:

    a.intersection_update(b)

    Burada a nesnesi artık a ve b'nin kesişimlerinden oluşan bir kğme haline gelmektedir. Bu işlemden yeni bir 
    küme elde edilmemektedir. 
#------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------
    Bir a kümesinin tüm elemanları b kümesinde varsa "a kümesi b kümesinin bir alt kümesidir (subset)". Alt küme işleminin tersine
    "üst küme (superset)" denilmektedir. Öz alt küme (proper subset) kendisi dahil olmayan alt kümedir. Her küme kendisinin 
    bir alt kümesidir ancak öz alt kümesi değildir. Benzer biçimde her küme kendisinin bir üst kümesidir ancak öz üst kümesi değildir. 

    Bir kümenin diğer kümenin alt kümesi olup olmadığı "<=" operatörü ile ya da issubset operatörü ile belirlenir. Yine "<="
    operatöründe sağ taraftaki operand set ya da frozenset türünden olabilir. Ancak issubset metodunda parametre herhangi bir dolaşılabilir 
    sınıf türünden olabilir.  Benzer biçimde üst küme kontrolü de ">=" ya da issuperset metoduyla yapılabilmektedir. Benzer biçimde >= operatörünün
    sol tarafındaki ve sağ tarafındaki nesneler set ya da frozenset türünden olmak zorundadır. Ancak issuperset metodunun parametresi herhangi 
    bir dolaşılabilir nesne olabilir. 
        
    Öz alt küme için bir metot yoktur. Bu işlem '<' operatörü ile yapılır. Öz üst küme kontrolü için de bir metot yoktur. Bu işlem '>' operatörü ile yapılır.
    Örneğin:

    {'veli', 'ayşe', 'fatma', 'ali', 'selami'}
    >>> s = {'ali', 'veli', 'selami', 'ayşe', 'fatma'}
    >>> s
    {'veli', 'ayşe', 'fatma', 'ali', 'selami'}
    >>> k = {'ali', 'veli', 'selami'}
    >>> k
    {'ali', 'veli', 'selami'}
    >>> result = k < s
    >>> result
    True
    >>> result = s < s
    >>> result
    False
    >>> result = s <= s
    >>> result
    True

#------------------------------------------------------------------------------------------------------------------------

a = {10, 20, 30, 40, 50}
b = {10, 40}

result = b < a
print(result)           # True

result = a < a
print(result)           # False

result = a <= a
print(result)           # True

result = a > b
print(result)           # True

result = a.issubset(range(10, 100, 10))
print(result)           # True

#------------------------------------------------------------------------------------------------------------------------
    İki kümenin hiçbir ortak elemanı yoksa bu iki kümeye "ayrık kümeler (disjoint sets)" denilmektedir. Ayrıklık kontrolü
    set sınıfının isdisjoint metodu ile yapılmaktadır. Bu metodun parametresi herhangi bir dolaşılabilir nesne olabilir. 
    Disjoint işleminin bir operatör karşılığı yoktur. Tabii işlem s & k == set() biçiminde de yapılabilir. Örneğin:

    >>> s = {'ali', 'veli', 'selami', 'ayşe', 'fatma'}
    >>> k = {'hasan', 'hüseyin', 'kazım'}
    >>> s.isdisjoint(k)
    True

#------------------------------------------------------------------------------------------------------------------------

a = {10, 20, 30, 40, 50}
b = {100, 200}

result = a.isdisjoint(b)
print(result)       # True

#------------------------------------------------------------------------------------------------------------------------
    Python'da "seyrek kullanılan" set sınıfının değiştirilemez (immutable) biçimi olan "frozenset" isimli bir sınıf da vardır. 
    set sınıfı ile frozenset sınıfı arasındaki farklılıklar şunlardır:

    1) frozenset sınıfı değiştirilebilir olmadığı için onun add gibi, update gibi, intersection_update gibi, remove gibi
    metotları yoktur. Ancak değiştirme işlemi yapmayan metotları set sınıf ile aynıdır. 

    2) frozenset sınıfında &=, |=, ^= -= gibi operatörler soldaki nesne üzerinde işlem yapmazlar. Yeni nesne yaratırlar. Yani örneğin,
    a |= b işlemi tamamen a = a | b işlemi ile eşdeğerdir.

    3) frozenset elemanları eğer hash'lenebilir ise frozenset nesnesi de hash'lenebilir durumdadır. 
#------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------
    Bir frozenset nesnesi küme parantezleriyle yaratılamaz. Ancak frozenset sınıfının tür fonksiyonu olan frozenset fonksiyonu 
    ile yaratılabilir. Bu fonksiyon herhangi bir dolaşılabilir nesneyi parametre olarak alabilmektedir. Örneğin:

    >>> fs = frozenset(['ali', 'veli', 'selami', 'ayşe', 'fatma'])
    >>> fs
    frozenset({'veli', 'fatma', 'ayşe', 'ali', 'selami'})
#------------------------------------------------------------------------------------------------------------------------

fs = frozenset([1, 'ali', 'selami', 2])
print(fs)

print(len(fs))

#------------------------------------------------------------------------------------------------------------------------
    set ile frozenset nesneleri '|', '&', '-', '^' işlemlerine sokulabilmektedir. Bu durumda işlemin sonucu soldaki operandın 
    türüne bağlıdır. Eğer soldaki operand set türündense sonuç set türünden, frozenset türündense sonuç frozenset türünden
    olur. Tabii bunların metot karşılıklarında her zaman sonuç metodun çağrıldığı nesnenin türünden olmaktadır.  Başka bir deyişle 
    yukarıdaki operatör işlemlerinde sol taraftaki ya da sağ taraftaki operand set ya da frozenset olabilmektedir. Ancak işlemin sonucu 
    her zaman sol taraftaki operand türünden olur. Örneğin (sembolik biçimde yazıyoruz):

    set & frozenset => set
    frozenset & set => frozenset
    frozenset & frozenset => frozenset

    Örneğin:

    >>> fs = frozenset(['ali', 'veli', 'selami', 'ayşe', 'fatma'])
    >>> fs
    frozenset({'veli', 'fatma', 'ayşe', 'ali', 'selami'})
    >>> s = {'ali', 'sacit', 'veli'}
    >>> s
    {'ali', 'veli', 'sacit'}
    >>> result = fs & s
    >>> result
    frozenset({'ali', 'veli'})
    >>> result = s & fs
    >>> result
    {'ali', 'veli'}

#------------------------------------------------------------------------------------------------------------------------

fs = frozenset([1, 'ali', 'selami', 2])
s = {1, 'sibel', 10, 'veli'}

result = fs & s
print(result, type(result))     # frozenset({1}) <class 'frozenset'>

result = s & fs
print(result, type(result))     # {1} <class 'set'>

#------------------------------------------------------------------------------------------------------------------------
    Yukarıda da belirtildiği gibi frozenset sınıfında &=, |=, ^=, -= gibi işlemlerde bir update yapılmamaktadır. Örneğin:

    >>> fs = frozenset(['ali', 'veli', 'selami'])
    >>> fs
    frozenset({'ali', 'selami', 'veli'})
    >>> id(fs)
    1525529415904
    >>> s = {'ali', 'ayşe', 'veli'}
    >>> s
    {'ali', 'veli', 'ayşe'}
    >>> fs |= s
    >>> fs
    frozenset({'ayşe', 'ali', 'selami', 'veli'})
    >>> id(fs)
    1525529416800
    >>> id(s)
    1525529417024
    >>> s |= fs
    >>> s
    {'ayşe', 'ali', 'selami', 'veli'}
    >>> id(s)
    1525529417024

#------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------
    Kümenin bir elemanı küme olamaz. Çünkü kümler hash'lenebilir değildir. Ancak kümenin bir elemanı frozenset olabilir. 
    Çünkü frozenset hash'lenebilir biçimdedir. Örneğin:

    >>> s = {1, 2, {3, 4}, 5}
    Traceback (most recent call last):
    File "<stdin>", line 1, in <module>
    TypeError: unhashable type: 'set'
    >>> s = {1, 2, frozenset({3, 4}), 5}
    >>> s
    {frozenset({3, 4}), 1, 2, 5}

    Anımsanacağı gibi bir demetin elemanı bir liste olabiliyordu. Ancak bir frozenset'in elemanlarının hash'lenebilir 
    olması gerekmektedir. Örneğin:

    >>> fs = frozenset([[1, 2, 3], 4, 5])
    Traceback (most recent call last):
    File "<stdin>", line 1, in <module>
    TypeError: unhashable type: 'list'

#------------------------------------------------------------------------------------------------------------------------

s = {10, frozenset((20, 30)), 40}

print(s)        # {40, 10, frozenset({20, 30})}

#------------------------------------------------------------------------------------------------------------------------
    Sözlükler (dictionaries) "anahtar-değer" çiftlerini tutan, anahtar verildiğinde değerin hızlı bir biçimde bulunmasını sağlayan 
    veri yapılarıdır. Sözlükler hızlı aramayı mümkün hale getirmek için özel algoritmik yöntemlerden faydalanmaktadır. Programlama 
    dillerinde sözlükler "hash tabloları (hash tables)", "dengelenmiş ikili ağaçlar (balanced binary tree)", "sıralı diziler (sorted arrays)"
    biçiminde gerçekleştirilebilmektedir. CPython gerçekleştiriminde sözlükler "hash tabloları" yoluyla oluşturulmuştur.

    Sözlükler yine küme parantezleri kullanılarak yaratılırlar. Ancak küme parantezlerinin içerisi "anahtar: değer"  çiftleerinden 
    oluşturulmaktadır. Sözlük yaratma işleminin genel biçimi şöyledir:

    { anahtar: değer, anahtar: değer, anahtar: değer, ...}

    Burada sözlklerin küme partantezleri içerisinde anahtardan sonra ':' ile değer belirtilerek yaratıldığını görüyorsunuz.
    Örneğin:

    >>> d = {'ankara': 6, 'istanbul': 34, 'eskişehir': 26, 'izmir': 35, 'denizli': 20}
    >>> d
    {'ankara': 6, 'istanbul': 34, 'eskişehir': 26, 'izmir': 35, 'denizli': 20}

#------------------------------------------------------------------------------------------------------------------------

d = {'ali': 100, 'veli': 200, 'selami': 300, 'ayşe': 1000, 'fatma': 400}

print(d)         # {'ali': 100, 'veli': 200, 'selami': 300, 'ayşe': 1000, 'fatma': 400}
print(type(d))   # <class 'dict'>

#------------------------------------------------------------------------------------------------------------------------
    Sözlükler "dict" isimli sınıfla temsil edilmiştir. Örneğin:

    >>> d = {10: 'ali', 20: 'veli', 30: 'selami', 40: 'ayşe', 50: 'fatma'}
    >>> d
    {10: 'ali', 20: 'veli', 30: 'selami', 40: 'ayşe', 50: 'fatma'}
    >>> type(d)
    <class 'dict'>

    Bir sözlüğü print fonksiyonu ile yazdırdığımızda sözlüğün bütün elemanları anahtar-değer çiftleri biçiminde yazdırılmaktadır. 
    Örneğin:

    >>> print(d)
    {10: 'ali', 20: 'veli', 30: 'selami', 40: 'ayşe', 50: 'fatma'}

#------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------
    Sözlüklerde anahtarların hash'lenebilir olması gerekmektedir. Ancak değerler için böyle bir koşul yoktur. Dolayısıyla anahtarlar
    int, float, str gibi türlerden olabilir. Ancak liste ve küme olamaz. Demetlerin eğer elemanları hash'lenebilir ise hash'lenebilir 
    olduğunu anımsayınız. Benzer biçimde frozenset nesneleri de hash'lenebilir durumdadır. Örneğin:

    >>> d = {'eskişehir': ['mihalıççık', 'sivrihisar', 'seyitgazi'], 'istanbul': ['şişli', 'pendik', 'ataşehir'], 
            'izmir': ['konak', 'gaziemir', 'karşıyaka']}
    
    Burada d sözlüğünün anahtarları str türündendir. str türü de hash'lenebilir bir türdür. Ancak d sözlüğünün değerleri birer listedir. 
    Değerlerin hash'lenebilir olması gerekmez. Yani sözlüklerin değerleri herhangi bir türden olabilir. 

    Aşağıdaki örnekte sözlüğün anahtarının bir liste olamadığına dikkat ediniz. 

    >>> d = {[10, 20]: 100}
    Traceback (most recent call last):
    File "<stdin>", line 1, in <module>
    TypeError: unhashable type: 'list'
    
    Görüldüğü gibi biz sözüğün anahtarını hash'able olmayan bir türden yapmak istersek xception (TypeError) oluşmaktadır.

    Demetler hash'able olabildiği için sözlük anahtarı yapılabilmektedir. Örneğin:

    >>> d = {(10, 20): 100}
    >>> d
    {(10, 20): 100}

#------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------
    Sözlüklerde anahtarlar ve değerler herhangi bir türden olabilirler (anahtarlar hash'lenebilir olmak zorundadır). Anahtarların ve
    değerlerin aslında aynı sözlük içerisinde aynı türden olması gerekmemektedir. Örneğin:

    d = {'ali': 100, 200: 'veli', 20: 30.2}

    Bu sözlük geçerlidir. Ancak uygulamada anahtarların ve değerlerin tutarlı biçimde aynı türlerden olması fayda sağlamaktadır.
    Bazen bir anahtar verildiğinde birden fazla değerin elde edilmesi istenebilir. Bu durumda değer bir liste ya da demet gibi 
    veri yapısı olabilir. Örneğin:
    
    d = {'eskişehir': ['alpu', 'mihalıççık', 'seyitgazi'], 'ankara': ['keçiören', 'polatlı', 'çankaya'], 
        'izmir': ['konak', 'buca', 'karşıyaka']}

    Burada anahtarlar şehir isimlerinden değerler de onların ilçelerini belirten listelerden oluşmaktadır. Programcı bir şehrin
    ismini verdiğinde onun ilçelerini hızlı bir biçimde elde etmek istemiş olabilir.     
#------------------------------------------------------------------------------------------------------------------------

d = {'eskişehir': ['alpu', 'mihalıççık', 'seyitgazi'], 'ankara': ['keçiören', 'polatlı', 'çankaya'], 
     'izmir': ['konak', 'buca', 'karşıyaka']}

print(d)

#------------------------------------------------------------------------------------------------------------------------
    Sözlüklerin kendisi de hash'lenebilir değildir. Dolayısıyla bir sözlük başka bir sözlüğe anahtar yapılamaz. Ancak bir szölüğün 
    değeri bir sözlük olabilir. Örneğin:

    >>> d = {'içanadolu': {'eskişehir': 26, 'konya': 42, 'ankara': 6}, 'ege': {'izmir': 35, 'aydın': 9}, 'marmara': {'istanbul': 34, 'kocaeli': 41}}
    >>> d
    {'içanadolu': {'eskişehir': 26, 'konya': 42, 'ankara': 6}, 'ege': {'izmir': 35, 'aydın': 9}, 'marmara': {'istanbul': 34, 'kocaeli': 41}}

#------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------
    Listelerin, demetlerin, kümelerin ve sözlklerin elemanları sabit yerine değişken de olabilir. Python'da bu bağlamda 
    sabitle değişken arasında bir farklılık yoktur. Biz bir sabit oluşturduğumuzda zaten o sabit için önce bir nesne yaratılmakta sonra o nesnenin 
    adresi kullanılmaktadır. Bunun doğrudan yapılmasıyla dolaylı yapılması arasında bir farklılık yoktur. Örneğin:

    a = [10, 20, 30]

    Böyle bir liste nesnesi yaratıldığında listenin elemanları 10, 20 v3 30 değerlerinin tutulduğu int türden nesnelerin adreslerini 
    tutmaktadır. Bu işlemin aşağıdakinden bir farkı yktur:

    x = 10
    y = 20
    z = 30
    a = [x, y, z]

    Burada da liste elemanlarında yine 10, 20, 30 değerlerinin bulunduğu int türden nesnelerin adresleri tutulmaktadır. 

    x = 26
    d = {x: 'eskişehir'}

    Biz her ne kadar atama işlemini bir operatör gibi ele almış olsak da aslında Python'da atama işlemi bir operatör değil 
    deyim statüsündedir. Dolayısıyla aşağıdaki bir durum geçerli değildir:

    >>> a = [x = 10 + 20, 20]
    File "<stdin>", line 1
        a = [x = 10 + 20, 20]
            ^^^^^^^^^^^
    SyntaxError: invalid syntax. Maybe you meant '==' or ':=' instead of '='?

    Tabii walrus gerçekten atama işlemi yapıp değer üreten bir operatördür. Dolayısıyla aşağıdaki gibi bir durum geçerlidir:

    >>> a = [x := 10, 20]
    >>> a
    [10, 20]
    >>> x
    10

#------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------
    Yukarıda da belirtildiği gibi sözlükler dict isimli sınıfla temsil edilmiştir. dict sınıfının tür fonksiyonu olan dict fonksiyonu 
    ile de sözlük yaratabiliriz. Örneğin boş bir sözlük dict() biçiminde yaratılabilir:

    >>> d = dict()
    >>> d
    {}
        
    Boş küme parantezleri de boş sözlük yaratmak için kullanılabilmektedir. Örneğin:

    >>> d = {}
    >>> d
    {}

    Boş küme parantezlerinin boş bir küme yaratmadığına boş bir sözlük yarattığına dikkat ediniz. Boş bir kme yaratmak için 
    mecburen set() çağrısı kullanılmaktadır: 

    >>> s = set()
    >>> s
    set()

#------------------------------------------------------------------------------------------------------------------------

d = dict()
print(d)        # {}

d = {}
print(d)        # {}

#------------------------------------------------------------------------------------------------------------------------
    dict fonksiyonuna biz iki elemanlı dolaşılabilir nesnelerden oluşan dolaşılabilir bir nesneyi argüman olarak geçirirsek,
    dict fonksiyonu bu nesneyi dolaşır. Her dolaşımda iki elemanlı bir dolaşılabilir nesne elde eder. O iki elemanlı dolaşılabilir
    nesnenin ilk elemanı anahtar ikinci elemanı değer olacak biçimde bir sözlük nesnesi oluşturur. Örneğin:

    >>> a = [('ali', 10), ('veli', 20), ('selami', 30), ('ayşe', 40), ('fatma', 50)]
    >>> a
    [('ali', 10), ('veli', 20), ('selami', 30), ('ayşe', 40), ('fatma', 50)]
    >>> d = dict(a)
    >>> d
    {'ali': 10, 'veli': 20, 'selami': 30, 'ayşe': 40, 'fatma': 50}

    Burada a nesnesini dolaştığımızda biz iki elemanlı dolaşılabilir nesneler elde edilmektedir. İşte dict fonksiyonu bunlardan
    sözlük yapmaktadır. Bu örnekte listenin elemanları birer demettir. Ancak tabii bunun tersi de söz konusu olabilirdi. Örneğin:

    >>> a = (['ali', 10], ['veli', 20], ['selami', 30], ['ayşe', 40], ['fatma', 50])
    >>> a
    (['ali', 10], ['veli', 20], ['selami', 30], ['ayşe', 40], ['fatma', 50])
    >>> d = dict(a)
    >>> d
    {'ali': 10, 'veli': 20, 'selami': 30, 'ayşe': 40, 'fatma': 50}

    Ya da örneğin:

    >>> a = (('ali', 10), ('veli', 20), ('selami', 30), ('ayşe', 40), ('fatma', 50))
    >>> d = dict(a)
    >>> d
    {'ali': 10, 'veli': 20, 'selami': 30, 'ayşe': 40, 'fatma': 50}

    Örneğin:

    >>> a = (['ali', 10], ['veli', 20], ['selami', 30], ['ayşe', 40], ['fatma', 50], 'ak', 'tk', 'xy')
    >>> d = dict(a)
    >>> d
    {'ali': 10, 'veli': 20, 'selami': 30, 'ayşe': 40, 'fatma': 50, 'a': 'k', 't': 'k', 'x': 'y'}

    Dolaşılabilir nesnenin elemanlarının iki elemandan daha fazla eleman içeren dolaşılabilir nesne olması durumu geçerli değildir.
    Bu durumda exception (Valueerror) oluşmaktadır. Örneğin:

    >>> d = dict([('ali', 10), ('veli', 20, 30)])
    Traceback (most recent call last):
    File "<stdin>", line 1, in <module>
    ValueError: dictionary update sequence element #1 has length 3; 2 is required

#------------------------------------------------------------------------------------------------------------------------

a = [('ali', 10), ('veli', 20), ('selami', 30), ('ayşe', 40), ('fatma', 50)]

d = dict(a)
print(d)        # {'ali': 10, 'veli': 20, 'selami': 30, 'ayşe': 40, 'fatma': 50}


a = [['ali', 10], ['veli', 20], ['selami', 30], ['ayşe', 40], ['fatma', 50]]

d = dict(a)
print(d)        # {'ali': 10, 'veli': 20, 'selami': 30, 'ayşe': 40, 'fatma': 50}

a = (['ali', 10], ['veli', 20], ['selami', 30], ['ayşe', 40], ['fatma', 50])

d = dict(a)
print(d)        # {'ali': 10, 'veli': 20, 'selami': 30, 'ayşe': 40, 'fatma': 50}

s = ['ak', 'sa', 'mk', 're']

d = dict(s)
print(d)

#------------------------------------------------------------------------------------------------------------------------
                                                18. Ders - 08/06/2022-Çarşamba
#------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------
    dict fonksiyonunda "değişken=değer" biçiminde argümanlar girdiğimizde dict bize o değişkenlerin string halini anahtar, 
    '=' operatörünün sağındakini de değer yaparak bir sözlük nesnesi oluşturur. Örneğin:

    >>> d = dict(x=10, y=20, z=30)
    >>> d
    {'x': 10, 'y': 20, 'z': 30}
    >>> d = dict(eskişehir=26, istanbul=34, izmir=35)
    >>> d
    {'eskişehir': 26, 'istanbul': 34, 'izmir': 35}

    Bu biçimde sözlük nesnesi oluşturma işlemi seyrek olarak kullanılmaktadır. 

#------------------------------------------------------------------------------------------------------------------------

d = dict(ali=10, veli=20, selami=30, ayşe=40, fatma=50)

print(d)    # {'ali': 10, 'veli': 20, 'selami': 30, 'ayşe': 40, 'fatma': 50}

#------------------------------------------------------------------------------------------------------------------------
    Burada değişken ismi yerine başka bir şey getirilemez. Örneğin aşağıdaki geçerli değildir:

    d = dict('ali'= 10, 'veli'=20, 'selami'=30)         # geçersiz!
    d = dict(10='ali', 20='veli', 30='selami')          # geçersiz!

#------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------
    Bir sözlükte anahtarı verip değeri elde etmek için [...] operatörü kullanılır. Köşeli parantezin içerisine anahtar yazılır. 
    Operatör de bize o anahtarın değerini verir. [...] operatöründe verdiğimiz anahtar sözlükte yoksa exception (KeyError) oluşur.
    Örneğin:

    >>> d = {'ali': 10, 'veli': 20, 'selami': 30, 'ayşe': 40, 'fatma': 50}
    >>> d
    {'ali': 10, 'veli': 20, 'selami': 30, 'ayşe': 40, 'fatma': 50}
    >>> val = d['ayşe']
    >>> val
    40"
    >>> val = d['fatma']
    >>> val
    50
    >>> val = d['sacit']
    Traceback (most recent call last):
    File "<stdin>", line 1, in <module>
    KeyError: 'sacit'

#------------------------------------------------------------------------------------------------------------------------

d = {'ali': 10, 'veli': 20, 'selami': 30, 'ayşe': 40, 'fatma': 50}

print(d)

val = d['veli']
print(val)          # 20

val = d['fatma']
print(val)          # 50

#------------------------------------------------------------------------------------------------------------------------
    Tabii bir sözlükte anahtar ve değerlerin türleri hep aynı olmak zorunda değildir. Örneğin:

    >>> d = {'ali': 10, 20: 'veli', 1.5: 'selami'}
    >>> d
    {'ali': 10, 20: 'veli', 1.5: 'selami'}
    >>> d['ali']
    10
    >>> d[20]
    'veli'
    >>> d[1.5]
    'selami'

#------------------------------------------------------------------------------------------------------------------------

d = {10: 'ali', 'veli': 20, 30: False}

print(d)

val = d['veli']
print(val)              # 20

val = d[10]
print(val)              # ali

#------------------------------------------------------------------------------------------------------------------------
    dict sınıfının get isimli metodu da anahtar verildiğinde değerin alınması için kullanılır. Ancak get anahtar sözlükte yoksa 
    exception oluşturmaz. İkinci parametresiyle girdiğimiz değere geri döner. Bu ikinci parametre için argüman girmeyebiliriz. Bu durumda
    get anahtar bulunamazsa None değeri ile geri dönmektedir. Örneğin:

    >>> d = {'ali': 10, 'veli': 20, 'selami': 30, 'ayşe': 40, 'fatma': 50}
    >>> val = d.get('ayşe')
    >>> val
    40
    >>> val = d.get('sacit')
    >>> print(val)
    None
    >>> val = d.get('ayşe', 'bulunamadı')
    >>> val
    40
    >>> val = d.get('sacit', 'bulunamadı')
    >>> val
    'bulunamadı'
    >>> val = d.get('sacit', 0)
    >>> val
    0

#------------------------------------------------------------------------------------------------------------------------

d = {'ali': 10, 'veli': 20, 'selami': 30, 'ayşe': 40, 'fatma': 50}

print(d)

val = d.get('selami', 'anahtar bulunamadı')
print(val)                          # 30

val = d.get('sacit', 'anahtar bulunamadı')
print(val)                          # Not found

val = d.get('sacit')
print(val)                          # None

#------------------------------------------------------------------------------------------------------------------------
    Sözlüklerde "in" ve "not in" operatörleri belli bir anahtarın sözlükte olup olmadığını anlamak için kullanılabilir. 
    Sözlüklerde de tıpkı kümelerde olduğu gibi "in" ve "not in" operatörleri çok hızlı çalışmaktadır. Bu operatörler anahtarın 
    varlığını sorgulamaktadır, değerlerin değil. Örneğin:

    >>> d = {'ali': 10, 'veli': 20, 'selami': 30, 'ayşe': 40, 'fatma': 50}
    >>> d
    {'ali': 10, 'veli': 20, 'selami': 30, 'ayşe': 40, 'fatma': 50}
    >>> 'ayşe' in d
    True
    >>> 20 in d
    False
    >>> 20 not in d
    True

#------------------------------------------------------------------------------------------------------------------------

d = {'ali': 10, 'veli': 20, 'selami': 30, 'ayşe': 40, 'fatma': 50}

print(d)

result = 'selami' in d
print(result)                   # True

result = 'fehmi' not in d
print(result)                   # True

#------------------------------------------------------------------------------------------------------------------------
    Built-in len fonksiyonuna biz bir sözlük nesnesini verirsek fonksiyon bize sözlükte kaç tane anahtar-değer çifti olduğunu verir.
    Örneğin:

    >>> d = {'ali': 10, 'veli': 20, 'selami': 30, 'ayşe': 40, 'fatma': 50}
    >>> len(d)
    5
    >>> d = {}
    >>> len(d)
    0

#------------------------------------------------------------------------------------------------------------------------

d = {'ali': 10, 'veli': 20, 'selami': 30, 'ayşe': 40, 'fatma': 50}

result = len(d)
print(result)           # 5

d = {}

result = len(d)
print(result)

#------------------------------------------------------------------------------------------------------------------------
    Sözlükler de dolaşılabilir (iterable) nesnelerdir. Bir sözlük nesnesi dolaşıldığında yalnızca "anahtarlar" elde edilir. 
    Ancak bu anahtarların elde edilmesi Python 3.6'ya kadar herhangi bir sırada olabiliyordu. Ancak Python 3.6 ve sonrasında 
    artık sözlük nesneleri dolaşıldığında anahtarlar eklenme sırasıyla elde edilir hale getirildi. Yani mevcut Python süsümlerinde
    bir sözlük nesnesi dolaşıldığında her zaman anahtarlar sözlükteki sıraya göre elde edilmektedir. Bu durumun Python 3.6'da 
    garanti edilmediğine dikkat ediniz. Örneğin:

    >>> d = {'ali': 10, 'veli': 20, 'selami': 30, 'ayşe': 40, 'fatma': 50}
    >>>  a = list(d)
    File "<stdin>", line 1
        a = list(d)
    IndentationError: unexpected indent
    >>> a = list(d)
    >>> a
    ['ali', 'veli', 'selami', 'ayşe', 'fatma']

#------------------------------------------------------------------------------------------------------------------------

d = {'ali': 10, 'veli': 20, 'selami': 30, 'ayşe': 40, 'fatma': 50}

a = list(d)
print(a)            # ['ali', 'veli', 'selami', 'ayşe', 'fatma']

#------------------------------------------------------------------------------------------------------------------------
    Sözlükler değiştirilebilir türlerdir. Biz sözlüğe yeni bir anahtar-değer çifti ekleyebiliriz, sözlükten bir anahtar-değer çiftini 
    silebiliriz. Mevcut bir anahtarın değerini değiştirebiliriz. 

    Bir sözlükte anahtarlar "tektir (unique)". Ancak daha önce var olan bir anahtara ilişkin anahtar-değer çiftini sözlüğe eklemek 
    istersek bu durum herhangi bir soruna yol açmaz. Artık daha önceki anahtarın değeri değiştirilmiş olur. Örneğin:

    >>> d = {'ali': 10, 'veli': 20, 'selami': 30, 'ali': 40, 'selami': 50}
    >>> d
    {'ali': 40, 'veli': 20, 'selami': 50}

    Tabii sözlükteki bir anahtarın değiştirilmesi biçiminde bir işlem yoktur. Zaten bu işlem bir anahtar-değer çiftinin silinip yeni bir anahtar-değer
    çiftinin eklenmesi ile aynı anlamdadır. 

#------------------------------------------------------------------------------------------------------------------------

d = {'ali': 10, 'veli': 20, 'selami': 30, 'ayşe': 40, 'fatma': 50, 'ali': 100}

print(d)        # {'ali': 100, 'veli': 20, 'selami': 30, 'ayşe': 40, 'fatma': 50}

#------------------------------------------------------------------------------------------------------------------------
    Sözlüğe yeni bir anahtar değer çifti eklemenin en basit yolu köşeli parantezli atama yapmaktır. Yani:

    d[key] = value

    ataması sözlüğe yeni bir anahtar-değer çifti eklemektedir. Ancak burada eğer anahtar zaten varsa anahtarın değeri değiştirilir.
    Örneğin:

    >>> d = {'ali': 10, 'veli': 20, 'selami': 30, 'ayşe': 40, 'fatma': 50}
    >>> d
    {'ali': 10, 'veli': 20, 'selami': 30, 'ayşe': 40, 'fatma': 50}
    >>> d['sacit'] = 60
    >>> d
    {'ali': 10, 'veli': 20, 'selami': 30, 'ayşe': 40, 'fatma': 50, 'sacit': 60}
    >>> d['selami'] = 100
    >>> d
    {'ali': 10, 'veli': 20, 'selami': 100, 'ayşe': 40, 'fatma': 50, 'sacit': 60}

#------------------------------------------------------------------------------------------------------------------------

d = {'ali': 10, 'veli': 20, 'selami': 30, 'ayşe': 40, 'fatma': 50}

print(d)            # {'ali': 10, 'veli': 20, 'selami': 30, 'ayşe': 40, 'fatma': 50}

d['sacit'] = 60

print(d)            # {'ali': 10, 'veli': 20, 'selami': 30, 'ayşe': 40, 'fatma': 50, 'sacit': 60}

d['veli'] = 100
print(d)            # {'ali': 10, 'veli': 100, 'selami': 30, 'ayşe': 40, 'fatma': 50, 'sacit': 60}

#------------------------------------------------------------------------------------------------------------------------
    Bir sözlüğe tek hamlede birden fazla anahtar-değer çifti eklemek için update metodu kullanılmaktadır. update metodunun parametresinin
    dolaşılabilir bir nesne olması gerekir. Bu durumda bu nesne dolaşıldıkça iki elemanlı dolaşılabilir nesneler elde edilmelidir. 
    update metodu da onların birinci elemanlarını anahtar, ikinci elemanlarını değer yaparak bunları sözlüğe ekler. Yani update metodunun 
    parametresi dict fonksiyonundaki gibi olmalıdır. Tabii zaten anahtar sözlükte bulunuyorsa onun yine değeri değiştirilecektir. Örneğin:

    >>> d = {'ali': 10, 'veli': 20, 'selami': 30, 'ayşe': 40, 'fatma': 50}
    >>> d
    {'ali': 10, 'veli': 20, 'selami': 30, 'ayşe': 40, 'fatma': 50}
    >>> d.update([('sacit', 100), ('mehmet', 200), ('sibel', 300)])
    >>> d
    {'ali': 10, 'veli': 20, 'selami': 30, 'ayşe': 40, 'fatma': 50, 'sacit': 100, 'mehmet': 200, 'sibel': 300}

#------------------------------------------------------------------------------------------------------------------------

d = {'ali': 10, 'veli': 20, 'selami': 30, 'ayşe': 40, 'fatma': 50}

print(d)            # {'ali': 10, 'veli': 20, 'selami': 30, 'ayşe': 40, 'fatma': 50}

d.update([('sibel', 60), ('kazım', 70), ('hasan', 90)])

print(d)    # {'ali': 10, 'veli': 20, 'selami': 30, 'ayşe': 40, 'fatma': 50, 'sibel': 60, 'kazım': 70, 'hasan': 90}

#------------------------------------------------------------------------------------------------------------------------
    Yukarıda da belirttiğimiz gibi bir sözlük nesnesi dolaşıldığında anahtarlar her zaman Python'ın 3.6 ve sonrasında sözlüğe 
    eklenme sırası dikkate alınarak elde edilmektedir. Yani biz bir sözlüğe köşeli paramtezlerle ya da update metodu ile ekleme 
    yaptığımızda bu eklenenlerin anahtarları sözlük dolaşıldığında bizim eklediğimiz sırada elde edilecektir. Örneğin:

    >>> d = {'ali': 10, 'veli': 20, 'selami': 30, 'ayşe': 40, 'fatma': 50}
    >>> d['ahmet'] = 100
    >>> d.update([('sacit', 200), ('mehmet', 300), ('sibel', 400)])
    >>> a = list(d)
    >>> a
    ['ali', 'veli', 'selami', 'ayşe', 'fatma', 'ahmet', 'sacit', 'mehmet', 'sibel']
#------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------
    Bir sözlükten bir anahtar-değer çiftini silmek için pop isimli metot kullanılır. pop metodu bizden anahtarı alır. Anahtar-değer
    çiftini sözlükten siler. Ancak silinen değeri bize geri dönüş değeri olarak verir. pop metodu anahtarı bulamazsa ve tek argüman ile 
    çağrılmışsa exception (KeyError) oluşturmaktadır. Ancak pop iki argümanla da çağrılabilir. Bu durumda anahtar bulunamzsa 
    ikinci argümandaki değer geri döndürülmektedir. Örneğin:

    >>> d = {'ali': 10, 'veli': 20, 'selami': 30, 'ayşe': 40, 'fatma': 50}
    >>> d
    {'ali': 10, 'veli': 20, 'selami': 30, 'ayşe': 40, 'fatma': 50}
    >>> val = d.pop('selami')
    >>> val
    30
    >>> d
    {'ali': 10, 'veli': 20, 'ayşe': 40, 'fatma': 50}
    >>> val = d.pop('sibel')
    Traceback (most recent call last):
    File "<stdin>", line 1, in <module>
    KeyError: 'sibel'
    >>> val = d.pop('sibel', 'anahtar yok')
    >>> val
    'anahtar yok'

#------------------------------------------------------------------------------------------------------------------------

d = {'ali': 10, 'veli': 20, 'selami': 30, 'ayşe': 40, 'fatma': 50}

print(d)            # {'ali': 10, 'veli': 20, 'selami': 30, 'ayşe': 40, 'fatma': 50}

value = d.pop('ayşe')
print(value)            # 40

print(d)                # {'ali': 10, 'veli': 20, 'selami': 30, 'fatma': 50}

value = d.pop('sacit', 'anahtar yok')
print(value)            # anahtar yok

#------------------------------------------------------------------------------------------------------------------------
    Bir sözlüğün tüm anahtarlarını keys isimli metotla, tüm değerlerini values isimli metotla elde edebiliriz. Bu metotlar bize 
    dolaşılabilir nesne verir. O nesne dolaşıldığında anahtarlar ve değerler elde edilecektir. Örneğin:

    >>> d = {'ali': 10, 'veli': 20, 'selami': 30, 'ayşe': 40, 'fatma': 50}
    >>> d
    {'ali': 10, 'veli': 20, 'selami': 30, 'ayşe': 40, 'fatma': 50}
    >>> a = list(d.keys())
    >>> a
    ['ali', 'veli', 'selami', 'ayşe', 'fatma']
    >>> b = list(d.values())
    >>> b
    [10, 20, 30, 40, 50]

    Yine keys metodu Python 3.6 ve sonrasında bize anahtarları onların listeye eklenme sırasına göre vermektedir. Benzer biçimde 
    yine Python 3.6 ve sonrasında values metodu da bize değerleri anahtarların eklenme sırasına göre vermektedir. Ancak Python'un 
    önceki sürümleri bunu garanti etmemektedir. 

    Burada keys metodunun aslında çok da gerekmediği ancak values metodunun gerektiği gibi bir sonuç çıkartabilirsiniz. Çünkü zaten
    biz sözlük nesnesini dolaştığımızda onunanahtarlarını elde edebiliyorduk.
#------------------------------------------------------------------------------------------------------------------------

d = {10: 'ali', 20: 'veli', 30: 'selami', 40: 'ayşe', 50: 'fatma'}

result = d.keys()
a = list(result)        
print(a)                # [10, 20, 30, 40, 50]

result = d.values()
a = list(result)        
print(a)                # ['ali', 'veli', 'selami', 'ayşe', 'fatma']

#------------------------------------------------------------------------------------------------------------------------
    Python'da çeşitli konularda karşımıza "view" nesnesi kavramı çıkabilmektedir. View nesnesi ana bir nesnenin bir bölümünü
    ya da tamamını temsil eden bir nesnedir. Ancak ana nesne üzerinde değişiklik yapıldığında bu view nesnesi bu değişikliği görür. 
    Bazı view nesneleri read only, bazıları read/write olabilmektedir. Eğer bir view nesnesi read/write biçimdeyse o view nesnesi 
    üzerinde değişiklilkler yapıldığında bundan ana nesne etkilenecektir. 
#------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------
    keys ve values metotlarının bize verdiği dolaşılabilir nesneler "view" nesneleridir. Örneğin:

    >>> d = {10: 'ali', 20: 'veli', 30: 'selami', 40: 'ayşe', 50: 'fatma'}
    >>> d
    {10: 'ali', 20: 'veli', 30: 'selami', 40: 'ayşe', 50: 'fatma'}
    >>> result = d.keys()
    >>> a = list(result)
    >>> a
    [10, 20, 30, 40, 50]
    >>> d[60] = 'sacit'
    >>> d
    {10: 'ali', 20: 'veli', 30: 'selami', 40: 'ayşe', 50: 'fatma', 60: 'sacit'}
    >>> a = list(result)
    >>> a
    [10, 20, 30, 40, 50, 60]

    Burada biz keys() metodunu çağırarak view nesnesini elde ettik. Daha sonra sözlüğe eleman ekledik. Sonra bu view nesnesini 
    dolaştığımızda elemanın ekli olduğunu gördük. 
#------------------------------------------------------------------------------------------------------------------------

d = {10: 'ali', 20: 'veli', 30: 'selami', 40: 'ayşe', 50: 'fatma'}

keys = d.keys()
a = list(keys)        
print(a)                # [10, 20, 30, 40, 50]

values = d.values()
a = list(values)
print(a)                # ['ali', 'veli', 'selami', 'ayşe', 'fatma']

d[60] = 'nurettin'

a = list(keys)        
print(a)                # [10, 20, 30, 40, 50, 60]

a = list(values)        
print(a)                # ['ali', 'veli', 'selami', 'ayşe', 'fatma', 'nurettin']

#------------------------------------------------------------------------------------------------------------------------
    dict sınıfının items isimli metodu dolaşılabilir bir view nesnesi verir. Bu nesne dolaşıldığında anahtar-değer çiftleri 
    iki elemanlı demetler biçiminde elde edilmektedir. Örneğin:

    >>> d = {10: 'ali', 20: 'veli', 30: 'selami', 40: 'ayşe', 50: 'fatma'}
    >>> d
    {10: 'ali', 20: 'veli', 30: 'selami', 40: 'ayşe', 50: 'fatma'}
    >>> items = d.items()
    >>> items
    dict_items([(10, 'ali'), (20, 'veli'), (30, 'selami'), (40, 'ayşe'), (50, 'fatma')])
    >>> a = list(items)
    >>> a
    [(10, 'ali'), (20, 'veli'), (30, 'selami'), (40, 'ayşe'), (50, 'fatma')]
    >>> t = tuple(items)
    >>> t
    ((10, 'ali'), (20, 'veli'), (30, 'selami'), (40, 'ayşe'), (50, 'fatma'))
    >>> s = set(items)
    >>> s
    {(30, 'selami'), (40, 'ayşe'), (20, 'veli'), (50, 'fatma'), (10, 'ali')}
    >>> d[60] = 'sacit'
    >>> d
    {10: 'ali', 20: 'veli', 30: 'selami', 40: 'ayşe', 50: 'fatma', 60: 'sacit'}
    >>> a = list(items)
    >>> a
    [(10, 'ali'), (20, 'veli'), (30, 'selami'), (40, 'ayşe'), (50, 'fatma'), (60, 'sacit')]

    Yine Python 3.6'ya kadar items metodundan elde edilen dolaşılabilir nesne dolaşıldığında elemanların hangi sırada elde 
    edileceğinin bir garantisi yoktu. Ancak Python 3.6 ile birlikte artık dolaşımdan elde edilen değerler onların sözlüğe eklenme
    sırasına göre olmaktdır.
#------------------------------------------------------------------------------------------------------------------------

d = {10: 'ali', 20: 'veli', 30: 'selami', 40: 'ayşe', 50: 'fatma'}

result = d.items()

a = list(result)
print(a)        # [(10, 'ali'), (20, 'veli'), (30, 'selami'), (40, 'ayşe'), (50, 'fatma')]

d[60] = 'sacit'

a = list(result)
print(a)        # [(10, 'ali'), (20, 'veli'), (30, 'selami'), (40, 'ayşe'), (50, 'fatma'), (60, 'sacit')]

#------------------------------------------------------------------------------------------------------------------------
    dict sınıfının clear isimli metodu sözlük içerisindeki anahtar-değer çiftlerinin hepsini siler. Örneğin:

    >>> d = {10: 'ali', 20: 'veli', 30: 'selami', 40: 'ayşe', 50: 'fatma'}
    >>> id(d)
    2500835703104
    >>> d.clear()
    >>> d
    {}
    >>> id(d)
    2500835703104

#------------------------------------------------------------------------------------------------------------------------

d = {10: 'ali', 20: 'veli', 30: 'selami', 40: 'ayşe', 50: 'fatma'}

print(d, id(d))        # {10: 'ali', 20: 'veli', 30: 'selami', 40: 'ayşe', 50: 'fatma'} 2449660834816

d.clear()

print(d, id(d))        # {} 2449660834816

#------------------------------------------------------------------------------------------------------------------------
    dict sınıfının copy isimli metodu sözlüğün bir kopyasını bize verir. Tabii kopya çıkartma işlemi yine "sığ kopyalama (shallow copy)"
    biçiminde yapılmaktadır. Örneğin:

    >>> d = {10: 'ali', 20: 'veli', 30: 'selami', 40: 'ayşe', 50: 'fatma'}
    >>> id(d)
    2500835703104
    >>> d.clear()
    >>> d
    {}
    >>> id(d)
    2500835703104
    >>> d = {10: 'ali', 20: 'veli', 30: 'selami', 40: 'ayşe', 50: 'fatma'}
    >>> id(d)
    2500835738496
    >>> k = d.copy()
    >>> k
    {10: 'ali', 20: 'veli', 30: 'selami', 40: 'ayşe', 50: 'fatma'}
    >>> id(k)
    2500835703104
    >>> id(d[10])
    2500835729264
    >>> id(k[10])
    2500835729264

    Burada copy metodu ile çıkartılan kopya farklı bir sçzlük nesnesidir. Ancak iki sözlük nesnesindeki değerlerin (ve anahtarlarınd da)
    aynı olduğu görülmektedir. 
#------------------------------------------------------------------------------------------------------------------------

d = {10: 'ali', 20: 'veli', 30: 'selami', 40: 'ayşe', 50: 'fatma'}

k = d.copy()

print(d, id(d))        
print(k, id(k))        

#------------------------------------------------------------------------------------------------------------------------
    Daha önce sözlükten anahtarı verip değer elde etmenin iki yolunu görmüştük: [...] operatörü ve get metodu. Aslında bu iş için 
    üçüncü bir metot daha vardır. O da setdefault isimli metottur. setdefault metodu bize her zaman anahtarın değerini verir. Eğer anahtarı bulamazsa
    setdefault o anahtarı bizim verdiğimiz değerler sözlüğe ekler eklediği anahtarın değerini bize verir. Yani setdefault anahtarı bulnazsa 
    ikinci parametresiyle belirtilen değerle anahtarı eklemekteve bu değeri bize vermektedir. Metotta ikinci parametre için argüman 
    girilmeyebilir. Eğer ikinci argüman girilmezse ve setdefault anahtarı bulamazsa anahtar için değer olarak sözlüğe None eklemektedir. 
    setdefault anahtarı bulursa ikinci argümanı hiç kullanmaz. Bu ikinci argüman "eğer anahtar bulamazsa" kullanılmaktadır.
    Örneğin:

    >>> d = {10: 'ali', 20: 'veli', 30: 'selami', 40: 'ayşe', 50: 'fatma'}
    >>> d
    {10: 'ali', 20: 'veli', 30: 'selami', 40: 'ayşe', 50: 'fatma'}
    >>> val = d.setdefault(20, 'kaya')
    >>> val
    'veli'
    >>> val = d.setdefault(60, 'kaya')
    >>> val
    'kaya'
    >>> d
    {10: 'ali', 20: 'veli', 30: 'selami', 40: 'ayşe', 50: 'fatma', 60: 'kaya'}
    >>> val = d.setdefault(30)
    >>> val
    'selami'
    >>> val = d.setdefault(70)
    >>> print(val)
    None
    >>> d
    {10: 'ali', 20: 'veli', 30: 'selami', 40: 'ayşe', 50: 'fatma', 60: 'kaya', 70: None}

#------------------------------------------------------------------------------------------------------------------------

d = {10: 'ali', 20: 'veli', 30: 'selami', 40: 'ayşe', 50: 'fatma'}

val = d.setdefault(20)
print(val)                  # veli

result = d.setdefault(60, 'sacit')
print(result)           # sacit

print(d)            # {10: 'ali', 20: 'veli', 30: 'selami', 40: 'ayşe', 50: 'fatma', 60: 'sacit'}

#------------------------------------------------------------------------------------------------------------------------
    Biz daha önce sözlükten pop metodu ile anahtar-değer çiftini silmiştik. Ancak del deyimi ile de sözlükten bir anahtar-değer 
    çiftini silebiliriz. Bunu sağlamak için del deyiminde anahtar yine köşeli parantez içerisinde verilir. Örneğin:

    del d[10]

    Burada del deyimi d sözlüğündeki 10 anahtarını ve o anahtara karşı gelen değeri sözlükten silecektir. Ancak anahtar sözlükte yoksa
    del deyimi exception (KeyError) oluşturmaktadır. Örneğin:

    >>> d = {10: 'ali', 20: 'veli', 30: 'selami', 40: 'ayşe', 50: 'fatma'}
    >>> d
    {10: 'ali', 20: 'veli', 30: 'selami', 40: 'ayşe', 50: 'fatma'}
    >>> del d[40]
    >>> d
    {10: 'ali', 20: 'veli', 30: 'selami', 50: 'fatma'}
    >>> del d[100]
    Traceback (most recent call last):
    File "<stdin>", line 1, in <module>
    KeyError: 100

#------------------------------------------------------------------------------------------------------------------------

d = {10: 'ali', 20: 'veli', 30: 'selami', 40: 'ayşe', 50: 'fatma'}

del d[40]               

print(d)            # {10: 'ali', 20: 'veli', 30: 'selami', 50: 'fatma'}

#------------------------------------------------------------------------------------------------------------------------
    Anımsanacağı gibi string'ler Python'da str isimli bir sınıfla temsil edilmektedir. Yani biz string'leri tek tırnak, iki tırnak, 
    üç tek tırnak ya da üç çift tırnak ile yarattığımızda aslında str sınıfı türünden bir nesne yaratmış olmaktayız. Yine biz str 
    sınıfının "değiştirilemez (immutable)" bir sınıf olduğunu görmüştük. Biz string üzerinde onu yarattıktan sonra bir değişiklik 
    yapamamaktayız.
#------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------
    Tıpkı listeler gibi, demetler gibi string'ler de Python'da "sequence type" grubundadır. Yani adreta string'ler onları oluşturan 
    larakterden oluşan bir dizilim gibi düşünülebilir. 
    
    String'lerin de karakterlerine tıpkı listelerde ve demetlerde olduğu gibi [...] operatörü ile erişebiliriz. Örneğin:

    >>> s = 'ankara'
    >>> result = s[2]
    >>> result
    'k'
    >>> type(result)
    <class 'str'>
    
    Tabii Python'da Java, C# gibi bazı dillerde olduğu gibi tek bir karakteri temsil eden bir tür yoktur. Dolayısıyla biz Python'da
    bir string'in belli bir indeksteki karakterini yine bir string olarak elde ederiz.

    String'ler değiştirilemez nesneler olduğu için biz bir string'in karakterlerini değiştiremeyiz. Örneğin:

    >>> s = 'ankara'
    >>> c = s[2]
    >>> c
    'k'
    >>> s[2] = 'x'
    Traceback (most recent call last):
    File "<stdin>", line 1, in <module>
    TypeError: 'str' object does not support item assignment
    
#------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------
    Bir stirng'in karakter uzunluğu built-in len fonksiyonu ile elde edilebilir. Örneğin:

    >>> s = 'ankara'
    >>> result = len(s)
    >>> result
    6
    >>> k = ''
    >>> result = len(k)
    >>> result
    0
#------------------------------------------------------------------------------------------------------------------------

s = 'ankara'

result = len(s)
print(result)           # 6

#------------------------------------------------------------------------------------------------------------------------
    Elemana erişimde yine negatif indeksler liste ve demetlerle aynı biçimde kullanılabilmektedir. Örneğin:

    >>> s = 'ankara'
    >>> s[-1]
    'a'
    >>> s[-2]
    'r'
    
    String'lerde dilimleme de  tamamen listelerde ve demetler olduğu gibi yapılabilmektedir. Tabii bir string dilimlendiğinde 
    dilimleme işlemi sonucunda yine bir string elde edilmektedir. Örneğin:

    >>> s = 'ankara'
    >>> s
    'ankara'
    >>> result = s[2:6]
    >>> result
    'kara'
    >>> result = s[1:3]
    >>> result
    'nk'
    >>> result = s[2:-2]
    >>> result
    'ka'

    Örneğin bir string'i ters çevirmek için yine aynı s[::-1] işlemini uygulayabiliriz:

    >>> s = 'ankara'
    >>> k = s[::-1]
    >>> s
    'ankara'
    >>> k
    'arakna'

#------------------------------------------------------------------------------------------------------------------------

s = 'ankara'

k = s[2:4]
print(k)            # ka

k = s[::-1]
print(k)            # arakna

k = s[-1]
print(k)            # a

#------------------------------------------------------------------------------------------------------------------------
    İki string '+' operatörü ile toplanabilir. Bu durumda yeni bir string nesnesi yaratılır. Bu yeni string nesnesi iki string'in
    birleştirilmesinden oluşur. Örneğin:

    >>> s = 'ankara'
    >>> k = 'izmir'
    >>> result = s + k
    >>> result
    'ankaraizmir'

    Java, C# gibi bazı dillerde bir string ile başka bir türden nesne toplanabilmektedir. Bu durumda o dillerde string olmayan tür 
    otomatik olarak string türüne dönüştürülüp string toplamı yapılmaktadır. Ancak Python'da bir özellik yoktur. Yani biz Python'da 
    örneğin bir string ile int bir değeri toplayamayız. (Halbuki bu işlem Java ve C# gibi bazı dillerde yapılabilmektedir.)
    Bu tür durumlarda bizim açıkta diğer operand'ı str türüne dönüştürmemiz gerekir. Örneğin:

    >>> a = 10
    >>> s = 'a = ' + a
    Traceback (most recent call last):
    File "<stdin>", line 1, in <module>
    TypeError: can only concatenate str (not "int") to str
    >>> s = 'a = ' + str(a)
    >>> s
    'a = 10'

#------------------------------------------------------------------------------------------------------------------------

a = 'ankara'
b = 'izmir'

c = a + b
print(c)        # ankaraizmir

#------------------------------------------------------------------------------------------------------------------------
    iki string toplandığında yeni bir string elde edilmektedir. Bu yeni string iki string'in uç uca eklenmesinden elde edilen yazıdan 
    oluşur. Ancak s += k gibi bir işlem mevcut s yazısının sonuna ekleme yapma anlamına gelmez. Çünkü string'ler değiştirilemez (immutable)
    nesnelerdir. Dolayısıyla s += k tamamen s = s + k anlamına gelir. Anımsanacağı gibi bu durum değiştirilemez olan demetlerde de 
    böyleydi. Ancak listeler değiştirilebilir olduğu için orada += işlemi sona ekleme anlamına geliyordu. Örneğin:

    >>> s = 'ali'
    >>> k = 'veli'
    >>> id(s)
    1986218231280
    >>> id(k)
    1986218230640
    >>> s += k
    >>> s
    'aliveli'
    >>> id(s)
    1986218223088

#------------------------------------------------------------------------------------------------------------------------

s = 'ankara'
k = 'izmir'

result = s + k
print(result)           # ankaraizmir

print(id(s))
s += k                  # s = s + k
print(id(s))
print(s)                # ankaraizmir

#------------------------------------------------------------------------------------------------------------------------
    Bir string tıpkı listelerde ve demetler olduğu gibi "yineleme (repitition)" işlemine sokulabilir. Bu durumda string n defa 
    kendisiyle toplanmaktadır. Yine yineleme işleminde "çarpılan değer" 0 ya da negatif bir değerse boş string elde edilmektedir. 
    Örneğin:

    >>> s = '*' * 20
    >>> s
    '********************'
    >>> s = 'ali' * 5
    >>> s
    'alialialialiali'
    >>> s = 'veli' * 0
    >>> s
    ''

#------------------------------------------------------------------------------------------------------------------------

s = '*' * 10

print(s)            # ********** 

s = 'ali' * 3
print(s)            # alialiali

#------------------------------------------------------------------------------------------------------------------------
    Aşağıdaki örnekte klavyeden bir yazı girilmektedir. Sonra o yazı üstte ve altta tireler olacak biçimde afiş gibi ekrana
    yazdırılmaktadır. 
#------------------------------------------------------------------------------------------------------------------------

s = input('Bir yazı giriniz:')

print('-' * len(s))
print(s)
print('-' * len(s))

#------------------------------------------------------------------------------------------------------------------------
    Şimdi de str sınıfının metotları üzerinde duracağız.  Ancak bu konuda bir noktaya dikkat çekmek istiyoruz. str sınıfının 
    "değiştirilemez" olduğunu yukarıda belirtmiştik. Bu durumda str sınıfının sanki yazıyı değiştirecekmiş gibi işlemler yapan 
    metotları aslında mevcut yazıyı değiştirmezler. Bize yeni bir yazı verirler. Zaten yaratılmış bir string nesnesi üzerinde 
    değişiklik yapmanın bir yolu yoktur. Biz aşağıda metotların sanki mevcut yazı üzerinde değişiklik yapıyormuş gibi bir 
    anlatım tarzı uygulayacağız. Aslında burada söylemek istediğimiz şey metodun değiştirilmiş yeni yazı ile geri döndüğüdür.
#------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------
    str sınıfının capitalize isimli metodu parametresizdir. Bu metot bize aynı yazıdan yalnızca ilk harfi büyük olan yeni bir 
    yazı oluşturup onu vermektedir. Örneğin:

    >>> s = 'list sınıfı'
    >>> k = s.capitalize()
    >>> k
    'List sınıfı'
    >>> s
    'list sınıfı'

#------------------------------------------------------------------------------------------------------------------------

s = 'bugün hava çok güzel'

k = s.capitalize()
print(k)            # Bugün hava çok güzel
print(s)            # bugün hava çok güzelçok güzel

#------------------------------------------------------------------------------------------------------------------------
    str sınıfının title isimli metodu yazının tüm sözcüklerinin ilk harfini büyük harf yapar (yani büyük harf yapılmış yazıyla 
    geri döner.) Bu metot da parametresizdir. Örneğin:

    >>> s = 'list sınıfı'
    >>> k = s.title()
    >>> k
    'List Sınıfı'

#------------------------------------------------------------------------------------------------------------------------

s = 'bugün hava çok güzel'

k = s.title()
print(k)            # Bugün Hava Çok Güzel

#------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------
                                                19. Ders - 13/06/2022-Pazartesi             
#------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------
    str sınıfının center isimli metodu bir yazıyı belli bir genişlikte ortalar. Metodun birinci parametresi geri döndürülecek yazının 
    uzunluğunu belirtir. Yani yazı bu uzunluktaki yazının içerisinde ortalanacaktır. Eğer metot tek argümanla çağrılırsa yazının iki tarafındaki 
    boş alan boşluk karakteriyle doldurulur. Ancak metot iki argümanla da çağrılabilir. Bu durumda ikinci argüman tek karakterli bir string
    olarak girilmek zorundadır. Bu ikinci argümanda belirtilen karakter iki tarafın doldurulacağı karakteri belirtir. Ancak eğer birinci
    parametre ile belirtilen uzunluktan yazının uzunluğu çıkarıldığında tek sayı kalıyorsa bu durumda fazlalığın ne tarafa verileceği
    konusunda "Python Standard Library Reference" içerisinde bir şey söylenmemiştir. Bu durum herhangi bir garantinin verilmediği 
    anlamına gelmektedir. Örneğin:

    >>> s = 'ankara'
    >>> k = s.center(20)
    >>> print(':' + k + ':')
    :       ankara       :
    >>> s = 'ali'
    >>> k = s.center(7)
    >>> print(':' + k + ':')
    :  ali  :
    >>> k = s.center(6)
    >>> print(':' + k + ':')
    : ali  :
    >>> k = s.center(20, '.')
    >>> print(':' + k + ':')
    :........ali.........:

#------------------------------------------------------------------------------------------------------------------------

s = 'ankara'

k = s.center(20);       
print(':' + k + ':')

k = s.center(20, 'x');  
print(':' + k + ':')                

k = s.center(11, 'x');
print(':' + k + ':')                

#------------------------------------------------------------------------------------------------------------------------
    str sınıfının find metodu bir yazı içerisinde bir yazıyı aramak ve yerini bulmak için kullanılmaktadır. Metot tek argümanla
    çağrılırsa arama baştan sona kadar yapılmaktadır. Eğer yazı bulunursa find metodu bize yazının "ilk bulunduğu yerin" asıl yazıdaki 
    indeks numarasıyla geri döner. Eğer yazı bulunamazsa find -1 değeri ile geri dönmektdir. Örneğin:

    >>> s = 'ankara'
    >>> result = s.find('k')
    >>> result
    2
    >>> result = s.find('ar')
    >>> result
    3
    >>> result = s.find('a')
    >>> result
    0
    >>> result = s.find('x')
    >>> result
    -1

#------------------------------------------------------------------------------------------------------------------------

s = 'bugün hava çok güzel, evet evet hava çok güzel'

index = s.find('hava')
print(index)            # 6

index = s.find('yarın')
print(index)            # -1

#------------------------------------------------------------------------------------------------------------------------
    find metodu iki argümanlı da çağrılabilir. Bu durumda arama ikinci argümanla belirtilen indeksten başlatılır.
#------------------------------------------------------------------------------------------------------------------------

s = 'bugün hava çok güzel, evet evet hava çok güzel'

index = s.find('hava', 10)
print(index)            # 32

#------------------------------------------------------------------------------------------------------------------------
    find metodu üç argümanlı da çağrılabilir. Bu durumda üçüncü argüman aramanın bitirileceği indeksi belirtir. Ancak bu indeks 
    aramaya dahil değildir. (Yani sanki önce dilimleme yapılıp bu dilimlemenin içerisinde find uygulanıyor gibi düşünebilirsiniz.)
#------------------------------------------------------------------------------------------------------------------------

s = 'bugün hava çok güzel, evet evet hava çok güzel'

index = s.find('z', 10, 20)
print(index)          # 17

#------------------------------------------------------------------------------------------------------------------------
    rfind isimli metot tamamen find metodu metodu gibidir. Ancak son bulunan yerin indeks numarasını verir. Başka bir deyişle 
    aramayı sondan başa doğru yapar. Yine metot iki ve üç argümanlı çağrılabilir. Argümanlar yine yazının başından itibaren indeks belirtir. 
    Yani bu duurmda ikinci ve üçüncü argümanlar sanki aranacak kısmın başını ve sonunu belirtiyor gibidir. (Yani sanki önce dilimleme
    yapılıp bu dilimlemenin içerisinde rfind uygulanıyor gibi düşünebilirsiniz.) Örneğin:

    >>> s = 'adıyaman'
    >>> pos = s.rfind('a', 1, 6)
    >>> pos
    4
    >>> pos = s.rfind('a', 1)
    >>> pos
    6
    >>> pos = s.rfind('a')
    >>> pos
    6

    Aşağıdaki örnekte Windows'tai bir yol ifadesinin hedefindeki dosya ismi elde edilmiştir. 
#------------------------------------------------------------------------------------------------------------------------

path = r'c:\windows\system\test.dll'

index = path.rfind('\\')
fname = path[index + 1:]

print(fname)        # test.dll

#------------------------------------------------------------------------------------------------------------------------
    Yukarıdaki programı girişi klavyeden isteyecek biçimde de değiştirebiliriz.
#------------------------------------------------------------------------------------------------------------------------

path = input('Bir yol ifadesi giriniz:')

index = path.rfind('\\')
fname = path[index + 1:]

print(fname)

#------------------------------------------------------------------------------------------------------------------------
    str sınıfının find metodu ile aynı işlemleri yapan index isimli bir metodu, rfind metodu ile ile aynı işlemleri yapan 
    rindex isimli bir metodu da vardır. Yine index ve rindex de tek argümanla, iki argümanla ya da üç argümanla çağrılabilmektedir. 
    Bu bakımdan bunların find metotlarından bir farkı yoktur. index ve rindex metotlarının find ve rfind metotlarından tek farkları
    başarısızlık durumunda exception index ve rindex metotlarının -1 ile geri dönmek yerine exception (ValueEroor) oluşturmasıdır. 
    Halbuki anımsanacağı üzere find ve rfind başarısızlık durumunda -1 değerine geri dönüyordu. Örneğin:

    >>> s = 'ankara'
    >>> pos = s.index('a')
    >>> pos
    0
    >>> pos = s.rindex('a')
    >>> pos
    5
    >>> pos = s.rindex('x')
    Traceback (most recent call last):
    File "<stdin>", line 1, in <module>
    ValueError: substring not found

#------------------------------------------------------------------------------------------------------------------------

s = 'bugün hava çok güzel'

result = s.index('çok')
print(result)                   # 11

result = s.rindex('a')
k = s[result:]
print(k)                        # a çok güzel

result = s.index('izmir')       # exception oluşur
print(result)

#------------------------------------------------------------------------------------------------------------------------
    count metodu belli bir karakterin ya da yazının asıl yazı içerisinde kaç tane olduğu bilgisini bize verir. Örneğin:

    >>> s = 'ankara'
    >>> result = s.count('a')
    >>> result
    3
    >>> s = 'bugün hava çok güzel, evet hava çok güzel'
    >>> result = s.count('hava')
    >>> result
    2

#------------------------------------------------------------------------------------------------------------------------

s = 'istanbul\'da iş buldum'

result = s.count('bul')
print(result)       # 2

#------------------------------------------------------------------------------------------------------------------------
    str sınıfının isxxx isimli bir grup metodu vardır. Bu metotlar yazının tüm karakterlerinin belirtilen koşulu sağlayıp sağlamadığına 
    bakmaktadır. Örneğin isalpha metodu yazının tüm karakterlerinin alfabetik karakter olup olmadığına bakar. Python 3'lü versüyonlardan 
    sonra tamamen UNICODE sisteme geçmiştir. Yani bu metotlar UNICODE tablodaki bütün dillerin harflerini bu testte dikkate alırlar. 
    Önemli isxxx metotları şunlardır:

    isalpha (alfabetik mi?)
    isupper (büyük harf mi?)
    islower (küçük harf mi?)
    isspace (boşuk karakterlerinden mi?)
    isalnum (alfanümerik karakter mi?)
    ...

    Örneğin:
    
    >>> s = 'ankara'
    >>> s.islower()
    True
    >>> s.isupper()
    False
    >>> s = '1234'
    >>> s.isdigit()
    True
    >>> s = 'ali Ankara'
    >>> s.islower()
    False
    >>> s = '1abc'
    >>> s.isidentifier()
    False
    >>> s = 'abc1'
    >>> s.isidentifier()
    True
    >>> s = '    \t    \n    '
    >>> s.isspace()
    True

#------------------------------------------------------------------------------------------------------------------------

s = 'ağrı-04'
k = 'AĞRIDağı'
m = '1293456789'
r = '             '

result = s.islower()
print(result)       # True

result = k.isupper()
print(result)       # False

result = m.isdigit()
print(result)       # True

result = k.isalpha()
print(result)       # True

result = r.isspace()
print(result)       # True

#------------------------------------------------------------------------------------------------------------------------
    str sınıfının join isimli metodu argüman olarak dolaşılabilir bir nesne alır. Ancak bu dolaşılabilir nesne dolaşıldıkça 
    string'ler elde edilmelidir. join metodu bu dolaşılabilir nesnenin elemanlarını aralarına metodun çağrılmasında belirtilen yazıyı
    ayraç yaparak bir yazı biçiminde birleştirir ve bize böyle bir yazı verir. Örneğin:

    >>> s = ', '
    >>> result = s.join(['ali', 'veli', 'selami'])
    >>> result
    'ali, veli, selami'
    >>> result = ', '.join(['ali', 'veli', 'selami'])
    >>> result
    'ali, veli, selami'
    >>> result = '\n'.join(['adana', 'adıyaman', 'afyon'])
    >>> result
    'adana\nadıyaman\nafyon'
    >>> print(result)
    adana
    adıyaman
    afyon
    >>> result = ''.join(['ali', 'veli', 'selami'])
    >>> result
    'aliveliselami'
    >>> result = '-'.join('ankara')
    >>> result
    'a-n-k-a-r-a'

#------------------------------------------------------------------------------------------------------------------------

names = ['ali', 'veli', 'selami', 'ayşe', 'fatma']
s = 'xxx'

k = s.join(names)
print(k)            # alixxxvelixxxselamixxxayşexxxfatma

s = ', '
k = s.join(names)
print(k)            # ali, veli, selami, ayşe, fatma

k = ' '.join(names)
print(k)            # ali veli selami ayşe fatma

k = ''.join(names)
print(k)            # aliveliselamiayşefatma

k = ' '.join('ankara')
print(k)            # a n k a r a

k = '\n'.join(names)
print(k)

"""
ali
veli
selami
ayşe
fatma
"""

#------------------------------------------------------------------------------------------------------------------------
    str sınıfının split metodu adeta join metodunun tersi gibidir. split yazının ayrıştırılacağı yazıyı parametre olarak alır. 
    Bu parametre yazıyı ayraç kabul ederek yazıyı parçalara ayırır ve bu parçalardan bir string listesi yapar bize o string listesini 
    verir. split parametresiz kullanılırsa tüm boşluk karakterlerini ayıraç kabul eder. Yani bir yazıyı tüm boşluklardan ayrıştırmak
    için split parametresiz kullanılabilir. Örneğin:

    >>> s = 'ali, veli, selami, ayşe, fatma'
    >>> result = s.split(', ')
    >>> result
    ['ali', 'veli', 'selami', 'ayşe', 'fatma']
    >>> result = s.split(',')
    >>> result
    ['ali', ' veli', ' selami', ' ayşe', ' fatma']
    >>> result = s.split(' ')
    >>> result
    ['ali,', 'veli,', 'selami,', 'ayşe,', 'fatma']
    >>> result = s.split('xxx')
    >>> result
    ['ali, veli, selami, ayşe, fatma']
    >>> s = 'ali,,,veli,,,selami'
    >>> result = s.split(',')
    >>> result
    ['ali', '', '', 'veli', '', '', 'selami']
    >>> s = 'ali     veli   \n\n\t \t    selami \t   '
    >>> result = s.split()
    >>> result
    ['ali', 'veli', 'selami']
    >>>

    join ile split metotlarının adresta ters işlemler yaptıklarına dikkat ediniz:

    >>> names = ['ali', 'veli', 'selami', 'ayşe', 'fatma']
    >>> result = ', '.join(names).split(', ')
    >>> result
    ['ali', 'veli', 'selami', 'ayşe', 'fatma']

#------------------------------------------------------------------------------------------------------------------------

s = 'ali, veli, selami, ayşe, fatma'

a = s.split(',')
print(a)            # ['ali', ' veli', ' selami', ' ayşe', ' fatma']

a = s.split(', ')
print(a)            # ['ali', 'veli', 'selami', 'ayşe', 'fatma']

a = s.split(' ')
print(a)            # ['ali,', 'veli,', 'selami,', 'ayşe,', 'fatma']

s = 'ali,,,veli,,,selami'
a = s.split(',')
print(a)            # ['ali', '', '', 'veli', '', '', 'selami']

s = 'ali   veli   selami'
a = s.split(' ')
print(a)            # ['ali', '', '', 'veli', '', '', 'selami']

s = 'ali   veli   \t\t\t     selami'
a = s.split()
print(a)            # ['ali', 'veli', 'selami']

s = 'ali, veli, selami'
a = s.split('xxx')
print(a)            # ['ali, veli, selami']

s = 'ali, veli, selami, ayşe, fatma'
a = s.split(', ')
k = ', '.join(a)
print(k)            # ali, veli, selami, ayşe, fatma    

d = '13/06/2022'
a = d.split('/')
print(a)            # ['13', '06', '2022']

#------------------------------------------------------------------------------------------------------------------------
    str sınıfının strip isimli metodu argümansız çağrılırsa metot yazının başındaki ve sonundaki boşluk karakterlerini atar. 
    Bu işlev pek çok programama dilinde "trim" isimli fonksiyonlarla yapılmaktadır. strip fonksiyonu parametreli kullanılırsa 
    strip edilecek karakteri de belirlememize olanak sağlar. Burada argüman birden fazla karakter olarak girilirse tüm bu karakterler
    bireysel olarak strip karakterleri olarak ele alınmaktadır. Örneğin:

    >>> s = '     Ali Serçe    '
    >>> k = s.strip()
    >>> print(':' + k + ':')
    :Ali Serçe:
    >>> s = '........Ali Serçe.......'
    >>> k = s.strip('.')
     >>> print(':' + k + ':')
    :Ali Serçe:
    >>> s = '.,.,.,.,.,Ali Serçe.,.,.,.,.'
    >>> k = s.strip('.,')
    >>> print(':' + k + ':')
    :Ali Serçe:
    >>> k = s.strip(',.')
    >>> print(':' + k + ':')
    :Ali Serçe:

#------------------------------------------------------------------------------------------------------------------------

s = '   ankara    '

k = s.strip()
print(':' + k + ':')        # :ankara:

s = 'xxxyyyyyyyyxxxankaraxxxxxxxxxxxxxyyyyyy'
k = s.strip('xy')
print(':' + k + ':')        # :ankara:

s = '    ankara    izmir    '
k = s.strip()
print(':' + k + ':')        # :ankara    izmir:

#------------------------------------------------------------------------------------------------------------------------
    strip metodunun lstrip ve rstrip isimli benzerleri vardır. lstrip yalnızca sol taraftaki strip karakterlerini atar, rstrip 
    ise yalnızca sağ taraftaki strip karakterlerini atar. (strip her iki taraftaki strip karakterlerini atmaktadır).Örneğin:

    >>> s = '    Ali Serçe   '
    >>> k = s.lstrip()
    >>> print(':' + k + ':')
    :Ali Serçe   :
    >>> k = s.rstrip()
    >>> print(':' + k + ':')
    :    Ali Serçe:
    >>> s = '......,,,,,,,Ali Serçe,,,,,.....'
    >>> k = s.lstrip('.,')
    >>> print(':' + k + ':')
    :Ali Serçe,,,,,.....:
    >>> k = s.rstrip('.,')
    >>> print(':' + k + ':')
    :......,,,,,,,Ali Serçe:

#------------------------------------------------------------------------------------------------------------------------

s = '    bugün hava çok güzel    '

result = s.lstrip()
print(':' + result + ':')       # :bugün hava çok güzel    :
    
result = s.rstrip()
print(':' + result + ':')       # :    bugün hava çok güzel:

#------------------------------------------------------------------------------------------------------------------------
                                            20. Ders - 15/06/2022-ÇArşamba    
#------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------
    str sınıfının partition isimli metodu yazı içinde aranacak bir yazıyı parametre olarak alır. Yazıyı bulursa üçlü bir 
    demete geri döner. Demetin ilk elemanı yazıda bulunan yerin sol tarafındaki yazıdan, sonraki elemanı bulunan yazının kendisinden ve
    sonraki elemanı da bulunan yazının sağ tarafındaki yazıdan oluşacaktır. Örneğin:

    >>> s = 'aliveliselami'
    >>> s
    'aliveliselami'
    >>> result = s.partition('veli')
    >>> result
    ('ali', 'veli', 'selami')
    >>> s = 'ali   veli selami'
    >>> s = '  ali  veli  selami  '
    >>> result = s.partition('veli')
    >>> result
    ('  ali  ', 'veli', '  selami  ')
    >>> s = 'aliveliselami'
    >>> result = s.partition('selami')
    >>> result
    ('aliveli', 'selami', '')
    >>> result = s.partition('ali')
    >>> result
    ('', 'ali', 'veliselami')
    >>> result = s.partition('xxx')
    >>> result
    ('aliveliselami', '', '')

    Burada eğer yazı asıl yazının başında bulunursa demetin ilk elemanının boş string olduğuna, sonunda bulunursa demetin son elemanın boş string 
    olduğuna dikkat ediniz. Eğer Yazı asıl yazıda bulunamazsa demetin ilk elemanı asıl yazıdan ikinci ve üçüncü elemanları boş
    string'ten oluşacaktır.

#------------------------------------------------------------------------------------------------------------------------

s = 'ankaraizmiristanbul'

t = s.partition('izmir')
print(t)        # ('ankara', 'izmir', 'istanbul')

left, center, right = s.partition('izmir')
print(left)         # ankara
print(center)       # izmir
print(right)        # istanbul

#------------------------------------------------------------------------------------------------------------------------
    Yukarıda da belirtitğimiz gibi eğer partition parametresiyle belirtilen yazıyı bulamazsa bu durumda yine üçlü demete 
    geri döner. Demetin birinci elemanı tüm yazıdan, ikinci ve üçüncü elemanları boş string'lerden oluşur.
#------------------------------------------------------------------------------------------------------------------------

s = 'ankaraizmiristanbul'

t = s.partition('xxxx')
print(t)        # ('ankaraizmiristanbul', '', '')

t = s.partition('ankara')
print(t)        # ('', 'ankara', 'izmiristanbul')

t = s.partition('istanbul')
print(t)        # ('ankaraizmir', 'istanbul', '')

#------------------------------------------------------------------------------------------------------------------------
    str sınıfının replace isimli metodu bir yazı içerisinde belli bir yazıyı başka yazıyla yer değiştirir. Metodun iki parametresi vardır. 
    Birinci parametre aranacak yazıyı, ikinci parametre yer değiştirilecek yazıyı belirtir. Örneğin:

    >>> s = 'ali top at, ali ip atla'
    >>> k = s.replace('ali', 'veli')
    >>> k
    'veli top at, veli ip atla'
    >>> s
    'ali top at, ali ip atla'

#------------------------------------------------------------------------------------------------------------------------

s = 'istanbul istanbul güzel istanbul'

k = s.replace('istanbul', 'ankara')
print(k)            # ankara ankara güzel ankara

#------------------------------------------------------------------------------------------------------------------------
    replace metodunun isteğe bağlı bir üçüncü parametresi de vardır. Bu parametre girilecekse int bir sayı olarak girilmelidir. 
    Bu durumda yalnızca replace burada belirtilen sayıda değiştirme yapar. Örneğin:

    >>> s = 'istanbul istanbul güzel istanbul'
    >>> k = s.replace('istanbul', 'ankara', 2)
    >>> k
    'ankara ankara güzel istanbul'

#------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------
    str sınıfının startswith isimli metodu yazının parametresiyle belirtilen yazı ile başlayıp başlamadığını belirlemek için 
    kullanılmaktadır. Örneğin:

    >>> s = '- bu bir denemedir'
    >>> result = s.startswith('-')
    >>> result
    True
    >>> result = s.startswith('- ')
    >>> result
    True
    >>> result = s.startswith('- xxx')
    >>> result
    False

#------------------------------------------------------------------------------------------------------------------------

s = 'ankara'

result = s.startswith('an')
print(result)               # True

result = s.startswith('anka')
print(result)               # True

result = s.startswith('anki')
print(result)               # False

#------------------------------------------------------------------------------------------------------------------------
    str sınıfının endswith isimli metodu yazının parametresiyle belirtilen yazı ile bitip bitmediğini belirlemek için kullanılmaktadır.
    Örneğin:

    >>> s = 'bu bir denemedir...'
    >>> result = s.endswith('...')
    >>> result
    True

#------------------------------------------------------------------------------------------------------------------------

s = 'ankara'

result = s.endswith('ra')
print(result)               # True

result = s.endswith('kara')
print(result)               # True

result = s.endswith('an')
print(result)               # False

#------------------------------------------------------------------------------------------------------------------------
    iki string toplandığında yeni bir string elde edilmektedir. Bu yeni string iki string'in uç uca eklenmesinden elde edilen yazıdan 
    oluşur. Ancak s += k gibi bir işlem mevcut s yazısının sonuna ekleme yapma anlamına gelmez. Çünkü string'ler değiştirilemez (immutable)
    nesnelerdir. Dolayısıyla s += k tamamen s = s + k anlamına gelir. 
#------------------------------------------------------------------------------------------------------------------------

s = 'ankara'
k = 'izmir'

result = s + k
print(result)           # ankaraizmir

print(id(s))
s += k                  # s = s + k
print(id(s))
print(s)                # ankaraizmir

#------------------------------------------------------------------------------------------------------------------------
    str sınıfının upper metodu yazıdaki küçük harfleri büyük harflere lower metodu da büük harfleri küçük harflere dönüştürür.
    Ancak upper ve lower büyük ya da küçük harf olamayan karakterleri olduğu gibi bırakır. Örneğin:

    >>> s = 'AnKaRa-06'
    >>> k = s.upper()
    >>> k
    'ANKARA-06'
    >>> k = s.lower()
    >>> k
    'ankara-06'

    Türkçe'deki küçük harf 'i'nin UNICODE büyük harf karşılığı 'I' biçimindedir. Benzer biçimde büyük harf 'I' karakterinin de
    küçük harf karşılığı 'i' biçimindedir. Bu da bazen Türkçe yazıla riçin istediğimiz sonucun elde edilmesini engeller. Örneğin:

    >>> s = 'iznik gölü'
    >>> k = s.upper()
    >>> k
    'IZNIK GÖLÜ'

    Bu problem şöyle çözülebilir:

    >>> s = 'iznik gölü'
    >>> k = s.replace('i', 'İ').upper()
    >>> k
    'İZNİK GÖLÜ'

#------------------------------------------------------------------------------------------------------------------------

s = 'AğRı dAğI-04'

k = s.upper()
print(k)            # AĞRI DAĞI-04

k = s.lower()
print(k)            # ağrı daği-04

#------------------------------------------------------------------------------------------------------------------------
    İki string >, >=, <, <=, == ve != operatörleriyle karşılaştırılabilir. Karşılaştırma leksikografik olarak yapılmaktadır. 
    Leksikografik karşılaştırma sözlükteki sıraya göre karşılaştırmadır. Yani iki yazıda karşılıklı karakterler aynı olduğu sürece 
    ilerlenir. İlk aynı olmayan karakterlerin UNICODE sıra numaralarına bakılır. Hangi karakterin UNICODE sıra numarası büyükse
    o yazı diğerinden büyüktür. Tabii daha çok iki string'in eşit olması ya da eşit olmaması biçiminde karşılaştırmalar yapılmaktadır. 
#------------------------------------------------------------------------------------------------------------------------

password = 'maviay'
s = input('Enter password:')

result = s == password
print(result)

#------------------------------------------------------------------------------------------------------------------------
    Karşılaştırmanın Türkçe'ye göre değil UNICODE tabloya göre yapıldığına dikkat ediniz. Örneğin:

    >>> s = 'aysel'
    >>> k = 'ayçe'
    >>> result = s > k
    >>> result
    False

    Eğer karşılaştımr Türkçe karakterlere göre yapılsaydı "aysel" yazısı "ayçe" yazısından büyük olurdu. Ancak UNICODE 
    tabloda 'ç' karakteri 's' karakterinden daha ileride bulunmaktadır. 
#------------------------------------------------------------------------------------------------------------------------

s = 'aysel'
k = 'ayçe'

result = s > k
print(result)           # False 's'nin UNICODE numarası 'ç'nin UNICODE numarasından küçük

#------------------------------------------------------------------------------------------------------------------------
    Tabii bir yazı diğer yazının ilk bölümü ile aynı ise bu durumda uzun olan yazı daha büyük olur. Yani örneğin 'aliye' yazısı
    'ali' yazısından daha büyüktür.
#------------------------------------------------------------------------------------------------------------------------

s = 'ali'
k = 'aliye'

result = k > s
print(result)           # True

#------------------------------------------------------------------------------------------------------------------------
    UNICODE tabloda önce büyük harfler sonra küçük harfler gelmektedir. Zaten UNICODE toblonun ilk 128 karakteri standart ASCII
    tablosu ile aynıdır. Sonraki 128 karakteri ASCII Latin-1 Code Page'i ile aynıdır. Büyük harflerin tabloda önce gelmesi ASCII 
    tablosundan kaynaklanmaktadır. 
#------------------------------------------------------------------------------------------------------------------------

s = 'ali'
k = 'Ali'

result = s > k
print(result)           # True

#------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------
    Bir karakterin UNOCODE tablodaki sıra numarası ord isimli built-in fonksiyonla elde edilebilmektedir. Örneğin:

    >>> result = ord('A')
    >>> result
    65
    >>> result = ord('a')
    >>> result
    97
    >>> result = ord('0')
    >>> result
    48
    >>> result = ord('5') - ord('0')
    >>> result
    5

    ord fonksiyonuna biz tek karakterli bir string'i argüman olarak verebiliriz. Aksi takdirde exception (TypeError) oluşur. Örneğin:

    >>> result = ord('ali')
    Traceback (most recent call last):
    File "<stdin>", line 1, in <module>
    TypeError: ord() expected a character, but string of length 3 found

    (Fonkisyonun birden fazla karakter için TypeError ile exception oluşturması ve exception mesajı biraz uygunsuz olmuştur. Zira Python'da
    char diye bir tür yoktur. Dolayısıyla fonksiyonun TypeError yerine ValueError exception'ı oluşturması daha uygun gözükmektedir.)

    (C, C++, Java ve C# gibi dillerde bir karakteri tek tırnak içerisine aldığımızda zaten bu ifade o karakterin ilgili tablodaki 
    sıra numarasını belirtmektedir. Bu dillerde tek karakterden oluşan yazılar "char" isimli bir türdendir. Bu char türü de zaten 
    bu dillerde aritmektik işlemlere sokulabilmektedir. Dolayısıyla bu dillerde ord gibi bir fonksiyona gereksinim duyulmamaktadır. )
#------------------------------------------------------------------------------------------------------------------------

s = input('Bir karakter giriniz:')
result = ord(s)
print(result)

#------------------------------------------------------------------------------------------------------------------------
    ord fonksiyonunun yaptığı şeyin terci chr fonksiyonuyla yapılabilmektedir. chr fonksiyonu bizden int bir değeri parametre
    olarak alır. Onun UNICODE tablodaki karakter karşılığını tek elemanlı bir string olarak verir.
#------------------------------------------------------------------------------------------------------------------------

n = int(input('Bir karakter numarası giriniz:'))
result = chr(n)
print(result)

k = ord(result)
print(k)

#------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------
    Aşağıdaki gibi üç değşiken olsun:

    a = 10
    b = 20
    c = 30

    Burada a, b, c'nin değerlerini bilmediğimizi varsayalım. Ve aşağıdaki gibi bir yazıyı ekrana basmak isteyelim:

    a = 10, b = 20, c = 30

    Bunu şimdiye kadarki bilgilerimizle ancak string'leri toplayıp yapabiliriz:

    a = 10
    b = 20
    c = 30


    s = 'a = ' + str(a) + ', b = ' + str(b) + ', c = ' + str(c)
    print(s)

    Ya da örneğin:

    print('a = ' + str(a) + ', b = ' + str(b) + ', c = ' + str(c))

    Bu tür yazımlara "formatlı yazım" denilmektedir. Formatlı azım işlemleri çok sık karşımıza çıkmaktadır. Ancak görüldüğü 
    gibi string toplamlarıyla formatlı yazıların oluşturulması oldukça zordur. Formatlı yazım için Python'da zaman içerisinde 
    üç değişik yöntem standart kütüphaneye ve dile dahil edilmiştir:

    1) % operatör metodu yoluyla formatlı yazım
    2) str sınıfının format metoduyla formatlı yazım
    3) string enterpolasyonu yoluyla formatlı yazım

    String enterpolasyonu Python'a çok sonralı 3.6 versiyonuyla girmiştir. String enterpolasyonu diğer iki yönteme göre hem daha pratik hem de 
    daha hızlı bir formatlama sunmaktadır. 
#------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------
    str sınıfının format isimli metodu istenildiği kadar çok argüman alabilmektedir. Bu metot yazı içerisindeki {n} kalıbını yer tutucu 
    olarak kabul eder ve bu {n} yer tutucusu yerine format metodunun n'inci argümanın değerini yerleştirir. format metodunun ilk argümanı 0'ıncı
    argümanıdır. Örneğin:

    >>> a = 10; b = 20; c = 30
    >>> s = 'a = {0}, b = {1}, c = {2}'.format(a, b, c)
    >>> print(s)
    a = 10, b = 20, c = 30

    Burada {0} a ile, {1} b ile ve {2} c ile eşleştirilmiştir. Genellikle programcılar bu format metodunu doğrudan print 
    fonksiyonun içerisine yerleştirirler. Örneğin:

    >>> print('a = {0}, b = {1}, c = {2}'.format(a, b, c))
    a = 10, b = 20, c = 30

    Format sentaksındaki sayıların peşi sıra gelme gibi bir zorunluluğu yoktur. Aörneğin:

    >>> print('a = {2}, b = {1}, c = {0}'.format(a, b, c))
    a = 30, b = 20, c = 10

    Örneğin:

    >>> a = 10; b = 20; c = 30
    >>> print('{0}{1}{2}'.format(a, b, c))
    102030

    Uygunsuz durumlarda exception oluşmaktadır. Örneğin yer tutucu içerisindeki sayı argüman sayısından büyükse exception oluşur:

    >> print('a = {10}, b = {1}, c = {2}'.format(a, b, c))
    Traceback (most recent call last):
    File "<stdin>", line 1, in <module>
    IndexError: Replacement index 10 out of range for positional args tuple

    Ancak format metodundaki argümanlar string'te kullanılmamışsa bu durum bir soruna yol açmamaktadır. Örneğin:

    >>> a = 10; b = 20; c = 30
    >>> print('{0}'.format(a, b, c))
    10

#------------------------------------------------------------------------------------------------------------------------

a = 10
b = 20
c = 30

s = 'a = {0}, b = {1}, c = {2}'
k = s.format(a, b, c)       
print(k)            # a = 10, b = 20, c = 30

s = '{2} {0} {1}'
k = s.format(a, b, c)
print(k)            # 30 10 20

print('a = {0}, b = {1}, c = {2}'.format(a, b, c))      # a = 10, b = 20, c = 30

#------------------------------------------------------------------------------------------------------------------------
    Aynı numaralı yer tutucu yazı içerisinde birden fazla kez kullanılabilir. Örneğin:

    >>> a = 10
    >>> b = 20
    >>> print('{0}, {1}, {0}'.format(a, b))
    10, 20, 10
#------------------------------------------------------------------------------------------------------------------------

a = 10
b = 20
c = 30

print('{2} {2} {1} {0} {1}'.format(a, b, c))      # 30 30 20 10 20

#------------------------------------------------------------------------------------------------------------------------
    format metodundaki argüman türleri herhangi bir türden olabilir. 
#------------------------------------------------------------------------------------------------------------------------

city = 'Eskişehir'
plate = 26
region = 'İç Anadolu'

print('{0}-{1}-{2}'.format(city, plate, region))        # Eskişehir-26-İç Anadolu

#------------------------------------------------------------------------------------------------------------------------
    Yer turucularda küme parantezinin içi boş bırakılabilir. Bu durumda her boş küme parantezi argümanlarla sırasıyla eşleştirilmektedir. 
    Ancak yazıdaki bir yer tutucu numaralı diğeri numarasız olamaz. Ya tüm yer tutucular numaralı olmalı ya da hiçbiri numaralı olmamalıdır. 
    Örneğin:

    >>> a = 10
    >>> b = 20
    >>> c = 30
    >>> print('a = {}, b = {}, c = {}'.format(a, b, c))
    a = 10, b = 20, c = 30
    >>> print('a = {}, b = {}, c = {}'.format(a, b, c))

    Numarısız yer tutucu kullanımı genellikle tercih edilmektedir. Ancak tabii biçimde aynı argüman birden fazla kez kullanılamamaktadır.
#------------------------------------------------------------------------------------------------------------------------

a = 10
b = 20
c = 20

print('a = {}, b = {}, c = {}'.format(a, b, c))     # a = 10, b = 20, c = 20

#------------------------------------------------------------------------------------------------------------------------
    fromat metodunda aslında daha ayrıntılı belirlemeler yapılabilmektedir. Biz şimdilik format metodunun bu ayrıntıları üzerinde 
    durmayacağız. Bunun için Internet'te çeşitli kaynaklara ya da Python Library Reference içerisindeki aşağıdaki kısma göz gezdirebilirsiniz:

    https://docs.python.org/3/reference/lexical_analysis.html#f-strings

    Ayrıntılı formatlama işlemi küme parantezi içerisinde ':' sentaksı ile yapılmaktadır. Örneğin:

    day = 8
    month = 5
    year = 2007

    print('{0:02d}/{1:02d}/{2:04d}'.format(day, month, year))       # 08/05/2007

    Örneğin biz değerleri değişik sayı sistemlerinde yazdırabiliriz:

    x = 100

    print('{:X}'.format(x))     # 64

#------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------
                                                    21. Ders - 20/06/2022 - Pazartesi
#------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------
    Python'a 3.6 ile birlikte "string enterpolasyonu" denilen bir özellik de eklenmiştir. Aslında string enterpolasyonları 
    bazı programlama dillerinde uzun süredir bulunmaktaydı. Artık yavaş yavaş pek çok programlama diline bu özellik sokulmuştur.

    String enterpolasyonu bir string'e ona yapışık bir 'f' ya da 'F' harfi önek getirilerek oluşturulmaktadır. String enterpolasyonunda
    yapılanlar string sınıfının format metoduna benzerdir. Ancak string enterpolasyonunda küme parantezleri içerisinde bir
    ifade bulunmak zorundadır. Yorumlayıcı akış sırasında string enterpolasyonu ile karşılaştığında bizzat kendisi bu ifadenin 
    değerini o anda hesaplayarak yer tutucu yerine yerleştirir. Örneğin:

    a = 10
    b = 20

    print(f'a = {a}, b = {b}')          # yorumlayıcı buradaki string'i 'a = 10, b = 20' haline dönüştürür.

    str sınıfının format metodu ismi üzerinde bir metottur. Yani bu metot yoluyla formatlama yapılacağı zaman formatlama 
    program çalışırken metot tarafından yapılmaktadır. Oysa string enterpolasyonları doğrudan yorumlayıcı tarafından program 
    çalıştırılırken işleme sokulur. Bu nedenle string enterpolasyonları hem daha kolay bir yazım sunmakta hem de göreli olarak daha hızlı 
    sonuç vermektedir. Dolayısıyla artık Python programcılları bu tarz formatlamalar için her zaman string enterpolasyonlarını tercih etmelidir. 
    Örneğin:

    >>> a = 10; b = 20; c = 30
    >>> s = f'a = {a}, b = {b * b}, c = {c}'
    >>> s
    'a = 10, b = 400, c = 30'
    >>> print(s)
    a = 10, b = 400, c = 30

#------------------------------------------------------------------------------------------------------------------------

a = 10
b = 20

print(f'a = {a}, b = {b}')      # a = 10, b = 20

#------------------------------------------------------------------------------------------------------------------------
    Tabii string enterpolasyonlarında küme parantezlerinin içerisinde aslında herhangi bir ifade olabilir. Örneğin:

    import math

    x = 10
    print(f"karekök {x} = {math.sqrt(x)}")          # karekök 10 = 3.1622776601683795
#------------------------------------------------------------------------------------------------------------------------

a = 10
b = 20

print(f"a'nın karesi' = {a * a}, b'nin karesi = {b * b}")                       # a'nın karesi' = 100, b'nin karesi = 400
print(f"a'nın karekökü ' = {math.sqrt(a)}, b'nin karekökü = {math.sqrt(b)}")    # a'nın karekökü ' = 3.1622776601683795, b'nin karekökü = 4.47213595499958

#------------------------------------------------------------------------------------------------------------------------
    string enterpolasyonunda küme parantezlerinin içerisnnde gerçek tırnaklar kullanılacaksa asıl string'in tırnağının bu tırnaklarla 
    karışması engellenmelidir. Örneğin:
    
    >>> s = f'{', '.join(a)}'
    File "<stdin>", line 1
        s = f'{', '.join(a)}'
                ^
    SyntaxError: f-string: expecting '}'

    Burada f'{', '.join(a)}' biçimindeki string enterpolasyonu geçerli değildir. Çünkü küme parantezlerinin içerisinde de 
    tek tırnak karakteri kullanılmıştır. Tabii biz bu tür durumlarda string'in tırnaklarını çft tırnak ya da üç tırnak yaparak 
    sorunu çözebiliriz. Örneğin:

    >>> s = f"{', '.join(a)}"
    >>> s
    'ali, veli, selami, ayşe, fatma'
    
    String enterpolasyonunda küme parantezleri içerisinde ters karakteri kullanılamamaktadır. Yani aşağıdaki gibi bir 
    string enterpolasyonu geçerli değildir:

      s = f'{\', \'.join(a)}'

#------------------------------------------------------------------------------------------------------------------------

a = ['ali', 'veli', 'selami', 'ayşe', 'fatma']

print(f"{', '.join(a)}")        # ali, veli, selami, ayşe, fatma

#------------------------------------------------------------------------------------------------------------------------
    Yukarıda da belirtitğimiz gibi artık (3.6 ve sonrasında) string enterpolasyonu str sınıfının format metoduna göre tercih 
    edilmelidir. Ancak yine de seyrek bazı durumlarda str sınıfının format metodu daha kolay bir kullanım sunabilmektedir. Örneğin
    string içerisinde aynı ifadenin değerinin birden fazla kez kullanılması durumunda string enterpolasyonunda küme parantezleri 
    içerisinde bu ifadenin tekrar tekrar yazılması gerekir. Halbuki str sınıfının format metodunda bu işlem daha az tuşa basılarka 
    yapılabilir. Örneğin:

    x = 10

    print(f'{x * x}, {x * x}, {x * x}, {x * x}, {x * x}')

    print('{0}, {0}, {0}, {0}, {0}'.format(x * x))

#------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------
    String enterpolasyonundaki format kuralları str sınıfının format metodunndaki gibidir. Örneğin:

    day = 8
    month = 7
    year = 2009

    print(f'{day:02d}/{month:02d}/{year:04d}')

#------------------------------------------------------------------------------------------------------------------------

a = 10
b = 20

print(f'{a:<20}{b:>20}')    # 10                                    20

#------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------
    Python'ın 2'li versiyonlarında string formatlama string sınıfının % operatör metodu ile yapılıyordu. O zamanlar C Programlama 
    Dili bütün programlama dillerini etkisi altına almıştı ve bu biçimdeki formatlama aslında C Programlama Dilindeki "printf" gibi,
    "scanf" fonksiyonlardan esinlenerek oluşturulmuştu. Bu çeşit formatlamada yer tutucular C'nin printf fonksiyonunda olduğu gibi 
    % karakterleriyle oluşturulmaktadır. Örneğin %d "int türünü 10'luk sistemde yazdır", %f "float türünü 10'luk sistemde yazdır anlamına gelmektedir. 
    Bu yontemde string içerisindeki % karakterleri % operatörünün sağındaki demetin elemanlarıyla eşleştirilmektedir. 
    Bu formatlama biçiminde yine printf fonksiyonundaki formatlama biçimleri ("%8.3f" gibi) burada da kullanılabilmektedir. Ancak artık bu yöntem Python'da 
    eski bir yöntem olarak değerlendirilmektedir. Yeni programlarda artık bu tarzda formatlama tercih edilmemektedir. Örneğin:

    >>> x = 10
    >>> y = 20
    >>> print('x = %d, y = %d' % (x, y))
    x = 10, y = 20

    Bu biçimdeki formatlamada % operatörünün solunda string'in sağında ise bir demetin bulunduğuna dikkat ediniz. Örneğin:

    >>> import math
    >>> x = 0.5
    >>> print('sin(%.1f) = %.2f' % (x, math.sin(x)))
    sin(0.5) = 0.48

    Bu formatlama biçiminde % operatörünün sağında ya tek bir ifade bulundurulur ya da bir demet biçiminde birden fazla ifade bulundurulur. 
    Yani başka bir deyişle tek bir değeri formatlamak için demet kullanmaya gerek yoktur. Ancak birden fazla değeri formatlamak için demet kullanmak 
    gerekir. Demet yerine liste ya da başka bir dolaşılabilir nesne kullanamyız. Örneğin:

    >>> a = 10
    >>> print('a = %d' % a)
    a = 10

    Burada string içerisinde tek bir yer tutucu olduğu için % operatörünün sağında demet yerine doğrudan bir ifade kullanılmıştır. 

#------------------------------------------------------------------------------------------------------------------------

a = 10
b = 20

s = 'a = %d, b = %d' % (a, b)       
print(s)                        # a = 10, b = 20

s = 'a = %x, b = %x' % (a, b)       
print(s)                        # a = a, b = 14

c = 12.3456

print('%-10.3f' % c)            # 12.346

#------------------------------------------------------------------------------------------------------------------------
    Daha önce de belirttiğimiz gibi Python'da genel bir silme semantiği için del isimli bir deyim bulundurulmuştur. 
    del deyiminin genel biçimi şöyledi:

    del <değişken listesi>
    del a[ifade], ...

    del deyimi değişkenleri silebilmektedir. Burada silmek demekle sanki o değişken hiç yaratılmamış gibi bir durum oluşturma
    kastedilmektedir. Yani bir değişkeni del deyimi ile sildikten sonra o değişkeni kulanırsak bu durum exception'a yol açar. Örneğin:

    >>> a = 10
    >>> print(a)
    10
    >>> del a
    >>> print(a)
    Traceback (most recent call last):
    File "<stdin>", line 1, in <module>
    NameError: name 'a' is not defined

    Tabii del deyiminde ',' atomu ile tek hamlede birden fazla değişkeni silebiliriz. Örneğin:

    >>> a = 10; b = 20
    >>> print(a, b)
    10 20
    >>> del a, b
    >>> print(a, b)
    Traceback (most recent call last):
    File "<stdin>", line 1, in <module>
    NameError: name 'a' is not defined

    Anımsanacağı gibi Python'da "değişken (variable)" kavramı ile "nesne (object)" kavramı farklı anlamlara gelmektedir. Python'da adres tutan yani bir nesneyi 
    gösteren isimlere değişken denmektedir. Değişkenin gösterdiği yere nesne denilmektedir. del deyimi değişkenleri siler. Nesnelerin silinmesi yorumlayıcı 
    tarafından "çöp toplama (gerbage collection)" mekanizması yoluyla otomatik olarak silinmektedir. Bir nesneyi gösteren hiçbir değişken kalmadıysa
    Python'ın çöp toplama mekanizması devreye girer ve o nesne silinir. Örneğin:

    s = 'ankara'
    s = 'izmir'

    Burada s değişkeni önce "ankara" yazısının bulunduğu nesneyi gösterirken sonra "istanbul" yazısının bulunduğu nesneyi gösterir hale gelmiştir. 
    İşte Python'ın çöp toplayıcı mekanizması devreye girip "ankara" yazısının bulunduğu nesneyi otomatik olarak silecektir. Her ne kadar del deyimi 
    nesneleri silmiyorsa da nesnelerin silinmesi için bir zemin de oluşturabilmektedir. Örneğin:

    s = 'ankara'
    del s

    Burada del deyimi ile s değişkeni silindiği için artık "ankara" yazısına ilişkin nesneyi gösteren bir değişken kalmayacaktır. Dolayısıyla del deyimi
    dolaylı da olsa bu nesnenin silinmesine de önayak olacaktır. 

    del deyimi ile köşeli parantez ile erişebildiğimiz veri yapılarının elemanları da silinebilmektedir. Örneğin:

    >>> a = [1, 2, 3, 4, 5, 6, 7, 8, 9, 100]
    >>> del a[3]
    >>> a
    [1, 2, 3, 5, 6, 7, 8, 9, 0]
    >>> a = [1, 2, 3, 4, 5, 6, 7, 8, 9, 100]
    >>> del a[2:5]
    >>> a
    [1, 2, 6, 7, 8, 9, 0]

    Tabii del ile biz ancak değiştirilebilir veri yapılarında silme yapabiliriz. Örneğin bir demet değiştirilemez olduğuna göre 
    demetin bir elemanını del deyimi ile silemeyiz.

    del deyimi ile bu biçimde silme yapılırken silme işleminin soldan sağa yürütüldüğüne dikkat ediniz. Örneğin:

    del a[2], a[5]

    Burada önce listenin 2'inci indeksli elemanı silinecektir. Bu silinme işleminden sonra 5'inci indeskli eleman bu silinmeden 
    sonra oluşan listenin 5'inci indeksli elemanı olacaktır. Yani:

    del a[2], a[5]

    işlemi ile aşağıdaki işlem eşdeğerdir:

    del a[2]
    del a[5]
    
    Örneğin:

    >>> a = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
    >>> del a[2], a[5]
    >>> a
    [1, 2, 4, 5, 6, 8, 9, 10]

    del deyimi ile dilimleme yapılarak da birden fazla eleman silinebilmektedir. Örneğin:

    >>> a = [1, 2, 3, 4, 5, 6, 7, 8, 9, 100]
    >>> del a[2:6]
    >>> a
    [1, 2, 7, 8, 9, 100]

    del deyimi ile sözlüklerden de eleman silinebilir. Çünkü sözlük elemanlarına da aslında köşeli parantez sentaksı ile erişilebilmektedir. 
    Tabii bu durumda sözlüğün yalnızca anahtarı ya da değeri değil anahtar-değer çifti silinir. Örneğin:

    >>> d = {'ali': 10, 'veli': 20, 'selami': 30}
    >>> del d['veli'], d['selami']
    >>> d
    {'ali': 10}
#------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------
    Python'da farklı türler her zaman == ve != operatöryle karşılaştırılabilirler. int, float ve bool türlerinin dışındaki 
    farklı türler == ve != operatörleriyle karşılaştırıldığında == operatörü ile karşılaştırma her zaman False, != operatör 
    ile karşılaştırma her zaman True değerini verir. Örneğin:

    >>> a = [1, 2, 3]
    >>> b = (1, 2, 3)
    >>> a == b
    False
    >>> a != b
    True
    >>> a == 10
    False
    >>> b != 10
    True

    Burada a list türünden b de tuple türündendir. Dolayısıyla a == b hiçbir zaman eşit olamayacağı için False değerini vermiştir. 
    Benzer biçimde biz bir list ya da demet ile örneğin int, float gibi türleri == ve != operatörleriyle karşılaştırabiliriz. Bu durumda
    == yine her zaman False değerini, != ise True değerini verir. 

    Tabii daha önceden de belirttiğimiz gibi int, float ve bool türleri kendi aralarında tüm karşılaştırma operatörleriyle karşılaştırılabilir. 
    Bu durumda sayıların değerleri karşılaştırılmaktadır. Örneğin:

    >>> a = 10
    >>> b = 10.0
    >>> a == b
    True
    >>> a = 1.0
    >>> b = True
    >>> a == b
    True

#------------------------------------------------------------------------------------------------------------------------

a = [10, 20]
b = (10, 20)

result = a == b
print(result)           # False

result = a != b
print(result)           # True

#------------------------------------------------------------------------------------------------------------------------
    Ancak int, float ve bool türlerinin dışındaki türlerin >, <, >= ve <= operatörleriyle karşılaştırılması geçersiz bir durumdur ve exception'a yol açar. 
    Örneğin:

    >>> a = [10, 20]
    >>> b = (10, 20)
    >>> a > b
    Traceback (most recent call last):
    File "<stdin>", line 1, in <module>
    TypeError: '>' not supported between instances of 'list' and 'tuple'

    Özetle int, float ve bool dışındaki farrklı türleri == ve != operatörleriyle karşılaştırabiliriz ancak >, <, >=, <= 
    operatörleriyle karşılaştıramayız.

#------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------
    Yukarıda da belirttiğimiz gibi int, float ve bool türleri farklı tür olsalar da birbirleriyle karşılaştırılabilmektedir. Örneğin:

    >>> a = 10
    >>> b = 3.7
    >>> a > b
    True
    >>> c = True
    >>> a > c
    True
    
#------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------
    İki listeyi ve iki demeti kendi aralarında tüm karşılaştırma operatörleriyle karşılaştırabiliriz. Bu durumda karşılaştırma 
    leksikografik biçimde yapılır. Yani karşılıklı elemanlar eşit olduğu sürece ilerlenir. İlk eşit olmayan elemanların durumlarına
    bakılarak karar verilir. Örneğin:

    >>> a = [1, 2, 3, 4, 5]
    >>> b = [1, 2, 3, 5, 1]
    >>> a > b
    False
    >>> a < b
    True
    >>> a = [1, 2, 3, 4, 5]
    >>> b = [1, 2, 3, 4, 5]
    >>> a == b
    True
    >>> a = [1, 2, 3, 4, 5]
    >>> b = [1, 2, 3, 4, 5, 6]
    >>> a == b
    False
    >>> a > b
    False
    >>> a < b
    True 
#------------------------------------------------------------------------------------------------------------------------

a = [10, 20, 30, 40, 50]
b = [10, 20, 40, 3, 5]

result = a > b
print(result)           # False

result = b > a
print(result)           # True

result = a == b
print(result)           # False

#------------------------------------------------------------------------------------------------------------------------
    Tabii listeler ve demetler heterojen türlere sahip olabildiğine göre karşılıklı elemanların karşılaştırılabilir olması
    gerekmektedir. Eğer karşılıklı elemanlar karşılaştırılabilir değilse exception oluşur. Örneğin:

    >>> a = [10, 'ali', 20]
    >>> b = [10, 20, 30]
    >>> a > b
    Traceback (most recent call last):
    File "<stdin>", line 1, in <module>
    TypeError: '>' not supported between instances of 'str' and 'int'

    Aşağıdaki gibi bir durumda exception oluşmadığına dikkat ediniz:

    >>> a = [10, 'ali', 20]
    >>> b = [20, 30, 40]
    >>> a > b
    False

    Çünkü burada str ile int türleri karşılaştırılmadan zaten karşılaştırmanın sonucu tespit edilebilmiştir. 

    Tabii listenin elemanları liste ya da demet, demetin elemanları da liste ya da demet olabilir. Bu durumda karşılaştırma 
    özyinelemei biçimde yapılır. Örneğin:

    >>> a = [1, [2, 3, 4], 5]
    >>> b = [1, [2, 3, 5], 2]
    >>> a > b
    False
    >>> a < b
    True

    Örneğin

    >>> a = [1, [2, 3, 4], 5]
    >>> b = [1, (2, 3, 4), 2]
    >>> a == b
    False
    >>> a > b
    Traceback (most recent call last):
    File "<stdin>", line 1, in <module>
    TypeError: '>' not supported between instances of 'list' and 'tuple'
    
    İki sözlük nesnesi kendi aralarında yalızca == ve != operatörleriyle karşılaştırılabilir. Bu durumda iki sözlüğün 
    anahatar değer çiftlerinin bire bir aynı olmasına bakılmaktadır (yani yalnızca anahtarlara bakılmamaktadır). Örneğin:

    >>> d1 = {'ali': 10, 'veli': 20, 'selami': 30}
    >>> d2 = {'ali': 10, 'veli': 20, 'selami': 50}
    >>> d1 == d2
    False
    >>> d1 > d2
    Traceback (most recent call last):
    File "<stdin>", line 1, in <module>
    TypeError: '>' not supported between instances of 'dict' and 'dict'

    İki sözlük nesneesinin >, <, >= ve <= operatörleriyle karşılaştırılmasının geçersiz olduğuna dikkat ediniz. 

    Her ne kadar Python'da 3.7 ve sonrasında sözlük elemanlarında dolaşım sırasında bir sıra söz konusu olsa da == ve != 
    operatörlerinde bu biçimde lexikografik bir karşılaştırma yapılmamaktadır. Yani eşitlik koşulu için karşılıklı anahtar-değer 
    çiftlerinin eşitliğine değil tüm anahtar-değer çiftlerinin eşitliğine bakılmaktadır. Örneğin:

    >>> d = {'ali': 30, 'veli': 30, 'selami': 40}
    >>> k = {'ali': 30, 'selami': 40, 'veli': 30}
    >>> d == k
    True

    İki küme == ve != operatörleriyle karşılaştırılabilir. Bu durumda iki kümenin elemanlarının tamamen aynı olup olmadığına
    bakılmaktadır. Örneğin:

    >>> s = {'ali', 100, 'veli', 120}
    >>> k = {100, 120, 'veli', 'ali'}
    >>> s == k
    True
    >>> s != k
    False

    Kümelerde >, >=, <, <= operatörlerinin küme işlemi yaptığını anımsayınız. (Kümelerde '<' öz alt küme, '>' öz üst küme, '<=' alt küme ve
    '>=' üst küme işlemlerini yapmaktadır.) Örneğin:

    >>> a = {10, 'ali', 'veli'}
    >>> b = {10, 'veli'}
    >>> a > b
    True
    >>> b < a
    True
    >>> c = set()
    >>> c < a
    True

#------------------------------------------------------------------------------------------------------------------------
                                            22. Ders - 22/06/2022-Çarşamba
#------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------
    Bir satırın başından itibaren ilk boşluk olmayan karaktere kadarki SPACE sayısına "girinti düzeyi (indent level)" denilmektedir. 
    Bir satırın girinti düzeyi eğer satırın başında hep SPACE karakteri varsa SPACE karakterlerinin toplamı olarak hesaplanır. 
    Ancak satırın başına SPACE ve TAB karakterleri varsa hesap şöyle yapılmaktadır: Her TAB karakteri görüldüğünde bu TAB karakterlerinin
    o zamana kadarki SPACE sayısını 8'in katlarına tamamlamak için n tane SPACE anlamına geldiği kabul edilir. Bu biçimdeki SPACE'lerin sayısına 
    bakılır. Örneğin:

    SPACE SPACE SPACE 

    Bu satırın girinti düzeyi 3'tür. Örneğin:

    SPACE TAB SPACE

    Bu satırın girinti düzeyi 9'dur. Çünkü:
    
    SPACE (1) TAB (7) SPACE
    
    Örneğin:

    SPACE TAB TAB SPACE

    Bu satırın girinti düzeyi 17'dir. Çünkü:

    SPACE (1) TAB (7) TAB (8) SPACE (1)
        
    Örneğin aşağıdaki iki satırın girinti düzeyleri editörde bu iki satır alt alta gözükmüyor olsa bile Python yorumlayıcısına göre aynıdır:

    SPACE SPACE SPACE SPACE SPACE SPACE SPACE SPACE SPACE 
    SPACE TAB SPACE

    Buradaki hesabın editörün tab ayarıyla ilgili olmadığına dikkat ediniz. Yukarıdaki iki satır editörde alt alta gözükmüyor olsa bile
    aynı girinti düzeyine sahiptir. 

    Daha önceden de belirttiğimiz gibi Python editörlerinin hemen hepsi zaten TAB yerine n tane SPACE karakterini kaynak koda yazmaktadır. 
    Bu durumda yorumlayıcı zaten artık TAB karakterlerini görmez yalnızca SPACE karakterlerini görür. Girinti düzeyi hesabı oldukça kolay olur. 
    Tabii Python editörünüzün TAB yerine SPACE basması yönünde bir zounluluk yoktur. 
#------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------
    Python programlarında girinti düzeyi 0 ile başlamak zorundadır. Yani Python programları en soldaki sütuna dayalı bir biçimde yazılır. 
#------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------
    Bir programlama dilinde çalıştırma birimlerine "deyim (statement)" denilmektedir. Yani "imperative dillerde" programın çalışması
    deyimlerin çalıştırılmasıyla sağlanmaktadır. Python yorumlayıcısı yukarıdan aşağıya doğru deyimleri tek tek sırasıyla çalıştırır. 
    C, C++, Java ve C# gibi pek çok dilde program main ya da Main isimli özel bir fonksiyondan çalışmaya başlamaktadır. Ancak Python gibi 
    bazı dillerde program kaynak kodun tepesinden çalışmaya başlar. 

    Her programlama dilinde deyimlerin sınıflandırılması o dile özgü bir biçimde yapılır. Python'da deyimler iki gruba 
    ayrılmaktadır:

    1) Basit Deyimler (Simple Statements)
    2) Bileşik Deyimler (Compound Statements)

    Python'da basit deyimler tek parçadan oluşan deyimlerdir. Bu deyimler tek satır üzerine yazılabilmektedir. Ancak bileşik deyimler
    birden fazla parçadan oluşan ve tek satır üzerinde yazılamayan ya da yazılmak zorunda olmayan deyimlerdir. Basit deyimlerin en önemli 
    özellikleri birden fazla basit deyimin aynı satıra aralarına ';' atomu getirilerek yazılabilmesidir. 
    Python'da basit deyimlerin de bileşik deyimlerin de çeşitli biçimler vardır. Örneğin if gibi for gibi deyimler Python'da 
    bileşik deyimler grubundandır. 
#------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------
    Python'daki en yalın basit deyim "ifadesel deyimdir (expression statment)". Bir ifade programın parçası halinde 
    bulundurulduğunda bu artık deyim olur. Bu tür deyimlere ifadesel deyim denir. Örneğin:

    print(z) 
    input('Bir yazı giriniz:')

    Bu iki deyim ifadesel deyimdir. 

    Biz bir ifadeyi bir satıra yazdığımızda artık o ifadenin artık bir deyim heline geldiğine dikkat ediniz. Örneğin:

    print(a + b)

    Tabii ifadeler başka deyimlerin parçalarını da oluşturabilmektedir. 
    
    Python'da atama işlemi aslında bir operatör değil bir deyim statüsündedir. Buna "atama deyimi (assignment statement)" denilmektedir. Örneğin:
    
    x = 10
    y = 20
    z = x + y
    print(z) 

    Burada ilk üç deyim atama deyimidir. Son deyim ifadesel deyimdir. Ancak bunların hepsi kategorik olarak basit deyim statüsündedir. 
    
    Biz basit deyimleri istersek tek satır üzerinde onların aralarına ';' getirerek de yazabiliriz:

    x = 10; y = 20; z = x + y; print(z) 

#------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------
    Programalama dillerinde bileşik deyimlerin parçalarını oluşturan deyimlerin nasıl yazılması gerektiğine yönelik çeşitli biçimler 
    bulunmaktadır. Örneğin C, C++, Java ve C# gibi diller bloklama tekniğini kullanırlar. Bu dillerde bileşik deyimin parçalarını oluşturan 
    deyimler bloklanarak belirlenir. Bloklama bu dillerde küme parantezleri ile yapılmaktadır. Örneğin:
    
    if (koşul) {
        ifade1;
        ifade2;
        ifade3;
    }
    ifade4;

    Ancak Python'da bloklama için girinti düzeyi tekniği kullanılmaktadır. Bir bileşik deyimin içindeki deyimlerin neler olduğu o deyimlerin 
    girinti düzeylerine bakılarak belirlenir. Örneğin:

    if koşul:
        ifade1
        ifade2
        ifade3
    ifade4

    Burada ifade1, ifade2 ve ifade3 aynı girinti düzeyine sahip olduğu için bileşik deyimin parçalarını oluşturmaktadır. 
    
    Bir bileşik deyimin içindeki deyimlerin aynı girinti düzeyine sahip olması gerekir. Örneğin:

    if koşul:
        ifade1;
          ifade2
          ifade3
    ifade4

    Bu yazım geçersizdir. Tabii yukarıda açıkladığımız girinti düzeyi kuralına göre editörde alt alta gözükmediği halde iki satır 
    aslında aynı girinti düzeyine sahip olabilir. Ancak yukarıda da belirttiğimiz gibi Python editörünüz eğer TAB yerine belli miktar 
    SPACE basıyorsa zaten o koddaki bileşik deyimin parçaları hep aynı hizada görüntülenecektir. 

    Python'da bileşik deyimler genel olarak bir anahtar sözcükle başlatılır, sonra bunu bir ya da birden fazla ifade izler sonra da bir ':' 
    atomu bulundurulur. 
#------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------
    Python'da bileşik deyimin anahtar sözcüğü ile aynı satıra yazılan birden fazla basit deyime ya da farklı satırlara 
    aynı girinti düzeyiyle yazılan birden fazla deyime "suit" denilmektedir. Pek çok deyim bir suit içermek durumundadır. 
    Örneğin:

    while ifade: ifade1; ifade2; ifade3

    Burada ifade1, ifade2 ve ifade3 bir suit belirtmektedir. Örneğin:

    while ifade:
        ifade1
        ifade2
        ifade3

    Burada da ifade1, ifade2 ve ifade3 bir suite belirtir. Örneğin:

    while ifade: ifade1
        ifade2
        ifade3

    Burada ifade1, ifade2 ve ifade3 bir suit belirtmemektedir. Çünkü suit ya deyimin anahtar sözcüğü ile aynı satıra yazılmış 
    birden fazla deyimi belirtir ya da  farklı satırlara aynı girinti düzeyiyle yazılmış birden fazla deyimi belirtir. Örneğin:

    while ifade:
        ifade1
        ifade2; ifade3

    Bu bir suite belirtmektedir. Görüldüğü gigi farklı satırlara yazılmıi deyimlerdeki satırlarda birden fazla basit deyim 
    olabilmektedir. Örneğin:

    while ifade:
        ifade1
          ifade2
        ifade3

    Burada ifade1, ifade2 ve ifade3 bir suit belirtmez. Çünkü aynı girinti düzeyine sahip değildir. 

    Suit'i oluşturan "farklı satırlardaki aynı girinti düzeyine sahip deyimler" arasında boş satırlar olabilir. Bu suit 
    kuralını bozmaz. Örneğin:

    while ifade:
        ifade1
        ifade2
    
        ifade3
        ifade4

    Buradaki suit yazımı geçerlidir. 
#------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------
    if deyimi bir ifadenin doğru ya da yanlış olması durumuna göre farklı işlemlerini yapılmasını sağlayan en temel bileşik deyimdir. 
    Genel biçimi şöyledir:

    if <ifade>: <suite>
   [else: <suite>]

    Buradan da görüldüğü gibi if deyiminin doğruysa ve yanlışsa kısmında ayrı suite'ler vardır. if deyimin else kısmı hiç olmayabilir. 
    Aşağıdaki if deyimi yazım bakımındna geçerlidir:

    if ifade:
        ifade1
        ifade2
    else:
        ifade3
        ifade4

    else anahtar sözcüğü ile if anahtar sözüğünün aynı girinti düzeyine saip olması gerekmektedir. Aşağıdaki if deyimi de geçerlidir:

    if ifade: ifade1; ifade
    else: 
        ifade3
        ifade4

    Aşağıdaki if deyimi de geçerlidir:

    if ifade: 
            ifade1; ifade2
    else:
        ifade3
        ifade4

    Yukarıda da belirttiğimiz gibi Python'da genel olarak bileşik deyimlerde deyimin kontrol kısmının sonunda ':' atomu bulunmaktadır. 
    Bu atom ifadeye yapışık olmak zorunda değildir. Ancak aynı satırda bulunmak zorundadır. Örneğin:

    if ifade                   : 
            ifade1; ifade2
    else                  : ifade3; ifade4

    Bu if deyimi geçerlidir. Tabii bu yazım iyi bir görüntüye sahip değildir. 

    if deyiminde kısmındaki deyimin doğruysa kısmındaki suit'in girinti düzeyiyle yanlışsa kısmındaki suit'in girinti düzeyinin 
    aynı olması gerekmez. Örneğin:

    if ifade:
        ifade1
        ifade2
    else:
                ifade3
                ifade4

    Bu yazım geçerlidir. Tabii böyle bir yazımda okunabilirlik bozuk olacaktır. Bu nedenle Python programcıları her ne kadar 
    zorunlu olmasa da if deyiminin doğruysa ve yanlışsa kısımlarındaki suit'leri aynı girinti düzeyine sahip olacak biçimde yazarlar. 
    Örneğin:

    if ifade:
        ifade1
        ifade2
    else:
        ifade3
        ifade4

    Suit "aynı satır üzerine yazılmış birden fazla basit deyim ya da farklı staırlara yazılmış olan aynı girinti düzeyine sahip 
    birden fazla deyim" anlamına geldiğine göre aşağıdaki if sentaksı geçersizdir:

    if ifade: ifade1
        ifade2
    else: ifade3; ifade4

    Çünkü if deyiminin doğurysa ksmındaki deyimler suite oluşturmamaktadır. Örneğin:

    if ifade: 
        ifade1
            ifade2
    else: ifade3

    Bu yazım da yanlıştır. Çünkü if deyimin doğruysa kısmındaki ifadeler suit belirtmemektedir. Örneğin:

    if ifade: ifade1; ifade2
    else: ifade3; ifade4
    ifade5

    Bu yazım doğrudur. Burada ifade5 if deyiminin else kısmında değildir. Yani buradaki ifade5 if deyimi ile aynı girinti düzeyine
    sahip olduğu için artık if deyimi içerisinde değildir. Örneğin:

    if ifade:
        ifade1:
        ifade2:
    else:
        ifade3
        ifade4
      ifade5

    Bu yazım geçersizdir. Çünkü burada ifade5 if dışında değildir. ifade5'in if dışında olabilmesi için if ile aynı hizada yazılması gerekirdi. 
    Öte yandan ifade5 else kısmındaki suite yazımına da aykırıdır. 
    
    Örneğin:

    if ifade: ifade1 else: ifade2

    Bu if deyimi geçersizdir. else anahtar sözcüğü kesinlikle if ile aynı girinti düzeyinde yazılmak zorundadır. 

    if deyimi şöyle çalışmaktadır: Önce yorumlayıcı if anahtar sözcüğünün yanındaki ifadenin türüne bakar. Eğer bu ifade bool türden değilse onu 
    bool türüne dönüştürür. Bu dönüşümden sonra eğer bu ifade True ise yaşnızca if deyiminin doğruysa kısmındaki suite çalıştırılır eğer bu ifade False
    ise yalnızca if deyiminin yanlışsa kısmındaki suit çalıştırılır. Böylece if deyiminin çalışması biter. Program if deyiminden sonraki deyiminden
    çalışmaya devam eder. Örneğin:

    x = 10
    if x > 0:
        print('ankara')
        print('izmir')
    else:
        print('adana')
    print('eskişehir')

    Burada toplam üç deyim vardır. İlk deyim atama deyimidir ve basit bir deyimdir. İkinci deyim if deyimidir. Üçüncü deyim 'eskişehir'i ekrana yazdıran
    basit deyimdir. x > 0 ifadesi zaten bool türdendir. Bu ifade True ise 'ankara' ve 'izmir' yazıları False ise 'adana' yazısı ekrana çıkacaktır. 
    'eskişehir' yazısını basan basit deyim if içerisinde değildir. Çünkü bu deyim if ile aynı girinti düzeyinde yazılmıştır. 
#------------------------------------------------------------------------------------------------------------------------

x = int(input('Bir syaı giriniz:'))

if x % 2 == 0:
    print('çift')
else:
    print('tek')
    
print('program sonlanıyor')

#------------------------------------------------------------------------------------------------------------------------
    Boş bir listenin, demetin ve strin'in bool türüne False olarak, dolu bir listenin, string'in ve demetin True olarak 
    dönüştürüldüğünü anımsayınız. Örneğin:

    a = []
    if a:
        ifade1
        ifade2
    else:
        ifade  
        ifade4

    Bu if deyimi yanlışsa kısmındna sapacaktır. Benzer biçimde sıfırdan farklı int ve float değerlerin bool türüne True olarak,
    0 değerinin False olarak dönüştürüldüğünü de anımsayınız. Örneğin:

    a = int(input('Bir değer giriniz:))
    if a:
        print('girilen değer sıfır değil')
    else:
        print('girilen değer sıfır')
#------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------
    Aşağıda ikinci derece bir denklemin köklerini bulan program verilmiştir. 
#------------------------------------------------------------------------------------------------------------------------

import math

a = float(input('a:'))
b = float(input('b:'))
c = float(input('c:'))

delta = b ** 2 - 4 * a * c
if delta < 0:
    print('kök yok')
else:
    x1 = (-b + math.sqrt(delta)) / (2 * a)
    x2 = (-b - math.sqrt(delta)) / (2 * a)

print(f'x1 = {x1}, x2 = {x2}')

#------------------------------------------------------------------------------------------------------------------------
    Yukarıdaki genel biçimden de görüldüğü gibi if deyiminin else kısmı olmayabilir. if deyiminin doğruysa kısmındaki 
    suite'ten sonra else anahtar sözcüğü gelmezse derleyici bunun "else kısmı olmayan bir if" olduğunu kabul eder. Örneğin:

    if ifade:
        ifade1
        ifade2
    ifade3

    Burada toplamda iki deyim vardır. if deyimi ve ifade3'ten oluşan basit deyim. Burada if deyimin else kısmı bulunmamaktadır. 
    ifade3 if deyimin dışında olan başka bir basit deyimdir. Örneğin:

    a = int(input('Bir sayı giriniz:'))

    if a > 0:
        print('Pozitif')
    print('Program sonlanıyor')

    Burada if deyiminin else kısmı bulundurulmamıştır. 
#------------------------------------------------------------------------------------------------------------------------

a = int(input('Bir sayı giriniz:'))

if a > 0:
    print('Pozitif')
print('Program sonlanıyor')

#------------------------------------------------------------------------------------------------------------------------
    C, C++, Java ve C# gibi dillerde if anahtar sözcüğündne sonra if ifadeesinin parantezler içerisinde olması zorunludur. 
    Örneğin:

    if (a > 0) 
        ifade1;
    else
        ifade2;

    Pekiyi nedne Python'da böyle bir zorunluluk yoktur? Bu dillerde bu zorunluluğun olmasının asıl nedeni if ifadesi ile
    if'in doğruysa kısmının ayrıştırılmasını sağlanmak istenmesidir. Örneğin:

    if a > 10 b = 20;

    O dillerde burada hangi ifadenin if deyiminin kontrol ifadesi olduğu hangi ifadenin if deyiminin doğruysa kısmını oluşturduğu 
    anlaşılamamaktadır. Halbuki:

    if (a > 10) b = 20;

    Artık her şey çok açıktır. Python'da zaten if deyiminin kontrol ifadesinden sonra ':' atomu gelmek zorunda olduğu için 
    bu ayrıştırma parantezlere gereksinim duyulmadan da yapılabilmektedir. Örneğin:

    if a > b: b = 20

    Swift gibi Kotlin gibi yeni bazı dillerde küme parantezleri dozunlu turulduğu için o dillerde de kontrol ifadesinin 
    paranteze alınması gerekmemiştir. Örneğin:

    if a > 10 {
        b = 10;
    }

    Tabii Python'da biz istersek if deyiminin kontrol ifadesinde de parantezleri kullanabiliriz. Ne de olsa parantezler 
    her ifadede kullanılabilir. 
#------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------
    if deyiminin doğruysa kısmında başka bir if deyimi olabilir. Örneğin:

    ifade1
    if ifade2:
        ifade3
        if ifade4:
            ifade5
            ifade6
        else:
            ifade7
        ifade8
    else:
        ifade9
    ifade10

    Burada toplamda dışarıdan bakıldığında üç deyim vardır. Dıştaki if deyiminin doğruysa kısmında başka bir if deyimid vardır. 

    C/C++, Java ve C# gibi dillerde hizalamanın bir önemi olmadığı için programcılar "dangling else" denilen bir durumda bazen hata yapabilmektedir. 
    "Dangling else" iki if için tek bir else bulunması durumudur. Ancak Python'da girinti düzeylerine bakılarak else'in aslında hangi if deyiminin
    else kısmı olduğu zaten anlaşılmaktadır. Örrneğin:

    if ifade1:
        if ifade2:
            ifade3
            ifade4
    else:
        ifade5

    Buradaki else dıştaki if'in else kısmıdır. Fakat örneğin:

    if ifade1:
        if ifade2:
            ifade3
            ifade4
        else:
            ifade5

    Buradaki else artık içteki if'in else kısmıdır. 
#------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------
    Aşağıdaki örnekte üç sayının en büyüğü bulunmuştur. 
#------------------------------------------------------------------------------------------------------------------------

a = int(input('Sayı giriniz:'))
b = int(input('Sayı giriniz:'))
c = int(input('Sayı giriniz:'))

if a > b:
    if a > c:
        print(a)
    else:
        print(c)
else:
    if b > c:
        print(b)
    else:
        print(c)

#------------------------------------------------------------------------------------------------------------------------
    Bir grup koşuldan bir tanesi doğru iken diğerlerinin doğru olma olasılığı yoksa bu koşullara "ayrık (discrete) koşullar" 
    denilmektedir. Örneğin:

    a > 0
    a < 0

    Bu iki koşul ayrıktır. Örneğin:

    a > 0
    a < 0
    a == 0

    Bu üç koşul da ayrıktır. Örneğin:

    a > 0
    a > 5

    Bu koşullar ayrık değildir.  Örneğin:

    a == 1
    a == 2
    a == 3

    Buradaki üç koşul da ayrıktır.  
#------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------
    Programalamda ayrık koşulların ayrı if'lerle ifade edilmesi kötü bir tekniktir. Örneğin:

    if a > 0:
        ifade1
    if a < 0:
        ifade2
    if a == 0:
        ifade3

    Burada a > 0 durumunda gereksiz bir biçimde diğer iki karşılaştırma da yapılacaktır. Bu karşılaştırmalar önemsiz olsa da bir bilgisayar zamanının
    harcanmasına yol açmaktadır. Örneğin:

    if a == 1:
        ifade1
    if a == 2:
        iafde2
    if a == 3:
        ifade3

    Bu da kötü bir tekniktir. Ayrık koşulların else-if biçiminde organize edilmesi iyi bir tekniktir. Örneğin:

    if a == 1:
        ifade1
    else:
        if a == 2:
            ifade2
        else:
            if a == 3:
                ifade3
#------------------------------------------------------------------------------------------------------------------------

a = int(input('Bir değer giriniz:'))

if a == 1:
    print('bir')
else:
    if a == 2:
        print('iki')
    else:
        if a == 3:
            print('üç')
        else:
            if a == 4:
                print('dört')
            else:
                if a == 5:
                    print('beş')
                else:
                    print('hiçbiri')
                    
print('program sonlanıyor')

#------------------------------------------------------------------------------------------------------------------------
    Yukarıdaki örnekte görüldüğü gibi else-if merdivenleri kaydırmalı bir biçimde yazılması gerektiği için görüntüyü bozmaktadır. 
    Bu görüntünün bozulmaması ve bu tür else-if merdivenlerinin daha kolay yazılması için Python'da if deyimin bir parçası olarak 
    elif kısmı da bulundurulmuştur. elif (else if'ten kısaltma) tamamen else if anlamına gelmektedir. Ancak yazımda if ile aynı 
    girinti düzeyine sahip olmak zorundadır. elif bir ifadeyle birlikte bulundurulur. elif kısımlarından sonra son bir else kısmı da 
    bulundurulabilmektedir. Örneğin:

    if a == 1:
        print('bir')
    elif a == 2:
        print('iki)
    elif a == 3:
        print('üç')
    elif a == 4:
        print('dört')
    elif a == 5:
        print('beş')
    else:
        print('hiçbiri')

#------------------------------------------------------------------------------------------------------------------------
a = int(input('Bir değer giriniz:'))

if a == 1:
    print('bir')
elif a == 2:
    print('iki')                    
elif a == 3:
    print('üç')
elif a == 4:
    print('dört')
elif a == 5:
    print('beş')
else:
    print('program sonlanıyor')                  

#------------------------------------------------------------------------------------------------------------------------
    Bir program parçasının yinelemeli olarak çalıştırılmasını sağlayan deyimlere döngü deyimleri denilmektedir. Python
    döngü deyimleri bakımından minimalist biçimde tasarlanmıştır. Python'da iki döngü deyimi vardır:

    1) while Döngüleri
    2) for Döngüleri 

    C/C++, Java ve C# gibi dillerde while döngüleri kendi aralarında "kontrolün başta yapıldığı while döngüleri" ve "kontrolün 
    sonda yapıldığı while döngüleri (do-while)" olmak üzere ikiye ayrılmaktadır. Ancak Python'da kontrolün sonda yapıldığı 
    while döngüleri yoktur.  
#------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------
                                                23. Ders - 27/06/2022-Pazartesi
#------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------
    while döngüsünün genel biçimi şöyledir:

    while <ifade>: <suite>

    while anahtar sözcüğünden sonra bir ifade ve sonra da ':' atomu bulunmak zorundadır. Bu ':' atomundan sonra da bir "suite"
    bulunmalıdır. 
#------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------
    while döngüsü şöyle çalışır: Yorumlayıcı önce while anahtar sözcüğünün sağındaki ifadenin türüne bakar. Eğer bu ifade
    bool türden değilse onu bool türüne dönüştürür. Sonra ifadenin değerine bakar. Eğer ifade True ise suit'i oluşturan deyimleri 
    çalıştırır ve başa döner. Eğer ifade False ise döngü deyiminin çalışması sonlandırılır. Program döngü deyiminden sonraki deyimle
    çalışmaya devam eder. Yani while döngüleri "bir ifade doğru olduğu sürece yinelenen" döngülerdir. 
#------------------------------------------------------------------------------------------------------------------------

i = 0
while i < 10:
    print(i)
    i += 1

#------------------------------------------------------------------------------------------------------------------------
    Aşağıdaki örnekte bir listenin elemanları while döngüsü ile yazdırılmaktadır.
#------------------------------------------------------------------------------------------------------------------------

a = [10, 20, 30, 40, 50]

i = 0
while i < len(a):
    print(a[i])
    i += 1

#------------------------------------------------------------------------------------------------------------------------
    Aşağıdaki örnekte de bir listenin elemanları while döngüsü ile sondan başa doğru yazdırılmaktadır.
#------------------------------------------------------------------------------------------------------------------------

a = [10, 20, 30, 40, 50]    

i = len(a) - 1
while i >= 0:
    print(a[i], end=' ')
    i -= 1
    
#------------------------------------------------------------------------------------------------------------------------
    Aşağıdaki örnekte 1'den klavyeden girilen sayıya kadar olan tamsayıların toplamı yazdırılmıştır. (Tabii aslında bu toplam 
    (n * (n + 1)) / 2 biçimindedir.)
#------------------------------------------------------------------------------------------------------------------------

n = int(input('Bir sayı giriniz:'))

i = 1
total = 0

while i <= n:
    total += i
    i += 1
    
print(total)

#------------------------------------------------------------------------------------------------------------------------
    while ifadesi bool türünden değilse bool türüne dönüştürülmektedir. Boş bir string'in ya da listenin bool türüne False olarak,
    dolu bir string'in ya da listenin True olarak dönüştürüldüğünü anımsayınız.
#------------------------------------------------------------------------------------------------------------------------

s = 'ankara'

while s:
    print(s)
    s = s[:-1]

#------------------------------------------------------------------------------------------------------------------------
    int ya da float bir değerin bool türüne sıfır dışı ise True olarak sıfır ise False olarak dönüştürüldüğünü anımsayınız.
    Dolaysıyla aşağıdkai örnekte i değeri 0'a geldiğinde döngüden çıkılacaktır. 
#------------------------------------------------------------------------------------------------------------------------

i = 10
while i:
    print(i)
    i -= 1

#------------------------------------------------------------------------------------------------------------------------
    Python'da atama operatörünün değer üretmediğini bunun için dile Walrus operatörünün eklendiğini anımsayınız. Aşağıdaki 
    while döngüsünde girilen sayının karesi ekrana yazdırılmaktadır. Ancak 0 girildiğinde döngü sonlandırılmaktadır. 
#------------------------------------------------------------------------------------------------------------------------

while (n := int(input('Bir değer giriniz:'))) != 0:
    print(n * n)

#------------------------------------------------------------------------------------------------------------------------
    Yukarıdaki kalıp çokça kullanılmaktadır. Pekiyi Walrus operatörü olmasaydı (yani eski Python sürümlerinde çalışyor olsaydık)
    aynı şeyi nasıl yapabilirdik? Aşağıdaki gibi bir çözüm akla gelebilir:
#------------------------------------------------------------------------------------------------------------------------

val = int(input('Bir değer giriniz:'))

while val != 0:
    print(val * val)
    val = int(input('Bir değer giriniz:'))

#------------------------------------------------------------------------------------------------------------------------
    Yukarıdaki çözümde rahatsız edici bir nokta vardır. input satırı kodda takrarlanmaktadır. Bu tekrarın aşağıdaki gibi
    engellenmesi de aklınıza gelebilir: 

    val = 1
    while val != 0:
        val = int(input('Bir değer giriniz:'))
        print(val * val)

    Ancak kodun bu biçimde organize edilmesi yine okunabilirliği bozmaktadır. Koda bakan kişi ne yapılmak istendiğini
    hemen anlayamayacaktır. O halde Walrus'lu kalıp gerçekten iyi işlev görmektedir:

    while (val := int(input('Bir değer giriniz:'))) != 0:
        print(val * val)

    Aslında zaten int değerler 0'dan farklıysa bool türüne True olarak dönüştürüldüğüne göre ifadedeki karşılaştırma 
    kısmını da atabiliriz:

    while val := int(input('Bir değer giriniz:')):
        print(val * val)

    Fakat bu yazım biçimi yerine açıkça karşılaştırma yapmak kodu daha anlaşılabilir hale getirecektir. 
#------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------
    İç içe döngüler söz konusu olabilir. Yani bir suit içerisinde başka bir döngü de olabilir. 
#------------------------------------------------------------------------------------------------------------------------

n = int(input('Bir sayı giriniz:'))

i = 1
while i <= n:
    k = 0
    while k < i:
        print('*', end='')
        k += 1
    print()
    i += 1

#------------------------------------------------------------------------------------------------------------------------
    Tabii yukarıdaki örneği aslında "yineleme (repitition)" ile çok daha kolay aşağıdaki gibi yapabilirdik.
#------------------------------------------------------------------------------------------------------------------------

n = int(input('Bir sayı giriniz:'))

i = 1
while i <= n:
    print('*' * i)
    i += 1

#------------------------------------------------------------------------------------------------------------------------
    Bilindiği gibi her sayı asal sayıların çarpımı biçiminde yazılabilir. Buna sayının "asal çarpanları (prime factors)"
    denilmektedir. Örneğin 100'ün asal çarpanları 2 * 2 * 5 * 5 biçimindedir. Bir sayının asal çarpanlarını bulmak 
    "düz mantıkla (brute force)" oldukça kolaydır. Sayı 1 olmadığı sürece döngüye sokulur. Sayının bölüneceği sayı bir değişkende 
    tutulur ve başlangıçta bu değişkenin içerisinde 2 vardır. Sayı bu sayıya bölündüğü sürece bölünerek ilerlenir. Sayı bu sayıya bölünmezse
    sonra sayı ile devam edilir. Aşağıda bu algoritma uygulanmıştır.
#------------------------------------------------------------------------------------------------------------------------

n = int(input('Bir sayı giriniz:'))

divider = 2
while n != 1:
    if n % divider == 0:
        print(divider, end=' ')
        n //= divider
    else:
        divider += 1
print()


#------------------------------------------------------------------------------------------------------------------------
    Bir problemi kesin çözüme götüren adımlar topluluğuna "algoritma (algorithm)" denilmektedir. Tabii söz konusu problemi
    çözebilecek birdenfazla alternatif algoritmalar söz konusu olabilir. Bu durumda bunların kıyaslanması gerekebilmektedir. 
    Algoritmaları kıyaslamak için en çok kullanılan iki temel ölçüt "hız" ve "kaynak kullanımı"dır. Ancak default ölüçüt
    olarak her zaman "hız" kullanılmaktadır. Alternatif algoritmaların hızlarını karşılaştırmak da o kadar olmayabilir. 
    Çünkü algoritmalar listeler gibi birtakım veri yapıları üzerinde işlemler yapıyor olabilir. Onların çalışma hızı o 
    veri yapısının dağılımına göre değişebilir. Örneğin falanca sort algoritması filance biçimdeki dizilerde daha hızlı çalışırken    
    başka dizilerde daha yavaş çalışıyor olabilir. Algoritmaların kıyaslanması sürecine genel olarak "algoritma analizi" 
    denilmektedir. 

    Bazen algortimaların kesin sonucu bulması mevcut bilgisayarlarla seneler sürüyor olabilir. Bu tür durumlarda kesin sonucu bulmak 
    yerine "nispeten tatimin edici" bir sonucun bulunması da arzu edilebilmektedir. Genellikle kesin çözümü bulmayan 
    bu tür adımlar topluluğuna "sezgisel yöntemler (heuristics)" denilmektedir. 
#------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------
    Python'da sonsuz döngü oluşturmak için while anahtar sözcüğünün yanındaki ifadeyi True yapabiliriz. Örneğin:

    while True:
        ...

    Burada koşul her zaman sağlanacağına göre bu döngü de her zaman yinelenecektir. Tabii bir döngünün sürekli dönmesi çoğu kez
    arzu edilen bir durum değildir. Şüphesiz sonsuz döngü için while yanındaki ifadeyi sıfır dışı herhangi bir sayı biçiminde de
    yazabiliri. Örneğin:

    while 1:
        ....

    Ancak sonsuz döngü oluşturmak için while anahtar sözcüğünün yanındaki ifadeyi açıkça True yapmak daha anlaşılabilir 
    bir durum oluşturur. Bir Python programı sonsuz döngüye girmişse komut o programı biz komut satırından çalıştırmışsak 
    Ctrl+C tuşları ile programı zorla durdurabiliriz. IDE'lerde durdurmak için fare durdurma simgesine tıklamak gerekir. 
    Aşağıdaki programı çalıştırıp zorla sonlandırmayı deneyiniz. 
#------------------------------------------------------------------------------------------------------------------------

i = 0
while True:
    print(i)
    i += 1

#------------------------------------------------------------------------------------------------------------------------
    Yukarıda da belrttiğimiz gibi Python'da C/C++, Java ve C# gibi dillerde bulunan "kontrolün sonda yapıldığı while 
    döngüleri (do-while döngüleri)" yoktur. Bazı algortimik problemlerde kontrolün sonra yapıldığı while döngüleri 
    işlemleri kolaylaştırabilmektedir. 
#------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------
    for döngülerinin genel biçimi şöyledir:

    for <değişken> in <dolaşılabilir nesne>: <suite>

    Python'da for döngüleri C/C++, Java ve C#'taki belli bir miktar yinelemeye yol açan tarzda for döngüleri değildir. Python'daki 
    for döngüleri diğer bazı dillerdeki "foreach" döngüleri gibidir. Yani Python'da for döngüleri aslında dolaşılabilir nesneleri 
    dolaşan bir döngüdür. 
    
    for döngüleri şöyle çalışır: Döngünün her yinelenmesinde dolaşılabilir nesnenin sıradaki elemanı döngü değişkenine 
    atanır. (Tabii aslında onun adresi döngü değişkenine atanır.) Sonra suit çalıştırılır. Böylece elemanlar sırasıyla tek tek 
    for döngüsündeki değişkene atanmış olur. Dolaşılabilir nesne bittiğinde dolaşım da biter.
    Örneğin:

    a = [10, 20, 30, 40, 50]
    for x in a:
        print(x)

    Burada döngünün her yinelenmesinde x'e listenin elemanları (yani o elemanların adresleri) atanacaktır. Liste elemanları 
    bittiğinde döngü bitecektir. Tabii aslında döngü değişkenine atama bir adres atamasıdır. Yani yukarıdaki örnekte aslında 
    x' sırasıyla 10, 20, 30, 40, 50 nesnelerinin adresleri atanmaktadır.
#------------------------------------------------------------------------------------------------------------------------

a = [10, 20, 30, 40, 50]

for x in a:
    print(x, end=' ')
    
print()

i = 0
while i < len(a):
    print(id(a[i]))
    i += 1

print()
   
for x in a:
    print(id(x))
    
#------------------------------------------------------------------------------------------------------------------------
    Biz for döngüleri ile dolaşılabilir olan her nesneyi dolaşabiliriz.
#------------------------------------------------------------------------------------------------------------------------

s = 'ankara'

for c in s:
    print(c)

#------------------------------------------------------------------------------------------------------------------------
    Bir sözlük dolaşıldığında sözlüğün anahtarlarının elde edildiğini anımsayınız.
#------------------------------------------------------------------------------------------------------------------------

d = {'ali': 58, 'veli': 87, 'selami': 59, 'ayşe': 98, 'fatma': 81}

for x in d:
    print(x)

#------------------------------------------------------------------------------------------------------------------------
    Dolaşılabilir olmayan nesnelere for döngüüsyle dolaşılamazlar. Örneğin:

    a = 10

    for x in a:
        print(x)

    Burada in anahtar sözcüğünün yanındaki ifade int türdendir. int türü de dolaşılabilir bir tür değildir. Dolayısıyla burada 
    bir error oluşaacaktır.
#------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------
    Biz Python'da C/C++, Java ve C# gibi dillerdeki for döngülerini range fonksiyonu ile emüle edebiliriz. Örneğin:

    for i in range(n):
        ...

    Bu for döngüsü C'deki aşağıdaki for döngüsüne benzemektedir:

    for (i = 0; i < n; ++i) {
        ...
    }
#------------------------------------------------------------------------------------------------------------------------

for i in range(10):
    print(i, end=' ')

#------------------------------------------------------------------------------------------------------------------------
    Bir listeyi dolaşmak isteyelim. for döngüsü ile iki alternatif yöntem kullanılabilir. Birincisi indeks yoluyla dolaşma 
    olabilir. Örneğin:

    a = [10, 20, 30, 40, 50]

    for i in range(len(a)):
        print(a[i], end=' ')

İkincisi liste dolaşılabilir bir nesne olduğuna göre onu doğrudna dolaşmak olabilir. Örneğin:

    for x in a:
        print(x, end=' ')

#------------------------------------------------------------------------------------------------------------------------

a = [10, 20, 30, 40, 50]

for i in range(len(a)):
    print(a[i], end=' ')
 
print()

for x in a:
    print(x, end=' ')

#------------------------------------------------------------------------------------------------------------------------
    for döngüsünde biz döngü değişkenini değiştirmekle dolaşılabilir nesneyi değiştirmiş olmayız. Örneğin bir listenin
    elemanlarını onların kareleriyle değiştirmek isteyelim. Bunu şöyle yapamayız:

    for x in a:
        x = x ** 2

    Çünkü biz burada x'i değiştiriyoruz, a'da bir değişiklik yapmıyoruz. Bu tür durumlarda indeks yoluyla listeye erişmek gerekir. Örneğin:

    for i in range(len(a)):
        a[i] = a[i] ** 2

    Burada gerçekten liste elemenaı değiştirilmiştir. 

#------------------------------------------------------------------------------------------------------------------------

a = [1, 2, 3, 4, 5]

for x in a:
    x = x ** 2
    
print(a)

for i in range(len(a)):
    a[i] = a[i] ** 2

print(a) 

#------------------------------------------------------------------------------------------------------------------------
    Tabii dolaşılabilir bir nesne de dolaşılabilir nesnelerden oluşuyor olabilir. Örneğin bir demet listesi söz konusu olabilir. 
    Bu durumda biz listeyi dolaştığımızda demetleri elde ederiz:

    a = [(1, 2), (3, 4), (5, 6), (7, 8), (9, 10)]

    for t in a:
        print(t)

    Burada her dolaşımda elde edilen demetler de iç bir for döngüsüyle dolaşılabilir. Örneğin:

    for t in a:
        for k in t:
            print(k, end=' ')
        print()
        
#------------------------------------------------------------------------------------------------------------------------

a = [(1, 2), (3, 4), (5, 6), (7, 8), (9, 10)]

for t in a:
    print(t)

print()

for t in a:
    for k in t:
        print(k, end=' ')
    print()

#------------------------------------------------------------------------------------------------------------------------
    Eğer for döngüsü ile dolaşımda dolaştıkça elde edilen nesneler de dolaşılabilir ise biz "açım (unpacking)" işlemini for 
    dönüsünün içerisinde yapabiliriz. Örneğin:

    a = [(1, 2), (3, 4), (5, 6), (7, 8), (9, 10)]

    for t in a:
        x, y = t
        ...

    Bu işlemi for içerisinde de tek hamlede de yapabiliriz:

    for x, y in a:
        ...

    Tabii bu açım işleminde köşeli parantezler ya da normal parantezler de kullanılabilir. Ancak gereksizdir. Örneğin:

    for [x, y] in a:
        print(x, y)

    for (x, y) in a:
        print(x, y)

#------------------------------------------------------------------------------------------------------------------------

a = [(1, 2), (3, 4), (5, 6), (7, 8), (9, 10)]

for t in a:
    x, y = t
    print(x, y)

print()

for x, y in a:
    print(x, y)

#------------------------------------------------------------------------------------------------------------------------
    Python'da _ aslında normal bir değişken ismi olarak kullanılabilmektedir. Ancak genel olarak programcılare _ ismini 
    "ben bu değişkenle ilgilenmiyorumi yalnızca bu değişkeni yer turucu olarak kullanıyorum" anlamında kullanmaktadır. Örneğin biz
    1000 kere dönen bir döngüde bir şeyler yapacak olalım. Ancak döngü değişkenini hiç döngü içerisinde kullanmayacak olalım. Bu durumu
    vurgulamak için döngü değişkeni için _ ismini kullanabiliriz. 
#------------------------------------------------------------------------------------------------------------------------

for _ in range(1000):
    pass

#------------------------------------------------------------------------------------------------------------------------
    Sözlüklerin de dolaşılabilir olduğunu, sözlükleri dolaştıkça anahtarların elde edildiğini anımsayınız. Tabii elimizde 
    bir anahtar varsa biz onun değerini de eld edebiliriz. 
#------------------------------------------------------------------------------------------------------------------------

d = {'ali': 10, 'veli': 20, 'selami': 30, 'ayşe': 40, 'fatma': 50}

for key in d:
    print(key, d[key])

#------------------------------------------------------------------------------------------------------------------------
    dict sınıfının items isimli metodunuın bize dolaşılabilir bir nesne verdiğini, o nesne dolaşıldığında da anahtar değer 
    çiftlerindne oluşan demetlerin elde edildiğini anımsayınız. O zaman biz sözlükteki anahtar değer çiftlerini şöyle de elde edebiliriz:

    for key, value in d:
        print(keyi value)
#------------------------------------------------------------------------------------------------------------------------

d = {'ali': 10, 'veli': 20, 'selami': 30, 'ayşe': 40, 'fatma': 50}

for t in d.items():
    print(t)
    
print()

for key, value in d.items():
    print(key, value)

#------------------------------------------------------------------------------------------------------------------------
    Dolaşılabilir bir nesneyi tersten dolaşabilir miyiz? Bunun yanıtı "o nesneye ilişkin sınıfı yazan kişi buna izin verdiyse
    dolaşabiliriz" biçimindedir. Tabii str gibi, list gibi, tuple gibi nesneler ters indekslemeyle ya da ters çeviren dilimleme 
    ile terten dolaşılabilirler. Bu türlere daha önceden de belirttiğimiz gibi "sequence type" denilmektedir. Pekiyi ya 
    dolaşılabilir nesne bir "sequence type" değilse?

    Aşağıda bir listenin tersten dolaşımına bir örnek görüyorsunuz.
#------------------------------------------------------------------------------------------------------------------------

a = [10, 20, 30, 40, 50]

for i in range(len(a) - 1, -1, -1):
    print(a[i], end=' ')
   
print()

for x in a[::-1]:
    print(x, end=' ')

#------------------------------------------------------------------------------------------------------------------------
    Tersten dolaşmanın daha genel bir biçimi daha önce görmüş olduğumuz "reversed" fonksiyonunu kullanmaktadır. Anımsanacağı gibi 
    reversed fonksiyonu bize tersten dolaşılabilir bir nesne vermekteydi. O zaman tersten dolaşımı aşağıdaki gibi de yapabiliriz.
#------------------------------------------------------------------------------------------------------------------------

a = [10, 20, 30, 40, 50]

for x in reversed(a):
    print(x, end=' ')

#------------------------------------------------------------------------------------------------------------------------
    Tabii biz her dolaşılabilir nesneyi reversed fonksiyonuna sokamayız. Bir dolaşılabilir nesnenin tersten dolaşılabilirliği o sınıfı 
    yazanlar tarafından sağlanmaktadır. Örneğin kümeler dolaşılabilir nesnelerdir. Kümeler dolaşıldığında elemanların hangi sırada elde 
    edileceğinin bir garantisi yoktur. Ancak kümeler tersten dolaşılabilir değildir. Daha önceden de belirtildiği gibi Python'da sonradan
    3.7 versiyonu ile birlikte sözlükler dolaşılırken elemanların onların ekleme sırasına göre dolaşılması garanti edilmiştir. 
    Bu eklemeden sonra artık sözlükler de reversed fonksiyonu ile tersten dolaşılabilir hale gelmiştir. 
#------------------------------------------------------------------------------------------------------------------------

d = {10: 'ali', 20: 'veli', 5: 'selami'}

d[100] = 'sacit'
d[300] = 'fehmi'

for x in reversed(d):
    print(x)

#------------------------------------------------------------------------------------------------------------------------
                                                24. Ders - 29-06/2022-Çarşamba
#------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------
    break deyimi yalnızca döngüler içerisinde kullanılabilir. Genel biçimi şöyledir:

    break

    Programın akışı break anahtar sözcüğünü gördüğünde döngü deyimi sonlandırılır ve akış döngüden sonraki ilk deyim ile devam eder.
    Tabii genellikle break bir koşul ile birlikte kullanılır. Örneğin:

    while True:
        ...
        if koşul:
            break
        ...

#------------------------------------------------------------------------------------------------------------------------

while True:
    val = float(input('Bir sayı giriniz:'))
    if val == 0:
        break
    print(val * val)

#------------------------------------------------------------------------------------------------------------------------
    İç içe döngülerde break yalnızca kendi döngüsünü sonlandırmaktadır. 
#------------------------------------------------------------------------------------------------------------------------

for i in range(10):
    for k in range(10):
        print(f'({i},{k})')
        s = input()
        if s == 'quit':
            break
    if s == 'quit':
        break

#------------------------------------------------------------------------------------------------------------------------
    Programın akışı continue anahtar sözcüğünü gördüğünde döngü başa sararak yeni bir yinelemeye geçilir. break deyimi 
    döngünün kendisini sonlandırırken continue deyimi döngü içerisindeki suite'i sonlandırmaktadır. Yani akış continue 
    deyimini gördüğünde sanki suit bitmiş de yeni bir yineleme yapılıyormuş gibi bir etki oluşur. Ancak continue 
    deyimine break deyiminden çok daha seyrek gereksinim duyulmaktadır.

    Aşağıdaki örnekte çift sayılarda programın akışı continue deyimini gördüğü için döngü başa sarmaktadır. Dolayısıyla ekrana 
    yalnızca tek sayılar basılacaktır.
#------------------------------------------------------------------------------------------------------------------------

for i in range(10):
    if i % 2 == 0:
        continue
    print(i)

#------------------------------------------------------------------------------------------------------------------------
    continue deyimi genellikle döngü içerisindeki uzun if bloklarını elimine etmek için kullanılmaktadır. Örneğin:

    while True:
        a = int(input()):
        if a % 7 == 0:
            ...
            ...
            ...
            ...
            ...

    Bu döngü continue ile daha analaşılabilir bir hale getirilebilir:

    while True:
        a = int(input()):
        if a % 7 != 0:
            continue
        ...
        ...
        ...
        ...
        ...

    Aşağıdaki örnekte bir komut satırı (ya da REPL) ortamı yaratılmak istenmiştir. Programda bir prompt eşliğinde bir komut 
    girilmesi istenmektedir. Eğer komut önceden belirlenen komutlardan bir tanesi ise ilgili işlem yapılmakta, değilse ekrana 
    "invalid command!" yazısı çıkartılmaktadır. Eğer kişi yalnızca boşluklar girerek ENTER tuşuna basarsa bu durumda 
    continue ile akış başa sardırılmıştır.
#------------------------------------------------------------------------------------------------------------------------

while True:
    print('CSD>', end='')
    cmd = input().strip()
    if cmd == '':
        continue
    if cmd == 'quit':
        break
    if cmd == 'copy':
        print('copy command executes...')
    elif cmd == 'rename':
        print('rename command executes...')
    elif cmd == 'dir':
        print('dir command executes...')
    else:
        print('invalid command!')

#------------------------------------------------------------------------------------------------------------------------
    Bir sayının basamak sayısını bulmak için bir döngü içerisinde sayı sürekli 10'a bölünebilir ve bu işlemin kaç kere yapıldığı
    hesaplanabilir. 
#------------------------------------------------------------------------------------------------------------------------

a = int(input('Bir sayı giriniz:'))

count = 0
while a:
    count += 1
    a //= 10

print(count)

#------------------------------------------------------------------------------------------------------------------------
    Tabii aslında sayının basamak sayısı hiç döngü kullanmadan 10 tabanına göre logaritmasının 1 fazlası olarak elde edilebilir. 
    10 tabanına göre logaritma hesabı yapan standart math modülünde log10 isimli bir fonksiyon vardır. Bu fonksiyon sonucu bize 
    float olarak verir. float sayıyı noktadan kurtarmak için int dönüştürmesi yapılabilir. 
#------------------------------------------------------------------------------------------------------------------------

import math  
    
a = int(input('Bir sayı giriniz:'))
result = int(math.log10(a)) + 1
print(result)

#------------------------------------------------------------------------------------------------------------------------
    Alternatif bir çözüm de int türden sayıyı önce yazıya yani str türüne dönüştürmek sonra uzun karakter uzunluğuna bakmak 
    olabilir.
#------------------------------------------------------------------------------------------------------------------------

val = int(input('Bir sayı giriniz:'))

result = len(str(val))
print(result)

#------------------------------------------------------------------------------------------------------------------------
    Python'da pass deyimi "boş deyim" anlamına gelmektedir. Normalde if gibi while gibi for gibi deyimlerde bir suite bulundurmak 
    zorunludur. Ancak bazen biz içi boş bir suit oluşturmak isteyebiliriz. İşte o zaman pass deyimi kullanılır. Örneğin:

    for _ in range(10000000):
        pass

    Burada programcı for döngüsünün içerisinde bir şey yapmak istememiştir. Burada programcının belki de amacı akışı bir süre 
    meşgul bir döngüde bekletmektir. C, C++, Java ve C# gibi dillerde ';' boş deyim anlamına  gelir. Ancak Python'da böyle 
    bir kullanım yoktur.. 
#------------------------------------------------------------------------------------------------------------------------

for i in range(10):
    print(i)
    for k in range(10000000):
        pass
        
#------------------------------------------------------------------------------------------------------------------------
    Örneğin biz kullanıcıyı pozitif bir değer girme konusunda zorlamak istebiliriz. Bunu bir while döngüsü içerisinde Walrus
    operatörü kullanarak sağlayabiliriz. Ancak bu durumda gerçekten de döngünün içerisinde yapacak bir şey kalmamaktadır. 
    O halde biz de pass deyimi ile sentaksın gereksinim duyduğu deyimi suite yerine yerleştirebiliriz. 
#------------------------------------------------------------------------------------------------------------------------

while (val := int(input('Pozitif bir sayı giriniz:'))) <= 0:
    pass

print(val ** 0.5)
        
#------------------------------------------------------------------------------------------------------------------------
    Yukarıdaki örneklerde kişiler sanki pass deyimi gereksizmiş gibi bir izlenime kapılabilmektedir. continue bir deyim olduğuna 
    göre ve sonraki yinelemeye geçmeyi sağladığına göre yukarıdaki örneklerde pass yerine continue yerleştirsek aynı durumu 
    oluşturabiliriz. Örneğin:

    for _ in range(10000000):
        pass

    ile aşağıdaki deyim arasında işleyiş bakımından gerçekten bir fark yoktur:

    for _ in range(10000000):
        continue

    Ancak continue deyimi pass deyiminin yerini tutamamaktadır. Çğnkü continue deyimi yalnız döngülerde kullanılabilmektedir. 
    Halbuki pass deyimi normal bir deyimdir. Her yerde kullanılabilir. Örneğin ilerleyen zamanlarda fonksiyonlar konusunu 
    göreceğiz. Fonksiyonlar da suit içermektedir. Dolayısıyla örneğin içi boş bir fonksiyon yazmak için continue deyimini kullanamayız. 
    Fakat pass deyimini kullanabiliriz:

    def foo():
        pass
#------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------
    Tabii aslında pass deyimi suite içerisinde kullanılmak zorunda değildir. Herhangi bir yerde kullanılabilir. pass deyimi 
    hiçbir işleme yol açmaz. Şüphesiz herhangi bir yerde gereksiz pass kullanımı da kötü bir tekniktir. Örneğin:

    x = 10
    pass                # gerek yok, kötü teknik!
    print(x)
    pass                # gerek yok, kötü teknik!
    print(x * x)
            
#------------------------------------------------------------------------------------------------------------------------
    pass deyimi ileride görecek olduğumuz fonksiyonlar, sınıflar gibi deyimlerde de boş suit oluşturmak amacıyla da
    kullanılabilmektedir:

    def foo():      # içi boş fonksiyon
        pass

    class Sample:   # içi boş sınıf
        pass
#------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------
                                                25. Ders 04/07/2022 - Pazartesi
#------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------
    Python'da diğer bazı dillerdeki gibi bir switch deyimi yoktu. Ancak Python'un 3.10 versiyonuyla birlikte dile "match"
    adı altında switch benzeri bir deyim eklenmiştir. Kursun yapıldığı sırada Python'un son versiyonu 3.11.4'tür. Dolayısıyla 
    aşağıda açıklanacak olan match deyiminin çalıştırılması için yorumlayıcınızın versiyonuna dikkat ediniz. Eğer Anaconda dağıtımında 
    çalışıyorsanız. "Envrionment" sekmesinden yeni bir "Virtual Envirionment" yaratıp Python'un en güncel versiyonunu yükleyebilirsiniz. 

    Python'daki match deyimi diğer bazı dillerdeki switch deyimininden daha ayrıntılı ve daha yeteneklidir. match deyimi
    "Structural Pattern Matching" başlığı altında PEP-634 dokmanında açıklanmıştır. PEP-636 dokğmanı da eğtici (tutorial) biçimde 
    hazırlanmıştır.
#------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------
    match deyiminin genel biçimi şöyledir:

    match <ifade>:
        case <kalıp>:
            <suit>
        case <kalıp>:
            <suit>
        case <kalıp>:
            <suit>
        ....

    match deyimi şöyle çalışmaktadır: Yorumlayıcı Önce match anahtar sözcüğünün yanındaki ifadeyi inceler. Sonra case 
    bölümlerini sırasıyla gözden geçirir. match ifadesi ile case bölümlerinde kalıp uyuşursa ilk uyuşan case bölümündeki 
    suite'i çalıştırır. 
    
    Diğer bazı dillerde olduğu gibi Python'da case bölümleri break gibi bir deyimle sonlandırılmanaktadır. match deyiminde
    zaten bir case kalıbı ile uyuşum sağlandığında yalnızca o case bölümündeki deyimler çalıştırılmaktadır. match deyiminde 
    diğer bazı dillerde olduğu gibi "aşağıya düşme (fall through)" mekazizması yoktur. Bir case bölümü uyuşumu sağlarsa yalnızca
     o case bölümü çalıştırılır. Sonra match deyimi biter ve programın akışı sonraki deyim ile devam eder. 

    Python'ın match deyiminde case bölümlerinde birden fazla uyuşum söz konusu olabilir. Bu durumda yukarıdan aşağıya doğru ilk uyuşan case bölümü 
    çalıştırılmaktadır. 
#------------------------------------------------------------------------------------------------------------------------

a = int(input('Bir değer giriniz:'))

match a:
    case 1:
        print('bir')
    case 2:
        print('iki')
    case 3:
        print('üç')
    case 4:
        print('dört')
    case 5:
        print('beş')

#------------------------------------------------------------------------------------------------------------------------
    Diğer bazı dillerde switch deyiminin eğer hiçbir case bölümü uyuşum sağlamazsa çalıştırılan bir "default" bölümü vardır. 
    Python'ın match deyiminde "default" bölüm yoktur. Ancak onunla aynı anlama gelen _ kalıbı vardır. Bu kalıp eğer yukarıdaki 
    kalıpların hiçbiri uyum sağlamazsa uyum sağlar. _ kalıbı case bölümlerinin sonuna yerleştirilmek zorundadır. (C, C++, 
    Java ve C# gibi dillerde default bölümün sonda olması zorunlu değildir.)
#------------------------------------------------------------------------------------------------------------------------

a = int(input('Bir değer giriniz:'))

match a:
    case 1:
        print('bir')
    case 2:
        print('iki')
    case 3:
        print('üç')
    case 4:
        print('dört')
    case 5:
        print('beş')
    case _:
        print('hiçbiri')

#------------------------------------------------------------------------------------------------------------------------
    Yukarıda belirttiğimiz gibi Python'a eklenen match deyimi oldukça detaylı ve yetenekli bir deyimdir. case bölümlerindeki
    kalıplar değişik biçimde oluşturulabilmektedir. Yukarıdaki örneklerde biz case anahtar sözcüğünün yanına birer sabit yazdık. 
    (Buraya diğer dillerdeki gibi sabit ifadeleri yazamayız. Tek bir sabit yazmak zorundayız). Bu tür kalıplara "sabit kalıpları 
    (iteral patterns)" denilmektedir. Sabit kalıpları tek bir sabittten oluşur. Bu sabitler string de olabilir. 
#------------------------------------------------------------------------------------------------------------------------

s = input('Bir şehir giriniz:')

match s:
    case 'ankara':
        print('06')
    case 'eskişehir':
        print('26')
    case 'kocaeli':
        print('41')
    case 'adana':
        print('01')
    case 'izmir':
        print('35')
    case _:
        print('hiçbiri')

#------------------------------------------------------------------------------------------------------------------------
    Bir case bölümünde "veya" biçiminde birden fazla kalıp "|" atomu ile oluşturulabilmektedir. Bu kalıba "veya kalıbı (or pattern)" 
    denilmektedir. Örneğin:

    case 1 | 2 | 3:
        pass

    Burada bu kalıplardan herhangi biri uyuşum sağlarsa ilgili case bölümü çalıştırılır. 
#------------------------------------------------------------------------------------------------------------------------

while True:
    cmd = input('CSD>').strip()
    if cmd =='':
        continue
    match cmd:
        case 'copy':
            print('copy executes')
        case 'rename':
            print('rename executes')
        case 'del' | 'erase' | 'remove':
            print('delete executes...')
        case 'quit' | 'exit':
            break
        case _:
            print(f'invalid command: {cmd}')

#------------------------------------------------------------------------------------------------------------------------
    Veya kalıbında veya kalıbını parantez içerisine alarak case bölümüne bir "as" cümleceği ekleyebiliriz. as cümleceğini 
    bir değişken izler bu değişken hangi veya kalıbı uyuşum sağladıysa onun değerini barındırır. Örneğin:

     case ('del' | 'erase' | 'remove') as as_cmd:
            print(f'{as_cmd} executes...')

    Burada del, erase ya da remove komutlarından hangisi yazılmışsa as_cmd onu belirtecektir. Aşağıdaki örnekte veya kalıbında
    as cümleceği kullanılmıştır. Bu örnekte zaten match ifadesi uyuşum sağlayan komutu içerdiğine göre as cümleceği gereksizmiş 
    düşünülebilir. Ancak as cümleceği diğer kalıplarda da kullanılabilmektedir. Bu tür durumlarda faydalı durumlara yol açabilmektedir. 
    
    Eğer ilgili case bölümü uyuşum sağlamazsa as anahtar sözcüğünün yanındaki değişken hiç yaratılmamış olacaktır. Bu nedenle buradaki as değişkenini
    match deyimi dışında kullanırken dikkat ediniz. 
#------------------------------------------------------------------------------------------------------------------------

while True:
    cmd = input('CSD>').strip()
    if cmd =='':
        continue
    match cmd:
        case 'copy':
            print('copy executes')
        case 'rename':
            print('rename executes')
        case ('del' | 'erase' | 'remove') as as_cmd:
            print(f'{as_cmd} executes...')
        case 'quit' | 'exit':
            break
        case _:
            print(f'invalid command: {cmd}')

#------------------------------------------------------------------------------------------------------------------------
    case bölümlerinde kullanılabilen diğer önemli bir kalıp da "dizilim (sequence)" kalıbıdır. Eğer match anahtar sözcüğünün 
    yanındaki ifade bir "dizilim türünden (sequence type)" ise (burada string dizilim türünden kabul edilmemektedir) bu durumda 
    case bölümleri dizilim kalıbına sahip olabilir. Standartlarda ve PEP 634'te dizilim türlerinin neler olduğu açıklanmıştır. 
    Ancak biz kursta dizilim türü için geldiğimiz noktaya kadar görmüş olduğumuz "list" ve "tuple" türlerini kullanabiliriz. 
    O halde özetle bizim bir dizilim kalıbını kullanabilmemiz için match yanındaki ifadenin bir liste ya da demet olması gerekir. 
    Bu durumda case yanındaki ifade de bir liste, demet olabilir. match anahtar sözcüğünün yanındaki ifadenin liste ya da demet 
    olması ve case anahtar sözcüğünün yanındaki ifadenin liste demet olması tamamen aynı etkiyi yaratmaktadır. Bu durumda dizilim 
    kalıbında case anahtar sözcüğünün yanındaki ifade aşağıdaki biçimlerden birine ilişkin olur:

    case [val1, val2, val3, ..., valn]:
    case (val1, val2, val3, ..., valn):
    case val1, val2, val3, ..., valn:

    Bu biçimlerin hepsi birbirleriyle eşdeğerdir. Aralarında hiçbir farklılık yoktur. Burada uyuşum için dizilimdeki
    elemanların sırasıyla val1, val2, val3, ..., valn ile aynı olması gerekmektedir. 

    Aşağıdaki örnek yukarıdaki örneğin dizilim kalıplı biçimidir. Ancak aslında dizilim kalıbının kullanılma nedeni aşağıdaki 
    örnekle örtüşmemektedir. Dizilim kalıplarında as cümleceği matsch yanındaki ifade hangi türden dizilim olursa olsun her zaman bir listedir. 

#------------------------------------------------------------------------------------------------------------------------

while True:
    cmd = input('CSD>').split()
    if len(cmd) == 0:
        continue
    match cmd:
        case 'copy', :
            print('copy executes')
        case ['rename']:
            print('rename executes')
        case (['del'] | ['erase'] | ['remove']) as as_cmd:
            print(f'{as_cmd[0]} executes...')
        case ['quit'] | ['exit']:
            break
        case _:
            print(f'invalid command: {cmd[0]}')

#------------------------------------------------------------------------------------------------------------------------
    Dizilim kalıbında dizilimin elemanları olarak sabit yerine  değişken isimleri de bulundurulabilir. Bu durumda uyuşum her 
    zaman sağlanır ve dizilimin ilgili elemanı o değişkene atanır. Örneğin:

    case ['del', path]:
        pass

    Buradaki dizilim kalıbı şu anlama gelmektedir: "Dizilimin birinci elemanı 'del' yazısı ikinci elemanı herhangi bir şey olabilir. 
    Ancak bu herhangi bir şey her ne ise path değişkenine atanacaktır." Dolayısıyla bu kalıp aşağıdaki gibi dizilimlerle eşleşebilir:

    ['del', 'a.txt']
    ('del', 'b.txt')
    ['del', 123]
    ...

    Burada biz hem del eşleşmesini sağlayıyoruz hem de del komutunun yanındaki yazıyı elde etmiş oluyoruz. Tabii yukarıdaki kalıp aşağıdaki gibi 
    bir dizilimle uyuşmaz:

    ['del', 'a.txt', 'b.txt']

    Çünkü kalıptaki path tek bir eleman anlamına gelmektedir. Yukarıdaki kalıp aşağıdakiyle de eşleşmez:

    ['del']
#------------------------------------------------------------------------------------------------------------------------

while True:
    cmd = input('CSD>').split()
    if len(cmd) == 0:
        continue
    match cmd:
        case 'copy', source_path, dest_path:
            print(f'copy {source_path} {dest_path} executes')
        case 'rename', source_path, dest_path:
            print(f'rename {source_path} {dest_path} executes')
        case (['del', path] | ['erase', path] | ['remove', path]) as as_cmd:
            print(f'{as_cmd[0]} {path} executes')
        case ['quit'] | ['exit']:
            break
        case _:
            print(f'invalid command: {cmd[0]}')

#------------------------------------------------------------------------------------------------------------------------
                                                    26. Ders 04/07/2022 - Çarşamba
#------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------
    Dizilim kalıbında dizilimin bir elemanı *'lı bir isimden oluşabilir. Ancak dizilimde tek bir *'lı eleman olabilir. 
    *'lı eleman sıfır ya da daha fazla elemanla uyuşum sağlar. *'lı elemanda *'ın yanındaki değişken her zaman list türünden 
    olmaktadır. Bu değişken uyuşum sağlayan elemanları barındıran bir list nesnesi biçimindedir. Örneğin:

   a = [10, 20, 30, 40, 50]

    match a:
        case 10, 20, *others:
            print(others)         # [30, 40, 50]
        #....

    Burada birinci case uyuşum sağlayacaktır. Dizilimin 30, 40, 50 elemanları bir liste olarak others değişkenine atanacaktır. 
    Yukarıda da belirttiğimiz gibi burada dizilim ne olursa olsun *'lı eleman her zaman liste olur. case anahtar sözcüğünün yanında 
    birden fazla *'lı eleman içeren dizilim kullanılamaz. Ancak *'lı eleman tipik olarak sonda bulunuyor olsa da aslında sonda bulunmak 
    zorunda değildir. Örneğin:

    a = [10, 20, 30, 40, 50]

    match a:
        case 10, *others, 50:
            print(others)               # [20, 30, 40]

    Dizilim kalıbında uyuşumun sağlanması için her zaman dizilimin tüm elemanlarının case içerisinde eşleştirilmiş olması gerekmektedir. Örneğin
    aşağıdaki case uyuşum sağlamaz:

    a = [10, 20, 30, 40, 50]

    match a:
        case 10, *others, 40:
            print(others)               

    Ancak aşağıdaki case uyuşum sağlar:

    a = [10, 20, 30, 40, 50]

    match a:
        case 10, *others, 40, 50:
            print(others)           # [20, 30]

    Dizilim kalıbında case bölümünde birtakım değişken isimleri yazılabilir. Bu durumda bu değişken isimleri her zaman uyuşum sağlar ve 
    uyuşum sağlandığında bu değişken isimlerine dizilimin ilgili elemanları atanmış olur. Örneğin:

    a = [10, 20, 30, 40, 50]

    match a:
        case 10, x, y, 40, 50:
            print(x, y)         # 20 30

    Burada x ve y her zaman uyuşum sağlayacaktır ve x'ya 20, y'ye de 30 atanacaktır. 

    a = [10, 20, 30, 40, 50]

    match a:
        case 10, x, y, 40, 50:
            print(x, y)         # 20 30

    Eğer buradaki değişkenin önemi yoksa bu durumda genellikle _ tercih edilir. Normalde Python'da _ aslında geçerli bir değişken ismidir. 
    Ancak match deyiminde _ bir değişken olarak değil "wildcard pattern" denilen, "her zaman uyuşum sağlama anlamında kullanılmaktadır. Örneğin:

    a = [10, 20, 30, 40, 50]

    match a:
        case 10, _, _, 40, 50:
            print('matched')        # Artık _ değişkenini burada kullanamayız, özel anlamı var
  
#------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------
    case anahtar sözcüğünün yanındaki ifade bir değişken olursa buna "capture pattern" denilmektedir. Bu durumda bu değişkenin 
    içerisindeki değere bakılmaz. Uyuşumun her zaman sağlandığı kabul edilir ve match ifadesi bu değişkene atanır. Tabii 
    "capture pattern" her şeye uyum sağladığı için case bölümlerinin sonuna yerleştirilmelidir. Eğer "capture pattern" case 
    bölümlerinin sonuna yerleştirilmezse sentaks error oluşur.
#------------------------------------------------------------------------------------------------------------------------

a = int(input('Bir değer giriniz:'))
match a:
    case 10:
        print('on')
    case 20:
        print('yirmi')
    case x:     # capture pattern
        print(f'x = {x}')            # a neyse o yazdırılır

#------------------------------------------------------------------------------------------------------------------------
    Diğer bir case kalıbı da "sözlük kalıbı (mapping pattern)" denilen kalıptır. Bu kalığta match yanındaki ifade bir sözlüktür 
    Bu durumda case anahtar sözcüğünün yanında da bir sözlüğün bulunması gerekir. Tabii sözlük doğrudan küme parantezleriyle 
    yazılmalıdır. Bu durumda case bölümüne yazılan sözlük ifadesinde anahtar-değer çiftleri uyuşursa case uyuşumu sağlanmış 
    kabul edilir. Dizilim kalıbına benzemeyen biçimde sözlük kalıbında match ifadesindeki sözlüğün her elemanının case bölümündeki 
    sözlükle uyuşması gerekmemektedir. Önemli olan case bölümündeki sözlüğün yazılan elemanlarının uyuşumudur. Uyuşum hem 
    anahtar hem değer ile yapılır. 
#------------------------------------------------------------------------------------------------------------------------

d = {'ali': 10, 'veli': 20, 'selami': 30, 'ayşe': 40, 'fatma': 50}

match d:
    case {'ali': 10, 'veli': 60}:
        print('match etmeyecek')
    case {'selami': 30, 'ayşe': 40}:
        print('match edecek')       # match edecek

#------------------------------------------------------------------------------------------------------------------------
    Sözlük kalıbında değerde _ kullanılırsa değerin her zaman uyuştuğu kabul edilir. Örneğin:

    case {'ali': 10, 'veli': _}:
        pass

    Burada anahtar 'veli' ancak değer ne olursa olsun uyuşum sağlanmaktadır. _ karakteri yalnızca sözlüğün değerlerinde 
    kullanılabilmektedir. Anahtarlarında kullanılamamaktadır. 
#------------------------------------------------------------------------------------------------------------------------

d = {'ali': 10, 'veli': 20, 'selami': 30, 'ayşe': 40, 'fatma': 50}

match d:
    case {'ali': 10, 'veli': _}:
        print('match edecek')           # match edecek

#------------------------------------------------------------------------------------------------------------------------
    Aslında kalıptaki sözlüğün değer kısmında bir değişken ismi de getirilebilir. Bu durumda anahtar uygunsa değer her zaman 
    uyuşma sağlar ve değer de aynı zamanda buradaki değişkene yerleştirilir. Örneğin:

    case {'ali': 10, 'veli': x}:
        print(x)

    Burada 'veli' anahtarı uyuşursa bunun değeri de uyuşmuş kabul edilir. Dolayısıyla değeri x değişkenine yerleştirilmektedir. 
    Ancak anahtar için bir değişken ismi getirilememektedir. 

#------------------------------------------------------------------------------------------------------------------------

d = {'ali': 10, 'veli': 20, 'selami': 30, 'ayşe': 40, 'fatma': 50}

match d:
    case {'ali': 10, 'veli': x}:
        print(x)           # 20

#------------------------------------------------------------------------------------------------------------------------
    Sözlük kalıbında sözlük elemanı olarak **'lı bir değişken kullanılabilir. Bu **'lı değişkene geri kalan tüm sözlük elemanlarına 
    uyuşum sağlayan bir sözlük yerleştirilir. Ancak **'lı değişkenin bir tane olması ve sözlüğün sonunda bulunması zorunludur. 
#------------------------------------------------------------------------------------------------------------------------

d = {'ali': 10, 'veli': 20, 'selami': 30, 'ayşe': 40, 'fatma': 50}

match d:
    case {'selami': 30, 'fatma': 50, **others}:
        print(others)           # {'ali': 10, 'veli': 20, 'ayşe': 40}

#------------------------------------------------------------------------------------------------------------------------
    case ifadelerinde *'lı değişkeninin liste ve demetler için kullanıldığına, **'lı değişkenin sözlükler için kullanıldığına 
    dikkat ediniz. Aslında *'lı ve **'lı değişkenler zaten Python'ın ileride göreceğimiz başka konularında da karşımıza çıkacaktır. 
    match deyimi dile eklandiğinde zaten var olan *'lı ve **'lı sentakslar burada da kullanılmaya başlanmıştır.
#------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------
    Aslında match deyiminde "sınıf kalıbı (class paterrn)" da kullanılabilmektedir. Ancak henüz sınıf konusunu ele almadığımızdan dolayı
    bu kalıp üzerinde burada durmayacağız. Aşağıda basit bir örnek verilmiştir. 
#------------------------------------------------------------------------------------------------------------------------

class Sample:
    def __init__(self, a, b):
        self.a = a
        self.b = b

s = Sample(10, 20)
match s:
    case Sample(a = 10, b = 20):
        print('match edecek')   # match edecek
        
#------------------------------------------------------------------------------------------------------------------------
                                            27. Ders 18/07/2022-Pazartesi
#------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------
    match deyiminde case bölümlerinde "koruma (guard)" da oluşturulabilmektedir. case bölümlerinde if anahtar söcüğüyle 
    ayrı bir koşul belirtilebilir. Bu durumda bu case bölümünün uyuşum sağlaması için o if koşulunun da sağlanması gerekir. Guard 
    oluşturmanın genel biçimi şöyledir:

    case <kalıp> if <koşul>:
        ...
    
    Örneğin:

    match a:
        case 10 if x > 0:
            pass

    Burada case bölümünün uyuşum sağlaması için a'nın 10 olmasının yanı sıra aynı zamanda x'in de 0'dan büyük olması 
    gerekmektedir. 
#------------------------------------------------------------------------------------------------------------------------

a = int(input('Bir sayı giriniz:'))
x = -2

match a:
    case 10 if x > 0:
        print('Ok')
    case _:
        print('cannot match...')

#------------------------------------------------------------------------------------------------------------------------
    case bölümündeki koruma kısmı bazı durumlarda pratik kullanımlara yol açabilmektedir. Örneğin uyuşum dışında ek başka 
    koşulların kontrolü bu sayede yapılabilmektedir. 
#------------------------------------------------------------------------------------------------------------------------

cmds = input('Komut giriniz:').split()

match cmds:
    case ['delete', *args] if len(cmds) == 2:
        print('delete command')
    case _:
        print('cannot match...')

#------------------------------------------------------------------------------------------------------------------------
    Koşul operatörü (conditional operator) üç operandlı (ternary) bir operatördür. Operatör if deyimine benzemekle birlikte bir değer üretir.
    Bu bağlamda ifadelerin içerisinde kullanılabilir. C, C++, Java ve C# gibi dillerde bu operatörün benzeri ?: biçiminde bulunmaktadır. 
    Koşul operatörü -ismi üzerinde- bir deyim değildir. Bir operatördür. Yani bir değer üretmektedir. Genel biçimi şöyledir:

    <ifade1> if <ifade2> else <ifade3>

    Koşul operatörü şöyle çalışmaktadır: if anahtar sözcüğünün yanındaki ifade bool türünden değilse bool türüne dönüştürülür. 
    Eğer bu ifade True ise yalnızca ifade1 yapılır ve operatör bu değeri üretir. Eğer bu ifade False ise yalnızca ifade3 yapılır ve operatör 
    bu değeri üretir.
#------------------------------------------------------------------------------------------------------------------------

a = int(input('Bir sayı giriniz:'))

b = 100 if a % 2 == 0 else 200

print(b)

#------------------------------------------------------------------------------------------------------------------------
    Şüphesiz koşul operatörü ile yapılan şeyler aslında if deyimiyle de yapılabilir. Ancak koşul operatörü bazı durumlarda 
    okunabilirliği artırmakta ve pratik bazı kullanımlara olanak sağlamaktadır. Örneğin:

    b = 100 if a % 2 == 0 else 200

    Biz bu işlemi if deyimi ile aşağıdaki gibi de yapabilirdik:

    if a % 2 == 0:
        b = 100
    else:
        b = 200

#------------------------------------------------------------------------------------------------------------------------
    Koşul operatörünü if deyimi gibi kullanmak kötü bir tekniktir. Örneğin:

    a = int(input('Bir sayı giriniz:'))

    print('çift') if a % 2 == 0 else print('tek')       # kötü teknik!

    Koşul operatörünün ürettiği değerin bir biçimde aynı ifadede kullanılması gerekir. Örneğin bir karşılaştırma sonucunda 
    bir değişkene değer atama işlminde koşul operatörünü kullanabiliriz:

    days = 366 if isleap(year) else 365        # doğru kullanım

    Koşul operatörü özellikle üç durumda tercih edilmelidir:

    1) Bir karşılaştıma sonucunda elde edilen değerin bir değişkene atandığı durumlarda. Örneğin:

    result = 100 if val % 2 == 0 else 200

    Aynı işlemi if deyimiyle şöyle de yapabilirdik:

    if val % 2 == 0:
        result = 100
    else:
        result = 200

    2) Fonksiyon ya da metot çağrımlarında argüman olarak koşul operatörü bazen yazımı kısaltmak için kullanılabilmektedir. Örneğin:

    val = int(input('Bir sayı giriniz:'))

    print('çift' if val % 2 == 0 else 'tek')  

    Bu örnekte val değişkeninin çift ya tek olmasına göre print fonksiyonuna 'çift' ya da 'tek' yazısı argüman olarak 
    gönderilmiştir. 

    Aslında burada yapılmak istenen aşağıdakiyle tamamen eşdeğerdir:

    if val % 2 == 0:
        print('çift')
    else:
        print('tek')

    3) return ifadelerinde de koşul operatörü bazı durumlarda tercih edilmektedir. Örneğin:

    return 100 if a % 2 == 0 else 200

    Bu işlemin eşdeğeri şöyledir:

    if a % 2 == 0:
        return 100
    else:
        return 200

    return işlemi fonksiyonların anlatıldığı izleyen bölümlerde ele alınmaktadır. 

#------------------------------------------------------------------------------------------------------------------------
    Koşul operatör olmasaydı biz if deyimini kullanarak yine yapmak istediğimiz şeyleri yapardık. Koşul operatörü bazı 
    ifadelerin daha kompakt yazılabilmesine olanak sağlamaktadır. Örneğin 0'dan 100'e kadar sayıları aşağıdaki gibi 
    beşer beşer yazdırmak isteyelim:

    0 1 2 3 4 
    5 6 7 8 9
    ...

    İlk aklımıza gelen şöyle bir döngü olacaktır:

    for i in range(100):   
        if i % 5 == 4:
            print(i, end='\n')
        else:
            print(i, end=' ')
    
    Oysa koşul operatörü kullanarak bu kod parçasını daha kompakt bir biçimde yazabiliriz:

    for i in range(100):
        print(i, end='\n' if i % 5 == 4 else ' ')

    Burada i'nin durumuna göre print fonksiyonunun end parametresi '\n' olarak ya da ' ' olarak girilmiştir. 
#------------------------------------------------------------------------------------------------------------------------

for i in range(100):
    print(i, end='\n' if i % 5 == 4 else ' ')

#------------------------------------------------------------------------------------------------------------------------
    Koşul operatörü öncelik tablosunda tablonun en aşağısında hemen atama işlemlerinin yukarısında bulunmaktadır. Yani 
    koşul operatörü düşük öncelikli bir operatördür.

    ()                          soldan sağa
    **                          sağdan sola
    +  -                        sağdan sola
    *  /  //  %                 soldan sağa
    +  -                        soldan sağa
    <  >  <=  >= == !=          soldan sağa
    not                         sağdan sola
    and                         soldan sağa
    or                          soldan sağa
    if else                     sağdan sola
    =  := , +=, -=, *=, ...     sağdan sola

    Aşağıdaki örnekte + operatörü koşul operatörnün dışında değildir. Onun bir parçasını oluşturmaktadır:

    result = 100 if val % 2 == 0 else 200 + 300

    Burada val çift ise result değişkenine 100 değeri tek ise 200 + 300 değeri atanacaktır. Eğer buradaki + operatörü
    koşul operatöründen ayrıştırılmak isteniyorsa parantezler kullanılmalıdır. Örneğin:

     result = (100 if val % 2 == 0 else 200) + 300

     Artık buradaki + operatörü ayrı bir operatördür. Yani val çiftse de tekse de elde edilen değere 300 toplanmaktadır. 
     Birtakım operatörlerin koşul operatörünün operand'ları olmaktan çıkartmak için parantezlerin kullanılması gerekmektedir. 
#------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------
    Örneğin iki değerden büyük olanını bir değişkene atamak istediğimizde koşul operatörünü tercih edebiliriz.
#------------------------------------------------------------------------------------------------------------------------

a = int(input('Bir değer giriniz:'))
b = int(input('Bir değer giriniz:'))

result = a if a > b else b
print(result)

#------------------------------------------------------------------------------------------------------------------------
    Tabii yukarıdaki örnekte aslında biz büyük olan değeri doğrudan da print ile yazdırabilirdik.
#------------------------------------------------------------------------------------------------------------------------

a = int(input('Bir değer giriniz:'))
b = int(input('Bir değer giriniz:'))

print(a if a > b else b)

#------------------------------------------------------------------------------------------------------------------------
    Koşul operatörü de iç içe kullanılabilir. İç içe kullanımda parantez kullanmak zorunlu değildir. Ancak parantezsiz 
    ifadeyi yazmak operatör öncelikleri dikkate alındığında zordur. Bu nedenle koşul operatörünü iç içe kullanırken 
    parantezleri kullanınız. Örneğin:

    a = int(input('Bir değer giriniz:'))
    b = int(input('Bir değer giriniz:'))
    c = int(input('Bir değer giriniz:'))

    result = (a if a > c  else c) if a > b else (b if b > c else c)    
    print(result)

#------------------------------------------------------------------------------------------------------------------------

a = int(input('Bir değer giriniz:'))
b = int(input('Bir değer giriniz:'))
c = int(input('Bir değer giriniz:'))

result = (a if a > c  else c) if a > b else (b if b > c else c)   
print(result)

#------------------------------------------------------------------------------------------------------------------------
    Sınıfta şöyle bir soruldu: Aşağıdaki kodda neden ben matrisin tek bir elemanını değiştirdiğim halde matrisin tüm 
    satırlarının elemanı değişmiş oluyor?

    a = [[0] * 5]
    b = a * 5
    print(b)
    b[0][0] = 100
    print(b)

    Buradan öyle bir çıktı elde edilmiştir:

    [[0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0]]
    [[100, 0, 0, 0, 0], [100, 0, 0, 0, 0], [100, 0, 0, 0, 0], [100, 0, 0, 0, 0], [100, 0, 0, 0, 0]]

    Bunun nedeni "yineleme (repitition)" işleminde aslında adres kopyalaması yapılmasıdır. Burada yineleme yapıldığında 
    artık b listesinin her elemanı aslında a listesini göstermektedir. Dolayısıyla a listesinde bir değişiklik yapıldığında
    b'bnin her elemanı a'yı gösterdiği için bu değişiklik sanki b'nin her elemanında yapılmış gibi bir duurm oluşmaktadır. 
    Burada eğer istenen şey b'nin farklı listeleri göstermesi ise bu durum bir öngü ile sağlanmalıdır:

    b = []

    for _ in range(5):
        a = [0] * 5
        b.append(a)
        
    print(b)

    b[0][0] = 10
    print(b)

    Tabii aslında tytukarıdkai işlem "liste içlemiyle (list comprehension)" tek satırda da yapılabilmektedir. Liste içlemleri 
    konusu ileride ele alınmaktadır:

    b = [[0] * 5 for _ in range(5)]

    print(b)

    b[0][0] = 100
    print(b)

#------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------
    Şimdiye kadar biz hep var olan fonksiyonları çağırdık. Şimdi kendimiz fonksiyonlar yazacağız. Bir fonksiyonun yazılmasına 
    "fonksiyonun tanımlanması (function definition)" da denilmektedir. Python'da fonksiyon tanımlamanın genel biçimi şöyledir:

    def <fonksiyon ismi> ([parametre listesi]): <suite>

    Buradaki def bir anahtar sözcüktür, mutlaka bulundurulması gerekir. Fonksiyon ismi isimlendirme kurallarına uygun herhangi bir
    isim olabilir. Fonksiyonlar parametre değişkenlerine sahip olabilirler ya da olmayabilirler. Her fonksiyon bir "suit" 
    içermek içermelidir. Örneğin:

    def foo():
        print('foo')

    Burada fonksiyonun ismi "foo" biçimindedir. Fonksiyonun parametresi yoktur. Örneğin:

    def bar(a, b):
        print(a, b)

    Burada fonksiyonun ismi "bar" biçimindedir. a ve b bu fonksiyonun parametre değişkenleridir. Burada parametre 
    değişkenleri için tür belirtilmediğine yalnızca onların isimlerinin yazıldığına dikkat ediniz. Dinamik tür sistemine
    sahip programlama dillerinde zaten bildirim yoktur.

    Biz aşağdaki örneklerimizde fonksiyon ismi uydurmak istediğimizde genellikle "foo", "bar", "tar", "zar" gibi 
    isimleri kullanacağız. Bu isimlerin hiçbir özel anlamı yoktur. Bunlar öylesine uydurulmuş isimlerdir. 

#------------------------------------------------------------------------------------------------------------------------
def foo(): 
    print('foo')

def bar(): print('bar'); print('yes bar')   

foo()
bar()
 
#------------------------------------------------------------------------------------------------------------------------
    Aslında Python'da fonksiyon tanımlama işlemi bir deyim statüsündedir. Yorumlayıcı bir fonksiyonun tanımlanadığını gördüğünde
    önce bir "fonksiyon nesnesi (function object)" yaratır. Sonra o fonksiyon nesnesinin içerisine fonksiyonun kodlarını (yani suit deyimlerini)
    yerleştirir. Fonksiyon nesnesinin adresini de fonksiyon ismine atar. Böylece aslında fonksiyon isimleri sıradan birer değişkendir. 
    Fonksiyon isimleri fonksiyon nesnelerini göstermektedir. Bir fonksiyonu (...) operatörü ile çağırdığımızda aslında biz
    bu operatörün operand'ı olan değişkenin içerisindeki adreste bulunan fonksiyon nesnesinin içerisindeki kodları çalıştırmış oluruz. 
    Örneğin:

    def foo():
        print('foo')

    Bu tanımlamayı yorumlayıcı gördüğünde önce bir fonksiyon nesnesi oluşturup foo'nun kodlarını (yani suit deyimlerini) o nesnenin 
    içerisine yerleştirir. O nesnenin adresini de foo değişkenine atar. Artık foo değişkeni fonksiyon nesnesini göstermektedir. 
    Biz fonksiyonu aşağıdaki gibi çağırmış olalım:

    foo()

    Aslında burada yapılan şey foo değişkenin içerisindeki adreste bulunan fonksiyon nesnesinin kodlarının çalıştırılmasıdır. Örneğin:

    >>> def foo():
    ...     print('foo')
    ... 
    >>> id(foo)
    4312805088
    >>> type(foo)
    <class 'function'>
    >>> foo()
    foo

    Mademki fonksiyon isimleri aslında sıradan birer değişkendir ve her atama aslında birer adres atamasıdır. O halde
    biz bir fonksiyon ismini başka bir değişkene atayabiliriz. Bu durumda aynı fonksiyonu o değişkenle de çağrabiliriz. 
    Örneğin:

    >>> def foo(): print('foo')
    ... 
    >>> bar = foo
    >>> foo()
    foo
    >>> bar()
    foo
    >>> id(foo)
    4312805232
    >>> id(bar)
    4312805232

    Fonksiyonların da aslında böyle normal değişkenler gibi olmasına ve atanmasına yazılım dünyasında "fonksiyonların da birinci 
    sınıf vatandaş (functions are first class citizens)" olması denilmektedir. Python'da fonksiyonlar da birinci sınıf vatandaştır. 
#------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------
    Aşağıdaki örnekte f değişkeninin içerisindeki fonksiyon nesnesinin adresi g değişkenine atanmıştır. Artık f ve g aynı 
    fonksiyon nesnesini gösterir duruma gelmiştir. Dolayısıyla artık f() ve g() aslında aynı fonksiyonun çağrılmasına yol 
    açmaktadır. 
#------------------------------------------------------------------------------------------------------------------------

def f(): 
    print('test function')
    
g = f

f()
g()

#------------------------------------------------------------------------------------------------------------------------
                                            28.Ders 20/7/2022 - Çarşamba
#------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------
    Bir fonksiyon çağrıldığında onu çağıran fonksiyona iletilen değere "geri dönüş değeri (return value)" denilmektedir. 
    Fonksiyonların geri dönüş değerleri return deyimiyle oluşturulmaktadır. return deyiminin genel biçimi şöyledir:

    return [ifade]

    Programın akışı return deyimini gördüğünde fonksiyon sonlanır ve geri dönüş değeri return anahtar sözcüğünün yanındaki ifade 
    olacak biçimde oluşturulur. 
#------------------------------------------------------------------------------------------------------------------------

def foo(): 
    print('foo')
    return 100

a = foo()
print(a)

#------------------------------------------------------------------------------------------------------------------------
    Fonksiyonun geri dönüş değeri kullanılmak zorunda değildir. Yani isteğe bağlı (optional) bir bilgidir. Biz fonksiyonu 
    çağırıp geri dönüş değerini hiç kullanmayabiliriz. 
#------------------------------------------------------------------------------------------------------------------------

def foo(): 
    print('foo')
    return 100

foo()

#------------------------------------------------------------------------------------------------------------------------
    C, C++, Java ve C# gibi statik tür sistemine sahip dillerde fonksiyonların geri dönüş değerlerinin türleri vardır. 
    Fonksiyonlar aynı türden değerlerle geri dönebilirler. Ancak Python dinamik tür sistemine sahip bir programlama dili olduğu için
    Python'da bir fonksiyon duruma göre farklı türlerle geri dönebilir. Python'da fonksiyonun geri dönüş değerinin türü diye bir 
    kavram yoktur. return deyiminde return anahtar sözcüğünün yanındaki ifade hangi türdense fonksiyon o türden bir değerle geri 
    dönecektir.

    Aşağıdaki örnekte klavyeden girilen değer pozitif bir değerse fonksiyon onun karesiyle geri dönmektedir. Eğer klavyeden 
    girilen değer pozitif değilse fonksiyon "error" yazısıyla geri dönecektir. 
#------------------------------------------------------------------------------------------------------------------------

def foo(): 
    a = int(input('Bir değer giriniz:'))
    if a > 0:
        return a * a

    return 'error'

result = foo()
print(result, type(result))

#------------------------------------------------------------------------------------------------------------------------
    Akış return deyimini görmeden fonksiyonu bitirirse geri dönüş değeri olarak None değeri elde edilmektedir. Örneğin:

    def foo():
        print('foo')

    val = foo()

    Burada geri dönüş değeri olarak None değeri elde edilecektir. 

    Tabii fonksiyonun bazı akışları return deyimini görürken bazı akışları görmeyebilir. Örneğin:

    import math

    def mysqrt(val):
        if val >= 0:
            return math.sqrt(val)

    Burada eğer val parametresi 0 ya da 0'dna büyükse fonksiyon onun karekökü ile eğer 0'dan küçükse None değeri ile
    geri dönecektir. 
#------------------------------------------------------------------------------------------------------------------------

def foo(): 
    print('foo')

result = foo()
print(result)           # None

#------------------------------------------------------------------------------------------------------------------------
    return anahtar sözcüğünün yanına bir ifade yazılmayabilir. Bu durumda fonksiyonun sonlandırılması istenmiştir ancak bir geri 
    dönüş değeri belirtilmemiştir. Bu durumda da geri dönüş değeri olarak None elde edilmektedir. Yani başka bir deyişle:

    return 

    kullanımı ile aşağıdaki kullanım eşdeğerdir:

    return None

#------------------------------------------------------------------------------------------------------------------------

def foo(): 
    print('foo')
    return

result = foo()
print(result)           # None

#------------------------------------------------------------------------------------------------------------------------
    Bir fonksiyonun tek bir geri dönüş değeri vardır. Yani fonksiyon tek bir değerle geri dönebilir. Eğer fonksiyonun birden fazla 
    değer iletmesi isteniyorsa geri dönüş değeri demet, liste gibi bileşik bir nesne yapılmalıdır. Demetler bu bağlamda tercih edilmelidir.
    Örneğin:

    def foo():
        print('foo')
        return 10, 20

    Burada foo fonksiyonu bir demetle geri dönmektedir. Yani biz fonksiyonu çağırdığımızda bir demet elde ederiz. Tabii 
    bu demet doğrudan açılabilir. Örneğin:

    a, b = foo()

#------------------------------------------------------------------------------------------------------------------------

def foo(): 
    print('foo')
    return 100, 200

a, b = foo()
print(a, b)  

#------------------------------------------------------------------------------------------------------------------------
    Aşağıda ikinci derece denklemin kökleri ile geri dönen getroots isimli bir fonksiyon örneği verilmiştir. Fonksiyon 
    eğer kök yoksa None değerine, eğer kök varsa ikili bir demete geri dönmektedir. 
#------------------------------------------------------------------------------------------------------------------------

import math

def getroots():
    a = float(input('a:'))
    b = float(input('b:'))
    c = float(input('a:'))

    delta = b ** 2 - 4 * a * c
    if delta < 0:
        return None
    
    x1 = (-b + math.sqrt(delta)) / (2 * a)
    x2 = (-b - math.sqrt(delta)) / (2 * a)
    
    return x1, x2

result = getroots()

if result:
    x1, x2 = result
    print(f'x1 = {x1}, x2 = {x2}')
else:
    print('no real root!')

#------------------------------------------------------------------------------------------------------------------------
    Tabii fonksiyon bir listeyle, bir kümeyle ya da bir sözlükle de geri dönebilir. Aşağıdaki örnekte 0'dan klavyedne girilen 
    değere kadar değerlerin kareleri bir listede toplanmış ve fonksiyon bu listeyle geri dönmüştür.
#------------------------------------------------------------------------------------------------------------------------

def foo():
    val = int(input('Bir sayı giriniz:'))
    a = []
    for i in range(val):
        a.append(i * i)
        
    return a

a = foo()
print(a)

#------------------------------------------------------------------------------------------------------------------------
    Fonksiyonların dış dünyadan aldıkları değerlere "parametre" denilmektedir. Fonksiyonlar parametrelere sahip olabilirler.
    Bu durumda parametrelerin isimleri parametre parantezinin içerisinde ',' atomu ile ayrılarak belirtilmektedir. Örneğin:

    def foo(a, b):
        pass

    Burada a ve b foo fonksiyonunun parametreleridir. Parametre terimi yerine bazen "parametre değişkeni" terimi de kullanılabilmektedir.

    Diğer statik tür sistemine sahip programlama dillerinde olduğu gibi bir parametre bildirimi Python'da yoktur. Pyton'da parametre parantezinin
    içerisine yalnızca parametre değişkenlerinin isimlerinin yazıldığına dikkat ediniz. Örneğin:

    def foo(a, b, c):
        print(a, b, c)

    Fonksiyonun parametre değişkenlerine "parametre (parameter)" fonksiyon çağrılırken girilen ifadelere ise "argüman (argument)" 
    denilmektedir. n tane parametreye sahip olan bir fonksiyon n tane argümanla çağrılmalıdır. Fonksiyon çağrılırken önce argümanların
    değerleri hesaplanır. Sonra argümanlardan parametre değişkenlerine karşılıklı bir atama yapılır. Sonra akış fonksiyona aktarılır. 
    Yani parametreli bir fonksiyonun çağrılması parametre değişkenlerine gizli bir atama işleminin yapılması anlamına gelmektedir. 
    Python'da her türlü atamanın bir adres ataması olduğuna dikkat ediniz. Dolayısıyla aslında buradaki atama sırasında aslında argüman olan 
    nesnelerin adresleri atanmaktadır. Örneğin:

    def foo(a, b):
        pass

    foo(10 + 20, 30 + 40)   

    Burada önce 10 ile 20 toplanıp değeri 30 olan bir int nesne oluşturulur. 30 ile 40 toplanıp değeri değeri 70 olan bir 
    int nesne yaratılır. Sonra bu int nesnelerin adresleri sırasıyla a ve b değişkenlerine atanır. Örneğin:

    def foo(a):
        pass

    x = 10
    foo(x)

    Burada önce içerisinde 10 değeir olan int türden bir nesne yaratılır. Bu nesnenin adresi x'e atanır. Sonra foo fonksiyonu 
    çağrılınca x'in içerisindeki adres parametre değişkeni olan a'ya atanacaktır. Yani aşağıdaki örnekte x'in id değeri ile
    a'nın id değeri (yani adresi) aynı olacaktır:

    def foo(a):                     # a = x
        print(a, id(a))
        
    x = 10
    print(x, id(x))

    foo(x)

#------------------------------------------------------------------------------------------------------------------------

def foo(a, b, c):
    print(a, b, c)
    
foo(10 + 20, 'ali', 12.3)

#------------------------------------------------------------------------------------------------------------------------
    Aşağıdaki örnekte argümanlara ilişkin nesnenin adresinin aslında parametre değişkenine yerleştirildiğini göreceksiniz.
#------------------------------------------------------------------------------------------------------------------------

def foo(a):
    print(a, id(a))
    
x = 10
print(id(x))
foo(x)

#------------------------------------------------------------------------------------------------------------------------
    Tabii aynı durum return işlemi için de geçerlidir. Yani return işleminde de aslında çağıran fonksiyona iletilen return ifadesindeki
    nesnenin adresidir. 
#------------------------------------------------------------------------------------------------------------------------

def foo():
    a = 10
    print(id(a))
    return a

result = foo()
print(id(result))
 
#------------------------------------------------------------------------------------------------------------------------
    Fonksiyonun parametre değişkenleri yalnızca o fonksiyonun içerisinde kullanılabilir. Dışarıdaki aynı isimli başka bir 
    değişken ile karışmaz. Örneğin:

    def foo(a):
        pass

    a = 10      
    foo(a)

    Buradaki a ile fonksiyonun parametre değişkeni olan a tamamne farklı iki değişkendir. 

    İki fonksiyonun parametre değişkenlerinin aynı isimde olması da bir soruna yol açmamaktadır. Örneğin:

    def foo(a):
        pass

    def bar(a):
        pass

    Burada hem foo fonksiyonun hem de bar fonksiyonunun parametre değişkenin ismi a'dır. Bunlar birbirleriyle karışmaz.
    Çünkü foo'nun parametre değişkeni olan a yalnızca foo içerisinde, bar'ın parametre değişkeni olan a ise yalnızca bar'ın
    içerisinde kullanılabilmektedir. 
#------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------
    Fonksiyonların parametre değişkenleri onlar hangi tüden argümanla çağrılmışsa o türden olurlar. Yani onların belli bir 
    türleri yoktur. Daha önce de belirttiğimiz gibi statik tür sistemine sahip C, C++, Java, C# gibi dillerde parametre 
    değişkenlerinin belli bir türü vardır. Bu tür hiç değişmez. 
#------------------------------------------------------------------------------------------------------------------------

def foo(a):
    print(a, type(a))
    
foo(10)
foo(1.2)
foo('ali')
foo(True)
foo([1, 2, 3])

#------------------------------------------------------------------------------------------------------------------------
    Pekiyi biz neden fonksiyon yazmak isteriz? İşte fonksiyonlar oluşturmanın gerekçeleri şunlardır:

    1) Fonksiyonlar "yeniden kullanılabilirliği (reusability)" sağlarlar. Yani belli bir amacı gerçekleştiren fonksiyon başka projelerde 
    yeniden yazılmadan çağrılarak kullanılabilmektedir. Biz bir işi yapan bir fonksiyon yazdığımızda onu değişikm projelerde kullanabiliriz. 

    2) Fonksiyonlar kod tekrarını engellemektedir. Bir işlem programın çeşitli yerlerinde yineleniyor olabilir. Eğer fonksiyonlar olmasaydı
    o işlemlerin tekrar tekrar yapılması gerekirdi. Bu da kodun büyümesine ve karmaşıklığa yol açardı. Halbuki fonksiyonlar kod tekrararını 
    engellemektedir. Biz bir işi yapan kodu bir fonksiyon olarak yazarsak onu programın çeşitli yerlerinde çağırarak kod tekrarını 
    engellemiş oluruz. 

    3) Karmaşık bir problem parçalarına ayrılarak daha kolay çözülebilir. Parçalarına ayırma işlemi genellikle fonksiyonlar 
    yoluyla yapılmaktadır. Yani işin belli kısımlarını yapan fonksiyonlar tanımlanır sonra karmaşık iş o fonksiyonların
    belli sırada çağrılmasıyla gerçekleştirilir. İlk bakışta karmaşık gibi gelen pek çok olgu aslında parçalara ayrıştırıldığında 
    çok daha yönetilebilir bir hale gelmektedir. 

    4) Fonksiyonların isimleri vardır. Dolayısıyla yapılmak istenen şey fonksiyon çağrılarıyla daha iyi ifade edilebilmektedir. 

    İşte programlamada bir işlemin fonksiyonlara ayrılarak fonksiyonların birbirlerine çağırması biçiminde gerçekleştirilmesine 
    "prosedürel programlama modeli (procedural paradigm)" denilmektedir.
#------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------
    Fonksiyonlar listelerin, demetlerin sözlüklerin elemanları olabilir. 
#------------------------------------------------------------------------------------------------------------------------

def foo():
    print('foo')
    
def bar():
    print('bar')
    
def tar():
    print('tar')
    
a = [foo, bar, tar]
        
for i in range(len(a)):
    a[i]()
    
for f in a:
    f()
    
#------------------------------------------------------------------------------------------------------------------------
    Fonksiyon nesneleri hash'lenebilir olmadığı için sözlüklerde anahtar yapılamaz. Ancak fonksiyonlar sözlüklerde 
    değer biçiminde bulunabilir. 
#------------------------------------------------------------------------------------------------------------------------

def foo():
    print('foo')
    
def bar():
    print('bar')
    
def tar():
    print('tar')
    
d = {'ali': foo, 'veli': bar, 'selami': tar}

d['ali']()
d['veli']()
d['selami']()

for key in d:
    d[key]()

#------------------------------------------------------------------------------------------------------------------------
    Tabii aşağıdaki iki listede yapılan şeyler tamamen farklıdır:

    a = [foo, bar, tar]
    b = [foo(), bar(), tar()]

    a listesinde listenin her elemanı bir fonksiyon nesnesini tutmaktadır. Ancak b listesinde listenin elemanları bu fonksiyonların
    geri dönüş değerlerinden oluşmaktadır. 
#------------------------------------------------------------------------------------------------------------------------

def foo():
    print('foo')
    return 10
    
def bar():
    print('bar')
    return 20
    
def tar():
    print('tar')
    return 30
    
a = [foo(), bar(), tar()]
    
for x in a:
    print(x)

#------------------------------------------------------------------------------------------------------------------------
    Aşağıdaki örnekte ikinci derece bir denklemin köklerini buluna bir fonksiyon yazılmıştır. Fonksiyon eğer kök yokse None
    değerine geri döner, kök varsa x1 ve x2 köklerini bir demet olarak geri döndürmektedir.
#------------------------------------------------------------------------------------------------------------------------

import math

def get_roots(a, b, c):
    delta = b ** 2 - 4 * a * c
    if delta < 0:
        return None
    
    x1 = (-b + math.sqrt(delta)) / (2 * a)
    x2 = (-b - math.sqrt(delta)) / (2 * a)
    
    return x1, x2

a = float(input('a:'))
b = float(input('b:'))
c = float(input('c:'))

result = get_roots(a, b, c)
if result != None:
    x1, x2 = result
    print(f'x1 = {x1}, x2 = {x2}')
else:
    print('Kök yok!')

#------------------------------------------------------------------------------------------------------------------------
    Aşağıdaki örnekte banner fonksiyonu tireler arasında parametresiyle aldığı yazıyı ekrana basmaktadır.
#------------------------------------------------------------------------------------------------------------------------

def banner(s):
    print('-' * len(s))
    print(s)
    print('-' * len(s))
    
banner('ankara')
banner('izmir')

#------------------------------------------------------------------------------------------------------------------------
    Aşağıdaki örnekte bir sayının asal olup olmadığını test eden isprime isimli bir fonksiyon yazılmıştır. 
#------------------------------------------------------------------------------------------------------------------------

def isprime(val):
    for i in range(2, val - 1):
        if val % i == 0:
            return False
        
    return True

val = int(input('Bir sayı giriniz:'))

print('Asal' if isprime(val) else 'Asal değil')
    
#------------------------------------------------------------------------------------------------------------------------
    Yukarıdaki fonksiyonu kullnarak 100'e kadar tüm asal sayıları aşağıdaki gibi yazdırabiliriz. 
#------------------------------------------------------------------------------------------------------------------------

def isprime(a):
    for i in range(2, a):
        if a % i == 0:
            return False
        
    return True

for i in range(2, 100):
    if isprime(i):
        print(i, end=' ')

#------------------------------------------------------------------------------------------------------------------------
    Aslında asallık testi daha hızlı bir biçimde aşağıdaki gibi yapılabilir. Aşağıdaki programda iki önemli matematiksel 
    özellikten faydalanılmıştır:

    1) Sayı çift ise ama 2'ye eşit değilse asal değildir. Başka çift sayıların kontrol edilmesine gerek yoktur.
    2) Asal olmayan her sayının kareköküne kadar bir asal çarpanı vardır. (Öklit teoremi). Dolayısıyla sayının kareköküne 
    kadar kontrol yapılması yueterlidir. 
#------------------------------------------------------------------------------------------------------------------------

import math

def isprime(a):
    if a % 2 == 0:
        return a == 2
    
    for i in range(3, int(math.sqrt(a)) + 1, 2):
        if a % i == 0:
            return False
        
    return True

for i in range(2, 100):
    if isprime(i):
        print(i, end=' ')


#------------------------------------------------------------------------------------------------------------------------
    Aşağıda parametresiyle girilen değerin faktöriyeline geri dönen fonksiyon örneği verilmiştir.
#------------------------------------------------------------------------------------------------------------------------

def factorial(n):
    total = 1
    for i in range(2, n + 1):
        total *= i
        
    return total

result = factorial(5)
print(result)

#------------------------------------------------------------------------------------------------------------------------
    Aslında math modülü içerisinde factorial fonksiyonu hazır olarak bulunmaktadır.
#------------------------------------------------------------------------------------------------------------------------

>>> import math
>>> math.factorial(5)
120

#------------------------------------------------------------------------------------------------------------------------
    Python dilinin tasarımı ve sürdürümü ve CPython gerçekleştiriminin yazımı Python Sooftware Foundation (python.org) 
    tarafından yapılmaktadır. PSP içerisinde çeşitli alt gruplar vardır. Dile ilişkin sentaks ve semantik yenilikler ve 
    standart kütüphaneye yapılacak eklemeler "PEP (Python Enhancement Proposals)" denilen dokümanlarla yürütülmektedir. 
    Bir kişi taslak biçiminde bir PEP dokğmanı hazırlar. Önerisini oraya belli bir formatta yazar. Sonra bu öneri tartışılıp
    sonuca bağlanır. Eğer kabul edilirse resmi bir biçimde PEP dokümanı olarak yayınlanır. Dolayısıyla PEP dokümanları 
    Python diline ilişkin pek çok "gerekçeyi (rationale)" de barındırmaktadır. PEP dokğmanlarına numaralar verilmiştir. 
    Dolayısıyla bir dil özelliğinin geniş bir açıklamasını elde etmek istiyorsanız bu PEP dokümanlarına başvurmalısınız. 
    Python'ın tüm PEP dokğmanlarına aşağıdaki bağlantıdan erişebilirsiniz:

    https://peps.python.org/
#------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------
    Python kodlarını yazarken peşi sıra gelen atomlar arasında nasıl boşluklar bulundurulacağı, kodun güzel gözükmesi için
    nasıl hizalamalar yapılacağı, değişken isimlendirmelerde hangi kuralların izleneceği gibi konuları kapsayan çeşitli yazım
    biçimleri oluşturulmuştur. Yazım biçimleri (style guides) proje grupğları arasında ve kurumlar arasında farklılaşmaktadır. 
    Örneğin Python Software Foundation tarafından PEP 8 dokümanı ile açıklanan yazım biçimine pek çok Python programcısı uymamaktadır. 
    Google firmasının da Python için önerdiği kendine özgü bir yazım sitili de bulunmaktadır. Biz kurusumuda CSD'ye özgü bir 
    yazım sitilini kullanmaktayız. Ancak dahil olduğunuz proje grubunun yazım biçimine kendinizi uydurmanız gerekebilir. 
    Aşağıda iki yazım biçiminin bağlantısını veriyoruz:

    https://peps.python.org/pep-0008/
    https://google.github.io/styleguide/pyguide.html
#------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------
                                            29. Ders 25/07/2022 - Pazartesi
#------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------
    Python'da diğer bazı dillerde olduğu gibi default argüman kullanımı vardır. Yani parametre değişkenleri Python'da default 
    değer alabilmektedir. Bir parametre değişkeni default değer almışsa çağrı sırasında o parametre değişkeni için argüman girilmezse
    sanki o parametre için o default değer girilmiş gibi işlem yapılır. Örneğin:

    def foo(a, b, c = 10):
        print(100, 200)

    Biz burada foo fonksiyonunu çağırırken c için default değer girmezsek sanki c için 10 değerini girmiş gibi oluruz. Örneğin:

    foo(100, 200)

    Bu çağrı aşağıdakiyle tamamen eşdeğerdir:

    foo(100, 200, 10)

    Ancak default değer almış olan parametre için argüman girilirse artık o default değerin bir önemi kalmaz. Örneğin:

    foo(100, 200, 300)

    Burada artık c için 300 değeri girilmiştir. Dolayısıyla c parametre değişkenine verilen default değerin bir önemi kalmamıştır. 
    Yani parametre değişkenine verilen default değer "eğer o parametre değişkeni için argüman girilmezse" devreye girmektedir. 
    Default değer almamış olan parametre değişkenleri için argüman girilmek zorundadır. 
#------------------------------------------------------------------------------------------------------------------------

def foo(a, b, c = 10):
    print(f'a = {a}, b = {b}, c = {c}')
    
foo(100, 200)           # foo(100, 200, 10)
foo(100, 200, 300)      # foo(100, 200, 300)

#------------------------------------------------------------------------------------------------------------------------
    Tabii fonksiyonun birden fazla parametresi default değer alabilir. 
#------------------------------------------------------------------------------------------------------------------------

def foo(a, b, c = 10, d = 20):
    print(f'a = {a}, b = {b}, c = {c}')
    
foo(100, 200)               # foo(100, 200, 10, 20)
foo(100, 200, 300)          # foo(100, 200, 300, 20)
foo(100, 200, 300, 400)     # foo(100, 200, 300, 400)

def bar(a = 10, b = 20):
    print(f'a = {a}, b = {b}')
    
bar()           # bar(10, 20)
bar(100)        # bar(100, 20)
bar(100, 200)   # bar(100, 200)

#------------------------------------------------------------------------------------------------------------------------
    Parametrelere verilen default değerlerin çok kullanılan değerler olması gerekir. Yoksa öylesine değerleri default değer olarak 
    vermek kötü bir tekniktir. Fonksiyonu inceleyen kişiler default değerlerin yaygın değerler olduğunu varsaymaktadır. 
    Örneğin farklı türden bir değeri int türüne dönüştürmek için kullandığımız int fonksiyonun aslında ikinci bir parametresi vardır. 
    Bu parametre birinci parametredeki yazının kaçlık sistemde yazılmış olduğunu belirten base parametresidir. Biz günlük yaşamımızda 
    10'luk sistemi kullandığımıza göre bu parametrenin default değerinin 10 olması oldukça makuldür. Böylece kişiler fonksiyonu 
    çağırırken boşuna bu ikinci parametre için her defasında 10 değrini girmezler. (int fonksiyonun bu ikinci parametresi ancak birinci parametre 
    bir yazı ise anlamlıdır. Eğer birinci parametre bir yazı değilse ikinci parametre için argüman girmek Exception'a (TypeError) 
    yol açmaktadır.) Default argümanlar bu örnekte olduğu gibi fonksiyonu çağıracak kişilere kolaylık sağlamaktadır. Hatta bazen 
    bir fonksiyonun çok parametresi olabilir. Ancak bunların önemli bir bölümü default değer almış olabilir. Meşgul bir programcı 
    da yalnızca default değer almamış parametrelerin anlamlarını öğrenip onlar için argüman girebilir. 
#------------------------------------------------------------------------------------------------------------------------

s = '123'

val = int(s)        # int(s, 10)
print(val)          # 123

val = int(s, 16)    
print(val)          # 291

#------------------------------------------------------------------------------------------------------------------------
    Fonksiyonda default değer alan parametre değişkenlerinin parametre listesinin sonunda toplanmış olması gerekir. Başka bir 
    deyişle "eğer bir parametre değişkeni default değer almışsa onun sağındakilerin hepsinin default değer almış olması" gerekir. 
    Örneğin:

    def foo(a, b = 10, c):
        pass

    Böyle bir fonksiyon tanımlaması geçerli değildir. Programcının fonksiyonu şöyle tanımlaması gerekirdi:

    def foo(a, c, b = 10):
        pass
 
#------------------------------------------------------------------------------------------------------------------------

def banner(s, ch='-'):
    print(ch * len(s))
    print(s)
    print(ch * len(s))
    
banner('ankara')
banner('ankara', '*')

#------------------------------------------------------------------------------------------------------------------------
    Python'da fonksiyon parametrelerine verilen default değerler fonksiyonun bir deyim olarak çalıştırılması sırasında yalnızca bir kez
    işleme sokulmaktadır. Bu davranış C++, Java ve C# gibi dillerdeki davranıştan farklıdır. Örneğin:

    def foo(a = [1, 2, 3]):
        print(a, id(a))

    Burada [1, 2, 3] elemanlarına sahip olan liste nesnesi yalnızca bir kez yaratılacaktır. Yani fonksiyon her çağrıldığında yaratılmayacaktır. 
    Bunu basit bir biçimde şöyle test edebilirsiniz:

    foo()
    foo()
    foo()

    Buradan elde edilen örnek bir çıktı şöyledir:

    [1, 2, 3] 1560817328576
    [1, 2, 3] 1560817328576
    [1, 2, 3] 1560817328576

    Benzer biçimde örneğin:

    def foo():
        print('foo')

        return 10

   def bar(a = foo()):
        pass

    Burada da foo fonksiyonu bar deyimi çalıştırılırken yalnızca bir kez çağrılacaktır. bar fonksiyonu her çağrıldığında çağrılmayacaktır. 
    Örneğin:

    bar()
    bar()
    bar()

    Bu tür durumlarda default argüman olarak "değiştirilebilir (mutable)" nesne kullanırken dikkat etmek gerekir. Örneğin:

    def foo(a = []):  
        a.append(10)
        return a

    x = foo()           # dikkat x aslında a parametre değişkeni ile aynı nesneyi gösteriyor
    x.append(20)
    foo()

    print(x)        # [10, 20, 10]

    Burada foo fonksiyonu default argüman olarak yaratılmış olan list nesnesinin adresiyle geri dönmüştür. Dolayısıyla x değişkeninde 
    artık default argüman olarak yaratılmış olan nesnenin adresi bulunacaktır. Yani kodda x.append(20) aslında aynı nesneye 
    ekleme yapmaktadır. Daha sonra çağrılan foo'daki a parametre değişkeni yeniden boş bir list nesnesini göstermeyecektir. 
    Zaten bir kez yaratılmış olan list nesnesini gösterecektir. 
 #------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------
    Python'da C++, Java ve C# gibi dillerdeki "function/method overloading" özelliği yoktur. Dolayısıyla bu tür bir etki 
    default argüman alan parametre değişkenleriyle sağlanmaktadır. Örneğin biz range fonksiyonunu (aslında bu bir sınıftır) 
    tek parametreyle, iki parametreyle ve üç parametreyle kullanabiliyorduk. Aslında üç ayrı range fonksiyonu yoktur. Tek bir range 
    fonksiyonu vardır. range fonksiyonu aşağıdaki gibi bir mantıkla yazılmıştır. 
#------------------------------------------------------------------------------------------------------------------------

def disp_range(start, stop=None, step = 1):
    if stop == None:
        stop = start
        start = 0
    
    for i in range(start, stop, step):
        print(i, end = ' ')
    print()
        
disp_range(10)
disp_range(10, 20)
disp_range(10, 20, 2)

#------------------------------------------------------------------------------------------------------------------------
    Daha önceden de belirttiğimiz gibi Python'da bir fonksiyonu ikinci kez tanımlamak aslında aynı değişkene ikinci kez
    atama yapmak gibi bir etki oluşturmaktadır. Örneğin:

    def foo(a):
        pass

    def foo(a, b):
        pass

    C++, Java ve C# gibi dillerde aynı isimli farklı parametrik yapılara sahip fonksiyonlar bir arada bulunabilmektedir. 
    Oysa Python'da böyle bir durum yoktur. Bu yukarıdaki kod parçasında foo fonksiyonunu çağırırsak artık ikinci 
    fonksiyonu çağırmış oluruz. 
#------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------
    Bazı programlama dillerinde parametre listesinde bulunan bir değişken daha sonra default argüman olarak kullanılabilmektedir. 
    Python'da böyle bir kullanım geçerli değildir. Örneğin:

    def foo(a, b = a):      
        pass

    Burada biz b parametre değişkenine a'yı default argüman olarak veremeyiz. Bu durum bir sentaks hatası oluşturacaktır.
#------------------------------------------------------------------------------------------------------------------------
    
#------------------------------------------------------------------------------------------------------------------------
    Python gibi dinamik tür sistemine sahip programlama dillerinde fonksiyonların parametre değişkenlerinin belli bir türü 
    olmadığı için fonksiyonlar yanlış türden argümanlarla çağrılırsa programın çalışma zamanı sırasında exception oluşarak program 
    çökebilir ya da program çökmeden yanlış bir biçimde çalışabilir. Genel olarak programlamada bir kodun hiç çalışmaması yanlış 
    çalışmasına tercih edilmektedir. (Yani kodun hatalı çalışmasındansa exception oluşarak hiç çalışmaması daha tercih edilir
    bir durumdur.) Örneğin daha önceden yazmış olduğumuz banner fonksiyonunun normal olarak bir string ile çağrılması gerekir. 
    Ancak biz bu fonksiyonu bir string ile çağırmazsak programımız exception ile çökecektir.  İşte Python'da fonksiyon çağrılarında 
    argümanların uygun bir biçimde girilmesi programcının sorumluluğundadır. Benzer biçimde bu banner örneğinde fonksiyonun 
    ikinci parametresinin bir karakter uzunluğunda bir string olarak girilmesi gerekmektedir. Aksi takdirde ya exception 
    oluşacak ya da program yanlış çalışacaktır.
#------------------------------------------------------------------------------------------------------------------------

def banner(s, ch='-'):
    print(ch * len(s))
    print(s)
    print(ch * len(s))
    
banner('ankara')
banner('ankara', 10)        # program çökmeyecek ama istenildiği gibi çalışmayacaktır
banner(10)  # burada exception oluşacak, çünkü len fonksiyonu int türüne uygulanamaz!

#------------------------------------------------------------------------------------------------------------------------
    Bir fonksiyon yazarken programcı yine de fonksiyon parametreleri üzerinde programın çalışma zamanı sırasında tür kontrolü 
    uygulayabilir. Bunun için isinstance isimli built-in fonksiyon kullanılmaktadır. isinstance fonksiyonunun birinci parametresi 
    bir ifade, ikinci parametresi ise bir tür ismi olarak girilir. Fonksiyon birinci parametresiyle belirtilen ifadenin ikinci 
    parametresiyle belirtilen türden (ya da o türden türemiş bir sınıf türünden) olup olmadığına ilişkin bool bir değer geri 
    döndürmektedir. Örneğin:

    if isinstance(s, str):
        pass

    Burada s değişkeninin str türünden olup olmadığına bakılmaktadır. Fonksiyonun ikinci parametresi türlerden oluşan bir demet biçiminde de girilebilir. 
    Bu durum "veya" anlamına gelmektedir. Örneğin:

    if isinstance(a, (int, float, complex)):
        pass

    Burada a değişkeni int, float ya da complex türündense isinstance True değerine geri dönecektir. 

    Python programcıları eğer fonksiyonun parametreleri üzerinde tür kontrolü yapıp onların uygun türlerdne olmadığını görürlerse 
    genellikle exception oluşturup fonksiyonun çalışmasını engellerler. Exception raise isimli bir deyimle oluşturulmaktadır. Bu
    konu ileride ayrıntılarıyla ele alınmaktadır. Örneğin:

    def disp_square(a):
        if not isinstance(a, (int, float)):
            raise TypeError('argument must be either int or float')
        print(a * a)

    Burada disp_square fonksiyonuna programcının int ya da float türden bir argüman geçmesi istenmektedir. Eğer programcı 
    int ya da float türden argüman geçmezse exception oluşturulmuştur. 

    Ancak Python programcıları fonksiyon yazarken çoğu kez fonksiyon içerisinde isinstance ile parametreler üzerinde tür kontrolü yapmazlar. 
    Bu durumda eğer fonksiyon uygunsuz türlerle çağrılırsa muhtemelen bir biçimde bir exception oluşacaktır. Fonksiyonun doğru türlerle
    çağrılması onu çağıran kişinin sorumlulupundadır. Yani eğer fonksiyon doğru türlerle çağrılmazsa sonucuna onu çağıran programcı 
    katlanacaktır.

    Aşağıdaki örnekte banner fonksiyonunda isinstance fonksiyonu ile tür kontrolü uygulanmıştır. Burada eğer programcı banner 
    fonksiyonunu çağırırken birinci pamatreye str türünden bir argüman geçmezse ya da ikinci parametreye tek karakterli bir 
    str türünden argüman geçmezse exception oluşturulmuştur.
#------------------------------------------------------------------------------------------------------------------------

def banner(s, ch='-'):
    if not isinstance(s, str):
        raise TypeError('first argument must be string')
    if not isinstance(ch, str) or len(ch) != 1:
        raise TypeError('second argument must be one charater string')
    print(ch * len(s))
    print(s)
    print(ch * len(s))
    
banner('ankara', 'ali')

#------------------------------------------------------------------------------------------------------------------------
    Bazen programcılar fonksiyon içerisinde parametre türlerini kontrol edip o türlere uygun bir çalışma sunabilirler. 
    Aşağıdaki örnekte banner fonksiyonun birinci parametresi int ya da float ise önce o yazıya dönüştürülmüş sonra banner
    işlemi yapılmıştır.
#------------------------------------------------------------------------------------------------------------------------

def banner(s, ch='-'):
    if isinstance(s, (int, float)):
        s = str(s)
    print(ch * len(s))
    print(s)
    print(ch * len(s))
    
banner('ankara')
banner(10)
banner(12.4)

#------------------------------------------------------------------------------------------------------------------------
    Python 3.10 ile birlikte birden fazla türün veya işlemine "|" operatörü ile sokulması sağlanmıştır. Örneğin:

    if isinstance(a, (int , float)):
        pass

    Bu işlem Python 3.10 ve sonrasında aşağıdaki gibi de yapılabilmektedir:

    if isinstance(a, int|float):
        pass

    Buradaki int|float ifadesi "int türü ya da float türü" anlamına gelmektedir. 

#------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------
    Bir fonksiyon çağrılırken arümanlara isim verilerek o argümanların hangi parametreler için girildiği belirtilebilmektedir. 
    Bu tür argümanlara Python referans kitabında "keyword arguments" denilmektedir. Ancak biz kurusumuzda bunlara "isimli argümanlar"
    diyeceğiz. İsimli argümanlar "parametre_ismi=ifade" sentaksıyla kullanılmaktadır. Örneğin:

    def foo(a, b, c):
        pass

    foo(c=100, a=200, b=300)

    Normal argümanlara (yani isimli olmayan argümanlara) Python referans kitabında "positional arguments" denilmektedir. 
    Biz kurumuzda bunları vurgulamak için "pozisyonel argümanlar" diyeceğiz.
#------------------------------------------------------------------------------------------------------------------------

def foo(a, b, c):
    print(f'a = {a}, b = {b}, c = {c}')
    
foo(10, 20, 30)                 # a = 10, b = 20, c = 30
foo(c=100, a=200, b=300)        # a = 200, b = 300, c = 100

#------------------------------------------------------------------------------------------------------------------------
    Pozisyonel argümanlarla isimli argümanları fonksiyon çağrısında bir arada kullanabiliriz. Ancak çağrıda isimli argümanların
    sonda toplaşmış olması gerekir. Başka bir deyişle bir argüman isimli olarak girilmişse onun sağındakilerin hepsinin isimli olarak 
    girilmiş olması gerekmektedir. Örneğin:

    def foo(a, b, c):
        pass

    foo(100, c=300, b=200)      # geçerli
    foo(100, c=300, 200)        # error!
#------------------------------------------------------------------------------------------------------------------------

def foo(a, b, c):
    print(f'a = {a}, b = {b}, c = {c}')
    
foo(100, c=200, b=300)        # a = 100, b = 300, c = 200

#------------------------------------------------------------------------------------------------------------------------
    Bir fonksiyon çağrısında default argümanlar da dikkate alınarak tüm parametre değişkenlerine bir ve yalnızca bir kez 
    değer verilmiş olmalıdır. Eğer bir parametre değişkenine hiç değer verilmemişse ya da birden fazla kez değer verilmişse bu durum 
    error ile sonuçlanır. Örneğin:

    def foo(a, b, c):
        pass

    foo(10, 20)                     # error! c değer almamış
    foo(10, a=20, c=30)             # error! a iki kez değer almış, b değer almamış
    foo(100, 200, b=300, c=400)     # error! b iki kez değer almış. 

    Örneğin:

    def bar(a, b, c = 10, d = 20):
        pass

    bar(10, 20)                         # geçerli, tüm parametreler bir ve yalnızca bir kez değer almış
    bar(b=100, a=200, d=300)            # geçerli, tüm parametreler bir ve yalnızca bir kez değer almış
    bar(100, 200, 300, c=400, d=500)    # error! c iki kez değer almış
    bar(100, 200, 300)                  # geçerli, c iki kez değer almamış, c'nin değerini biz vermişiz
#------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------
    Pekiyi isimli argümanlara neden gereksinim duyulmaktadır. Aslında isimli argümanlara iki nedenden dolayı gereksinim duyulmaktadır:

    1) Çok sayıda default değer alan parametre değişkenlerinin bulunduğu fonksiyonda default değer almış bir parametre değişkenine 
    istenilen bir değeri pratik bir biçimde geçirebilmek için. Örneğin:

    def foo(a, b, c=10, d=20, e=30, f=60, g=70):
        pass

    Bu fonksiyonda biz en azından a ve b parametreleri için argüman girmek zorundayız. Ancak f parametresi için verilmiş default değerin
    dışında bir değer girmek istersek isimli argümanlar bize kolaylık sağlamaktadır:

    foo(100, 200, f=300)

    Eğer isimli argümanlar olmasaydı biz f'ye kadarki parametre değişkenleri için o default değerleri argüman olarak belirtmek 
    zorunda kalırdık. Örneğin:

    foo(100, 200, 10, 20, 30, 100)

    2) İsimli argümanlar okunabilirliği artırmak için de kullanılabilmektedir. Örneğin:

    val = int(s, base=16)

    Burada aslında isimli argüman kullanmaya gerek yoktur. Ancak programcı buradaki 16'nın taban belirttiğini vurgulamak için 
    isimli argüman kullanımını tercih etmiş olabilir. 
#------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------
    Biz kursumuzda atama işleminde '=' atomunun iki tarafında birer boşluk karakteri bırakıyoruz. Ancak Python programcıları 
    genel olarak (ancak hepsi değil) isimli argüman belirtirken '=' atomunun iki yanına boşluk karakteri girmemektedir. Biz de 
    kursumuzda bu yazım biçimini tercih edeceğiz. Default argümanlarda bazı programcılar boşluk bırakırken bazıları bırakmamaktadır. 
    Biz kursumuzda default argümanlarda '=' atomunun iki tarafına boşluk bırakacağız. Python yazım stilini anlatan "PEP 8"
    dokümanlarında her iki durumda da '=' atomunun iki yanında boşluk nırakılmamaktadır. Bu durum "Google Python Style Guide" 
    dokğmanında da aynı biçimdedir. Örneğin:

    def disp(a, base=10):
        pass

    disp(100, base=16)

    Ancak biz parametre değişkenlerine default argüman verirken '=' atomunun iki yanına boşluk bırakacağız. Örneğin:

    def disp(a, base = 10):
        pass

    disp(100, base=16)
#------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------
    Fonksiyonun parametre listesinde parametre değişkeni yerine '*' kullanılırsa '*'ın sağındaki tüm parametreler çağrım sırasında
    isimli argümanlarla çağrılmak zorundadır. Böylece fonksiyonu yazan kişi okunabilirliği artırmak amacıyla çağıran kişiyi isimli argüman 
    kullanmaya zorlayabilmektedir. Örneğin:

    def foo(a, b, *, c, d):
        pass

    Parametredeki "*" gerçek bir parametre değildir. Yani yukarıdaki foo fonksiyonunun 4 parametresi vardır. Buradaki "*" 
    bunun sağındaki parametreler için çağrım sırasında isimli argüman girilmesinin zorunlu olduğunu belirtmektedir. Örneğin:

    foo(100, 200, 300, 400)         # error! c ve d isimli kullanılmak zorunda
    foo(100, 200, c=300, d=400)     # geçerli
    foo(100, 200, d=400, c=300)     # geçerli

#------------------------------------------------------------------------------------------------------------------------
    Fonksiyonun parametre listesinde bir parametre yalnızca '/' biçiminde girilmişse bu durum "onun solundaki tüm parametreler
    argümanların pozisyonel olarak girilmesi gerektiği" anlamına gelmektedir. Örneğin:

    def foo(a, b, /, c = 100, d = 200):
        pass

    Burada a ve b parametreleri isimli girilemez. Pozisyonel girilmek zorundadır. Yine parametre listesindeki '/' karakteri
    gerçek bir parametre değildir. Dolayısıyla yukarıdaki fonksiyonun 4 parametresi vardır. Bu '/' parametresi bunun solundaki 
    parametreler için çağrım sırasında isimli argüman girilemeyeceği anlamına gelmektedir. Örneğin:

    foo(10, 20, 30, 40)             # geçerli
    bar(a=10, b=20)                 # error! a ve b pozisyonel girilmek zorundadır. 

    Örneğin:

    def disp_pixel(x, y, /):
        pass

    disp_pixel(10, 20)          # geçerli
    disp_pixel(10, y=20)        # error!

#------------------------------------------------------------------------------------------------------------------------

def foo(a, b, /, c, d):
    print(a, b, c, d)
    
foo(10, 20, c=30, d=40)     # 10 20 30 40

#------------------------------------------------------------------------------------------------------------------------
    * ile / parametre belirleyicileri aynı anda kullanılabilir. Ancak bu durumda önce / sonra * parametre belirleyicilerinin
    gelmesi gerekir. Örneğin:

    def foo(a, b, /, c,  *, d, e):
        print(a, b, c, d, e)
    
    Yukarıdaki örnekte / parametresinin solu pozisyonel biçimde, * parametresinin sağı isimli biçimde kullanılmak zorundadır. 
    Ancak / ile * arasındaki parametreler için isimli ya da pozisyonel argüman girilebilir. Yani bu örnekte a ve b parametrelerinin 
    pozisyonel argümanlarla, d ve e parametrelerinin isimli argümanlarla kullanılması zorunludur. Ancak c parametresi pozisyonel 
    ya da isili kullanılabilir. Örneğin:

    foo(10, 20, 30, d=40, e=50)     # geçerli
    foo(10, 20, c=30, d=40, e=50)   # geçerli
    foo(10, 20, 30, 40, e=50)       # error! d isimli kullanılmak zorunda   

    Pekiyi programcıyı pozisyonel argüman girmeye zorlamanın bir anlamı olabilir mi? Aslında her ne kadar isimli argüman girmek okunabilirliği 
    artırıyorsa da bazen tam tersi olabilmektedir. Örneğin sayının sinüsünü alan fonksiyonu düşünelim. Bu fonksiyonun parametresinin isminin 
    bir önemi var mıdır? Burada isim belirtilirse kodu inceleyen kişide tam tersine bir tereddüt oluşur. Örneğin:

    def sin(x, /):
        pass
#------------------------------------------------------------------------------------------------------------------------

def foo(a, b, /, c,  *, d, e):
    print(a, b, c, d, e)
    
foo(10, 20, 30, d=40, e=50)     # geçerli1
foo(10, 20, c=30, d=40, e=50)   # geçerli

#------------------------------------------------------------------------------------------------------------------------   
    Fonksiyonların *'lı parametreleri olabilir. Ancak fonksiyonun parametre listesinde yalnızca bir parametre değişkeni 
    önüne * getirilerek belirtilebilir. Örneğin:

    def foo(a, b, *c):
        pass

    Bunlara *'lı parametre diyeceğiz. *'lı parametreler en fazla bir tane olabilir. Örneğin:

    def foo(a, b, *c, *d):      # error!
        pass

    *'lı parametre genellikle parametre listesinin sonunda olsa da böyle bir zorunluluk yoktur. Örneğin:

    def foo(a, *b, c):      # geçerli
        pass

    *'lı parametre sıfır tane ya da daha fazla argümanla eşleşir. Yorumlayıcı çağırma ifadesindeki argümanları bir demete yerleştirip 
    demeti *'lı parametreye geçirmektedir. Yani *'lı parametre her zaman bir demet türündendir. Örneğin:

    def foo(a, b, *c):
        pass

    foo(10, 20, 30, 40, 50)

    Burada 10 a parametresi ile, 20 b parametresi ile 30, 40 ve 50 bir demet haline getirilerek c parametresi ile eşleştirilecektir. 
    Örneğin:

    foo(10, 20)

    Burada yine 10 değeri a parametre değişkenine, 20 değeri b parametre değişkenine atanacaktır. c paramatre değişkenine 
    ise boş bir demet geçirelecektir. 
#------------------------------------------------------------------------------------------------------------------------

def foo(a, b, *c):
    print(f'a = {a}, b = {b}, c = {c}')
        
foo(10, 20, 30, 40, 50, 60)     # a = 10, b = 20, c = (30, 40, 50, 60)
foo(10, 20, 30)                 # a = 10, b = 20, c = (30,)
foo(10, 20)                     # a = 10, b = 20, c = ()
       
#------------------------------------------------------------------------------------------------------------------------
                                                30. Ders 27/07/2022 - Çarşamba
#------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------
    *'lı parametre parametre listesinin sonunda olmak zorunda değildir. Ancak her parametre değişkeninin bir ve yalnızca 
    bir kez değer almış olması gerekir. Örneğin:

    def foo(a, *b, c):
        pass

    foo(10, 20, 30)         # error! c değer almamış

    Burada 20 ve 30 c için girilmiş gibi olmaktadır. Dolayısıyla c paramere değişkeni değer almamış durumdadır. Bu tür durumlarda
    *'lı parametrenin sağındaki parametre değişkenlerine mecburen isimli bir biçimde argüman girilmelidir. Örneğin:

    foo(10, 20, 30, 40, c=50)       # geçerli

    Burada 10 argümanı a ile, (20, 30, 40) argümanları b ile eşleşmektedir. 50 argümanı b *'lı parametresinin bir parçası değildir. 
    Çünkü açıkça isimli bir biçimde belirtilmiştir. Dolayısıyla 50 c argümanı ile eşleşecektir. Burdada her parametre değişkeni daha önce
    de belirttiğimöiz gibi en az bir kez ve en fazla bir kez değer almış durumdadır. Örneğin:

    def foo(a, *b, c = 100):
        pass

    foo(10, 20, 30)         # geçerli, c de değer almış

    Gördüğünüz gibi *'lı parametre parametre listesinin sonunda değilse *'lı parametrenin sağındaki parametrelerin ya default 
    değer almış olması gerekir ya da argüman listesinde isimli bir biçimde kullanılmış olması gerekir. 
#------------------------------------------------------------------------------------------------------------------------

def foo(a, *b, c, d):
     print(f'a = {a}, b = {b}, c = {c}, d = {d}')

foo(10, 20, 30, c=100, d=200)           # geçerli, a = 10, b = (20, 30), c = 100, d = 200

#------------------------------------------------------------------------------------------------------------------------
    *'lı parametrenin her zaman demet belirttiğine dikkat ediniz. Demetler dolaşılabilir nesneler olduğuna göre biz
    *'lı parametreyi for döngüsi içerisinde dolaşılbiliriz.
#------------------------------------------------------------------------------------------------------------------------

def add(*args):
    total = 0
    for x in args:
        total += x
        
    return total

result = add()
print(result)           # 0

result = add(10)
print(result)           # 10

result = add(10, 20, 30)
print(result)           # 60

#------------------------------------------------------------------------------------------------------------------------
    Aslında print fonksiyonu da *'lı parametre almaktadır. Biz de print fonksiyonunu myprint ismiyle yazabiliriz. Tabii 
    burada ekrana yazdırma için yine orijinal print fonksiyonunu kullanacağız. Aşağıdaki örnek yalnızca print fonksiyonunun nasıl 
    yazılmış olabileceğini göstermek amacıyla verilmektedir. 
#------------------------------------------------------------------------------------------------------------------------

def myprint(*objects, sep=' ', end='\n'):
    i = 0
    while i < len(objects):
        if i != 0:
            print(end=sep)
        print(objects[i], end='')
        i += 1
    print(end=end)
    
myprint(10, 20, 30)
myprint(10, 20, 30, sep='*')
myprint(10, 20, 30, sep='*', end='/')

#------------------------------------------------------------------------------------------------------------------------
    Yukarıdaki myprint fonksiyonunu for döngüsüyle de yapabilirdik. Ancak for döngüsü bu tür durumlarda daha zahmetli
    bir çözüm sunabilmektedir. 
#------------------------------------------------------------------------------------------------------------------------

def myprint(*objects, sep=' ', end='\n'):
    if len(objects):
        print(objects[0], end='')
    for x in objects[1:]:
        print(end=sep)
        print(x, end='')
    print(end=end)
    
myprint(10, 20, 30)
myprint(10, 20, 30, sep='*')
myprint(10, 20, 30, sep='*', end='/')

#------------------------------------------------------------------------------------------------------------------------
    print fonksiyonuna hiç argüman girilmemişse fonksiyon nasıl çalışacaktır? Örneğin:

    print()

    Burada fonksiyonun *'lı parametresine boş bir demet aktarılacaktır. Dolayısıyla fonksiyon bir şey yazdırmyacaktır. 
    Fonksiyon bir şey yazdırmayacağına göre sep parametresi de kullanılmayacaktır. Çünkü sep parametresi print fonksiyonu 
    birden fazla argümanı yazdırırsa onların arasına yerleştirilecek karakteri belirtmektedir. print fonksiyonu işini bitirince 
    end parametresiyle belirtilen yazıyı ekrana (stdout dosyasına) bastıracağına göre boş print yalnızca imlecin aşağı satırın
    başına geçmesine yol açacaktır.
#------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------
    Tabii biz *'lı parametreler için listeler, demetler, kümeler ve sözlükler de girebiliriz. Örneğin:

    def foo(*a):
        pass

    Burada biz fonksiyonu şöyle çağırmış olalım:

    foo(10, 20, 30)

    10, 20 ve 30 değerleri bir demet haline getirilerek fonksiyonun a parametre değişkenine geçirilecektir. Şimdi fonksiyonu şöyle
    çağırmış olalım:

    foo([10, 20, 30])

    Burada a parametre değişkenine tek elemanlı bir demet aktarılacaktır. Demetin tek elemanı da liste olacaktır. Örneğin:

    foo((10, 20, 30))

    Burada a parametre değişkenine yine tek elemanlı bir demet aktarılacaktır. Demetin tek elemanı da (10, 20, 30) demeti 
    olacaktır. 
#------------------------------------------------------------------------------------------------------------------------

def foo(*a):
    for x in a:
        print(x, end=' ')
    print()
        
foo(10)                 # 10
foo(10, 20, 30)         # 10 20 30
foo([10, 20, 30])       # [10, 20, 30]
foo((10, 20, 30))       # (10, 20, 30)

#------------------------------------------------------------------------------------------------------------------------
    Python'ın standart kütüphanesindeki min ve max isimli built-in fonksiyonlar bir dolaşılabilir nesneyi alıp onun en küçük 
    ve en büyük elemanlarına geri dönmektedir. 
#------------------------------------------------------------------------------------------------------------------------

a = [34, 56, 21, 76, 18]

result = max(a)
print(result)               # 76

result = min(a)
print(result)               # 21

#------------------------------------------------------------------------------------------------------------------------
    Aslında min ve max fonksiyonlarına birden fazla argüman da girilebilmektedir. Bu durumda bu argümanların en büyük ve 
    en küçük değerleri elde edilir. 
#------------------------------------------------------------------------------------------------------------------------

result = max(89, 79, 34)
print(result)           # 89

result = min(4, 67, 1, 68)
print(result)           # 1

#------------------------------------------------------------------------------------------------------------------------
    Görüldüğü gibi eğer biz min ve max fonksiyonlarına tek eleman girersek o argümanın dolaşılabilir  olması gerekir. 
    Ancak biz bu fonksiyonlara birden fazla argüman girersek bu fonksiyonlar o argümanların en küçük ve en büyük değerlerini bulular. 
    Pekiyi min ve max fonksiyonları nasıl yazılmış olabilir? Bu fonksiyonlar birden fazla argümanı kabul ettiğine göre *'lı bir 
    parametreye sahip olmalıdır. O zaman bu *'lı parametreye aktarılan argüman bir tane ise biz onu dolaşılabilir bir nesne kabul edip 
    onun en küçük ya da en büyük elemanını bulmaya çalışırız. Eğer bu *'lı parametreye birden fazla argüman girilmişse bu 
    durumda biz bu *'lı parametreye aktarılan demetin en küçük ya da en büyük elemanını bulmaya çalışırırz. Dolaşılabilir bir nesnenin 
    en küçük ya da en büyük elemanını bulmak için ilk eleman en küçük ya da en büyük kabul edilip bir değişken de saklanır. Sonraki elemanlar 
    bu değişkendekiyle karşılaştırılıp değişkenin değeri güncellenir. Biz ileride dolaşılabilir nesnelerin elemanlarını for döngüsü olmadan 
    da ilerletebileceğiz. Örneğin next isimli built-in fonksiyon bunun için kullanılmaktadır. Ancak biz henüz dolaşılabilir nesnelerin 
    ayrıntılarını bilmiyoruz. Bu nedenle gerçekleştirimi aşağıdaki gibi yapıyoruz.
   #------------------------------------------------------------------------------------------------------------------------

def mymax(*args):
    iterable = args[0] if len(args) == 1 else args
    
    maxval = None
    for x in iterable:
        if maxval == None or x > maxval:
            maxval = x
            
    return maxval

a = [1, 6, 3, 2, 5]

result = mymax(a)
print(result)               # 6

result = mymax(4, 16, 2, 3)
print(result)               # 16


def mymin(*args):
    iterable = args[0] if len(args) == 1 else args
    
    minval = None
    for x in iterable:
        if minval == None or x < minval:
            minval = x
            
    return minval
        
a = [1, 6, 3, 2, 5]

result = mymin(a)
print(result)               # 1

result = mymin(4, 16, 2, 3)
print(result)               # 2

#------------------------------------------------------------------------------------------------------------------------
    Fonksiyonların *'lı parametreleri için fonksiyon çağrılırken isimli argüman girilememektedir. Örneğin:

    def foo(a, b, *c):
        pass

    foo(10, 20, c=30)                   # error!
    foo(10, 20, c=(30, 40, 5))          # error!

    Fonksiyonun *'lı parametreleri default argüman alamaz. Örneğin:

    def foo(a, b, *c = (10, 20, 30)):           # error! *'lı parametrelere default değer veremeyiz!
        pass

#------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------
                                                31. Ders 01/08/2022 - Pazartesi
#------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------
    Fonksiyonların *'lı parametrelerinin yanı sıra bir de **'lı parametreleri bulunabilmektedir. Bir fonksiyonun **'lı parametresi 
    eğer bulundurulacaksa parametre listesinin sonunda bulundurulmak zorundadır. (Halbuki *'lı parametre listesinin herhangi bir yerinde
    bulundurulabilmektedir.) Fonksiyonun tek bir **'lı parametresi olabilir. Geleneksel olarak pek çok programcı fonksiyonun *'lı parametresine 
    args ismini **'lı parametresine ise kwargs ya da kargs ismini vermektedir. 

    Bir fonksiyon aslında olmayan parametrelere ilişkin isimli argümanlarla çağrılırsa, yorumlayıcı bu isimli argümanları bir sözlükte 
    toplayarak sözlüğü fonksiyonun **'lı parametresine geçirmektedir. Olmayan parametrelere ilişkin isimli argümanların argüman isimleri 
    sözlüğün anahtarları, onlara '=' ile verilen değerler de o anahtarlara karşı gelen değerleri oluşturmaktadır. Buradaki anahtarlar 
    her zaman str türündendir. Örneğin:

    def foo(a, *args, **kwargs):
        print('a = {}, args = {}, kwargs = {}'.format(a, args, kwargs))
    
    Biz bu fonksiyonu şöyle çağırmış olalım:

    foo(10, 20, 30, 40, xx='ali', yy=100)

    Görüldüğü gibi aslında fonksiyonun xx ve yy isimli parametre değişkenleri yoktur. Yorumlayıcı önce {'xx': 'ali', 'yy': 100}
    biçiminde bir sözlük nesnesi oluşturur sonra bu sözlük nesnesini **'lı parametreye aktarır. Örneğin:

    foo(10, 20, 30, 40)

    Burada fonksiyon olmayan bir parametre ismiyle çağrılmamıştır. Bu durumda **'lı parametreye boş sözlük geçirilecektir. 
    Tıpkı *'lı parametrelerde olduğu gibi fonksiyonun **'lı parametreleri de default değer alamaz ve bunlara isimli olarak 
    argüman geçirilemez.

    Mademki *'lı ve **'lı parametreler için isimli argüman girilememektedir. Bu durumda eğer bu argümanlar isimli kullanılırsa
    ve fonksiyonun da **'lı bir parametresi varsa bu argümanlar "olmayan parametre değişkenleri gibi" değerlendirilecek ve bir 
    sözlük biçiminde **'lı parametreye aktarılacaktır. Örneğin:

    def foo(a, *args, **kwargs):
        print('a = {}, args = {}, kwargs = {}'.format(a, args, kwargs))
        
    foo(10, args=20, kwargs=30)

    Buradan şöyle bir çıktı elde edilecektir:

    a = 10, args = (), kwargs = {'args': 20, 'kwargs': 30}

#------------------------------------------------------------------------------------------------------------------------

def foo(a, *args, **kwargs):
    print('a = {}, args = {}, kwargs = {}'.format(a, args, kwargs))
    
foo(10, 20, 30, 40, xx='ali', yy=100)       # a = 10, args = (20, 30, 40), kwargs = {'xx': 'ali', 'yy': 100}
foo(10, 20, 30, 40)                         # a = 10, args = (20, 30, 40), kwargs = {}
foo(a=10)                                   # a = 10, args = (), kwargs = {}
foo(10, args=(100, 200))                    # a = 10, args = (), kwargs = {'args': (100, 200)}
foo(10, 20, 30, kwargs={})                  # a = 10, args = (20, 30), kwargs = {'kwargs': {}}

#------------------------------------------------------------------------------------------------------------------------
    Pekiyi fonksiyonların **'lı parametreleri neden kullanılmaktadır? Bunun iki nedeni vardır: Birincisi bir fonksiyon çok fazla
    parametreye sahipse parametre sayısını azaltmak için **'lı parametre kullanılabilmektedir. Örneğin bir fonksiyon için 50 tane parametre 
    söz konusu olsun. Bu 50 parametrenin parametre listesinde belirtilmesi okunabilirliği bozar. Üstelik bu parametreler başka fonksiyonlarda da
    söz konusu ise hem programcının bunları yazması zorlaşır hem de okunabilirlik düşer. İşte bu durumda **'lı parametreler 
    kolaylık sağlamaktadır. Şimdi foo fonksiyonun a, b, c, d, e, f, g, h, i, j, k, l, m parametrelerinin olduğunu düşünelim. Bu parametrelerin 
    ilk ikisi dışındakiler default değer alıyor olsun. Foksiyonu aşağıdaki gibi tanımlamış olalım:

    def foo(a, b, **kwargs):
        pass

    Burada fonksiyonu çağıran onu aşağıdaki gibi çağırabilir:

    foo(10, 20, c=100, f=200, k=300, j=400)
    foo(10, 20, m=200)

    Görüldüğü gibi **kwargs parametresi bu çağrımlara izin vermektedir. Tabii bu durumda aşağıdaki gibi bir çağrım da geçerli olacaktır:

    foo(10, 20, r=20)

    Halbuki fonksiyonda r biçiminde bir parametre yoktur. O halde bu tür fonksiyonları yazan kişiler aslında her isimli argümanı kabul 
    etmemektedir. Yalnızca daha önce belirlemiş oldukları isimli argümanları kabul etmektedir. Bu nedenle bu tür fonksiyonlarda 
    genellikle işin başında bir parametre kontrolü yapılmaktadır. Örneğin:

    def foo(a, b, **kwargs):                # c, d, e, f, g, h, i, j, k, l, m 
        legal_args = ['c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm']
     
        for key in kwargs:
            if key not in legal_args:
                print(f'invalid argument: {key}={kwargs[key]}')
                return
            
        print('Ok')
    
    foo(10, 20, c=10, f=20, i=30, k=40)         # Ok
    foo(10, 20, c=10, r=30)                     # invalid argument: r=30

    Burada programcı işin başında isimli argümanlar için geçerlilik kontrolü yapmıştır. Yani fonksiyonun **'lı parametreye sahip 
    olması onun istenildiği gibi olmayan bir isimli argümanla çağrılabileceği anlamına gelmemektedir. 
    
    Tabii aslında isimli argümanlar için default değerler de söz konusu olabilmektedir. Örneğin c=100, d=200, e=300, f=400, 
    g=500, h=600, i=700, j=800, k=900, l=1000, m=1100, default değerleri söz konusu olsun. Yani fonksiyonu çağıran bu değerleri 
    girmezse buradaki değerler kullanılacak olsun. Bu mekanizmayı basit bir biçimde şöyle sağlayabiliriz:

    def foo(a, b, **kwargs):   
        legal_args = ['c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm']
        
        for key in kwargs:
            if key not in legal_args:
                print(f'invalid argument: {key}={kwargs[key]}')
                return
            
        c = kwargs.get('c', 100)
        d = kwargs.get('d', 200)
        e = kwargs.get('e', 300)
        f = kwargs.get('f', 400)
        g = kwargs.get('g', 500)
        h = kwargs.get('h', 600)
        i = kwargs.get('i', 700)
        j = kwargs.get('j', 800)
        k = kwargs.get('k', 900)
        l = kwargs.get('l', 1000)
        m = kwargs.get('m', 1100)
        
        print(f'c = {c}, d = {d}, e = {e}, f = {f}, g = {g}, h = {h}, i = {i}, j = {j}, k = {k}, l = {l}, m = {m}')
        
    
    foo(10, 20, c=10, f=20, i=30, k=40)         # c = 10, d = 200, e = 300, f = 20, g = 500, h = 600, i = 30, j = 800, k = 40, l = 1000, m = 1100
    foo(10, 20)                                 # c = 100, d = 200, e = 300, f = 400, g = 500, h = 600, i = 700, j = 800, k = 900, l = 1000, m = 1100

    Parametre saysı çok fazlaysa yukarıdaki yöntem biraz zahmetli olmaya başlayabilir. Bu durumda isimli argümanlar default değerleriyle
    bir sözlükte toplanabilir. Sonra bu sözlükteki değerler bir döngüyle girilen isimli argümanlar için güncellenebilir:

    def foo(a, b, **kwargs):   
        legal_args = {'c': 100, 'd': 200, 'e': 300, 'f': 400, 'g': 500, 'h': 600, 'i': 700, 'j': 800, 'k': 900, 'l': 1000, 'm': 1100}
        
        for key in kwargs:
            if key not in legal_args:
                print(f'invalid argument: {key}={kwargs[key]}')
                return
        
        for key, value in kwargs.items():
            legal_args[key] = value
                
        for key, value in legal_args.items():
            print(f'parameter: {key}, value: {value}')
            
    foo(10, 20, c=10, f=20, i=30, k=40)     
    print()   
    foo(10, 20)

    Tabii yukarıdaki örnekte ilk döngü ile ikinci döngü de duruma göre aşağıdaki gibi birleştirilebilir:

    def foo(a, b, **kwargs):   
        legal_args = {'c': 100, 'd': 200, 'e': 300, 'f': 400, 'g': 500, 'h': 600, 'i': 700, 'j': 800, 'k': 900, 'l': 1000, 'm': 1100}
        
        for key, value in kwargs.items():
            if key not in legal_args:
                print(f'invalid argument: {key}={kwargs[key]}')
                return
            else:
                legal_args[key] = value    
                
                
        for key, value in legal_args.items():
            print(f'parameter: {key}, value: {value}')
            
    foo(10, 20, c=10, f=20, i=30, k=40)     
    print()   
    foo(10, 20)

#------------------------------------------------------------------------------------------------------------------------

def foo(a, b, **kwargs):   
    legal_args = {'c': 100, 'd': 200, 'e': 300, 'f': 400, 'g': 500, 'h': 600, 'i': 700, 'j': 800, 'k': 900, 'l': 1000, 'm': 1100}
     
    for key, value in kwargs.items():
        if key not in legal_args:
           print(f'invalid argument: {key}={kwargs[key]}')
           return
        else:
            legal_args[key] = value    
               
            
    for key, value in legal_args.items():
        print(f'parameter: {key}, value: {value}')
        
foo(10, 20, c=10, f=20, i=30, k=40)     
print()   
foo(10, 20)

#------------------------------------------------------------------------------------------------------------------------
    Pekiyi biz bir fonksiyonda ** parametresi gördüğümüzde ne düşünmeliyiz? İşte böyle bir fonksiyon karşısında bizim şu çıkarımı 
    yapmamız gerekir: "Bu fonksiyon pek çok parametreye sahip olabilir. Bu parametreleri fonksiyonu yazan tek tek belirtmek istememiş.
    Ben geçerli parametreleri fonksiyonu çağırırken isim=değer biçiminde isimli argüman olarak geçebilirim. Benim geçebileceğim 
    isimli argümanların neler olduğunu anlamak için dokümantasyona bakmalıyım".

    **'lı parametreye örnek olarak matplotlib kütüphanesindeki plot, title ve text gibi fonksiyonlar verilebilir. plot fonksiyonu
    aynı uzunlukta x ve y dolaşılabilir nesnelerini alıp onların karşılıklı elemanlarının belirttiği noktaları çizgiyle birleştirmektedir. 
    Ancak plot grafiğinin çok sayıda özelliği vardır. Bu özelliklerin tek tek parametrelerle ifade edilmesi çok zordur. Bu nedenle plot fonksiyonu
    **'lı bir parametreyle tüm parametreleri temsil etmektedir. Benzer biçimde grafiğe başlık atmakta kullanılan title fonksiyonunda ve
    yazı yazmakta kullanılan text fonksiyonunda da aynı durum geçerlidir. 
#------------------------------------------------------------------------------------------------------------------------

import math
import matplotlib.pyplot as plt

xpoints = []
ypoints = []

x = -6.
while x <= 6:
    xpoints.append(x)
    ypoints.append(math.sin(x))
    x += 0.01
        
print(xpoints)   

plt.title('Sinüs Grafiği', fontsize=18, color='blue', pad=20, fontweight='bold')
plt.plot(xpoints, ypoints, color='red', linewidth=6, linestyle='--', alpha=0.5)
plt.text(2, -0.50, 'Test', fontsize=16, color='green', fontweight='bold')

plt.show()

#------------------------------------------------------------------------------------------------------------------------
    Fonksiyonun *'lı parametresinden sonraki parametreler eğer default değer almamışsa zaten isimli argüman biçiminde kullanılabileceğine göre 
    şöyle bir ince kural dile eklenmiştir: Bir parametre değişkeni default değer almışsa *'lı parametreye kadar onun sağındakilerin hepsinin
    default değer alması gerekir. *'lı parametreden sonraki parametreler karışık sırada default değer alan ve almayan biçiminde bulunabilir. Örneğin:

    def foo(a, b = 10, c = 20, d):                      # error!
        pass

    def foo(a, b = 10, c = 20, *args, d):               # geçerli
        pass

    def foo(a, b = 10, c = 20, *args, d, e = 30, f):    # geçerli
        pass

#------------------------------------------------------------------------------------------------------------------------
    **'lı parametre kullanımının ikinci nedeni "forwarding (iletme)" yapmak içindir. Buna ilişkin örnek izleyen örneklerde verilecektir. 
#------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------
    Fonksiyonları çağırırken argümanların önüne '*' atomu getirilebilir. Bu tür argümanlara "*'lı argümanlar" diyeceğiz. 
    *'lı argümanlar argüman listesinde birden fazla bulunabilirler. Örneğin:

    foo(a, b, *c, d, *e, f)

    *'lı argümanların "dolaşılabilir (iterable)" nesne belirtmesi gerekir. Yani *'ın yanındaki nesne bir liste olabilir, 
    demet olabilir, sözlük olabilir, range nesnesi olabilir ya da başka dolaşılabilir nesneler olabilir. Ancak öneğin int ve float olamaz.
    Çünkü int ve float dolaşılabilir değildir. 

    Bir argümanın önüne * getirildiği zaman derleyici bu dolaşılabilir nesneyi dolaşır ve dolaşımdan elde ettiği değerleri sanki programcı tek tek 
    girmiş gibi fonksiyona yollar. Yani örneğin:

    x = [10, 20, 30]
    foo(*x)

    çağrısı tamamen aşağıdakiyle eşdeğerdir:

    foo(10, 20, 30)

    Örneğin:

    foo(*'ali')

    çağrısı da aşağıdaki eşdeğerdir:

    foo('a', 'l', 'i')

    Tabii buradan da görüldüğü gibi *'ın yanındaki dolaşılabilir nesnenin eleman sayısının fonksiyon ile uyumlu olması gerekmektedir. Örneğin:

    def foo(a, b, c):
        pass

    foo(*'ali')         # geçerli
    foo(*'ankara')      # error! fonksiyondaki parametreler yetersiz!

    Ancak örneğin:

    def foo(a, b, *args):
        pass

    x = [10, 20, 30, 40, 50]
    foo(100, *x)

    Bu çağrı geçerlidir. Çünkü eşdeğeri şöyledir:

    foo(100, 10, 20, 30, 40, 50)

    Burada 100 değeri a parametresine, 10 değeri b parametresine ve diğerleri de args parametresine demet olarak aktarılacaktır. Örneğin:

    def foo(*args):
        pass

    Aşağıdaki çağrısı da geçerlidir:

    foo(*'ankara')
#------------------------------------------------------------------------------------------------------------------------

def foo(a, b, c, d, e):
    print(f'a = {a}, b = {b}, c = {c}, d = {d}, e = {e}')
    
t = 10, 20, 30

foo(1, 2, *t)                       #  a = 1, b = 2, c = 10, d = 20, e = 30


a = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
b = {100, 200, 300}
print(*a, 10, *b)                   # 1 2 3 4 5 6 7 8 9 10 10 200 100 300


print(*range(10, 20), sep=', ')     # 10, 11, 12, 13, 14, 15, 16, 17, 18, 19


def bar(a, b, *c):
    print(f'a = {a}, b = {b}, c = {c}')
    
x = [10, 20, 30, 40, 50, 60]

bar(1, *x)                          # a = 1, b = 10, c = (20, 30, 40, 50, 60)
    
#------------------------------------------------------------------------------------------------------------------------
    Örneğin bir liste içerisindeki değerleri aralarına ', ' koyarak yazdırmak isteyelim. Tabii böyle bir yazımın sonunda ','
    karakteri olmamlıdır. Muhtemel çözüm şöyle olabilir:

    a = [10, 20, 30, 40, 50]

    for i in range(len(a)):
        if i != 0:
            print(end=', ')
        print(a[i], end='')

    print()
        
    Aslında *'lı argüman sayesinde bu işlem tek bir print ile yapılabilmektedir:

    print(*a, sep=', ')

#------------------------------------------------------------------------------------------------------------------------
    *'lı argüman sarma fonksiyon yazarken "iletme (forwarding)" amaçlı da kullanılabilmektedir. Örneğin biz myprint isimli 
    fonksiyon yazmak isteyelim. Ancak fonksiyonumuz aldığı parametreleri print fonksiyonuna yollasın (forward etsin):

    def myprint(*args):
        print(*args)
    
    myprint(10, 20, 30, 40, 50)     

    Ancak buradaki iletmede bir kusur vardır. Ya sep ve end parametrelerini kullanmak istersek?

    myprint(10, 20, 30, 40, 50, sep=', ', end='*')     

    Aşağıdaki gibi çözüm bu örnekte çalışabilise de genel bir çözüm oluşturmaz:

    def myprint(*args, sep=' ', end='\n'):
        print(*args, sep=sep, end=end)
    
    myprint(10, 20, 30, 40, 50, sep=', ')     
#------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------
    Sözlüklerin de dolaşılabilir nesneler olduğunu unutmayınız.
#------------------------------------------------------------------------------------------------------------------------

d = {10: 'ali', 20: 'veli', 30: 'selami', 40: 'ayşe', 50: 'fatma'}

print(*d)                   # 10 20 30 40 50
print(*d.values())          # ali veli selami ayşe fatma

#------------------------------------------------------------------------------------------------------------------------
    Fonksiyonların **'lı argümanları da olabilmektedir. Bu argümanlar argüman listesinde birden fazla kez bulundurulabilmektedir. 
    **'lı argümanlar bir sözlük nesnesi olmak zorundadır. Bu argümanlara ilişkin sözlük nesnelerinin anahtarlarının str türünden olması 
    gerekir. Ancak değerleri herhangi bir türden olabilir. 

    Yorumlayıcı argümanda ** gördüğünde argümana ilişkin sözlük nesnesini dolaşır. Anahtarları argümanların isimleri, değerleri 
    de o isimli argümanlara onlara verilmiş  değerler kabul ederek fonksiyonu çağırır. Örneğin:

    def foo(a, b, c):
        pass
    
    d = {'a': 10, 'b': 'ankara', 'c': 12.3}

    Burada çağrı şöyle yapılmış olsun:

    foo(**d)        

    Bu çağrının tamamen eşdeğeri şudur:

    foo(a=10, b='ankara', c=12.3)

    Aşağıdaki çağrıya dikkat ediniz:

    d = {'a': 10, 'b': 20}

    foo(**d, 100)       # error!

    Bu çağrı geçersizdir. Çünkü bunun eşdeğeri şöyledir:

    foo(a=10, b=20, 100)

    İsimli argümanlardan sonra isimsiz argümanlar gelemez. Örneğin:

    def foo(a, b, c):
        pass

    foo(100, *{'b': 10, 'c': 20})

    Bu çağrı geçerlidir. Çünkü eşdeğeri şöyledir:

    foo(100, b=10, c=20)

#------------------------------------------------------------------------------------------------------------------------

def foo(a, b, c, d, e, f):
    print(f'a = {a}, b = {b}, c = {c}, d = {d}, e = {e}, f = {f}')

d = {'c': 100, 'd': 200, 'e': 300}
    
foo(10, 20, **d, f=400)     # foo(10, 20, c=100, d=200, e=300, f=400)

#------------------------------------------------------------------------------------------------------------------------
    **'lı argümanlar sarma fonksiyonlarda "iletme (forwarding)" işlemlerinde kullanılabilmektedir. Örneğin:

    def myprint(*args, **kwargs):
        print(*args, **kwargs)      # perfect forwarding

    myprint(10, 20, 30, sep=', ', end='*')

    Burada myprint fonksiyonuna geçirilen tüm argümanlar print fonksiyonuna mükemmel biçimde iletilmektedir. Çünkü örnek 
    çağrıdaki sep ve end isimli argümanları myprint fonksiyonunun kwargs parametresine sözlük nesnesi olarak geçirilecektir. 
    myprint fonksiyonu da bunu print fonksiyonuna aynı biçimde iletmiştir. 

    "forwarding" bir bir fonksiyonun aldığı parametreleri başka bir fonksiyona argüman olarak iletmesi durumuna denilmektedir. 
    Yukarıdaki örnekte myrint fonksiyonu kendisi hangi argümanlarla çağrılmışsa print fonksiyonunu da o argümanlarla çağırmıştır. 

    Aşağıdaki örnekte matplotlib kütüphanesindeki plot fonksiyonu myplot isimli bir fonksiyon tarafından sarmalanmış ve 
    parametreler plot fonksiyonuna ilketilmiştir. 
#------------------------------------------------------------------------------------------------------------------------

import math
import matplotlib.pyplot as plt

xpoints = []
ypoints = []

x = -6.
while x <= 6:
    xpoints.append(x)
    ypoints.append(math.sin(x))
    x += 0.01
        
def myplot(*args, **kwargs):
    plt.plot(*args, **kwargs)

plt.title('Sinüs Grafiği', fontsize=18, color='blue', pad=20, fontweight='bold')
myplot(xpoints, ypoints, color='red', linewidth=6, linestyle='--', alpha=0.5)
plt.text(2, -0.50, 'Test', fontsize=16, color='green', fontweight='bold')

plt.show()

#------------------------------------------------------------------------------------------------------------------------
                                             32. Ders 03/08/2022 - Çarşamba
#------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------
    Bir listenin ya da demetin elemanı da *'lı bir dolaşılabilir nesne olabilir. Bu durumda bu dolaşılabilir nesne dolaşılır.
    Sanki onların değerleri liste ya da demete eleman yapılmış gibi olur. Örneğin:

    a = 1, 2, 3, 4, 5
    b = [10, 20, *a, 30, 40]

    Tabii listeleri ve demetleri oluştururken istediğimiz kadar çok *'lı eleman kullanabiliriz. 
#------------------------------------------------------------------------------------------------------------------------

a = [10, 20, *range(5), 30, 40]
print(a)                            # [10, 20, 0, 1, 2, 3, 4, 30, 40]

t = 10, 20, *'ali', 30, 40
print(t)                            # (10, 20, 'a', 'l', 'i', 30, 40)

#------------------------------------------------------------------------------------------------------------------------
    Benzer biçimde bir sözlük oluşturulurken sözlüğün elemanları da **'lı nesneler olabilir. Bu duurmda **'ın sağındaki sözlüğün 
    elemanları o sözlüğün elemanlarına eklenmiş olur. Örneğin:

    d = {'süleyman': 100, 'sacit': 200}
    k = {'ali': 10, 'veli': 20, 'selami': 30, **d, 'ayşe': 40, 'fatma': 50}

    Tabii burada artık **'ın sağındaki sözlüğün anahtarlarının birer string olması gerekmez. Biz bu biçimde sözlük oluştururken
    istediğimiz kadar çok **'lı eleman kullanabiliriz. 
#------------------------------------------------------------------------------------------------------------------------

d = {'süleyman': 100, 'sacit': 200}
k = {'ali': 10, 'veli': 20, 'selami': 30, **d, 'ayşe': 40, 'fatma': 50}

print(k)            # {'ali': 10, 'veli': 20, 'selami': 30, 'süleyman': 100, 'sacit': 200, 'ayşe': 40, 'fatma': 50}

#------------------------------------------------------------------------------------------------------------------------
    Bir çağrı sırasında argümanların girilişi ile ilgili nihai kural şöyledir:

    1) İsimli argümanlar (keyword arguments) her zaman isimsiz (pozisyonel) argümanların sağında bulunmak zorundadır. İsimli bir argümanın sağında 
    isimsiz bir argüman bulunamaz.**'lı argümanlar isimli argüman olarak kabul edilmektedir. 

    2) Ancak isimli argümanın sağında bir ya da birden fazla karışık sırada *'lı ve **'lı argüman bulunabilir. 

    3) Her zaman *'lı argümanlar **'lı argümanların solunda bulunmak zorundadır. 

    4) Argüman parametre eşleşmesinde önce yalnızca isimsiz argümanlar ve *'lı argümanlar dikkate alınır. isimli ve **'lı argümanlar
    nerede bulunuyor olursa olsun bu aşamada dikkate alınmazlar. İsimsiz argümanlar ve *'lı argümanlar ilk n tane parametre değişkeni ile
    sırasıyla eşleştirilir. Sonra isimli argümanlar eşleştirilir. Eğer toplamda bir parametre için birden fazla değer eşleştirilmişse 
    ya da bir parametre için hiçbir değer eşleştirilmemişse bu durum error oluşturmaktadır. Örneğin aşağıdaki gibi bir fonksiyon olsun:

    def foo(a, b, c, d, e, f):
        print(f'a = {a}, b = {b}, c = {c}, d = {d}, e = {e}, f = {f}')

    Aşağıdaki gibi bir çağrı geçerlidir:

    t = (10, 20) 
    foo(1, 2, f=10, *t, e=30)   

    Burada önce isimsiz ve *'lı argümanlar eşleştirilir. 1 --> a ile, 2 --> b ile, 10 --> c ile ve 20 --> d ile eşleştirilecektir. 
    Sonra isimli argümanlar da eşleştirilir. Burada toplamda her parametreye yalnızca bir kez ve en fazla bir kez eşleştirme y
    apılmıştır. Örneğin:

    foo(1, 2, f=10, *t, *t)  

    Burada f'ye iki kez eşleştirme yapıldığı için çağrı geçersizdir. Örneğin:

    foo(1, 2, f=100, **d, c=200)   

    Bu çağrı da yukarıda belirtilen kurallara tamamen uygundur. Bu nedenle geçerlidir. Örneğin:

    t = (10, 20) 

    foo(1, 2, f=100, *t) 

    Burada argüman kuralları uygulnamıştır. Argüman parametre eşleştirmesinde önce isimş ve *'lı argümanlar dikkate alınacaktır. 
    Bu durumda 1 --> a ile, 2 --> b ile, 10 --> c ile, 20 -->d ile ve f --> 100 ile eşleştirilecektir. Ancak e parametre değişkeni 
    değer almadığı için bu çağrı error ile sonuçlanacaktır. Örneğin:

    t = (10, 20) 
    d = {'f': 100, 'e': 200}

    foo(1, 2, *t, **d) 

    Burada da yukarıda belirtitğimiz tüm kurallara uyulmuştur. Argüman parametre eşleştirmeleri de uygundur. O halde çağrı geçerlidir. 
    Örneğin:

    t = (10, 20) 
    d = {'f': 100, 'e': 200}

    foo(1, 2, **d, *t) 

    Burada **'lı argümanın *'lı argümanın sağında olması gerekirdi. Bu nedenle bu durum error oluşturacaktır.
#------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------
    Açağıdaki örnekte add isimli fonksiyon *'lı paramtresiyle aldığı değerlerin toplamına geri dönmektedir. Ancak bu değerler eğer
    bir demet ya da liste ise onlar da bu toplama katılmışlardır. 
#------------------------------------------------------------------------------------------------------------------------

def add(*args):
    total = 0
    for x in args:
        if isinstance(x, (tuple, list)):
            for y in x:
                total += y
        else:
            total += x
        
    return total

result = add(1, (2, 3), (4, 5))
print(result)

#------------------------------------------------------------------------------------------------------------------------
    Yukarıdaki örnekte biz add fonksiyonunu aşağıdaki gibi çağıramayız:

    result = add(1, (2, (3, 4)), (4, 5))
    print(result)
    
    Bu tür durumlarda "özyineleme (recursion)" uygulamak gerekir. Özyineleme bir olgunun kendisine benzer bir olguyu barındırması 
    anlamına gelmektedir. Özyineleme programalamada tipik olarak kendi kendi çağıran fonksiyonlar yoluyla sağlanır. Biz burada 
    özyineleme üzerinde durmayacağız. Ancak bu özyinelemeli aşağıdaki gibi sağlanabilmktedir.
#------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------
    Listenin ve demetin elemanlarının *'lı olabileceğini belirtmiştik. Aşağıdaki programı bu bağlamda inceleyiniz.
#------------------------------------------------------------------------------------------------------------------------

def add(*args):
    total = 0
    for x in args:
        total += x
        
    return total
        
result = add(1, 2, 3, 4, 5, *(7, *(8, 9)), *[9, 2, *(3, 5, 6)])
print(result)

#------------------------------------------------------------------------------------------------------------------------
                                                    33. Ders 08/08/2022 - Pazartesi
#------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------
    Büyük bir projenin tek bir kaynak dosya biçiminde  organize edilmesi iyi bir teknik değildir. Bunun tipik nedenlerini 
    şöyle açıklayabiliriz:

    - Program tek bir kaynak dosyada yazılırsa dosya çok büyük olabilir. Bu da dosyanın edit edilmesini zorlaştırır.
    - Programda bir değişiklik yapıldığında yeniden yorumlama işlemi gerekir.
    - Programın bir proje ekibi tarafından geliştirileceği durumda tek kaynak dosya bunun için uygun değildir. Kişilerin farklı 
    kaynak dosyalar üzerinde aynı zaman diliminde çalışması gerekir. 

    Python'da ".py" uzantılı kaynak dosyalara "modül (module)" de denilmektedir. Örneğin biz içerisinde birtakım faydalı fonksiyonlar 
    olan "utility.py" biçiminde bir dosya oluşturmuş olalım. Bu dosyaya aynı zamanda modül de denilmektedir. Eğer biz 
    Python programcısı olarak bir modül içerisindeki fonksiyonları ve global değişkenleri kendi programımızdan kullanmak istersek 
    önce o modülü "import etmemiz" gerekir. Import işlemi "bir modülün (yani Python kaynak dosyasının)" kullanıma hazır getirilmesi 
    işlemidir. Inport işlemi import deyimi ile yapılmaktadır. import deyiminin genel biçimi şöyledir:

    import <dosya ismi> [as <isim>] [, <dosya ismi> [as <isim>], ...]

    Burada dosya ismi uzantı içermemelidir. Örneğin biz utility.py dosyasının içerisindekileri kullanmak isteyelim. import işlemini
    şöyle yapabiliriz:

    import utility

    import işlemi yapılırken as anahtar sözcüğü ile modüle bir takma isim verilebilir. Örneğin:

    import utility as util

    Aslında Python'ın standart kütüphanesindeki öğeler de .py dosyalarının içerisindedir. Onları kullanmak için bizim o modülleri 
    import etmemiz gerekir. Örneğin:

    import math
    import statistics

    Biren fazla modülün import edilmesi tek bir import deyimi ile de modül isimlerinin arasına ',' atomu getirilerek de yapılabilir. 
    Örneğin:

    import math, statistics

    Tabii birden fazla modülü tek bir import deyimi ile import ederken herbir modüle as cümleciği ile takma isimler de verebiliriz. 
    Örneğin:

    import math as mt, statistics as st

    Bir modülü import ettikten sonra o modülün içerisindeki değişkenler modül ismiyle ya da as ile belirttiğimiz isimle "." operatörü ile 
    niteliklendirilerek edilerek kullanılmak zorundadır. Örneğin:

    import math

    result = math.sqrt(10)

    import deyimindeki as anahtar sözcüğü niteliklendirmede belirtilecek modül ismini değiştirmek amacıyla kullanılmaktadır. 
    Örneğin:

    import math as mt

    result = mt.sqrt(10)

    as ile takma isim verme genellikle uzun isimleri kısaltmak için as kullanılmaktadır. Örneğin:

    import numpy as np

    result = np.sqrt(10)

    Tabii as ile isim değiştirildiğinde modül ismi artık kullanılamaz. Örneğin:

    import math as mt

    result = mt.sqrt(10)            # geçerli
    result = math.sqrt(10)          # error! math ismi yerine mt isminin kullanılması gerekir. 

    Daha önceden belirttiğimiz gibi Python'da yorumlayıcının içine gömülmüş olan yani herhangi bir modül içerisinde olmayan 
    dolayısıyla da kullanmak için import işlemi gerekmeyen bir grup fonksiyona "built-in" fonksiyon denilmektedir. print, input,
    max, min, type, id gibi fonksiyonlar built-in fonksiyonlardır. 

    Örneğin biz sample.py dosyası içerisinde utility.py dosyasındaki foo fonksiyonunu çağırmak isteyelim. Bunun için önce 
    dosyayı import etmemiz gerekir:

    import utility

    utility.foo()

#------------------------------------------------------------------------------------------------------------------------

# utility.py 

def add(*args):
    total = 0
    for x in args:
        total += x
        
    return total

def multiply(*args):
    total = 1
    for x in args:
        total *= x
        
    return total

pi = 3.14156265

# sample.py 

import utility as util

result = util.add(1, 2, 3, 4, 5)
print(result)

result = util.multiply(1, 2, 3, 4, 5)
print(result)

print(util.pi)

#------------------------------------------------------------------------------------------------------------------------
    import deyimi kaynak dosyanın herhangi bir yerinde bulunabilir. Bazı programcılar bütün import dosyalarını programın 
    tepesinde import ederler.   Bazıları gerektiği zaman gerektiği yerde import ederler. 
#------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------
    Bir modül import edildiğinde o modülün içerisindeki tüm kodlar (yani deyimler) çalıştırılmaktadır. Yani import etme 
    aslında import edilen dosyanın aynı zamanda çalıştırılması anlamına da gelmektedir. Bu nedenle import edilen dosyada 
    örneğin print gibi komutlar varsa bunlar da işletilecektir. 

    Aşağıdaki programda sample.py çalıştırıldığında import işlemi neticesinde ekranda print fonksiyonun yazdırdığı yazılar da 
    görüntülenecektir. sample.py programının çalıştırılması sonucunda ekranda şu yazıları görmelisiniz:

    sample.py
    one
    two
    three
    15
    120
    3.14156265
#------------------------------------------------------------------------------------------------------------------------

# sample.py

print('sample.py')

import utility as util

result = util.add(1, 2, 3, 4, 5)
print(result)

result = util.multiply(1, 2, 3, 4, 5)
print(result)

print(util.pi)

# utility.py

print('one')

def add(*args):
    total = 0
    for x in args:
        total += x
        
    return total

print('two')

def multiply(*args):
    total = 1
    for x in args:
        total *= x
        
    return total

pi = 3.14156265

print('three')

#------------------------------------------------------------------------------------------------------------------------
    Bir modül import edildiğinde yorumlayıcı modülün içindeki kodları çalıştırır. Sonra "module" isimli bir sınıf türünden bir 
    nesne yaratır. Modülün içerisindeki değişkenleri bu nesneye yerleştirir besbebin adresini de import deyiminde belirtilen 
    değişkenin içerisine yerleştirir. Yani modül isimleri aslında module türünden nesnelerin adreslerini tutmaktadır. Örneğin:

    >>> import math
    >>> type(math)
    <class 'module'>
    >>> math.sqrt(10)
    3.1622776601683795
    >>> x = math
    >>> x.sqrt(10)
    3.1622776601683795
    >>> type(x)
    <class 'module'>

    Burada biz modeule türünden bir değişkeni başka bir değişkene atadık. Artık iki değişken de aynı module nesnesini 
    gösterdiğine göre fonksiyon çağrılırken hangi ismin kullanılacağının bir önemi kalmamıştır. 

    Tabii import komutunda as cümleciği ile module nesnesinin adresinin atanacağı değişkenin ismini değiştirebiliriz. 
    Örneğin:

    import math as m

    Burada module nesnesinin adresi m değişkenine atanmaktadır. Bu import işleminde math isimli bir değişken yaratılmamaktadır.
#------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------
    Bir modül birden fazla kez import edilebilir. (Bu durum geçerli olsa da anlamlı değildir.) Bu durumda modülün kodları 
    yalnızca modül ilk kez import edildiğinde çalıştırılır. Daha sonraki import işlemlerinde modülün içerisinde kodlar 
    çalıştırılmaz. Bunu siz de deneyebilirsiniz. 
#------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------
    Pekiyi bir modül yanlışlıkla kendisini import ederse ne olur? Örneğin:

    # sample.py

    import sample

    print('sample')

    Biz bu sample.py" dosyasını çalıştırırsak ne olur? Burada dosya çalıştırıldığında import deyiminden dolayı "sample.py" 
    dosyası çalıştırılacaktır.  Ancak o dosya çalıştırılırken yeniden import görülse bile bu ikinci import işlemi olacağından 
    dosyanın içi yeniden çalıştırılmayacaktır. import işlemindne dolayı ekrana "sample" yazısı basılacaktır. import deyiminin 
    çalışması bittikten sonra yine print deyimi deyimi çalıştırılacağına göre yine ekrana "sample" yazısı çıkacaktır. Yani 
    şöyle bir çıktı elde edilecektir:

    sample
    sample

    Programcıların yanlışlıkla kaynak dosyalarına standart bir modülün ismini vermeleri sık karşılaşılan bir hatadır. Örneğin:

    # math.py

    import math

    result = math.sqrt(10)
    print(result)

    Burada programcı standart modül olan math modülü yerine kendi dosyasını import etmiş olabilir. Bu durumda math.sqrt çağrımı 
    error oluşturacaktır. Tabii bu durum aslında standart modüllerin sys.path listesinde aranması sırasına da bağlıdır (bunu izleyen 
    paragraflarda ele alacağız). Siz kaynak dosyalarınıza Python'ın standart modüllerinin ismini vermemelisiniz. 
#------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------
    Modül dosyası yerel düzeyde de import edilebilir. Bu durumda bu import ismine yalnızca o fonksiyonda erişebiliriz. 
    (Yerel değişkenler konusu izleyen bölümlerde ele alınmaktadır.) Aslında aynı dosya nasıl import edilmiş olursa olsun 
    her zaman tek bir modül nesnesi yaratılmaktadır. Örneğin:

    def foo():
        import util

        print(id(util))     # 1581194445344
        
    foo()

    import util

    print(id(util))     # 1581194445344

    del util

    import util

    print(id(util))     # 1581194445344

#------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------
    Pekiyi bir modül import edildiğinde ilgili modül dosyası (yani .py dosyası) yorumlayıcı tarafından hangi dizinlerde 
    aranmaktadır? İşte Python yorumlayıcısı modülleri sys.path isimli bir listede belirtilen dizinlerde sırasıyla aramaktadır. 
    sys modülü Python standart kütüphanesinin içerisindeki bir modüldür. path değişkeni de bu modülün içerisindeki global 
    bir değişkendir. Örneğin:

    >>> sys.path
    ['', 'f:\\', 'C:\\Users\\CSD\\anaconda3\\python39.zip', 'C:\\Users\\CSD\\anaconda3\\DLLs', 'C:\\Users\\CSD\\anaconda3\\lib', 
    'C:\\Users\\CSD\\anaconda3', 'C:\\Users\\CSD\\anaconda3\\lib\\site-packages', 'C:\\Users\\CSD\\anaconda3\\lib\\site-packages\\win32', 
    'C:\\Users\\CSD\\anaconda3\\lib\\site-packages\\win32\\lib', 'C:\\Users\\CSD\\anaconda3\\lib\\site-packages\\Pythonwin']

    Burada boş string yani '' ifadesi "çalışma dizini (current working directory)" anlamına gelmektedir. Genellikle çalışma dizini 
    bizim Python programını çalıştırdığımız dizindir. Ancak çalışma dizini program çalışırken de istenildiği gibi değiştirilebilir. 
    Default durumda çalışma dizini eğer programı komut satırından çalıştırıyorsak içinde bulunduğumuz dizindir. PyCharm IDE'si 
    her zaman çalışma dizinini proje dizini olarak ayarlamaktadır. Spyder IDE'si ise çalışma dizinini o anda çalıştırılan Python 
    programının içinde bulunduğu dizin olarak ayarlamaktadır. 

    sys.path listesi program her çalıştırıldığında yeniden oluşturulmaktadır. Programcı kendi programı çalışırken bu listeye 
    ekleme yapabilir ya da bu listeden bazı elemanları (yani dizinleri) silebilir. Ancak bu işlem kalıcı olmaz. Program yeniden 
    çalıştırıldığında bu listede yine önceki çalıştırmadaki dizinler bulunacaktır. 

    Aslında Python standart kütüphane dokümanlarına göre sys.path listesinin ilk elemanı boş string ya da python yorumlayıcısını 
    çalıştıran script dosyasının bulunduğu dizin olmak zorundadır. Ancak Python yorumlayıcıları ve birtakım IDE'ler burada belirtilen 
    bu kurala uymayabilmektedir. 

    Pekiyi biz sys.path listesine kalıcı bir biçimde nasıl dizin ekleyebiliriz? İşte bunu yapabilmek için PYTHONPATH isimli bir 
    "çevre değişkeni (envirionment variable)" eklemek gerekir. Çevre değişkenleri konusu kursumuzun kapsamı dışındadır ve Derneğimizde
    "Sistem Programlama ve İleri C Uygulamaları" kursunda ele alınmaktadır. Biz burada yalnızca bu çevre değişkeninin nasıl oluşturulacağını 
    göreceğiz. 

    Windows'ta çevre değişkeni oluşturmak için "Denetim Masası/Sistem/Gelişmiş Sistem Ayarları/Ortam Değişkenleri diyalog 
    penceresi kullanılmaktadır. Eğer birden fazla dizin girilecekse dizinler arasında ';' bulundurulmalıdır. UNIX/Linux 
    ya da macOS sistemlerinde aynı işlem bash kullanıcıları için şöyle yapılmaktadır: bash kabuğu login olunduğunda 
    "interaktive login shell" için ~/.bah_profile dosyasını, "interaktif non-login shell" için ~/.bashrc dosyasını çalıştırmaktadır. 
    Bu dosyaların içerisine şu satır eklenmelidir:

    export PYTHONPATH=/istenilen/dizinin/yol/ifadesi

    UNIX/Linux ve macOS sistemlerinde PYTHONPATH çevre değişkenine birdne fazla dizin eklemek için dizinler arasıbnda ':'
    karakteri bulunmalıdır. 

    Tabii sys.path listesi yalnızca PYTHONPATH çevre değişkenindeki öğeleri içermemektedir. Yorumlayıcının kendisi de default olarak
    bu listeye bazı dizinler eklemektedir. Yorumlayıcı tipik olarak standart Python kütüphanesinin install edildiği dizinleri de 
    bu listeye eklemektedir. Genel olarak PYTHONPATH ile belirtilen dizinler yorumlayıcının kendi dizinlerinden önce eklenmektedir.      
    
#------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------
                                                    34. Ders 17/08/2022 - Carsamba
#------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------
    Bir modül import edildiğinde CPython gerçekleştirimi import edilen modülü "arakoda" dünüştürerek __pycache__ isimli bir 
    dizinde .pyc uzantılı bir dosya içerisinde saklamaktadır. Arakodlar bir sonraki import işleminde yorumlayıcı tarafından 
    çok daha hızlı bir biçimde işleme sokulmaktadır. Genel olarak CPython gerçekleştirimi arakod dosyasını modül dosyası 
    neredeyse o modül dosyasının bulunduğu dizin içerisindeki __pycache__ dizinine yerleştirmektedir. Bu durumda örneğin 
    biz math modülünü import ettiğimizde math.py dosyası hangi dizindeyse arakdo dosyası da o dizinin içerisindeki __pycache__
    dizininde oluşturulacaktır. Tabii biz bu __pycache__ dizininin silersek ilk import işleminde bu dizin yeniden yaratılacaktır. 

    Pekiyi ya biz import işleminden sonra modül dosyasının kaynak kodu üzerinde değişiklik yaparsak ne olacaktır? İşte CPython 
    yorumlayıcısı modül dosyasında değişiklik yapıldığında artık __pycache__ dizinindeki arakodu kullanmadan önce modül dosyasını 
    yeniden arakoda dönüştürmektedir. Böylece __pycache__ dizini içerisinde içerisinde her zaman modülün en güncel halinin 
    arakodu bulunmaktadır. (CPython yorumlayıcısı .py dosyasının tarih zaman bilgisiyle __pycache__ dizini içerisindeki arakod 
    dosyasının tarih zaman bilgisini karşılaştırarak arakod dosya oluşturulduktan sonra .py dosyasında bir değişiklik yapılıp
    yapılmadığını anlayabilmektedir.)

    Ancak Python dünyasında standart bir arakod sistemi yoktur. Yani belli bir Python yorumlayıcısı import işleminde modülü
    hiç arakoda dönüştürmeyebilir. Kaldı ki farklı Python yorumlayıcılarında farklı arakod sistemleri de kullanılabilmektedir. 
#------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------
    Bir modüldeki belli değişkenleri modül ismiyle niteliklendirmeden doğrudan kullanabilmek için from import deyimi 
    kullanılmaktadır. from import deyiminin genel biçimi şöyledir:

    from <modül_ismi> import <değişken_ismi> [as <değişken_ismi][, <değişken ismi...]

    Örneğin:

    from utility import add, multiply

    Biz burada artık add ve multiply değişkenlerini utility.add ve utility.multiply biçiminde değil doğrudan add ve multiply 
    biçiminde kullanabiliriz. import edilen değişkenlere as ile başka isimler de verilebilmektedir. Örneğin:

    from utility import add as a, multiply

    Burada biz artık add ismini değil a ismini kullanabiliriz. multiply isminde as kullanılmadığına göre bu isim yine multiply
    biçiminde kullanılacaktır. Tabii multiply ismi için de as cümleciğini bulundurabilirdik:

    from utility import add as a, multiply as m

    from import ile bir değişken import edildiğinde yine modüldeki kodların tamamı çalıştırılmaktadır. Tabii bu işlem toplamda yine
    bir kez yapılır. from import deyimi modülün kendisini import etmemektedir. Örneğin:

    from utility import add

    Burada biz utility ismini kullanamayız. Eğer utility ismini kullanacaksak ayrıca import uygulamalıyız:

    import utility

    Aşağıdaki from import işlemine bakınız:

    from utility import add

    Aslında bu işlemin eşdeğeri şöyledir:

    import utility
    add = utility.add
    del utility

    Bu eşdeğerlilikten şunu anlamalıyız: Biz sanki modülü önce imort etmiş sonra da modül değişken ismini silmiş olmaktayız. 
    Eşdeğerlilikte modül import edilmiş gibi olduğna göre modüln içerisindeki kodlar da yine çalıştırılacaktır.
#------------------------------------------------------------------------------------------------------------------------

from statistics import mean
from math import sqrt

result = mean([1, 2, 3, 4, 5, 6])
print(result)

result = sqrt(10)
print(result)

#------------------------------------------------------------------------------------------------------------------------
    from import deyiminde verilen isim zaten varsa artık o değişkene yeni bir atama yapılacağına dikkat ediniz. Örneğin:

    s = 10

    from math import sqrt as s

    print(s)            # <built-in function sqrt>

    import ya da from import deyimi global düzeyde kullanılırsa global bir değişkenin yerel düzeyde kullanılırsa yerel 
    bir değişkenin yaratılmasına yol açmaktadır. Örneğin:

    def foo():
        import math
    
        result = math.sqrt(10)
        print(result)
    
    def bar():
        result = math.sqrt(10)      # error! çünkü math ismi foo'da yerel
        print(result)

    foo()
    bar()

    Tabii farklı fonksiyonlarda aynı modül yerel olarak import edilmiş olsa bile toplamda modülün içerisindeki kodlar yine yalnızca 
    bir kez çalıştırılmaktadır. Örneğin:

  def foo():
    import utility
    
    util.foo()
    
    def bar():
        import utility
        
        result = utility.add(1, 2, 3, 4, 5)
        print(result)

    foo()
    bar()

    Burada utility içerisindkei kodlar toplamda bir kez çalıştırılacaktır. 

    Biz global değişkenleri henüz görmedik. İzleyen paragraflarda bu konu üzerinde duracağız. 
#------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------
    from import deyiminin özel bir biçimi de yıldızlı biçimdir. Örneğin:

    from math import *

    Bu biçimde modüldeki tüm isimler import edilir. Yani o isimlerin hepsini biz doğrudan kullanabiliriz. 
#------------------------------------------------------------------------------------------------------------------------

from math import *

result = sqrt(10)
print(result)

result = pow(10, 2)
print(result)

result = sin(0.5)
print(result)

#------------------------------------------------------------------------------------------------------------------------
    Python'da başında ve sonunda iki alt tire olan bazı özel isimler çeşitli nedenlerle kullanılabilmektedir. Örneğin:

    __init__
    __new__
    __main__
    __add__

    Bu isimlerin kolay okunması için "dunder" ya da "dunderscore" sözcükleri uydurulmuştur. Yani örneğin "dunder foo" 
    demekle biz "__foo__" demiş olmaktayız. Ya da örneğin "dunder init" demekle biz "__init__" demiş olmaktayız. 
#------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------
    import ya da from import deyiminde modülün tüm kodlarının çalıştırılması bazen istenmeyebilir. Örneğin birisi "utility.py" isimli bir
    program yazmış olabilir. Bu program çeşitli şeyleri yapıyor olabilir. Ancak bu u"tility.py" içerisinde foo ve bar isimli fonksiyonlar 
    başka kişilerin de kullanabileceği faydalı fonksiyonlar olabilir:

    # utility.py

    def foo():
        print('foo') 

    def bar():
        print('bar')
    
    print('çeşitli kodlar')
    print('çeşitli kodlar')
    print('çeşitli kodlar')

    Burada biz bu foo ve bar fonksiyonlarını kullanmak için modülü import etsek modülün kodları çalışacak ve aslında bizim 
    istemediğimiz şeyler de yapılacaktır. Bu durum nasıl engellenebilir?

    İşte Python'da __name__ isimli özel bir değişken vardır. Bu değişken str türündendir. Eğer modül bağımısız bir program gibi 
    çalıştırılırsa __name__ değişkeni '__main__' yazısını içerir. Eğer modül import edilerek çalıştırılırsa __name__ değişkeni 
    modül ismini içerir. Böylece biz yazdığımız programdaki fonksiyonların ve değişkenlerin import edilerek kullanılmasını istiyorsak
    va aynı zamanda da onu bağımsız bir program gibi de çalıştırmak istiyorsak o programı aşağıdaki gibi bir uygulayarak yazmalıyız:

    if __name__ == '__main__':
        pass

    Örneğin utility.py isimli bir program yazacak olalım. Programımız da 2'den 1000'e kadar asal sayıları ekrana yazdırıyor olsun. 
    Ancak bu modülde isprime isimli asallık testi yapan fonksiyonu da başkalarının kullanmasına imkan tanıyacak biçimde yazmış olalım. 
    Şimdi bu utility modülünü import eden kişi 2'den 1000'e kadar asal sayıları yazdırmak istemeyecektir. Yalnızca isprime fonksiyonunu 
    kullanmak isteyecektir. O zaman "utility.py" dosyası şöyle düzenlenmelidir:

    #utility.py 

    import math

    def isprime(val):
        if val % 2 == 0:
            return val == 2
        
        sqrt_val = math.sqrt(val)
        for i in range(3, int(sqrt_val) + 1):
            if val % i == 0:
                return False
            
        return True

    if __name__ == '__main__':
        for i in range(2, 1000):
            if isprime(i):
                print(i, end=' ')

    Kullanımı da şöyle olabilir:

    # sample.py

    import utility

    result = utility.isprime(101)
    print('prime' if result else 'not prime')

#------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------
    Rastgele sayı üretme yazılımda çeşitli amaçlarla kullanılabilmektedir. Örneğin bir oyun programı rastgele sayılar üreterek 
    birtakım nesnelerin rasgele hareket etmesini sağlayabilir. Benzer biçimde bir simülayon programı rasgele sayılarla gerçek 
    bir ortamı simüle etmeye çalışabilir. Rastgele sayı üretimi kriptolojide de kullanılmaktadır. 

    Ratsgelelik (rassallık) felsefi açılımları da olan bir konudur. Doğada rastgele sayılar elde edebilmek için rastgele olaylardan 
    faydalanılmaktadır. Ancak bilgisyayarlar tamamen deterministik biçimde çalışırlar. Yani bilgisayar devrelerinde doğadaki
    gibi rassal deney oluşturmak mümkün olmamaktadır.   Bilgisayarlar restgele sayıları tamamen sayısal işlemlerle elde ederler. 
    Böyle elde edilmiş rastgele sayılara "sahte rasgele sayılar (pseudo random numbers)" denilmektedir. Sahte rassal sayı 
    üretiminde bir "tohum değerden (seed)" başlanır. Sonra bir dizi rasrgele sayı elde edilir. Tohum değer aynı olursa aynı 
    dizimler elde edilmektedir. 

    Python'da rastgele (rassal) sayılar standart random modülündeki fonksiyonlarla elde üretilmektedir. 
#------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------
    rondom modülündeki random iisimli fonksiyon parametresizdir. Her çağrıldığında [0,1) aralığında rastegele float bir 
    sayı üretir. eğer bir alalıkta rastgele sayı üretilirken her sayının elde edilme olsaılığı diğerleri ile aynıysa böyle
    rassal sayılara "düzgün dağılmış rassal sayılar" denilmektedir. random modülündeki random fonksiyonu istatistiksel 
    terminolojide "düzgün dağılmış rastgele sayı" üretmektedir.
#------------------------------------------------------------------------------------------------------------------------

import random

for _ in range(10):
    result = random.random()
    print(result)

#------------------------------------------------------------------------------------------------------------------------
    Doğadaki pek çok olgu ismine "normal dağılım" ya da "Gauss dağılımı" denilen dağılıma uymaktadır. Bu dağılımda değerler
    ortalama etrafında toplanma eğilimindedir. Oratalamadan uzaklaştıkça o değerlerin görülme sıklığı yani olasılıkları azalır.
    
    random modülündeki gauss fonksiyonu normal dağılıma uygun rastgele sayılar üretmek için kullanılmaktadır. Fonksiyonun ilk 
    parametresi ortalamayı, ikinci parametresi standart sapmayı belirtir:

    random.gauss(mu=0.0, sigma=1.0)

    Fonksiyonda ortalamanın default değerinin 0, standart sapmanın default değerinin 1 olduğunu görüyorsunuz. Bu biçimdeki
    normal dağılıma istatistikte "standart normal dağılım" da denilmektedir. 
#------------------------------------------------------------------------------------------------------------------------

import random

for i in range(10):
    result = random.gauss(100, 15)
    print(result)

#------------------------------------------------------------------------------------------------------------------------
    random modülündeki randint isimli fonksiyon [a, b] aralığında rastgele bir tamsayı (int türden sayı) üretir. Yani randint
    fonksiyonu yalnızca tamsayı değerlerinden oluşan "kesikli düzgün (discrete uniform) dağılama" uygun rastgele sayılar üretmektedir. 
    Fonksiyonda aralığın her iki değerinin de üretime dahil olduğuna dikkat edşniz. 
#------------------------------------------------------------------------------------------------------------------------

import random

for i in range(10):
    result = random.randint(10, 20)
    print(result)

#------------------------------------------------------------------------------------------------------------------------
    Biz randint fonksiyonu ile yazı-tura denemesi yapabiliriz. Yazı tura işlemini belli miktarda yapıp oranlara bakarsak 
    gitgide sonucun 0.5'e yakınsadığını görürüz. Buna istatistikte "büyük sayılar yasası (law of large numbers)" denilmektedir. 
#------------------------------------------------------------------------------------------------------------------------

import random

def head_tail(n):
    head = 0
    tail = 0
    
    for _ in range(n):
        result = random.randint(0, 1)
        if result == 0:
            head += 1
        else:
            tail += 1
            
    return head / n, tail / n

head, tail = head_tail(10)
print(head, tail)

head, tail = head_tail(1000)
print(head, tail)

head, tail = head_tail(1000000)
print(head, tail)

head, tail = head_tail(100000000)
print(head, tail)

#------------------------------------------------------------------------------------------------------------------------
    random modülündeki choice isimli fonksiyon bir "sequence container'ı" yani [...] ile indekslenebilen bir nesneyi parametre 
    olarak alır. O nesnedeki rastgele bir elemanı geri dönüş değeri olarak verir. 
#------------------------------------------------------------------------------------------------------------------------

import random

a = ['ali', 'veli', 'selami', 'ayşe', 'fatma']

result = random.choice(a)
print(result)

#------------------------------------------------------------------------------------------------------------------------
    random modülündeki sample isimli fonksiyon indekslenebilir (yani [] ile kullanılabilen) bir nesneyi ve bir de eleman 
    sayısını parametre  olarak alır. O nesneden o miktarda elemanı rastgele seçer. (Buna istatistikte "rassal örnekleme" 
    (random sampling)" denilmektedir. Fonksiyon bize rastgele değerlerden oluşan bir liste vermektedir. Fonksiyonun geri 
    döndürdüğü listede aynı elemanlardan bulunmayacağına dikkat ediniz. sample fonksiyonunun geri döndürdüğü listedeki eleman 
    sıralamsı rastgeledir. sample fonksiyonunun parametrik yapısı şöyledir:

    random.sample(population, k, *, counts=None)

#------------------------------------------------------------------------------------------------------------------------

import random

a = ['ali', 'veli', 'selami', 'ayşe', 'fatma', 'sacit', 'süleyman']

result = random.sample(a, 3)
print(result)

#------------------------------------------------------------------------------------------------------------------------
    Sayısal lotoda rastgele bir colon oynamak için bu fonksiyondan faydalanabiliriz. Örneğin:

    column = random.sample(range(1, 50), 6)

    Burada fonksiyon bize 1 ile 50 arasında (50 dahil değil) 6 değerden oluşan bir liste verecektir. Bu 6 değerden hiçbiri 
    diğeri ile aynı olmayacaktır. 
#------------------------------------------------------------------------------------------------------------------------

import random

column = random.sample(range(1, 50), 6)
print(column)

#------------------------------------------------------------------------------------------------------------------------
    Pekiyi sayısal lotoda bir kolon oynayan kodu randint fonksiyonunu kullanarak yazabilir miydik? İlk akla gelecek yöntem
    gemellikle aşağıdaki gibi olmaktadır:

    import random

    column = []
    for i in range(6):
        while True:
            val = random.randint(1, 49)
            if val not in column:
                column.append(val)
                break    
        
    print(column)

    Buradaki yöntem iyi bir yöntem değildir. Burada "rastgele üretine değer daha önceden lsitede varsa yeniden değer üretilmiştir.
    Böylece listede aynı değerden birden fazla kez olması engellenmiştir. Tabii aynı işlemi küme kullanarak da yapabilirdik:

    import random

    s = set()

    while len(s) != 6:
        val = random.randint(1, 49)
        s.add(val)
        
    column = list(s)
    print(column)

    Aklımıza şöyle bir çözümde gelebilir: Biz sayıları numbers ismindw listede toplayalım. Sonra listeden choice fonksiyonuyla 
    rastgele bir sayı seçelim. Sonra o sayıyı column listesine ekleyip, numbers listesinden silelim:

    import random

    column = []
    numbers = list(range(1, 50))
    for i in range(6):
        val = random.choice(numbers)
        column.append(val)
        numbers.remove(val)
        
    print(column)

    Bu yöntem de aslında etkin değildir. Çünkü numbers listesinden remove metoduyla silme yapılırken aslında listede içsel 
    olarak bir kaydırma yapılmaktadır. Bu da her ne kadar biz görmüyor olsak da bir zaman kaybı oluşturacaktır. Bu tür durumlarda
    bir kaydırmayı engellemek için mantıksal olarka liste küçültme yöntemi uygulanmaktadır. Aşağıdaki kodda numbers listesinden 
    çekilen rastgele eleman listesine eklenmiştir. Ancak o eleman elemana son eleman atanarak liste küçültülmüştür.

    import random

    numbers = list(range(1, 50))
    column = []

    for i in range(6):
        val = random.randint(1, 50 - i)
        column.append(numbers[val])
        numbers[val] = numbers[49 - i - 1]
        
    print(column)

#------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------
    sample fonksiyonundaki counts parametresi birinci parametredeki nesnenin eleman sayısı kadar olmalıdır. Bu parametre 
    aslında ağırlıklandırmak için kullanılmaktadır. Yani örneğin:

    result = random.sample(['ali', 'veli', 'selami'], 5, counts=[3, 2, 1]) çağrısı aşağıdakiyle eşdeğerdir:

    result = random.sample(['ali', 'ali', 'ali', 'veli', 'veli', 'selami'], 5)

    counts parametresine belli bir değer girildiğinde artık sample fonksiyonun geri döndürdüğü liste aynı elemanlardan oluşabilmektedir. 

    counts parametresinin isimli kullanılmak zorunda olduğuna dikkat ediniz. 
#------------------------------------------------------------------------------------------------------------------------

import random

a = ['ali', 'veli', 'selami']

result = random.sample(a, 4, counts=[10, 5, 2])
print(result)

#------------------------------------------------------------------------------------------------------------------------
    random modülündeki choices fonksiyonu sample fonksiyonuna benzemektedir. sample fonksiyonu iadesiz (without replacement) 
    çekim yaparken choices fonksiyonu iadeli (with replacement) çekim yapmaktadır. Fonksiyonun parametrik yapısı şöyledir:

    random.choices(population, weights=None, *, cum_weights=None, k=1)

    isimli kullanılmak zorunda olan k parametresi kaç elemanlık çekim yapılacağını belirtmektedir. Buradaki weights parametresi 
    sample fonksiyonundaki counts parametresi gibidir. 
#------------------------------------------------------------------------------------------------------------------------

import random

names = ['ali', 'veli', 'selami', 'ayşe', 'fatma']

result = random.choices(names, k=3)
print(result)

result = random.sample(names, k=7)
print(result)

#------------------------------------------------------------------------------------------------------------------------
    random modülündeki randrange fonksiyonu parametrik kullanım bakımından range fonksiyonuna benzemektedir. Ancak rastgele 
    tamsayı üretmektedir. Örneğin:

    result = random.randrange(0, 10, 2)

    Burada aslında biz 0, 2, 4, 8 sayıları arasında rastgele bir sayı üretmiş oluruz. 
#------------------------------------------------------------------------------------------------------------------------

import random

a = ['ali', 'veli', 'selami']

for i in range(10):
    result = random.randrange(0, 10, 2)
    print(result)

#------------------------------------------------------------------------------------------------------------------------
    random modülündeki shuffle isimli fonksiyon karıştırma işlemini yapar. Fonksiyonun parametresinin bir liste olması gerekir. 
    Karıştırma "in-place" biçimde yapılmaktadır. (Örneğin demetler değiştirilebilir olmadıkları için shuffle fonksiyonu ile 
    karıştırılamazlar.)
#------------------------------------------------------------------------------------------------------------------------

import random

a = ['ali', 'veli', 'selami', 'ayşe', 'fatma']

print(a)
random.shuffle(a)
print(a)

#------------------------------------------------------------------------------------------------------------------------
                                                    35. Ders 22/08/2022 - Pazartesi
#------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------
    Aslında karıştırma algoritması çok kolaydır. Genellikle izlenen yol dizinin tüm elemanlarını sırasıyla rastgele elemanla
    yer değiştirme yöntemidir. Aşağıda bu yöntem uygulanmıştır.
#------------------------------------------------------------------------------------------------------------------------

import random

def myshuffle(a):
    for i in range(len(a)):
        k = random.randrange(len(a))
        a[k], a[i] = a[i], a[k]
              
names = ['ali', 'veli', 'selami', 'ayşe', 'fatma']  
myshuffle(names)
print(names)
            
#------------------------------------------------------------------------------------------------------------------------
    Bir demeti karıştırmak istersek bunu nasıl yapabiliriz? Tabii yöntemlerden biri "önce demet elemanlarından bir liste 
    elde etmek, sonra listeyi karıştırmak, sonra da yeniden demet oluşturmak" olabilir:
    
    import random

    names = ('ali', 'veli', 'selami', 'ayşe', 'fatma')

    result = list(names)
    random.shuffle(result)
    result = tuple(result)

    print(result)
            
    
    Aslında sample fonksiyonu da kendi içerisinde rastgele bir dizilim vermektedir. sample fonksiyonunun in-place işlem 
    yapmadığını anımsayınız. Bu durumda sample fonksiyonunda uzunluk parametresini nesnenin uzunluğu kadar girersek bir 
    karıştırma işlemi yapmış oluruz:

    import random

    names = ('ali', 'veli', 'selami', 'ayşe', 'fatma')
            
    result = tuple(random.sample(names, len(names)))

    print(result)
#------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------
    Aşağıdaki örnekte bir oyun kartı destesi oluşturulmuş sonra da bu deste dört oyuncuya dağıtılmıştır. Ancak oyunculara dağıtılan 
    kartlar sıraya da dizilmiştir.
#------------------------------------------------------------------------------------------------------------------------

import random

card_vals = {'As': 14, 'Papaz': 13, 'Kız': 12, 'Vale': 11, '10': 10, '9': 9, '8': 8, '7': 7, '6': 6, '5': 5, '4': 4, '3': 3, '2': 2}
card_types = {'Kupa': 3, 'Maça': 2, 'Karo': 1, 'Sinek': 0}

def build_deck():
    deck = []

    for cval in card_vals:
        for ctype in card_types:
            deck.append((cval, ctype))
        
    return deck

def distribute(deck):
    random.shuffle(deck)

    players = [[], [], [], []]
    
    for i in range(52):
        players[i % 4].append(deck[i])
        
    for player in players:
       player.sort(key=keyfunc, reverse=True)

    return players

def keyfunc(t):
    cval, ctype = t
    return card_vals[cval] * 4 + card_types[ctype]  
   
def disp_players(players):  
    for player in players:
        print(player)
        print('-------')
  
def main():
    deck = build_deck()
    players = distribute(deck)
    disp_players(players)
    
main()  
    
#------------------------------------------------------------------------------------------------------------------------
    Rastgele sayı üreterek belli duyarlılıkta pi sayısını elde edebiliriz. Bunun için bir birim çamberdeki dörtte birlik 
    daire dilimini dikkate alırız. Bu dörtte birlik daire dilimi aslında 1x1'lik bir karenin içerisindedir. Biz de [0, 1]
    aralığında iki rastgele sayı üreterek bu kare içerisinde rastgele noktalar elde ederiz. Kare içerisinde elde ettiğimiz 
    noktaların bazıları aynı zamanda bu daire diliminin de içerisinde olacaktır. Toplam nokta sayısı n tane olsun. Bu n tane
    noktanın k tanesi aynı zamanda daire diliminin de içerisinde olsun. Buradaki 1x1'lik karenin daire dilimine oranı b değerinin
    k değerine oranına eşit olacaktır:

    n / k = 1 / (pi / 4)
    
    Burada içler dışlar çarpımı ile pi değeri çekilirse şu sonuç bulunur:

    pi = 4 * k / n 

    Tabii buradaki n değerini n kadar artırırsak pi'ye o kadar yaklaşırız. 

    Aşağıda bu örnek verilmiştir. 
#------------------------------------------------------------------------------------------------------------------------

import random
import math

def getpi(n):
    k = 0
    for _ in range(n):
        x = random.random()
        y = random.random()
        distance = math.sqrt(x ** 2 + y ** 2)
        if distance < 1:
            k += 1
        
    pi = 4 * k / n
    
    return pi
    
pi = getpi(1000)
print(pi)

pi = getpi(10000)
print(pi)

pi = getpi(100000)
print(pi)

pi = getpi(1000000)
print(pi)

pi = getpi(10000000)
print(pi)

#------------------------------------------------------------------------------------------------------------------------
    enumerate isimli built-in fonksiyon bizden dolaşılabilir bir nesne alır, bize dolaşılabilir bir nesne verir. enumerate 
    fonksiyonun verdiği dolaşılabilir nesne dolaşıldığında iki elemanlı demetler elde edilecektir. Öyle ki bu demetlerin
    ilk elemanları 0'dan başlayan indeks numarasından ikinci elemanları da bizim verdiğimiz dolaşılabilir nesnedeki elemnalardan 
    oluşur. Örneğin:

    names = ['ali', 'veli', 'selami', 'ayşe', 'fatma']

    for t in enumerate(names)
        print(t)

    Buradan sırasıyla (0, 'ali'), (1, 'veli'), (2, selami), (3, 'ayşe'), (4, 'fatma') biçiminde demetler elde edilecektir. 
    Tabii biz genellikle unpack yaparak demet elemanlarını elde ederiz:

    for index, x in enumerate(names)
        print(index, x)

#------------------------------------------------------------------------------------------------------------------------

names = ['ali', 'veli', 'selami', 'ayşe', 'fatma']

iterator = enumerate(names)
for t in iterator:
    print(t)
    
iterator = enumerate(names)
for index, x in iterator:
    print(index, x)
    
for index, x in enumerate(names):
    print(index, x)

#------------------------------------------------------------------------------------------------------------------------
    enumerate fonksiyonu bir dolaşılabilir nesneyi for döngüsü ile dolaşırken hem elemanların index numaralarını hem de 
    elemanların değerlerini elde etmek için kullanılmaktadır. enumerate fonksiyonunun ikinci bir parametresi de vardır. Bu ikinci 
    parametreye default olarak 0 değeri verilmiştir. Bu ikinci parametre indeksin nereden başlatılacağını belirtir. Örneğin:

    names = ['ali', 'veli', 'selami', 'ayşe', 'fatma']

    for t in enumerate(names, 10):
        print(t)

    Burada artık şu demetler elde edilecektir:  (10, 'ali'), (11, 'veli'), (12, selami), (13, 'ayşe'), (14, 'fatma')
#------------------------------------------------------------------------------------------------------------------------

 names = ['ali', 'veli', 'selami', 'ayşe', 'fatma']

for t in enumerate(names, 10):
    print(t)
    
#------------------------------------------------------------------------------------------------------------------------
    Bir değişkenin kullanılabildiği program aralığına "faaliyet alanı (scope)" denilmektedir. Python'da değişkenler faaliyet alanları 
    bakımından üç gruba ayrılmaktadır:

    1) Yerel Değişkenler (Local Variables)
    2) Global Değişkenler (Global Variables)
    3) Sınıf Değişkenleri (Class Variables)

    Biz sınıf değişkenlerini "sınıflar" konusunda ele alacağız. 

    Python'da "değişken (variable)" ile "nesne (object)" kavramları farklı anlamlara gelmektedir. Değişkenler isimli olan varlıklardır. 
    Değişkenler adres tutarlar. Değişkenlerin içerisindeki adresteki varlıklara "nesne (object)" denilmektedir. Örneğin:

    a = 10
    b = a

    Burada a ve b iki ayrı değişkendir. Ancak aynı nesnenin adresini tutmaktadır. Yani bu kod parçasında iki değişken ancak tek bir nesne vardır. 

    Bir değişkene bir fonksiyon içerisinde ilk kez bir değer atandığında yeni bir değişken yaratılır. Fonksiyon içerisinde yaratılan değişkenlere 
    "yerel değişkenler (local variables)" denilmektedir. Yerel değişkenler yaratıldıkları noktadan yaratıldıkları fonksiyonun sonuna 
    kadarki bölgede faaliyet gösterirler. Başka yerden kullanılamazlar. Örneğin:

    def foo():
        x = 10;     # x bir yerel değişken
        print(x)    # geçerli, x buarada faaliyet gösteriyor

    print(x)        # error! x burada kullanılamaz, burada faaliye göstermiyor.

    Farklı fonksiyonlarda aynı isimli yerel değişkenler farklı değişkenlerdir. Bunlar birbirlerine karışmazlar. Örneğin:

    def foo():
        x = 10
        print(x)

    def bar():
        x = 20
        print(x)

    Burada foo fonksiyonundaki x ile bar fonksiyonundaki x farklı değişkenlerdir.

    Fonksiyonların parametre değişkenleri de yerel değişken gibi faaliyet alanına sahiptir. Yani yalnızca o fonksiyonda kullanılabnilirler. 
    Farklı fonksiyonların aynı isimli parametre değişkenleri farklı değişkenlerdir. Örneğin:

    def foo(x):         # bu x foo'ya özgü bir x
        print(x)        
        
    def bar(x):         # bu x bar'a özgü bir x
        print(x)
    
    Bir değişken fonksiyonların dışında yaratılmışsa böyle değişkenlere global değişkenler denilmektedir. Global değişkenler 
    yaratıldıkları yerden dosyanın sonuna kadar her yerde (fonksiyonların içerisinde de) kullanılabilmektedir. Örneğin:

    a = 10

    def foo():
        print(a)            # global olan a
        
    def bar():
        print(a)            # global olan a
        
    foo()
    bar()

    Tabii global fonksiyonların isimleri de birer gobal değişkendir. 

    Bir fonksiyon içerisinde global değişkenle aynı isimli bir değişkene atama yapılırsa bu durum global değişkene atama yapıldığı 
    anlamına gelmez. Aynı isimli yeni bir yerel değişken yaratılır. Atama ona yapılmış olur. Örneğin:

    x = 10

    def foo():
        x = 20      # x yeni bir yerel değişken, global olan değil
        print(x)    # buradaki x yerel olan x
        
    foo()
    print(x)        # buradaki x global x, zaten yerel x burada faaliyet göstermiyor, 10 çıkacak

    Bazen bir fonksiyonun global bir değişkeni değiştirmesi istenebilir. Bu durumda yorumlayıcıya bunun belirtilmesi 
    gerekir. Bu işlem global bildirimi ile yapılmaktadır. global bildiriminin genel biçimi şöyledir:

    global <değişken listesi>

    Örneğin:

    global x
    global y, z, k

    Örneğin:

    a = 10

    def foo():
        global a
        a = 20      # global olan a
        print(x)    # global olan a
        
    foo()
    print(a)        # 20

    Burada artık foo'nun içeisindeki a global olan a'dır. Dolayısıyla foo'nun içerisinde global olan a'ya 20 atanmıştır. global 
    bildirimi fonksiyon içerisinde bir global değişkenin değerini değiştirmek için kullanılır. Yoksa global değişkenin değeri 
    değiştirilmeyecekse zaten global değişkenler doğrudan fonksiyonlar içerisinde kullanılabilmektedir. Bunun için gobal bildiriminin 
    yapılmasına gerek yoktur. Örneğin:

    a = 10

    def foo():
        global a    # burada global bildirimine gerek yok
        
        print(a)    # global olan a
        
    foo()

    Bir fonksiyon içerisinde önce bir global değişken kullanılmışsa artık aynı isimli bir yerel değişken yaratılamaz. Eğer yaratılmak 
    istenirse bu durum error oluşturur. Örneğin:

    a = 10

    def foo():
        print(a) 
        a = 20          # geçersiz! çünkü daha önce aynı isimli global değişken fonksiyonda kullanılmış
        print(a)
        
    foo()

    Fonksiyon ieçrisinde önce bir global değişken kullanılıp sonra aynı değişkene ilişkin global bildirimi de yapamayız. Örneğin:

    a = 10

    def foo():
        print(a)        # global olan a
        global a        # error önce bir global değişken kullanılıp sonra o değişkene ilişkin global bildirimi yapılamaz!
        a = 20          
        print(a)
        
    foo()

    C/C++, Java, C# gibi dillerde fonksiyonlar ve metotlar içerisinde ayrıca bloklarla yeni faaliyet alanları oluşturulabilmektedir. 
    Python'da böyle bir durum söz konusu değildir. Python'da biz for döngüsü, if deyimi vs. içinde bir değişken yarattığımızda 
    o değişkeni bu deyimlerin dışında da kullanabiliriz. Yani Python'da fonksiyonun içerisindeki bloklar ayrı bir faaliyet alanı 
    belirtmemektedir. Örneğin:

    def foo():
        for i in range(10):
            print(i)
            x = 10

        print(x)        # geçerli
        print(i)        # geçerli
    
#------------------------------------------------------------------------------------------------------------------------
    global bildiriminde henüz ilgili global değişken yaratılmamış olabilir. Bu durum geçerlidir. Eğer global bildirimi görüldüğünde
    global değişken yaratılmadıysa yine de bu bildirim global bir değişkeni belirtir. Yani bu sayede global değişken fonksiyonun 
    içerisinde yaratılabilir. Örneğin:

    def foo():
        global a        
        
        a = 10      # a global değişikeni yaratılıyor, çünkü henüz yaratılmamış

    foo()
    print(a)

    Tabii aslında global bildirimi global değişkenin yaratılacağı anlamına geşmez. Yalnızca kullanılacak değişkenin 
    global olduğu anlamına gelir. Örneğin:

    def foo():
        global a
        
        print(a)        # error! henüz global nesne yaratılmadı

    foo()
    print(a)

    Buradaki problem foo çağrıldığında henüz a global değişkeninin yaratılmamışi olmasıdır. 
#------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------
                                                        36. Ders 24/08/2022 - Çarşamba
#------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------
    Bir değişken (nesneyi kastetmiyoruz) programın belli bir aşamasında yaratılır, bir süre faaliyet gösterdikten sonra yok edilir. 
    Değişkenin bellekte kaldığı zaman aralığına "ömür (duration)" denilmektedir. 
    
    - Python'da bir yerel değişken fonksiyon çağrıldıktan sonra akış o değişkene ilk kez değer atandığı noktaya geldiğinde yaratılır, 
    akış o fonksiyon bittiğinde değişken otomatik olarak yok edilir. Yani yerel değişkenler fonksiyon çağrılmadan bellekte yer kaplamazlar. 
    Fonksiyon bittiğinde de yok edilmiş olurlar. Zaten bir yerel değişkenin fonksiyon dışında kullanılamamasının temel nedeni de budur. Örneğin:

    def foo():
        x = 10
        # ...

    print(x)

    Burada x henüz fonksiyon çağrılmadığına göre ya da çağrılıp sonlandığına göre aslında yaşamamaktadır. Bu nedenle biz x'i
    fonksiyonun dışında kullanamayız. 

    - Fonksiyonların parametre değşkenleri de fonksiyon çağrıldığında yaratılır, fonksiyon sonlandığında otomatik olarak yok edilir. 
    Bir fonksiyon çağrıldığında önce parametre değişkenleri yaratılır, sonra argümanlardan parametre değişkenlerine atama yapılır, ondan sonra
    akış fonksiyona aktarılır. Örneğin:

    def foo(a, b):
        pass

    foo(10, 20)

    Burada fonksiyon çağrıldığında önce a ve b yaratılır. Sonra a = 10, b = 20 atamaları yapılır. Sonra da programın akışı
    fonksiyona aktarılır. Fonksiyon sonlandığında da a ve b yok edilir. 

    - Bir global değişken o değişkene ilk kez değer atandığında yaratılır, program sonuna kadar yaşamaya devam eder. Bu nedenle
    global değişkenler her yerden yani fonksiyonlardan da kullanılabilmektedir. Örneğin:

    x = 10

    def foo():
        print(x)

    print(x)
    foo()

#------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------
    Bir değişkenin ne zaman yaratılıp ne zaman yok edildiğini yukarıda açıkladık. Pekiyi değişkenlerin gösterdikleri nesneler 
    ne zaman yaratılıp yok edilmektedir. Örneğin:

    x = 10
    x = 20

    Burada x değişkeni yaratılırken aynı zamanda int bir nesne de yaratılır. Daha sonra int türü "değiştirilemez (immutable)" olduğu için 
    yeni bir int nesnesi yaatılıp x değişkeni artık o yeni yaratılan x nesnesini gösterecektir. Pekiyi eski nesneye ne olacaktır? İşte Python'da
    "çöp toplayıcı (garbage collector)" denilen mekanizma bir nesneyi hiçbir değişken göstermiyorsa artık o nesneyi arka planda bellekten silmektedir. 
    Çöp toplama tamamen yorumlayıcı sistem tarafından yönetilir. Dolayısıyla programcı bu konuda bir şey yapmaz. Örneğin:
     
    def foo(a):             # bu noktada int nesnesyi x ve a gösteriyor
        pass                # fonksiyon bittiğinde a yok edilecek, böylece int nsneyi yalnızca x gösterir durumda olacaktır.

    def bar():
        x = 10              # bu noktada int nesneyi yalnızca x gösteriyor
        foo(x)
        print(x)            # bu noktada yine int nesnesi yalnızca x gösteriyor

    bar()

    Buradaki kod parçasında önce bar fonksiyonu çağrılmıştır. bar fonksiyonunun içerisinde yerel x değişkeni yaratılmıştır. Bu 
    yerel x değişkeni içerisinde 10 değeri olan bir int nesneyi göstermektedir. Sonra foo fonksiyonu çağrılmış ve bu x değişkeninin 
    içerisindeki adres foo fonksiyonunun a parametre değişkenine atanmıştır. Artık içerisinde 10 olan int nesnesi iki değişken 
    gösteriyor durumdadır. foo bitince a parametre değişkeniş yok edilecektir. Akış bar fonksiyonuna geri döndüğünde artık yine 
    nesneyi yalnızca x değişkeni gösteriyor durumdadır. Nihayet bar da bitince artık x de yok edilecek ve nesneyi hiçbir değişken 
    göstermiyor durumda olacaktır. İşte bu durumda yorumlayıcının çöp toplayıcı mekanizması devreye girecek ve çöp haline gelmiş
    içerisinde 10 olan nesneyi silecektir.

    Aşağıdaki örnekte döngünün her ynelenemesinde yeni bir int nesne yaratılır, ancak öncekiler çöp toplayıcı tarafından yok edilir. 

    i = 0
    for _ in range(100):
        print(id(i))            # her defasınde değişik bir adres yazıdırılacaktır
        i += 1

    Python standart dokümanlarında çöp toplayıcının kullandığı yöntem ve algoritma açıklanmamıştır. Bu nedenle çöp tıoplayıcılar 
    arasında işleyiş bakımından farklılıklar olabilmektedir. CPython gerçekleştirimi "referans sayacı (reference counting)" temelinde 
    bir çöp toplama mekanizması kullanmaktadır. 
#------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------
    Python'da çokça kullanılan bir "built-in" fonksiyon da map isimli fonksiyondur. Bu fonksiyon bizden bir fonksiyonu 
    ve dolaşılabilir bir nesneyi parametre olarak olarak alır. Bize bir dolaşım (şiterator) nesnesi verir. map fonksiyonun 
    verdiği dolaşım nesnesi dolaşıldığında bizim verdiğimiz dolaşılabilir nesnenin elemanları verdiğimiz fonksiyona argüman 
    yapılıp fonksiyonun geri dönüş değerleri elde edilecektir. Bizim map fonksiyonuna verdiğimiz fonksiyonun bir parametresi 
    olmak zorundadır. 
#------------------------------------------------------------------------------------------------------------------------

a = [1, 2, 3, 4, 5]

def square(x):
    return x * x

iterable = map(square, a)

x = list(iterable)
print(x)

for x in map(square, a):
    print(x, end=' ')
        
#------------------------------------------------------------------------------------------------------------------------
    Aşağıdaki örnekte isimlerin karakter uzunlukları elde edilmektedir. 
#------------------------------------------------------------------------------------------------------------------------

names = ['ali', 'veli', 'selami', 'ayşe', 'fatma']

for x in map(len, names):
    print(x, end=' ')
    
#------------------------------------------------------------------------------------------------------------------------
    Aşağıdaki örnekte yazı içerisindeki sayılar toplanmaktadır. 
#------------------------------------------------------------------------------------------------------------------------

s = '1 2 3 4 5'

total = 0
for x in map(int, s.split()):
    total += x
    
print(total)

#------------------------------------------------------------------------------------------------------------------------
    Built-in sum fonksiyonu dolaşılabilir bir nesne alıp onun tüm elemanlarının toplamanına geri dönmektedir. O halde yukarıdaki 
    örneği daha kompakt bir biçimde aşağıdaki gibi oluşturabiliriz. 
#------------------------------------------------------------------------------------------------------------------------

s = '1 2 3 4 5'

total = sum(map(int, s.split()))
print(total)

#------------------------------------------------------------------------------------------------------------------------
    Built-in max ve min fonksiyonları bizden dolaşılabilir bir nesne alıp onların en büyük ve en küçük elemanlarını verir. 
    Aşağıdaki örnekte en uzun ismin karakter uzunluğu elde edilmiştir.
#------------------------------------------------------------------------------------------------------------------------

names = ['ali', 'veli', 'selami', 'ayşe', 'fatma']

result = max(map(len, names))
print(result)

#------------------------------------------------------------------------------------------------------------------------
    Tabii map fonksiyonunun birinci parametresi bir metot da olabilir. Ancak metotlar tek başına kullanılamazlar. Metotlar
    ancak ilişkin oldukları sınıf türünden bir değişkenle '.' operatörü ile kullanılabilirler. Bu durumda map fonksiyonunun
    birinci parametresibe metot vereceksek metodu isimle değil <değişken>.<metot> biçiminde vermeliyiz. Örneğin:

    d = {'ali': 1, 'veli': 2, 'selami': 3, 'ayşe': 4, 'fatma': 5}

    names = ['ali', 'selami', 'ayşe', 'güray', 'fatma', 'veli', 'can']

    for x in map(d.get, names):
        print(x, end=' ')

    Burada names listesi içerisindeki her bir isim d.get metoduna sokulacak ve oradan elde edilen değerler dolaşım sırasında
    elde edilecektir. Örneğin:

    s = 'ankara'

    for x in map(s.count, s):
        print(x, end=' ')

    Burada yazının her karakterinin yazı içerisinde kaç tane bulunduğu elde edilmek istenmiştir.
#------------------------------------------------------------------------------------------------------------------------

d = {'ali': 1, 'veli': 2, 'selami': 3, 'ayşe': 4, 'fatma': 5}

names = ['ali', 'selami', 'ayşe', 'güray', 'fatma', 'veli', 'can']

for x in map(d.get, names):
    print(x, end=' ')
    
#------------------------------------------------------------------------------------------------------------------------
    Aslında map fonksiyonu birden fazla dolaşılabilir nesne alabilmektedir. Bu durumda bu dolaşılabilir nesnenin karşılıklı elemanları
    birinci parametresiyle verilen fonksiyona parametre olarak aktarılır. Yani map fonksiyonuna biz kaç tane dolaşılabilir nesne verirsek
    birinci parametre ile geçirdiğimiz fonksiyonun o kadar parametresi olmak zorundadır. 
#------------------------------------------------------------------------------------------------------------------------

a = [1, 2, 3, 4, 5]
b = [10, 20, 30, 40, 50]
c = [100, 200, 300, 400, 500]

def foo(a, b, c):
    return a + b + c

iterable = map(foo, a, b, c)
for x in iterable:
    print(x)

#------------------------------------------------------------------------------------------------------------------------
    map fonksiyonuna birden fazla dolaşılabilir nesne geçirdiğimizde bunların eleman sayısı aynı olmak zorunda değildir. 
    Bunlardan herhangi birinde sona gelindiğinde tüm dolaşım sonlandırılır. Aşağıdaki örnekte yalnızca iki dolaşım
    yapılacaktır. 
#------------------------------------------------------------------------------------------------------------------------

a = [1, 2, 3, 4, 5]
b = [10, 20]
c = [100, 200, 300, 400, 500]

def foo(a, b, c):
    return a + b + c

iterable = map(foo, a, b, c)
for x in iterable:
    print(x)

#------------------------------------------------------------------------------------------------------------------------
    Tabii burada map fonksiyonuna geçirdiğimiz fonksiyonun da parametresi *'lı olabilir. 
#------------------------------------------------------------------------------------------------------------------------
    
a = [1, 2, 3, 4, 5]
s = ['ali', 'veli', 'selami', 'ayşe', 'fatma', 'cumhur']
w = [72.4, 69.5, 84.2, 51.6, 56.2]

def foo(*x):
    return x

for x in map(foo, a, s, w):
    print(x)

#------------------------------------------------------------------------------------------------------------------------
    Python'da iç içe (nested) fonksiyon tanımlamaları yapılabilmektedir. Örneğin:

    def foo():
        ...
        def bar():
           ...
        ...

    Tabii iç fonksiyonun içerisinde de başka bir fonksiyon tanımlanabilir. Bu tür durumlarda iç fonksiyon ismi yerel bir değişken olmaktadır. 
    Dolayısıyla iç fonksiyon ancak dıştaki fonksiyonun içerisinden çağrılabilir. 

    Aşağıdaki örnekte biz bar fonksiyonunu ancak foo fonksiyonun içerisinde ve bar tanımlandıktan sonra çağırabiliriz. 
    bar fonksiyonunu dışarıdan çağıramayız:

    def foo():
        print('foo')
        def bar():
            print('bar')
        bar()

#------------------------------------------------------------------------------------------------------------------------

def foo():
    print('foo')
    def bar():
        print('bar')
    
    bar()  
    
foo()

#------------------------------------------------------------------------------------------------------------------------
    Eğer bir fonksiyon genel değil de yalnızca başka bir fonksiyonun yazımı için oluşturuluyorsa bu fonksiyonu asıl fonksiyonun 
    iç fonksiyonu olarak tanımlamak iyi bir tekniktir. Çünkü dışarıdaki fonksiyonlar herkesin ilgisini çeker. Halbuki iç 
    fonksiyonlar dışarıdan kullanılamayacağından dolayı zaten kişilerin ilgisini çekmez. Dolayısıyla onların kafalarını karıştırmaz. 
    Örneğin 2'den parametresiyle belirtilen sayıya kadar asal sayıları yazdıran bir fonksiyon yazmak isteyelim. Bu fonksiyon 
    sayının asal olup olmadığını test eden isprime gibi bir fonksiyonu kullanıyor olsun. Bu isprime fonksiyonu dışarıyı 
    ilgilendiren bir fonksiyon değilse bir iç fonksiyon olarak yazılabilir. Bir fonksiyon yalnızca başka bir fonksiyonun yazımında 
    kullanılmak için oluşturuluyor ise onu iç fonksiyon yapmak iyi bir tekniktir. Tabii iç bir fonksiyonu dış fonksiyon içerisinde
    kullanmadıktan sonra onu tanımlamanın da bir anlamı yokturç
#------------------------------------------------------------------------------------------------------------------------

import math 

def print_primes(n):
    def isprime(val):
        if val % 2 == 0:
            return val == 2
        for i in range(3, int(math.sqrt(val)) + 1, 2):
            if val % i == 0:
                return False
        return True
    
    for x in range(2, n + 1):
        if isprime(x):
            print(x, end=' ')
        
print_primes(100)

#------------------------------------------------------------------------------------------------------------------------
                                                        37. Ders 31/08/2022 - Pazartesi
#------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------
    İç bir fonksiyon dış fonksiyonun o ana kadar yaratılmış olan yerel değişkenlerini kullanabilir. Ancak dış fonksiyon iç fonksiyonun
    yerel değişkenlerini kullanamaz. Örneğin:

    def foo():
        a = 10
        def bar():
            print(a)            # 10
            b = 20
            print(b)            # 20
        bar()
            
    foo()
    
    Burada bar fonksiyonu foo fonksiyonun a yerel değişkenini kullanmıştır. 
#------------------------------------------------------------------------------------------------------------------------

def foo():
    a = 10  
    def bar():
        print(a)            # 10
        b = 20
        print(b)            # 20
    bar()
        
foo()
    
#------------------------------------------------------------------------------------------------------------------------
    Tabii Python'da isim araması fonksiyon çağılıp akış ilgili noktaya geldiğinde yapıldığına göre dış fonksiyonun yerel 
    değişkeni iç fonksiyondan sonra da oluşturulmuş olsa eğer çağrılma sırasında bu yerel değişken yaratılmışsa iç 
    fonksiyon içerisinden kullanılabilir. Örneğin:

    def foo():
        a = 10   
        def bar():
            print(a)            # 10
            print(b)            # 20  
        b = 20
        bar()

    Burada bar fonksiyonu çağrıldığında foo fonksiyonunun b yerel değişkeni de yaratılmış durumda olacaktır. Dolyısıyla
    bar çağrımında bir sorun oluşmayacaktır.
#------------------------------------------------------------------------------------------------------------------------

def foo():
    a = 10
    def bar():
        print(a)            # 10
        print(b)            # 20  
    b = 20
    bar()
       
#------------------------------------------------------------------------------------------------------------------------
    İç bir fonksiyon içerisinde dış fonksiyonun yerel değişkeni ile aynı isimli bir değişkene atama yaptığımızda biz dış 
    fonksiyounun yerel değişkenini değiştirmiş olmayız. İç fonksiyonda yeni bir yerel değişken yaratmış oluruz. Örneğin:
    
    def foo():
        a = 10
        def bar():
            a = 20          # bar'a ilişkin yeni bir yerel a oluşturulmaktadır
            print(a)        # 20
        bar()
        print(a)            # foo'nun yerel a'sı, 10

    Burada foo fonksiyonu çağrıldığında bar içerisindeki a değişkenine atama yapıldığında üst fonksiyon olan foo fonksiyonunun 
    yerel a değişkenine atama yapılmamaktadır. bar içerisinde yeni bir yerel a değişkeni yaratılmış olmaktadır. 
#------------------------------------------------------------------------------------------------------------------------

    def foo():
        a = 10
        def bar():
            a = 20          # bar'a ilişkin yeni bir yerel a oluşturulmaktadır
            print(a)        # 20
        bar()
        print(a)            # foo'nun yerel a'sı, 10
        
    foo()

#------------------------------------------------------------------------------------------------------------------------
    İç fonksiyonun dış fonksiyonun yerel değişkenini değiştirebilmesi için nonlocal bildiriminin  yapılması gerekir. nonlocal 
    bildiriminin genel biçimi şöyledir:
    
    nonlocal <değişken listesi>;

    Örneğin:

    def foo():
        a = 10
        def bar():
            nonlocal a
            a = 20          # buradaki a foo'nun a'sı
            print(a)        # foo'nun a'sı, 20
        bar()
        print(a)            # foo'nun a'sı, 20
        
    foo()

#------------------------------------------------------------------------------------------------------------------------

def foo():
    a = 10
    def bar():
        nonlocal a

        a = 20          # buradaki a foo'nun a'sı
        print(a)        # foo'nun a'sı, 20
    bar()
    print(a)            # foo'nun a'sı, 20
    
foo()

#------------------------------------------------------------------------------------------------------------------------
    Tabii iç fonksiyonun da iç fonksiyonu olabilir. Bu durumda nonlocal bildirimi benzer biçimde etki gösterir.
#------------------------------------------------------------------------------------------------------------------------

def foo():
    a = 10
    def bar():
        nonlocal a
        def tar():
            nonlocal a  

            a = 20      # foo'nun a'sı
            print(a)    # foo'nun a'sı yazdırılıyor, 20
        tar()
        print(a)        # foo'nun a'sı yazdırılıyor, 20
    bar()
    print(a)            # foo'nun a'sı yazdırılıyor, 20
        
foo()

#------------------------------------------------------------------------------------------------------------------------
    nonlocal bildirimi ile belirtilen ismin aranması içten dışa doğru yapılmaktadır. Dolayısıyla nonlocal bildirimi için bildirilen
    değişkenin hemen dış fonksiyonda bulunyor olması gerekmez. 
#------------------------------------------------------------------------------------------------------------------------

def foo():
    a = 10
    def bar():
        def tar():
            nonlocal a    # bar'da a olmadığı için foo'nun a'sı

            a = 20
        tar()
    bar()
    print(a)                # foo'nun a'sı yazdırılıyor, 20
        
foo()

#------------------------------------------------------------------------------------------------------------------------
    Anımsanacağı gibi global bildirimi fonksiyon içerisinde henüz global değişken yaratılmamış olsa bile yapılabiliyordu. Ancak 
    nonlocal bildirimi için durum böyle değildir. nonlocal bildirimi ile bildirilen değişken dıştaki herhangi bir fonksiyonda 
    bulunamazsa bu durum error oluşturur. Örneğin:

    def foo():
        def bar():
            nonlocal a          # error! dış fonksiyonda a yok!

            a = 10
        bar()
            
    foo()

    nonlocal bildiriminde bildirilen değişken dış fonksiyonların yerel değişkeni olarak aranır. Bu aramda global değişkenlere 
    bakılmaz. Örneğin:

    a = 10
    def foo():
        def bar():
            nonlocal a          # error! dış fonksiyonda yerel a yok! global bir a'nın olması önemli değil

            a = 10  
        bar()       
    foo()

    Dış fonksiyonda aynı isimli değişken global bildirimi ile bildirilmiş olsa bile nonlocal bildirimi bu değişkeni görmez. 
    Çünkü global bildirimi de hiçbir zaman yerel bir değişkene ilişkin değildir. 

    a = 10
    def foo():
        global a
        def bar():
            nonlocal a          # error! dış fonksiyonda yerel a yok! global bir a'nın olması önemli değil
            
            a = 10         
        bar()
        
    foo()

    Benzer biçimde dış fonksiyonda bir global bildirimi yapılmışsa daha iç bir fonksiyonda yaratılan aynı isimli değişken 
    o iç fonksiyonun değişkeni olur. Örneğin:

    a = 10

    def foo():
        global a
        
        a = 20          # global a değiştiriliyor
        def bar():
            a = 30      # yeni bir yerel a yaratılıyor     
        bar()

    foo()

    print(a)         # global a yazdırılıyor  

#------------------------------------------------------------------------------------------------------------------------

<BURADA KALDIK>

#------------------------------------------------------------------------------------------------------------------------
    Tabii her modülün global değiikenleri o modüle özgüdür. Yani her modül kendi içerisinde farklı bir isim alanı (nameepace) oluşturmaktadır. 
    Örneğin util modülü içerisinde globa bir a değişkeni yaratılmış olsun:

    # util.py

    a = 10

    Şimdi biz sample.py dosyasında bu modülü import edelim:

    # sample.py

    import util

    a = 20

    print(a)            # 20
    print(util.a)       # 10

    Görüldüğü gibi util.py içerisinmdeki a global değişkeni ile sample.py içerisindeki a global değişkeni farklı değişkenlerdir. 
    Tabii from import deyimi ilgili modülde yeni bir değişken yaratmaktadır. 

    from import deyiminin eşdeğerini hatırlayınız. Örneğin:

    from util import a

    Bu işlemin tamamen eşdeğeir şöyledir:

    import util
    a = util.a 
    del util 

    Bu durumda:
    
    from import util a 

    deyimi ile biz a'yı kullandığımızda util'deki a'yı kullanmış olmayız. Çünkü int değiştirilmez bir tür olduğu için a = util.a atamasında
    a artık başka bir int değişkeni göstermektedir. Dolayısıyla:

    from util import a

    a = 10

    print(a)        # a bu modüldeki a

    import util

    print(util.a)   # util'deki a

    Tabii from import deyimi ile import ettiğimiz değişken değiştitilebilir bir nesneye ilişkin ise bu durumda gerçekten o nesne 
    üzerinde yapılan değişiklik o modüldeki nesneyi etkileyecektir. Örneğin:

    # util.py

    a = [1, 2, 3, 4, 5]

    #sample.py

    from util import a

    a[0] = 100

    print(a)        # [100, 2, 3, 4, 5]

    import util

    print(util.a)        # [100, 2, 3, 4, 5]

#------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------
    Bir modül yerel düzeyde import edildiğinde her ne kadar modül değişkenini yalnızca o mfonksiyonda kullanabiliyor olsak da 
    aslında hangi düzeyde import yapılmış olursa olsun toplamda her zaman tek bir modül nesnesi olşturulmaktadır. Aşağıdaki örnekte
    util modülündeki listenin elemanı yerel değişkende değiştirilmiştir. Ancak kodun başka bir yerinde yeniden aynı modül import edildiğinde
    listenin o elemanı değiştirilmiş olarak görülür.
#------------------------------------------------------------------------------------------------------------------------

def foo():
    import util
    
    util.a[0] = 100
    
    print(util.a)       # [100, 2, 3, 4, 5]
    
    print(id(util))     # 1581194445344
    
foo()

import util

print(util.a)       # [100, 2, 3, 4, 5]
print(id(util))     # 1581194445344

del util

import util

print(util.a)       # [100, 2, 3, 4, 5]
print(id(util))     # 1581194445344

#------------------------------------------------------------------------------------------------------------------------
    Python'da globals isimli built-in fonksiyon o andaki tüm global değişkenleri bir sözlük nesnesi biçiminde bize verir. 
    Sözlüğün anahtarları global değişkenlerin isimlerinden değerleri ise onların değerlerinden oluşur. globals fonksiyonu ile
    global değişkenleri elde ettiğinizde kendiniz yaratmadığı başka değişkenler de görürsenin şaşırmayınız. Örneğin __name__ isimli 
    global değişkenin biz daha önce yorumlayıcı tarafındna oluşturulduğunu görmüştük. Benzer biçimde bütün built-in değişkenler 
    __builtins__ isimli bir global sözlük nesnesi içerisinde bulunmaktadır. 
#------------------------------------------------------------------------------------------------------------------------

a = 10
name = 'ali'

def foo():
    pass

g = globals()
print(g)
print(list(g))      # ['__name__', '__file__', '__nonzero__', '__builtins__', 'a', 'name', 'foo', 'g']

#------------------------------------------------------------------------------------------------------------------------
    Biz globals fonksiyonuyla elde etmiş olduğumuz sözlüğe eleman ekleyerek yeni global değişkenleri bu yolla oluşturabiliriz. 
    Yorumlayıcı da zaten bütün global değişkenleri aslında kendi içerisinde bir sözlükte tutmaktadır. 
#------------------------------------------------------------------------------------------------------------------------

a = 10
g = globals()
g['b'] = 20
print(b)        # 20
print(a)        # 10

#------------------------------------------------------------------------------------------------------------------------
    locals fonksiyonu da hangi fonksiyon içerisinde çağrılmışsa o fonksiyonun yerel değişkenlerini bir sözlük olarak vermektedir. 
    locals fonksiyonu global düzeyde çağrılırsa tamamen globals gibi etki göstermektedir. 
#------------------------------------------------------------------------------------------------------------------------

a = 10

def foo():
    b = 20
    l = locals()
    print(l)            # {'b': 20}
    print(list(l))      # ['b']
    
foo()
    
#------------------------------------------------------------------------------------------------------------------------
    locals fonksiyonu iç bir fonksiyonda da çağrılabilir. Bu durumda yalnızca kendi fonksiyonundaki yerel değişkenleri 
    verir. 
#------------------------------------------------------------------------------------------------------------------------

def foo():
    a = 10
    def bar():
         b = 20
         l = locals()
         print(l)           # {'b': 20}
         
    bar()

foo()

#------------------------------------------------------------------------------------------------------------------------
    locals fonksiyonu ile elde edilen sözlüğe bir ekleme yapıldığında gerçekten de sözlüğe ekleme yapılmış olur. Ancak eklenen 
    isim yerel değişken olarak kullanılamaz. Bu durum globals fonksiyonundaki duruma bu bakımdan benzememektedir. 
    Python yorumlayıcı aslında fonksiyonun yerel değişkenlerini de kendi içerisinde bir sçzlükte tutmaktadır. 
#------------------------------------------------------------------------------------------------------------------------

def foo():
    a = 10
    l = locals()
    print(l)            # {'a': 10}
    l['b'] = 20
    print(l)            # {'a': 10, 'b': 20}
    print(b)            # error! b eklenmiş olsa da bu biçimde kullanılamaz!

foo()
    
#------------------------------------------------------------------------------------------------------------------------
    İçlemler (comprehensions) "fonksiyonel (functional)" daha çok dillerde karşımıza çıkan özel ifadelerdir. İçlemler üçe 
    ayrılmaktadır:

    1) Liste içlemleri (list comprehensions)
    2) Küme içlemleri (set comprehensions)
    3) Sözlük içlemleri (dicitionary comprehensions)

    Eğer içlemden bir liste elde ediliyorsa buna "liste içlemi", kğme elde ediliyorsa buna "küme içlemi", sözlük elde 
    ediliyorsa buna da "sözlük içlemi" denilmektedir. 
#------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------
    İçlemlerin genel biçimleri biribirine çok benzemektedir. Liste içlemlerinin genel biçimi şöyledir:

    [<ifade> for <değişken> in <dolaşılabilir nesne> [if koşul] ]

    İçlemin çalışma mekanizması oldukça basittir. for göngüsünün her çalıştırılmasından sonra for döngüsünün ysolundaki ifade 
    çalıştırılır. Bu ifadenin değeri bir listeye eklenir. Böylece for döngüsü her çalştırıldığında listeye yeni bir eleman eklenmiş olacaktır.
    Örneğin:

    a = [i * i for i in range(10)]
    print(a)

    Burada for döngüsünden sırasıyla 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 değerlri i olarak elde edilir. Her değer elde edildiğinde soldaki i * i 
    ifadesi çalıştırılırsa ve bu değerler bir listede biriktirilirse sonuçta [0, 1, 4, 9, 16, 25, 36, 49, 64, 81] biçiminde 
    bir liste oluşturulacaktır. Aslına aşağıdkai bir içlem olsun:

    [ifade for i in iterable]

    Bunun eşdeğeri şöyledir:

    temp = []
    for i in iterable:
        temp.append(ifade)

    Örneğin:

    a = [i * i for i in range(10)]
    print(a)

    Bu işlemin eşdeğeri şöyledir:

    a = []
    for i in range(10):
        a.append(i * i)
    print(a)

    Her ne kadar yukarıdaki iki ifade eşdeğer gibi gözükse de içlemler genel olarak daha hızlı olma eğilimindedir. 
    Çünkü içlemler genellikle daha temel düzeyde ve tek bir operasyon biçiminde yapılmaktadır. 

    Tabii içlemlerin önemi aslında hızdan ziyade kompakt bir görünüm sağlamasındadır .İçlemler bir ifade (expression)
    durumundadır. Dolayısıyla başka ifadelerin içerisinde kullanılabilrler. Örneğin:

    total = sum([i * i for i in range(10)])
    print(total)

    Burada 10'a kadar sayıların karelerinin toplamı bulunmuştur. Eğer içlemler olmasaydı bu ifadeyi bu kadar kompaks yazamazdık.

    Tabii aslında for döngüsünün solundaki ifadenin döngü değişkeni ile ilgili olması zorunluluk değildir. Örneğin:

    a = [100 for i in range(10)]
    print(a)            # [100, 100, 100, 100, 100, 100, 100, 100, 100, 100]

#------------------------------------------------------------------------------------------------------------------------

names = ['ali', 'veli', 'selami', 'ayşe', 'fatma']
names_len = [len(name) for name in names]
print(names_len)

#------------------------------------------------------------------------------------------------------------------------
    Liste içlemleriyle yapılmak istenen şeylerin bir bölümü map fonksiyonuyla da yapılabilir. liste içlemleri bize ürün olarak
    liste vermektedir. Halbuki map fonksiyonu bize ürün olarak dolaşılabilir bir nesne verir. 
#------------------------------------------------------------------------------------------------------------------------

names = ['ali', 'veli', 'selami', 'ayşe', 'fatma']

names_len = [len(name) for name in names]
print(names_len)

names = list(map(len, ['ali', 'veli', 'selami', 'ayşe', 'fatma']))
print(names)

#------------------------------------------------------------------------------------------------------------------------
    İçlemlerde istenirse for cümlesinin sağına if anahtar sözcüğü ile bir koşul cümleceği de eklenebilir. Bu durumda for döngüsü 
    her işletildiğinde sağdaki koşula bakılır. Eğer koşul doğruysa soldaki ifade işletilir. Koşulsuz yanlışsa soldaki ifade işletilmez 
    ve bu ifadenin sonucu listeye eklenmez. Örneğin:

    a = [i for i in range(10) if i % 2 == 0]
    print(a)        # [0, 2, 4, 6, 8]

    Burada koşul i çift ise sağlanmaktadır. Dolayısıyla listede çift sayılar bulunacaktır. O halde örneğin:

    [ifade for i in iterable if koşul]

    içleminin işlevsel eşdeğeri şöyledir:

    temp = []

    for i in iterable:
        if koşul:
            temp.append(ifade)

    Örneğin:

    total = sum([i for i in range(10) if i % 2 == 1])
    print(total)

    Burada 10'a kadar tek sayıların toplamı bulunmaktadır. Örneğin:

    names = ['ali', 'veli', 'selami', 'ayşe', 'fatma']

    a = [name for name in names if 'a' in name]
    print(a)

    Burada için 'a' harfi geçen isimler bir liste biçiminde elde edilmektedir. 
#------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------
                                            38. Ders 05/09/2022 - Pazartesi
#------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------
    Aşağıdaki örnekte başı 'a' ya da 'A' harfi ile başlayan isimler liste içlemi yoluyla elde edilmektedir. 
#------------------------------------------------------------------------------------------------------------------------

names = ['ali', 'veli', 'selami', 'ayşe', 'fatma']

a = [name for name in names if name[0] == 'a' or name[0] == 'A']
print(a)

#------------------------------------------------------------------------------------------------------------------------
    Aşağıdaki örnekte küçük harf olan şehir isimleri büyük harfe dönüştürülerek bir liste biçiminde elde edilmiştir.
#------------------------------------------------------------------------------------------------------------------------

cities = ['ankara', 'izmir', 'eskişehir', 'muğla', 'kastamonu']

upper_cities = [city.upper() for city in cities]
print(upper_cities)

#------------------------------------------------------------------------------------------------------------------------
    Aşağıdaki liste içlemi tam palindrom olan cümleleri elde etmektedir. 
#------------------------------------------------------------------------------------------------------------------------

sentences = ['anastas mum satsana', 'izmir', 'ey edip adanada pide ye', 'eskişehir', 'adamla çeneç almada']

palindromes = [sentence for sentence in sentences if sentence == sentence[::-1]]
print(palindromes)

#------------------------------------------------------------------------------------------------------------------------
    Aşağıdaki örnekte tam palindrom olmayan cümleler de elde edilmektedir.
#------------------------------------------------------------------------------------------------------------------------

sentences = ['anastas mum satsana', 'izmir', 'ey edip adanada pide ye', 'eskişehir', 'adamla çene çalmada']

palindromes = [sentence for sentence in sentences if ''.join(sentence.split()) == ''.join(sentence.split())[::-1]]
print(palindromes)

#------------------------------------------------------------------------------------------------------------------------
    Aşağıdaki örnekte palindrom sayılar liste içlemi yoluyla elde edilmektedir. 
#------------------------------------------------------------------------------------------------------------------------

numbers = [12, 1221, 13431, 12345, 197262]

palindrome_numbers = [number for number in numbers if str(number) == str(number)[::-1]]
print(palindrome_numbers )

#------------------------------------------------------------------------------------------------------------------------
    Aşağıdaki örnekte (şehir_ismi, plaka_numarası) biçimindeki demet listesinde "şehir_ismi-plaka_numarası" biçiminde 
    bir string listesi elde edilmiştir. 
#------------------------------------------------------------------------------------------------------------------------

cities = [('ankara', 6), ('izmir', 35), ('eskişehir', 26), ('muğla', 48), ('kastamonu', 37)]

result = [city + '-' + str(plate) for city, plate in cities]
print(result)

#------------------------------------------------------------------------------------------------------------------------
    Yukarıdaki örnek aşağıdaki gibi de yapılabilirdi
#------------------------------------------------------------------------------------------------------------------------

cities = [('ankara', 6), ('izmir', 35), ('eskişehir', 26), ('muğla', 48), ('kastamonu', 37)]

result = [f'{city}-{plate}' for city, plate in cities]
print(result)

#------------------------------------------------------------------------------------------------------------------------
    Örneğin biz belli bir sayıya kadar olan asal sayıları bir liste biçiminde liste içlemi yoluyla elde edebiliriz. 
#------------------------------------------------------------------------------------------------------------------------

def isprime(val):
    if val % 2 == 0:
        return val == 2
    for i in range(3, val, 2):
        if val % i == 0:
            return False
    return True

primes = [i for i in range(2, 1000) if isprime(i)]
print(primes)

#------------------------------------------------------------------------------------------------------------------------
    Aşağıdaki örnekte bir listenin çift indisli elemanları liste içlemi yoluyla elde edilmektedir. 
#------------------------------------------------------------------------------------------------------------------------

a = [10, 20, 30, 40, 50, 60]

b = [a[i] for i in range(0, len(a), 2)]
print(b)

#------------------------------------------------------------------------------------------------------------------------
    Yukarıdaki işlem aşağıdaki gibi enumerate fonksiyonu kullanılarak da yapılabilirdi.
#------------------------------------------------------------------------------------------------------------------------

a = [10, 20, 30, 40, 50, 60]

b = [elem for index, elem  in enumerate(a) if index % 2 == 0]
print(b)

#------------------------------------------------------------------------------------------------------------------------
    Aslında içlemlerin içerisinde birden fazla for döngüsü de olabilir. Örneğin:

    names = ['ali', 'veli', 'selami', 'ayşe', 'fatma']

    names_chars = [char for name in names for char in name ]
    print(names_chars)
#------------------------------------------------------------------------------------------------------------------------

names = ['ali', 'veli', 'selami', 'ayşe', 'fatma']

names_chars = [char for name in names for char in name ]
print(names_chars)

#------------------------------------------------------------------------------------------------------------------------
    Aşağıdaki örnekte iki kümenin kartezyen çarpımları bir demet listesi biçiminde elde edilmişir. İçlemlerde demet oluştururken
    parantezler gerekmektedir. 
#------------------------------------------------------------------------------------------------------------------------

names = ['ali', 'veli', 'selami', 'ayşe', 'fatma']
cities = ['ankara', 'izmir', 'adana', 'iskenderun', 'fatsa']

cartesian_product = [(name, city) for name in names for city in cities]
print(cartesian_product)

#------------------------------------------------------------------------------------------------------------------------
    Bir içlemdeki ifade başka bir içlem olabilir. Örneğin bu yöntemle biz liste listeleri elde edebiliriz. Örneğin:

    [[ifade for y in x] for x in a]

    Burada for dngsü her işletildiğinde ifade olarak solda içlem yapılacaktır. Soldaki içlem de bize bir liste vereceğine göre 
    burada listelerden oluşan bir liste elde edilecektir. 

    Aşağıdaki örnekte listelerden oluşan bir listedaki sayılar string'e dönüştürülmüştür.
#------------------------------------------------------------------------------------------------------------------------

a = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]

b = [[str(y) for y in x] for x in a]
print(b)
   
#------------------------------------------------------------------------------------------------------------------------
    Aşağıdaki örnekte liste içeisindeki listelerdeki çift elemanlar elde elde edilmiştir.
#------------------------------------------------------------------------------------------------------------------------

a = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]

b = [[y for y in x if y % 2 == 0] for x in a]
print(b)            # [[2], [4, 6], [8]]
   
#------------------------------------------------------------------------------------------------------------------------
    Amacımız her biri 5 elemandan oluşan 10 elemanlı tüm elemanları 0 olan bir liste listesi oluşturmak olsun. 
    Bu işlemi "repitition" ile yapamayız:

    >>> a = [[0, 0, 0, 0, 0]] * 10
    >>> a
    [[0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0],
    [0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0]]

    Her ne kadar görünüşte bu işlem yapılmış gibi olsa da aslında buada bir kusur vardır. Listeler "değiştirilebilir (mutable)" 
    olduğu için "repitition" işlemi de kopyalama yoluyla yapıldığı için iç listenin bir elemanı değiştirildiğinde sanki tüm 
    listelerin ilgili elemanları değiştirilmiş gibi olur. Örneğin:

    >>> a[0][0] = 100
    >>> a
    [[100, 0, 0, 0, 0], [100, 0, 0, 0, 0], [100, 0, 0, 0, 0], [100, 0, 0, 0, 0], [100, 0, 0, 0, 0], [100, 0, 0, 0, 0], [100, 0, 0, 0, 0], [100, 0, 0, 0, 0], [100, 0, 0, 0, 0], [100, 0, 0, 0, 0]]
    >>> id(a[0])
    2608002477184
    >>> id(a[1])
    2608002477184
    >>> id(a[2])
    2608002477184

    Pekiyi bu işlemi doğru olarak nasıl yapabiliriz? İlk akla gelecek yöntem namuel bir for döngüsü kullanmaktadır:

    >>> a = []
    >>> for _ in range(10):
    ...     a.append([0, 0, 0, 0, 0])
    ...
    >>> a
    [[0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0], 
    [0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0]]
    >>> a[0][0] = 100
    >>> a
    [[100, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0],
     [0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0]]

    Ancak bu işlemin en pratik yöntemi liste içlemi kullanmaktadır. Örneğin:

    >>> a = [[0, 0, 0, 0, 0] for _ in range(10)]
    >>> a
    [[0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0], 
    [0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0]]
    >>> a[0][0] = 100
    >>> a
    [[100, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0],
     [0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0]]  
#------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------
    Bir liste içleminde for cümleciğinin "in" kısmında da içerisindeki ifade de içlem kullanılabilir. Örneğin:

    [ifade for x in [for y in z]]

#------------------------------------------------------------------------------------------------------------------------

text = 'bugün hava çok güzel, sen de parka gittin mi?'
a = [revword for revword in [word[::-1] for word in text.split()] if revword[0] == 'n']
print(a)

#------------------------------------------------------------------------------------------------------------------------
    Genel olarak içlemler bir ifade oluşturduğu için hem daha kompakt yazımlara olanak sağlamakta hem de daha hızlı olma
    eğilimindedir. Bu nedenle eğer içlem kullanabiliyorsanız içlemi tercih etmelisiniz. 

    Aşağıdaki örnekte bir listenin manuel yolla ve içlem yoluyla oluşturulması örneği verilmiştir. Her ikisinin de zamanı 
    ölçülmüştür.
#------------------------------------------------------------------------------------------------------------------------

import time

start = time.time()

a = []

for i in range(10000000):
    a.append(str(i))
    
stop = time.time()

print(stop - start)             # 3.7108449935913086
    
start = time.time()

a = [str(i) for i in range(10000000)]
stop = time.time()

print(stop - start)             # 2.890331983566284

#------------------------------------------------------------------------------------------------------------------------
    Küme içlemleri (set comprehension) aslında sentaktik biçim olarak tamamen liste içlemleri ile aynıdır. Yalnızca dıştaki
    köşeli parantezler yerine küme parantezleri kullanılmaktadır. Örneğin:

    s = {ch for ch in 'ankara'}

    Bu işlemden artık bir liste değil bir küme elde edilecektir. Küme parantezlerinin içi tamamen liste içlemlerindeki gibidir. 
#------------------------------------------------------------------------------------------------------------------------

s = {ch for ch in 'ankara'}
print(s)

#------------------------------------------------------------------------------------------------------------------------
    Aşağıdaki örnekte listenin iki elemanın toplamları bir küme olarak elde edilmiştir. Burada yinelenen toplamların 
    alınmadığına dikkat ediniz.
#------------------------------------------------------------------------------------------------------------------------

a = [1, 2, 3, 4, 5]

s = {i + k for i in a for k in a}
print(s)

#------------------------------------------------------------------------------------------------------------------------
    Tabii küme içlemi kullanmak yerine liste içlemi oluşturup elde edilen liste kümeye de dönüştürülebilir. Ancak bu işlem
    küme içlemine göre daha yavaş bir çalışmaya neden olmaktadır. 
#------------------------------------------------------------------------------------------------------------------------

a = [1, 2, 3, 4, 5]

s = set([i + k for i in a for k in a])
print(s)

#------------------------------------------------------------------------------------------------------------------------
    Sözlük içlemleri (dictionary comprehension) tamamen küme içlemleri gibidir. Ancak ifadenin anahtar: değer biçiminde olması gerekir:

    {key: value  for x in a}
#------------------------------------------------------------------------------------------------------------------------

a = [1, 2, 3, 4, 5]

d = {x: str(x) for x in a}
print(d)

#------------------------------------------------------------------------------------------------------------------------
    Yukarıdaki işlemi biz manuel olarak bir for döngüsüyle de yapabilirdik. Ancak içlemler hem kompkt bir ifade oluşturmak da 
    hem de daha hızlı olma eğilimindedir. 
#------------------------------------------------------------------------------------------------------------------------

a = [1, 2, 3, 4, 5]
d = {}

for x in a:
    d[x] = str(x)
    
print(d)

#------------------------------------------------------------------------------------------------------------------------
    Yine aslında biz bir liste içlemi oluşturup oradan sözlük elde edebiliriz. Ancak bu yöntem dolaylı ve yavaş bir yöntemdir. 
#------------------------------------------------------------------------------------------------------------------------

a = [1, 2, 3, 4, 5]

d = dict([(x, str(x)) for x in a])
print(d)

#------------------------------------------------------------------------------------------------------------------------
    Bir sözlükteki anahtarları değer, değerleri anahtar yapan kod parçasını daha önce aşağıdaki gibi oluşturmuştuk:

    d = {'ali': 10, 'veli': 20, 'selami': 30, 'ayşe': 40, 'fatma': 50}

    result = {}

    for key, value in d.items():
        result[value] = key
        
    print(result)

    Aslında bu işlem aşağıdaki gibi sözlük içlemiyle kompakt bir biçimde de yapılabilir. 
#------------------------------------------------------------------------------------------------------------------------

d = {'ali': 10, 'veli': 20, 'selami': 30, 'ayşe': 40, 'fatma': 50}

result = {value: key for key, value in d.items()}
print(result)
    
#------------------------------------------------------------------------------------------------------------------------
    Yukarıdaki işlem items metodu kullanılmadan da aşağıdkai gibi yapılabilirdi.
#------------------------------------------------------------------------------------------------------------------------

d = {'ali': 10, 'veli': 20, 'selami': 30, 'ayşe': 40, 'fatma': 50}

result = {d[key]: key for key in d}
print(result)
    
#------------------------------------------------------------------------------------------------------------------------
    Python'da liste içlemleri, küme içlemleri ve sçzlük içlemleri vardır. Ancal demeyt içlemleri fiye bir şey yoktur. 
    Aslında sentaks olarak demet içlemi gibi bir sentaks vardır. Ancak bu sentaks tamamen farklı bir anlama gelmektedir. Örneğin:

    (x for x in a)

    Bu sentaks Python'da geçerlidir ama "üretici ifade (generator expression)" anlamına gelmektedir. Üretici ifadeler 
    ileride bir başlık altında ele alınacaktır. 
#------------------------------------------------------------------------------------------------------------------------

ge = (str(i) for i in range(100))       # dikkat! bu bir demet içlemi değildir! Üretici ifadedir!
for s in ge:
    print(s)

#------------------------------------------------------------------------------------------------------------------------
    zip fonksiyonu çok kullanılan "built-in" bir fonksiyondur. Parametrik yapısı şöyledir:

    def zip(*iterables):
        pass

    Yani fonksiyon istenildiği kadar çok dolaşılabilir nesneyi parametre olarak alabilmektedir. Başka bir deyişle
    zip fonksiyonu birden fazla argümanla kullanılabilir. Ancak argümanların hepsinin dolaşılabilir nesneler olması gerekir. 

    zip fonksiyonu bizden dolaşılabilir nesneleri alır ve bize geri dönüş değeri olarak bir dolaşılabilir nesne verir. 
    zip fonksiyonun geri döndürdüğü dolaşılabilir nesneyi dolaştığımızda demetler elde ederiz. Öyle demetler elde ederiz ki
    bu demetin elemanları bizim zip fonksiyonuna verdiğimiz dolaşılabilir nesnenin karşılıklı elemanlarıdır. Örneğin:

    a = ['ali', 'veli', 'selami']
    b = [10, 20, 30]
    c = [5.2, 3.8, 4.6]

    z = zip(a, b, c)

    for t in z:
        print(t)

    Burada z nesnesi her dolaşıldığında üç elemanlı aşağıdaki demetler elde edilecektir:

    ('ali', 10, 5.2)
    ('veli', 20, 3.8)
    ('selami', 30, 4.6)

#------------------------------------------------------------------------------------------------------------------------

a = ['ali', 'veli', 'selami']
b = [10, 20, 30]
c = [5.2, 3.8, 4.6]

z = zip(a, b, c)

for t in z:
    print(t)

#------------------------------------------------------------------------------------------------------------------------
    zip fonksiyonuna verdiğimiz dolaşılabilir nesnelerin uzunlukları aynı olmak zorunda değildir. En kısa nesne bittiğinde 
    dolaşım biter. Aşağıdaki örnekte en kısa nesne 3 eleman uzunlukta olduğuna göre dolaşım üç kere devam edecektir. 
#------------------------------------------------------------------------------------------------------------------------

a = ['ali', 'veli', 'selami', 'ayşe', 'fatma']
b = [10, 20, 30]
c = [5.2, 3.8, 4.6, 5.8, 9.6]

z = zip(a, b, c)

for t in z:
    print(t)
    
#------------------------------------------------------------------------------------------------------------------------
                                                39. Ders 07/09/2022 - Çarşamba
#------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------
    Tabii biz zip fonksiyonunun bize verdiği dolaşılabili,r nesneyi dolaşırken açım işlemi (unpacking) de yapabiliriz.
#------------------------------------------------------------------------------------------------------------------------

a = ['ali', 'veli', 'selami', 'ayşe', 'fatma']
b = [10, 20, 30, 40, 50]
c = [5.2, 3.8, 4.6, 5.8, 9.6, 3.4, 10.2]

for x, y, z in zip(a, b, c):
    print(x, y, z)
    
#------------------------------------------------------------------------------------------------------------------------
    zip yapılmış bir nesneyi unzip yapabiliriz. Aslında bunun için de yine zip fonksiyonunun kendisi kullanılmaktadır. 
    Şöyle ki: zip fonksiyonu bize z isimli dolaşılabilir bir nesne vermiş olsun. Şimdi biz bu dolaşılşabilir nesneyi her dolaştığımızda 
    aslında demetler elde ederiz. O zaman biz zip(*z) gibi bir çağrı yaptığımız zaman bu demetleri sanki zip fonksiyonun argümanları yapmış gibi oluruz.
    Buradan bize verilen dolaşılabilir nesne dolaşıldığında eski değerler birer demet olarak elde edilecektir. 
#------------------------------------------------------------------------------------------------------------------------

a = ['ali', 'veli', 'selami', 'ayşe', 'fatma']
b = [10, 20, 30, 40, 50]
c = [5.2, 3.8, 4.6, 5.8, 9.6, 3.4, 10.2]

z = zip(a, b, c)
    
for t in zip(*z):
    print(list(t))

#------------------------------------------------------------------------------------------------------------------------
    Yukarıdaki unzip işleminin daha iyi anlaşılması için aşağıdaki örneği inceleyiniz.
#------------------------------------------------------------------------------------------------------------------------

a = [(10, 'ali'), (20, 'veli'), (30, 'selami')]

result = zip(*a)
for t in result:
    print(t)
    
# yukarıdakinin eşdeğeri

result = zip((10, 'ali'), (20, 'veli'), (30, 'selami'))
for t in result:
    print(t)

#------------------------------------------------------------------------------------------------------------------------
    Aşağıdaki örnekte önce liste enumerate fonksiyonuna sokulmuş sonra oradan elde edilen dolaşılabilir nesne zip fonksiyonuna
    *'lı argüman olarak verilmiştir. Nasıl bir sonuç elde edildiğine dikkat ediniz. 
#------------------------------------------------------------------------------------------------------------------------

a = ['ali', 'veli', 'selami', 'ayşe', 'fatma']

for t in zip(*enumerate(a)):
    print(t)

#------------------------------------------------------------------------------------------------------------------------
    Permütasyon n elemanlı kümenin k elemanlı farklı dizilimlerine denilmektedir. Halbuki kombinasyon n elemanlı kümenin k'lı
    alt kümeleri anlamına gelmektedir. n elemanlı kümenin k'lı permütasyonlarının sayısı şöyle hesaplanmaktadır:

    P(n, k) = n! / (n - k)!

    Benzer biçimde n elemanlı kümenin k'lı kombinasyonlarının sayısı da şöyle hesaplanmaktadır:

    C(n, k) = n! / ((n - k)! * k!)

    Eskiden bu değerleri veren Python'da standart bir fonksiyon yoktu. Ancak Python 3.8 ile birlikte math modülüne comb ve perm 
    fonksiyonları eklenmiştir. Örneğin:

    >>> import math
    >>> math.perm(6, 3)
    120
    >>> math.comb(6, 3)
    20
#------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------
    itertools modülündeki permutations isimli fonksiyon bizden dolaşılabilir bir nesneyi ve bir sayıyı parametre olarak alır ve bize
    dolaşılabilir bir nesne verir. İşte permutations fonksiyonunun bize verdiği dolaşılabilir nesneyi dolaştığımızda bizim 
    birinci parametreyle verdiğimiz kümenin ikinci parametreyle belirtilen permütasyonlarını elde ederiz. 
#------------------------------------------------------------------------------------------------------------------------

import itertools

a = ['a', 'b', 'c', 'd', 'e']

result = itertools.permutations(a, 3)

for t in result:
    print(t)

#------------------------------------------------------------------------------------------------------------------------
    Şimdi de permutations fonksiyonun bize verdiği dolaşılabilir nesneyi enumerate fonksiyonuna sokarak dolaşalım.
#------------------------------------------------------------------------------------------------------------------------

import itertools

a = ['a', 'b', 'c', 'd', 'e']

result = itertools.permutations(a, 3)

for index, t in enumerate(result):
    print(index, '--->', t)
    
#------------------------------------------------------------------------------------------------------------------------
    Aşağıdaki örnekte yazdırma işlemi yan yana yapılmıştır.
#------------------------------------------------------------------------------------------------------------------------

import itertools

a = ['a', 'b', 'c', 'd', 'e']

for t in itertools.permutations(a, 5):
    print(*t, sep='')
    
#------------------------------------------------------------------------------------------------------------------------
    itertools modülündeki combinations isimli fonksiyon permutations isimli fonksiyonla aynı parametrik yapıya sahiptir. 
    Ancak bu fonksiyon kombinasyonları bize vermektedir. 
#------------------------------------------------------------------------------------------------------------------------

import itertools

a = ['a', 'b', 'c', 'd', 'e']

for t in itertools.combinations(a, 3):
    print(*t, sep='')

#------------------------------------------------------------------------------------------------------------------------
    Bir grup oyuncu bir karşılaşmada birbirleriyle eşlendirilerek oynayacak olsunlar. Her oyuncı-u her oyuncuyla oynasın.
#------------------------------------------------------------------------------------------------------------------------

import itertools

players = ['ali', 'veli', 'selami', 'ayşe', 'fatma']

for player1, player2 in itertools.combinations(players, 2):
    print(player1, '<--->', player2)

#------------------------------------------------------------------------------------------------------------------------
    Bilindiği gibi temel bellek birimi byte'tır. Bugünkü bilgisayar sistemlerinde adresleme byte esasına göre yapılmaktadır. 
    Bu nedenle programcılar çeşitli biçimlerde bir grup byte'ı saklamak durumunda kalabilirler. Bu yüzden programlamlama dillerinde 
    byte kavramını temsil eden türler bulundurulmuştur. İşte Python'da da byte kavramını temsil etmek için "bytes" isimli bir 
    tür bulundurulmuştur. 

    Aslında byte kavramı 8 bitten oluşur. 8 bit de [0, 255] arasında bir syaı belirtir. Ancak bute kavramını int türüyle temsil etmek verimsizdir. 
    Çünkü int türü sınırsız uzunlukta tamsayıları temsil etmek içimn düşünülmüştür. 
#------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------
    Bir bytes nesnesini pratik bir biçimde oluşturabilmek için tek tırnak, iki tırnak ya da üç tırnağa yapışık bir 'b' ya da
    'B' harfi kullanmak gerekir. Örneğin:

    >>> b = b'ankara'
    >>> type(b)
    <class 'bytes'>
    >>> b = B'izmir'
    >>> type(b)
    <class 'bytes'>

    bytes türü byte kavramını temsil etmekle birlikte bytes türünden nesneyi sanki bir string'miş gibi yaratmak kişilerin 
    kafasını karıştırmaktadır. Biz bytes nesnesi oluştururken tırnak içerisindeki karakterlerin ASCII tablosundaki sıra numaralarından 
    bu nesnenin sayısal değerini oluşturmuş oluruz. Örneğin:

    b = b'a'

    Biz aslında burada 'a' karakterinin ASCII tablosundaki sıra numarası olan 97 sayısına ilişkin bir bytes nesnesi oluşturmuş oluruz. 
    Ancak bir bytes nesnesini bu biçimde oluştururken tırnak içerisindeki karakterlerin ASCII tablosunun ilk 128 karakterlerinden 
    oluşturulmuş olması gerekir. Örneğin:

    >>> b = b'ağrı'
    File "<stdin>", line 1
        b = b'ağrı'
                ^
    SyntaxError: bytes can only contain ASCII literal characters.

    Byte kavramı [0, 255] arasında bir sayı belirttiğine göre biz de ancak ASCII tablosunun ilk 128 karakterini bu biçimde kullanabildiğimize göre
    o zaman geriş kalan byte değerlerini nasıl temsil ederiz? İşte tırnak içerisinde \x ve yanına iki hex digit yani \xhh biçiminde bir 
    sentaks hh numaralı hex sayıya karşılık gelen byte'ı temsil etmektedir. İki hex digit [0, 255] arası tüm sayıları ifade edebildiği için
    bir byte'ın her değerini ifade edebilmektedir. Örneğin:

    >>> b = b'\xFC\x17\x56'
    >>> len(b)
    3
    >>> b
    b'\xfc\x17V'

    Burada b nesnesi içerşisinde toplam 3 byte vardır. Ancak yukarıdaki örnekten de görüldüğü gibi bytes nesnesi yazdırılırken 
    eğer byte değeir [0, 127] arasında ise yazdırmada doğrudan o sayının ASCII karakter karşılığı basılmaktadır. Başka bir deyişle
    bytes nesnesi yazdırılırken yazdırılabilen karakterler karakter olarak diğerleri \xhh biçiminde yazdırılmaktadır. Örneğin:

    >>> b = b'\x168\x41\xFF'
    >>> b
    b'\x168A\xff'
    >>> len(b)
    4
    >>
#------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------
    Bir bytes nesnesini oluşturmanın diğer bir yolu bytes fonksiyonunu kullanmaktadır. Bu fonksiyonu biz argümansız kullanırsak 
    boş bir bytes nesnesi elde ederiz. Eğer bu fonksiyona dolaşılabilir bir nesneyi argüman olarak verirsek bu durumda 
    o dolaşılabilir nesnenin içerisindeki sayılardan bytes nesnesi oluşturulur. Tabii bu durumda bizim dolaşılabilir nesne içeriside
    [0, 255] arası sayılar bulundurmamız gerekir. Örneğin:

    >>> a =[34, 56, 129, 227, 78]
    >>> b = bytes(a)
    >>> len(b)
    5
    >>> b
    b'"8\x81\xe3N'

    Örneğin:

    >>> a = [34, 556, 129, 227, 78]
    >>> b = bytes(a)
    Traceback (most recent call last):
    File "<stdin>", line 1, in <module>
    ValueError: bytes must be in range(0, 256)

#------------------------------------------------------------------------------------------------------------------------
    Bir bytes nesnesi bir string nesnesinden de oluşturulabilir. Ancak bu durumda bir encoding belirtmek gerekir. Çünkü 
    Python'da tüm yazılar UNICODE olarak tutulmaktadır. Bu nedenle bir yazıyı byte'larına ayrıştırıp bir bytes nesnesi biçiminde
    oluştururken bir encoding belirtmek gerekir. UNICODE bir yazının çeşitli byte temsilleri olabilmektedir. Bunlara "encoding" 
    denilmektedir. UNICDODE'un "utf-8", "utf-16", "utf-32" gibi çeşitli encoding'leri vardır. Tabii UNICODE bir yazı eğer mümkünse
    ASCII biçimine ya da ASCII tablosunun çeşitli code page'lerine de dönüştürülebilir. Encoding konusu ileride başka konular içerisinde
    ele alınacaktır. Örneğin:

    >>> s = 'ağrı dağı'
    >>> b = bytes(s, 'utf-8')
    >>> b
    b'a\xc4\x9fr\xc4\xb1 da\xc4\x9f\xc4\xb1'

    Bir yazıyı byte'larına ayrıştırarak bytes nesnesi elde etmenin diğer bir yolu da str sınıfının encode metonu kullanmaktadır. 
    Bu metot da encoding parametresi almaktadır. Ancak bu encoding girilmezse default durumda 'utf-8' kullanılır. Örneğin:

    >>> s = 'ağrı dağı'
    >>> s.encode('utf-8')
    b'a\xc4\x9fr\xc4\xb1 da\xc4\x9f\xc4\xb1'
    >>> s.encode()
    b'a\xc4\x9fr\xc4\xb1 da\xc4\x9f\xc4\xb1'

    Encoding belirten parametrenin ismi "encoding" biçimindedir. BAzı programcılar okunabilirliği artırmak için parametreninismini açıkça yazmaktadır. 
    Örneğin:

    >>> b = bytes('ankara', encoding='utf-8')
    >>> b
    b'ankara'
    >>> s = 'ankara'
    >>> b = s.encode(encoding='utf-8')
    >>> b
    b'ankara'

    Bazen yukarıdaki işlemin tersini yapmak da gerekebilir. Yani elimizde bir bytes nesnesi vardır. Bu nesnenin içerisinde belli bir 
    encoding'e göre bir yazıyı belirten byte'lar bulunmaktadır. Biz de bu bytes nesnesinden bir str nesnesi elde etmek isteyebiliriz. 
    Bunun için str fonksiyonu kullanılabilir. Fonksiyonun birinci parametresi bir bytes nesnesi alırsa ikinci parametre de
    encoding belirtmelidir. Örneğin:

    >>> b = b'\x61\x62\x63'
    >>> s = str(b, encoding='ascii')
    >>> s
    'abc'

    Bir bytes nesnesinin içerisindeki byte'lardan bir string elde etmenin ikinci yolu da bytes sınıfının decode metodunu kullanmaktadır. 
    Yine metot parametre olarak encoding bilgisini alacaktır. Örneğin:

    >>> b = b'\x61\x62\x63'
    >>> s = b.decode(encoding='ascii')
    >>> s
    'abc'

    Özetle string'ten bytes'a dönüştürme için bytes fonksiyonu ve str sınıfının encode metodu kullanılırken, bytes'tan string'e dönüştürme 
    için str fonksiyonu ve bytes sınıfının decode metodu kullanılmaktadır. 
#------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------
                                                40. Ders 12/09/2022 Pazartesi
#------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------
    bytes türü de "değiştirilemez (immutable)" bir türdür. Dolayısıyla biz bir bytes nesnesinin içerisindeki yazıyı değiştiremeyiz. 
    Bu bakımdan bytes nesneleri str nesnelerine çok benzemektedir. 
    Örneğin:

    >>> b = b'ankara'
    >>> b
    b'ankara'
    >>> b[0] = 'x'
    Traceback (most recent call last):
    File "<stdin>", line 1, in <module>
    TypeError: 'bytes' object does not support item assignment

    bytes sınıfının str sınıfında olan pek çok metodu bulunmaktadır. Örneğin: split, strip, count, index, find gibi. 

    bytes nesneleri tamamen str nesneleri gibi dilimlenebilmektedir. Örneğin:

    >>> b = b'ankara'
    >>> b
    b'ankara'
    >>> b[2:4]
    b'ka'
    >>> b[:-2]
    b'anka'
#------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------
    Python'da built-in bytearray isimli bir tür de vardır. Aslında bytes türü ile bytearray türü birbirlerine çok benzemektedir. 
    Aralarındaki tek fark bytes türü "değiştirilemez (immutable)" olduğu halde bytearray türünün "değiştirilebilir (mutable)"
    olmasıdır. Bir bytearray nesnesi ancak bytearray fonksiyonu ile yaratılabilir. String gibi başına bir şeyler getirilerek yaratılmaz. 
    
    bytearray fonksiyonunda biz parametre olarak dolaşılabilir bir nesne verirsek bu dolaşılabilir nesnenin elemanlarının [0, 255] arasında
    int değerler olması gerekir. Bu durumda bu değerlerden bytearray nesnesi yaratılır. Örneğin:

    >>> ba = bytearray([1, 2, 3, 4, 5])
    >>> ba
    bytearray(b'\x01\x02\x03\x04\x05')

    bytearray nesnesi benzer biçimde bytes nesnesinden de yaratılabilir. Örneğin:

    >>> ba = bytearray(b'ankara')
    >>> ba
    bytearray(b'ankara')

    bytearray nesnesi string nesnesinden de yaratılabilir. Bu durumda encoding belirtmek gerekir. Örneğin:

    >>> ba = bytearray('ankara', encoding='utf-16')
    >>> ba
    bytearray(b'\xff\xfea\x00n\x00k\x00a\x00r\x00a\x00')
#------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------
    bytearray türü değiştirilebilir olduğu için biz bir bytearray nesnesinin içerisindeki byte'ları değiştirebiliriz. Zaten bytearray
    türünün bytes türünden tek farkı budur. Örneğin:

    >>> b = b'\x00\x01\x02'
    >>> len(b)
    3
    >>> b
    b'\x00\x01\x02'
    >>> b[0] = 10
    Traceback (most recent call last):
    File "<stdin>", line 1, in <module>
    TypeError: 'bytes' object does not support item assignment
    >>> ba = bytearray(b'\x00\x01\x02')
    >>> ba
    bytearray(b'\x00\x01\x02')
    >>> len(ba)
    3
    >>> ba[0] = 10
    >>> ba
    bytearray(b'\n\x01\x02')

    bytearray türü üzerinde de dilimler yapılabilmektedir. 

    bytearray türü de bytes türü gibi str sınıfında olan pek çok metodu içermektedir: Örneğin count, index, strip, split gibi.
#------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------
    bytes türü değiştirilemez olduğu için yorumlayıcının bazı optimizasyonlarına katılabilmektedir. Aynı zamanda bytes türü 
    yine değiştirilemez olduğu için toplamda bellekte daha az yer kaplamaktadır. Bu nednele eğer byte dizisinin elemanlarını değiştirmeyecekseniz
    bytes türünü, değiştirecekseniz bytearray türünü tercih etmelisiniz. Yine değiştirilemez türlerin hash'lenebilir olduğunu ama değiştirilebilir
    türlerin hash'lenebilir olmadığını anımsayınız. Bu nedenle örneğin bytes türü bir sözlüğe anahtar yapılabilir ancak bytearray 
    türü yapılamaz. Örneğin:

    >>> d = {b'ali': 100}
    >>> d
    {b'ali': 100}
    >>> d = {bytearray(b'ali'): 100}
    Traceback (most recent call last):
    File "<stdin>", line 1, in <module>
    TypeError: unhashable type: 'bytearray'

#------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------
    Biz şimdiye kadar hep fonksiyonları kullanarak kodlar oluşturduk. Bir programın fonksiyonlar yoluyla oluşturulmasına 
    "prosedürel programlama tekniği" denilmektedir. Sınıflar (classes) "Nesne Yönelimli Programlama Tekniğini (NYPT)" 
    uygulamak için gereken yapı taşlarıdır. NYPT "sınıflar kullanarak program yazma" tekniğidir. Yani işin içine sınıflar 
    girdiğinde artık NYPT'den bahsederiz. 
#------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------
    Sınıf tanımlamanın (sınıf oluşturmanın) genel biçimi şöyledir:

    class <isim>: <suite>

    Örneğin:

    class Sample:
        pass

    Sınıf isimleri Python programcıları tarafından genellikle "Pascal harflendirmesiyle (Pascal casting)" yazılmaktadır. 
    Yani isim tek bir sözcükten oluşuyorsa sözcüğün ilk harfi büyük olur. Birden fazla sözcükten oluşuyorsa her sözcüğün
    ilk harfi büyük olur. Biz de kurusumuzda sınıf isimlerini genel olarak Pascal casting biçiminde oluşturacağız. 
#------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------
    Su-ınıflar aynı zamanda birer tür de belirtmektedir. Oluşturduğumuz bir sınıf türünden nesneler yaratabiliriz. Bir sınıf türünden 
    nesne yaratmanın genel biçimi şöyledir:

    sınıf_ismi([argüman listesi])

    Örneğin:

    s = Sample()

    Burada s artık Sample türünden bir nesnenin adresini tutmaktadır. 

    Bir sınıf türünden nesnenin yaratılmasının adeta bir fonksiyon çağrısına benzediğine dikkat ediniz. Aslında list, tuple, str
    gibi sınıflar türünden de nesneleri biz aynı sentaksla yaratabiliyorduk. Örneğin:

    s = str()
    t = tuple()
    a = list()
#------------------------------------------------------------------------------------------------------------------------

class Sample:
    pass

s = Sample()
print(type(s))      # <class '__main__.Sample'>

#------------------------------------------------------------------------------------------------------------------------
    NYPT'de bir sınıf türünden nesneye o sınıf türünden bir "örnek (instance)" da denilmektedir. Yani "örnek (instance)" 
    sözcüğü sınıf türündne nesneler için kullanılmaktadır. Sınıflar elemanlara sahip olabilir. Sınıf nesneleri (yani örnekler)
    bileşik nesnelerdir. Yani parçalara sahiptir. Python'da bir sınıf nesnesinin elemanlarına yani parçalarına "öznitelik (attribute)"
    denilmektedir. (Halbuki sınıf elemanlarına C++'ta "veri elemanı (data member)", Java ve C#'ta "alan (field)" denilmektedir.)
    Eğer öznitelik bir nesnenin parçası durumunda ise buna "örnek özniteliği (instance attribute)" da denilmektedir. 
#------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------
    Bir nesne yaratıldığında henüz nesnenin içi boştur. Örneğin:

    class Sample:
        pass

    s = Sample()

    Burada s değişkeninin gösterdiği yerdeki nesnenin içi henüz boştur. Yani s'in henüz bir özniteliği yoktur. 
#------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------
    Bir sınıf türünden birden fazla nesne (yani örnek) yaratabiliriz. Örneğin:

    class Sample:
        pass

    s = Sample()
    k = Sample()

    Burada s başka bir nesneyi k;'da başka bir nesneyi göstermektedir. Örneğin:

    >>> s = Sample()
    >>> k = Sample()
    >>> id(s)
    3104147128816
    >>> id(k)
    3104147434752
#------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------
    Bir sınıf nesnesi yaratıldığında boştur demiştik. İşte bir nesnenin "öznitelikleri (attributes)" aşağıdaki sentaksla 
    yaratılmaktadır:

    <değişken_ismi>.<öznitel_ismi> = değer

    Örneğin:

    s = Sample()
    s.a = 10
    s.b = 20
    s.c = 'ankara'

    Burada biz s nesnnesinin içerisinde üç tane öznitelik oluşturduk. Yani artık s'nin ü. elemanı bulunmaktadır. Tabii Pyton'da
    her zaman değişkenler adres tutarlar. s nesnesinin içerisindeki a, b, ve c'de aslında sırasıyşla int, int ve str nesnelerinin 
    adreslerini tutmaktadır. Başka bir deyişle s nesnesinin a, b ve c parçaları içerisinde adresler vardır. Bu adreslerde sırasıyla 
    int bir nesne, int bir nesne ve str türünden bir nesne bulunmaktadır. 

#------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------
    C++, Java ve C# gibi dillerde bir sınıf türünden farklı nesnelerin elemanları hep aynı isimli ve aynı türden olur. Ancak 
    Python'da böyle olmak zorunda değildir. Örneğin Sample türünden iki sınıf nesnesi olsun. Bunların elemanları yani öznitelikleri 
    farklı olabilir:

 class Sample:
    pass

    s = Sample()
    k = Sample()

    s.a = 10
    s.b = 20

    k.x = 'ali'
    k.y = 12.3

#------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------
    Bir sınıf nesnesi için öznitelik yaratıldıktan sonra bu öznitelik istenildiği zaman <değişken_ismi>.<öznitelik_ismi> 
    sentaksıyla kullanılabilmektedir. Nesnenin özniteliklerini "nesnenin içerisindeki değişkenler" gibi düşünebilirsiniz. 
#------------------------------------------------------------------------------------------------------------------------

class Sample:
    pass

s = Sample()

s.a = 10
s.b = 'ankara'

print(s.a)      # 10
print(s.b)      # ankara

#------------------------------------------------------------------------------------------------------------------------
    Python'da sınıfların içerisinde fonksiynlar olabilir. Sınıfların içerisindeki fonksiyonlara "metot (method)" denilmektedir. 
    Eğer fonksiyon sınıfların dışındaysa ona "fonksiyon", bir sınıfın içerisindeyse ona "metot" denilmektedir. 

    Python'da metotların en azından bir parametresi olur. Metotların ilk parametreleri özel bir anlama sahiptir. Programcılar genel olarak
    metotların bu ilk parametrelerini "self" biçiminde isimlendirirler. Amcak bu ilk parametrenin "self" biçiminde isimlendirilmesi 
    zorunlu değildir. Örneğin:

    class Sample:
        def foo(self):
            pass

        def bar(self, a):
            pass

        def tar(self, a, b):
            pass

    def zar():
        pass

    Burada foo, bar ve tar Sample sınıfının metotlarıdır. zar şse sınıf içerisinde değildir. O halde zar bir fonksiyondur, metot değildir. 

    Bir metodun çağrılması için o metodun içinde bulunduğu sınıf türünden bir değişkenin olması gerekir. Metot çağırma işleminin genel 
    biçimi şöyledir:

    <değişken_ismi>.<metot_ismi>([argüman listesi])

    Örneğin:

    s = Sample()
    s.foo()
    s.bar(10)
    s.tar(10, 20)

    Metot bu biçimde çağrılırken birinci self parametresi için argüman girilmez. Metoda girilen argümanlar self parametresinden 
    sonraki parametrelere ilişkindir. Örneğin:

    s = Sample()
    s.tar(10, 20)

    Burada 10 tar metodunun a parametresine, 20 ise b parametresine aktarılmaktadır.
#------------------------------------------------------------------------------------------------------------------------

class Sample:
    def foo(self):
        print('foo')
    
    def bar(self, a):
        print(f'bar: {a}')
    
    def tar(self, a, b):
        print(f'tar: {a}, {b}')
        
def zar():
    print('zar')
    
s = Sample()

s.foo()
s.bar(10)
s.tar(10, 20)

zar()

#------------------------------------------------------------------------------------------------------------------------
    Metotların en azından bir parametresi olmak zorunda olduğunu belirtmiştik. Bu parametrenin de genellikle "self"
    biçiminde isimlendirildiğini söylemiştik. Pekiyi bu self parametresinin anlamı nedir? İşte metotlar ilgili sınıf türünden değişkenlerle 
    çağrılırlar. Her zaman self parametresine metodun çağrılmasında kullanılan değişken (yani onun içindeki adres) atanmaktadır. 
    Başka bir deyişle self metodun çağrılmasında kullanılan nesneyi belirtmektedir. Örneğin:

    class Sample:
        def foo(self, a, b):
            pass

    s = Sample()
    s.foo(10, 20)

    Burada s değişkeni (yani içindeki adres) self'e, 10 (yani 10 nesnesinin adresi) a, ya 20 de (yani 20 nesnesinin adresi) b'ye 
    atanmaktadır. Burada self tamamen s ile aynı nesneyi gösterir. 

#------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------
    Bir sınıf türünden değişken  başka bir değişkene atanabilir. Bu durumda iki değişken de aynı nesneyi gösterir. Nesneye 
    hangi değişkenle erişildiğinin bir önemi yoktur. Örneğin:

    s = Sample()
    s.a = 10
    
    k = s

    Python'da bütün atamalar adres ataması olduğuna göre k = s işleminde s'in içerisindek adres k'ya atanmıştır. Bu durumda 
    s ve k aynı nesneyi göstermektedir. O halde s.a ike k.a arasında hiçbir farklılık yoktur. Çünkü s.a "s değişkenin 
    içerisindeki adresteki nesnenin a özniteliği" anlamına gelmektedir. k.a da "k değişkenin içerisindeki adrestek, nesnenin a
    özniteliği" anlamına gelir. O halde iki ifade arasında hiçbir farklılık yoktur. 
#------------------------------------------------------------------------------------------------------------------------

class Sample:
    pass

s = Sample()
s.a = 10

k = s

print(s.a)
print(k.a)

print(id(s))        # 1781626597584
print(id(k))        # 1781626597584

print(id(s.a))      # 1781443422800
print(id(k.a))      # 1781443422800

#------------------------------------------------------------------------------------------------------------------------
    Bir metot çağrılırken her zaman metodun çağrılmasında kullanılan değişken (yani onun içerisindeki adres) metodun birinci parametresi 
    olan self parametresine atanktadır. Bu durumda self parametresi metodun çağrılmasında kullanılan değişken ile aynı nesneyi gösterir durumda olur. 
    Metotlar ilgili sınıf türünden bir değişkenle rçağrıldığına göre o değişkenin atanacağı metotta bir self parametresinin bulunması gerekmektedir. 
    Aşağıdaki örnekte self parametresi ile s aynı nesneyi göstermektedir. Dolayısıyla nesnenin a özniteliğine self parametresiyle de 
    erişilebilmiştir. 
#------------------------------------------------------------------------------------------------------------------------

class Sample:
    def foo(self):
        print(self.a)       # 10
        
s = Sample()
s.a = 10

s.foo()

#------------------------------------------------------------------------------------------------------------------------
    Yukarıdaki, işlemin tersini de yapabiliriz. Yani metodun içerisinde nesenin öznitelikleri yaratılabilir. Yaratılan bu öznitelikler
    daha sonra kullanılabilir. 
#------------------------------------------------------------------------------------------------------------------------

class Sample:
    def foo(self):
        self.a = 10
        self.b = 20
        
s = Sample()
s.foo()

print(s.a, s.b)         # 10 20

#------------------------------------------------------------------------------------------------------------------------
                                                            41. Ders 14/09/2022 Carsamba
#------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------
    Python'da başında ve sonunda iki alt tire olan özel bazı isimler kullanılmaktadır. Örneğin __init__, __add__ gibi. 
    Bu isimleri kolay ifade edebilmek için __xxx__ için "dunderscore xxx" ya da "dunder xxx" ifadeleri kullanılmaktadır. Yani örneğin biz
    "dunder init" demekle "__init__" ismini kastedeceğiz.  
#------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------
    Python'da sınıfların __init__ isimli özel bir metotları vardır. Bu metotlara "initializer" ya da bazen "constructor" da 
    denilmektedir. __init__ metodu bir sınıf türünden nesne yaratıldığında otomatik olarak çağrılan bir metottur. 

    Aşağıdaki örnekte Sample sınıfı türünden her nesne yaratıldığında yorumlayıcı tarafından sınıfın __init__ metodu otomatik bir biçimde 
    çağrılacaktır.
#------------------------------------------------------------------------------------------------------------------------

class Sample:
    def __init__(self):
        print('__init__ called')
        
s = Sample()
print('Ok')
k = Sample()

#------------------------------------------------------------------------------------------------------------------------
    Bir sınıf türünden nesne yaratıldığında önce nesne yaratılır. Sonra sınıfın __init__ metodu çağrılır. Ondan sonra atama işlemi yapılır. Örneğin:

    s = Sample()

    Burada __init__ çağrıldıktan sonra s'e atama yapılacaktır. __init__ metodunun self parametresi henüz yaratılmış olan nesneyi belirtmektedir. 
    İşte programcı tipik olarak nesnenin özniteliklerini __init__ metodu içerisinde yaratır. Böylece yaratılan her nesne aynı elemanlara 
    yani özniteliklere sahip olur. 
#------------------------------------------------------------------------------------------------------------------------

class Sample:
    def __init__(self):
        self.a = 10
        self.b = 20
        
s = Sample()
k = Sample()

print(s.a, s.b)
print(k.a, k.b)

#------------------------------------------------------------------------------------------------------------------------
    __init__ metodunun self dışında başka parametreleri de olabilir. Bu durumda nesne yaraılırken bu parametreler için de argüman 
    girilmelidir. Örneğin:

    class Sample:
        def __init__(self, a, b):
            self.a = a
            self.b = b

    Burada nesneyi yaratırken parantezler içerisinde bir a ve b için iki argüman girmeliyiz. Örneğin:

    s = Sample(10, 20)

    Burada Sample(a, b) ifadesi ile yeni yaratılan nesnenin adresi self parametresine 10 nesnesinin adresi a parametresine, 20 nesnesinin 
    adresi de b parametresine aktarılır. Bu parametreler de nesnenin özniteliklerine atanmıştır. 
#------------------------------------------------------------------------------------------------------------------------

class Sample:
    def __init__(self, a, b):
        self.a = a
        self.b = b
        
s = Sample(10, 20)
print(s.a, s.b)         # 10 20

k = Sample(30, 40)
print(k.a, k.b)         # 30 40

#------------------------------------------------------------------------------------------------------------------------
    Aşağıdaki örnekte sınıfın __init__ metodunda a ve b isimli iki örnek özniteliği yaratılmıştır. disp metodunda da bunlar 
    ekrana yazdırılmıştır. 
#------------------------------------------------------------------------------------------------------------------------

class Sample:
    def __init__(self, a, b):
        self.a = a
        self.b = b
        
    def disp(self):
        print(self.a, self.b)
        
s = Sample(10, 20)
k = Sample(30, 40)

s.disp()        # 10 20
k.disp()        # 30 40

#------------------------------------------------------------------------------------------------------------------------
    Pekiyi bir sınıf nedir? Aslında sınıf örnek özniteliklerinden ve metotlardan oluşan bir veri yapısıdır. Sınıflar belli bir konuda
    işlemleri yapan metotlara sahiptirler. Bu metotlar da nesnenin özniteliklerini ortak bir biçimde kullanmaktadır. NYPT'de 
    bir konuda bir işi yapabilecek sınıflar yazılır ve program sınıflar yoluyla oluşturulur. 

    şağıdaki örnekte Date sınıfı bir tarh bilgisini tutup onu ekrana yazdıran metoda sahiptir. 
#------------------------------------------------------------------------------------------------------------------------

class Date:
    def __init__(self, day, month, year):
        self.day = day
        self.month = month
        self.year = year
        
    def disp(self):
        print(f'{self.day}/{self.month}/{self.year}')

d = Date(10, 12, 2009)
d.disp()        # 10/12/2009

#------------------------------------------------------------------------------------------------------------------------
    Aşağıdaki örnekte Complex sınıfı bir karmaşık sayıyı temsil etmektedir. 
#------------------------------------------------------------------------------------------------------------------------

class Complex:
    def __init__(self, real, imag):
        self.real = real
        self.imag = imag
        
    def disp(self):
        print(f'{self.real}+{self.imag}i')
             
z = Complex(3, 2)
z.disp()
        
#------------------------------------------------------------------------------------------------------------------------
    Bir sınıf bi konuyla ilgili belli işlemleri yapmak amacıyla yazılır. Biz sınıf nesnesini yaratırken __init__ metodunda 
    onu argümanlar geçeriz. __init__ metodu bunları nesnenin özniteliklerinde saklar. Diğer metotlar da self yoluyla bunlara erişierek 
    faydalı işlemler yaparlar. 

    Python'ın standart kütüphanesindeki modüller içerisinde hem fonksiyonlar hem de sınıflar vardır. Örneğin datetime modülünün 
    içerisindeki date sınıfı tarih bilgisini temsil etmektedir. Biz bir date nesnesini yıl, ay, gün değerlerini vererek yaratırız. 
    Sonra da bu tarih bilgisi üzerinde çeşitli işlemler yaparız. Örneğin sınıfın weekday isimli metodu bizim verdiğimiz 
    tarihin hangi gün olduğunu bize bir sayı olarak verir (0 = Pazartesi, 1 = Salı, 2 = Çarşamba, ...).

    Biz date nesnesinin içerisindeki tarih bileşenlerini nesnenin day, month ve year özniteliklerinden istersek geri alabiliriz. 

#------------------------------------------------------------------------------------------------------------------------

import datetime

d = datetime.date(2022, 9, 14)

print(d)
print(d.day, d.month, d.year)

days = ['Pazartesi', 'Salı', 'Çarşamba', 'Perşembe', 'Cuma', 'Cumartesi', 'Pazar']
print(days[d.weekday()])

#------------------------------------------------------------------------------------------------------------------------
    Şimdi karmaşık sayıyı temsil eden Complex sınıfına add ve sub metotlarını ekleyelim. 
#------------------------------------------------------------------------------------------------------------------------

class Complex:
    def __init__(self, real, imag):
        self.real = real
        self.imag = imag
        
    def disp(self):
        print(f'{self.real}+{self.imag}i')
        
    def add(self, z):
        real = self.real + z.real
        imag = self.imag + z.imag
        
        result = Complex(real, imag)
        
        return result
    
    def sub(self, z):
        real = self.real - z.real
        imag = self.imag - z.imag
        
        result = Complex(real, imag)
        
        return result   
        
x = Complex(6, 5)
y = Complex(2, 3)

z = x.add(y)
z.disp()

z = x.sub(y)
z.disp()
        
#------------------------------------------------------------------------------------------------------------------------
    Aslında daha önce görmüş olduğumuz list, tuple, set, dict birer sınıftır. Zaten biz daha önce bu sınıflar türünden nesneler yaratıp
    onların metotlarını çağırarak faydalı işlemler yapmıştık. 
#------------------------------------------------------------------------------------------------------------------------

a = [1, 2, 3, 4, 5]

print(a)

a.pop(2)
print(a)

a.append(100)
print(a)

#------------------------------------------------------------------------------------------------------------------------
    Pekiyi bir metodun ilgili sınıf türünden bir değişkenle çağrılmasının anlamı nedir? İşte örneğin x.foo() gibi bir çağrı
    foo metodunun x değişkeninin gösterdiği yerdeki nesne üzerinde (kısaca buna x nesnesi üzerinde) işlem yapacağı anlamına gelir. 
    Yani metotlar spesifik bir nesne üzerinde işlem yaparlar. Bu nedenle bir nesne ile çağrılırlar. Yani biz bir metodu hangi nesneyle çağırırsak
    o metot aslında o nesnenin elemanları yani öznitelikleri üzerinde işlem yapar. 
#------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------
    Python'da "function overloading" ya da "method overloading" denilen özellik yoktur. Yani aynı isimli tek bir fonksiyon ya da 
    metot bulunabilir. Fakat istersek metotlarımızın parametre değişkenlerine default değerler verebiliriz. 
#------------------------------------------------------------------------------------------------------------------------

class Complex:
    def __init__(self, real = 0, imag = 0):
        self.real = real
        self.imag = imag
        
    def disp(self):
        print(f'{self.real}', end='')
        if self.imag != 0:
            print(f' + {self.imag}i')
        else:
            print()
              
x = Complex(6, 5)
y = Complex(6)        
z = Complex()

x.disp()            # 6+5i
y.disp()            # 6
z.disp()            # 0

#------------------------------------------------------------------------------------------------------------------------
    Sınıflar "değiştirilebilir (mutable)" türlerdir. Yani bir sınıfın örnek özniteliklerini biz değiştirebiliriz. Örneğin:

    class Sample:
        pass

    s = Sample()
    s.a = 10
    s.b = 20
    s.a = 30            # s.a'yı değiştirdik

#------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------
    Sınıfların metotları alternatif biçimde sınıf ismi ile de çağrılabilmektedir. Ancak bu çağrı biçiminde self parametresini 
    açıkça argüman olarak geçirmek gerekir. Örneğin:

    class Sample:
        def foo(self):
            print('foo')
            
        def bar(self, a):
            print(f'bar: {a}')
                    
    s = Sample()

    s.foo()
    s.bar(10)

    Sample.foo(s)
    Sample.bar(s, 10)

    Burada örneğin s.foo() çağrısı ile Sample.foo(s) çağrısı tamamen eşdeğerdir. Ancak birinci çağrı yani s.foo() çağrısı 
    tercih edilmelidir. 
#------------------------------------------------------------------------------------------------------------------------

class Sample:
    def foo(self):
        print('foo')
        
    def bar(self, a):
        print(f'bar: {a}')
                
s = Sample()

s.foo()
s.bar(10)

Sample.foo(s)
Sample.bar(s, 10)

#------------------------------------------------------------------------------------------------------------------------
    Tabii alternatif sentaksı biz diğer built-inm sınıflarda da kullanabiliriz. 
#------------------------------------------------------------------------------------------------------------------------

a = [1, 2, 3, 4, 5]
print(a)

list.append(a, 10)      # a.append(10)
list.append(a, 20)      # a.append(20

print(a)

#------------------------------------------------------------------------------------------------------------------------
    Biz "bir nesnenenin öznteliği" demekle nesnenin elemanlarını kastetmekteyiz. "Nesnenin özniteliği" ile "sınıfın örnek özniteliği"
    aynı anlamdadır. Nesnenin özniteliklerine İngilizce "instance attribute" denilmektedir. Ancak Pyton'da bir "sınıf öznitelikleri (class attribute)"
    denilen bir kavram vardır. Biz "sınıf özniteliği" yerine bazen "sınıf değişkenleri" de diyeceğiz. 

    Anımsanacağı gibi bir değişken tüm fonksiyonların dışında yaratılmışsa ona "global değişken" diyorduk. Bir fonksiyonun ya da metodun 
    içerisinde yaratılmışsa ona "yerel değişken" diyorduk. İşte bir değişken bir sınıfın içerisinde de yaratılabilir. Örneğin:

    x = 10          # x global bir değişken

    def foo():
        y = 20      # y yerel bir değişken 

    class Sample:
        z = 30      # z sınıf değişkeni (sınıfın özniteliği)

    s = Sample()
    s.a = 10        # a örnek özniteliği        
    
#------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------
    Bir sınıfın öznitelikleri sınıfın içerisinde doğrudan ismiyle kullanılabilir. Ancak sınıfın dışından ve sınıfın metotları içerisinden 
    ancak sınıf ismi ve nokta operatörü ile niteliklendirilerek kullanılabilmektedir.  Örneğin:

    class Sample:
        x = 10
        
        def foo():
            print(Sample.x)     # metot içerisinden x'i doğrudan kullanamayız, sınıf ismiyle kullanmalıyız
        
        print(x)                # doğrudan kullanılabilir
        
    print(Sample.x)             # dışarıdan x'i doğrudan kullanamayız sınıf ismiyle kullanmalıyız

#------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------
    Aslında Python'da sınıflar birer deyim statüsündedir. Yani sınıfların içerisindeki kodlar da çalıştırılmaktadır. 
    Örneğin:

    class Sample:
        print('Sample')         # Sample
        
        x = 10
        
        print(x)                # 10
    
    Burada Sample sınıfının içi de sanki programın bir parçasıylmış gibi çalıştırılacak ve biz de ekransa "Sample" yazısıyla 
    "10" yazısını göreceğiz. C++, Java, C# gibi dillerde sınıfların birer deyim statüsünde olmadığına dikkat ediniz. 
#------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------
    Anımsanacağı gibi fonksiyon tanımlama işlemi de aslında Python'da bir deyim statüsündeydi. Yorumlayıcı bir fonksiyonun 
    tanımlandığını gördüğünde bir fonksiyon nesnesi yaratıyordu. Fonksiyonun iç kodlarını o nesnenin içerisine yerleştiriyordu. 
    Sonra da bu nesnenin adresini fonksiyon ismi olan değişkene atıyordu. 

    Aslında sınıfın metotları da deyim statüsündedir. Bir fonksiyon için yapılanların aynısı metotlar için de yapılır. Bu durumda 
    metot isimleri aslında sınıf değişkenleri gibidir. Başka bir deyişle sınıfın özniteliği durumundadır. Örneğin:

    class Sample:
        x = 10

        def foo(self):
            pass

    Burada teknik olarak x de foo da bu sınıfın birer değişkenidir. Biz sınıf değişkenlerini dışarıdan sınıf ismi ile kullanabiliyorduk. 
    İşte zaten metodun alternatif çağrımı bu yüzden geçerlidir. Örneğin:

    Sample.x = 20           # geçerli

    s = Sample()
    Sample.foo(s)           # geçerli
#------------------------------------------------------------------------------------------------------------------------

class Sample:   
    x = 10
    
    def foo(self):
        pass
    
print(type(Sample.x))       # <class 'int'>
print(type(Sample.foo))     # <class 'function'>

#------------------------------------------------------------------------------------------------------------------------
    Aslında Python'da sınıfın öznitelikleri (yani sınıf değişkenleri) dışarıdan sınıf ismiyle kullanılabildiği gibi o sınıf türünden 
    bir değişkenle de kullanılabilmektedir. Sınıf değişkenlerinin sınıf türünden değişkenlerle kullanılması yanlış anlaşılmalara yol açtığı 
    için pek tavsiye edilmemektedir. Örneğin:

    class Sample:   
        x = 10
        
        def foo(self):
            pass
        
    s = Sample()

    s.foo()
    Sample.foo(s)

    print(s.x)              # geçerli ama yanlış anlaşılabilir!
    print(Sample.x)         # tavsiye edilen biçim 

    Tabii hem nesnenin hem de sınıfın aynı isimli öznitelikleri olabilir. Bu durumda sınıf türünden değişkenler nokta operatörü kullanılarak bu değişkene
    erişildiğinde nesnenin özniteliği anlaşılır. (Tabii nesnenin özniteliği olmasaydı sınıfın özniteliği anlaşılacaktı.) Örneğin:

    class Sample:   
        def __init__(self):
            self.x = 100
            
        x = 10
        
        def foo(self):
            pass
        
    s = Sample()

    print(s.x)              # 100
    print(Sample.x)         # 10

    Sınıf değişkenleri C++, Java ve C# gibi dillerdeki sınıfın static elemanlarına benzemektedir. Ancak o dillerde sınıfın metotları
    içerisinde sınııfn static elemanları doğrudan kullanılabilmektedir. Oysa Python'da sınıf değişkenleri bir metot içerisinde doğrudan 
    kullanılamaz. Sınıf değişkenleri ya sınıf ismiyle ya da self paraemtresi yoluyla kullanılmak zorundadır.

#------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------
                                                    42.Ders 21/09/2022 - Çarşamba
#------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------
    Sınıfların birer deyim statüsünde olduğunu daha önce belirtmiştik. Python yorumlayıcısı bir sınıf ile karşılaştığında
    type isimli bir sınıf türünden nesne yaratır. Sınıfın bilgilerini bu nesnenin içerisine yerleştirir. Bu nesnenin adresini de 
    sınıf ismi ile belirtilen değişkene atar. Yani sınıf isimleri aslında sıradan birer değişkendir. Sınıf isimleri type türünden bir nesnesyi
    gösterirler. Bu nesnenin içerisinde de sınıfın bilgileri vardır. Ancak sınıflar türünden de nesneler yaratılabilmektedir. Sınıflar türünden
    yaratılan nesneler o sınıf türünden olur. Örneğin:

    class Sample:
        pass

    print(type(Sample))     # <class 'type'>

    s = Sample()
    print(type(s))          # <class '__main__.Sample'>

#------------------------------------------------------------------------------------------------------------------------

class Sample:
    pass

print(type(Sample))     # <class 'type'>

s = Sample()
print(type(s))          # <class '__main__.Sample'>

#------------------------------------------------------------------------------------------------------------------------
    type sınıfı gibi bir sınıfın bilgilerini tutan sınıflara Python dünyasında "meta sınıflar (meta classes)" denilmektedir. 
    type bir meta sınıftır. Aslında biz de hiç class bildirimi yapmadan doğrudan type sınıfının __init__ metodu yoluyla bir sınıf 
    oluşturabiliriz. Örneğin:

    class Sample:
        pass

    Bu işlemin tamamen eşdeğeri şöyledir:

    Sample = type('Sample', (), {})

    Aslında bir değişkenin türünü elde etmek için kullandığımız type fonksiyonu da aynı fonksiyondur. type fonksiyonun 
    tek parametreli özel kullanımı yeni bir type nesnesi yaratmaz bize değişkenin ilişkin olduğu sınıfın type nesnesini verir. 

    Mademki sınıf isimleri aslında sıradan birer değişkendir. O zaman o değişken başka değişkenlere atanabilir. Örneğin:

    class Sample:
        pass

    Mample = Sample

    Burada Sample değişkeni ile Mample değişkeni aynı type nesnesini görmektedir. O halde biz her iki ismi de aynı sınıf türünden nesne 
    yaratmakta kullanabiliriz. Örneğin:
    
    x = Sample()
    y = Mample()

    print(type(x))          # __main__.Sample  
    print(type(y))          # __main__.Sample

    type fonksiyonun da tek parametreli kullanımının aslında değişkenin type nesne adresini verdiğine dikkat ediniz. Yani type fonksiyonunun 
    tek parametreli kullanımı bize bir yazı vermemektedir, type nesnesi vermektedir. Çıkan yazı type nesnesi yazdırılmaya çalışıldığında
    çıkan yazıdır. Örneğin:

    class Sample:
        pass

    s = Sample()

    X = type(s)

    x = X()
    y = Sample()

    print(type(x))  # <class '__main__.Sample'>
    print(type(y))  # <class '__main__.Sample'>

    Başka bir deyişle type(x) gibi bir çağrıda aslında type fonksiyonu x değişkenin ilişkin olduğu sınıfın type nesne adresini 
    bize vermektedir. 

    Python'da meta sınıflar nispeten ileri bir konudur. Biz kursumuzda meta sınıfları uygulama konuları içerisinde ele alacağız. 
#------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------
    O halde bir sınıf nedir? Bir sınıf "belli bir konuda işlemler yapan metotlardan ve bu metotların ortak kullandığı nesne 
    özniteliklerinden oluşan bir veri yapısıdır." Sınıflar sayesinde birbirlerinden kopu izlenim veren fonksiyonlar mantıksal bir 
    bağ içerisinde bir araya getirilmiş ve algısal kolaylıklar sağlanmıştır. Prosedürel teknikte her şey fonksiyonlarla yapılmaktadır. 
    Elimizde sanki birbirlerinden bağımsız olan pek çok fonksiyon var gibidir. Nesne yönelimli teknikte bir konuya ilişkin fonksiyonlar
    metot adı altında bir sınıfın içerisine yerleştirilir. Böylece "çok fazla fonksiyon var" duygusu yerine "şu sınıf bunu yapar, 
    bu sınıf şunu yapar" biçiminde algısal kolaylık sağlanmış olur. 

    Python "multiparadigm" bir dildir. Programcı isterse Python'ın sınıf özelliklerini hiç kullanmadan prosedürel teknikle 
    program yazabilir. Ya da isterse sınıflar oluşturarak program yazabilir. Ya da her iki tekniği bir arada kullanabilir. 
    Python'ın standart kütüphanesinde hem fonksiyonlar hem de sınıflar bulunmaktadır. 
#------------------------------------------------------------------------------------------------------------------------

class Worker:
    def __init__(self, name, department, shift):
        self.name = name
        self.department = department
        self.shift = shift
        
    def disp(self):
        print(self.name, self.department, self.shift)
        
w = Worker('Ali Serçe', 'Üretim', 'Sabah')
k = Worker('Necati Ergin', 'Kalite', 'Öğle')

w.disp()
k.disp()

#------------------------------------------------------------------------------------------------------------------------
    Aslında Python'da sınıflar minimalist biçimde tasarlanmıştır. Yani C++, Java ve C# gibi dillere kıyasla Python'daki sınıfların
    çok detayları yoktur. Bu nedenle Pyton'daki sınıfsal özellikleri C++, Java ve C# gibi dillerle karşılaştırmamak gerekir. 
#------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------
    Ağaç, kedi, okul, öğrenci gibi sözcüklerin hepsi birer kavram belirtmektedir. Kavramlar gerçek nesneler değildir. Bir grup nesnenin
    ortak özelliklerinden hareketle uyduurlmuş zihinsel temsillerdir. Aslında dünyada ağaç diye bir şey yoktur. Somut ağaçlar vardır. 
    Ağaç bizim biribirine benzeyen bir grup nesne için uydurduğumuz bir temsildir. Ağaç bir kavramdır ancak evimizin önündeki ağaç 
    o kavramdan bir örnektir (instance). İşte NYPT'de sınıflar kavramları belirtir. Sınıflar türünden nesneler de gerçek nesneleri belirtir. 

    O halde bir proje nesne yönelimli olarak modellenecekse önce proje içerisindeki bütün kavramlar sınıflarla temsil edilmeli ve sonra da
    bu sınıflar türündne nesneler yaratılarak örnekler oluşturulmalıdır. Örneğin bir hastane otomasyonu için gerekli kavramların bazıları şunlardır:
    Hastane, doktor, hasta, hastalık, hasta oadaları, hemşire, ilaç. İşte bizim bu sınıfları yazmamız gerekir. Sonra örneğin hastanemizde 10 tane 
    doktor varsa Doktor sınıfından 10 tane nesne yaratmalıyız. 5 tane hemşire için Hemşire sınıfından 5 nesne yaratırız. Programı nesnleer ile
    bu sınıfların metotlarını çağırarak yazarız. 

#------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------
    Tabii bir projedeki sınıflar arasında da birtakım ilişkiler söz konusu olmaktadır. Örneğin Hastane sınıfı ile Doktor sınıfı arasında
    bir ilişki vardır. Doktor ile Hasta sınıfları arasında da bir ilişki vardır. 

    NYPT'de sınıflararası ilişkiler dört başlıkta ele alınmaktadır:

    1) İçerme İlişkisi (Composition)
    2) Birleşme İlişkisi (Aggregation)
    3) Türetme İlişkisi (Inheritance)
    4) Çağrışım İlişkisi (Association)

#------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------
    Bir sınıf türünden bir nesne başka bir sınıf türünden bir nesnenin bir parçasını oluşturuyorsa bu iki sınıf arasında 
    "içerme (composition)" ilişkisi vardır. Örneğin "insan" ile "karaciğer" sınıfları arasında, "araba" ile "motor" sınıfları 
    arasında bu biçimde içerme ilişkisi vardır. İki sınıf arasında içerme ilişkisi olması için aşağıdaki iki özelliğin ikisin de sağlanması gerekir:

    1) İçeren nesneyle içerilen nesnenin ömürleri aynı olmalıdır. 
    2) İçerilen nesne tek bir nesne tarafından içerilmelidir. 

    Bu durumda örneğin "hastane" sınıfı ile "doktor" sınıfı arasında içerme ilişkisi yoktur. Çünkü bunların ömürleri aynı değildir. Bir doktor
    aynı anda birden fazla hastanede de çalışabilmektedir. Ancak "saat" ile "akrep" arasında, "dünya" ile "kıtalar" arasında, 
    "cep telefonu" ile "işlemcisi" arasında içerme ilişkisi vardır. "Oda" ile "duvar" arasında içerme ilişkisi yoktur. Her ne kadar oda ile
    duvar aynı ömre sahipse de duvar aynı zamanda yan odanın da duvarıdır. Tabii yukarıda belirttiğimiz iki özellik "tipik durumlar" dikkate alınarak
    değerlendirilmelidir. İnsan öldükten sonra karaciğeri organ nakli yoluyla yaşayabilir. Yapışık ikizler bazı organları ortak kullanıyor da olabilir. 
    Ancak bu durumlar t,pk değil istisnai durumlardır. 

    UML (Unfied Modeling Language) bir projeyi nesne yönelimli olarak modelleme kiçin kullanılan diyagramlardan oluşan bir dildir. 
    Diyagramlardan biri de "sınıf diyagramları (class diagrams)" denilen diyagramlardır. Burada projedeki sınıflar ve onların arasındaki ilişkiler
    betimlenmektedir. UML sınıf diyagramlarına içerme ilişkisi "içeren sınıf tarafında içi dolu bir baklavacık (diamond)" ,le temsil edilmektedir. 

    İçerme ilişkisine İngilizce "has a" ilişkisi de denilmektedir. İçerme ilişkisi 1'e 1 olabileceği gibi 1'e N de olabilir. 
    Örneğin "insan" sınıfı ile "böbrek" sınıfı arasında içerme ilişkisi vardır. Ancak bu ilişkisi 1'e 2'dir. Yani bir tane insan 
    iki böbreğe sahiptir. UML sınıf diyagramlarında bu durum da belirtilmektedir. Satranç tahtası ile tahtanın kareleri arasında 
    1'e 64 olan bir içerme ilişkisi vardır. 

#------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------
    Python'da içerme ilişkisi içeren sınıfın __init__ metodunda içerilen nesnenin yaratılarak içeren sınıfın örnek özniteliğinde tutulması yoluyla sağlanabilir. 
    Örneğin:

    class Araba:
        def __init__(self):
            self.motor = Motor()
            #...
            
    class Motor:
        pass

    a = Araba()

    Burada Araba sınıfı türünden nesne yaratıldığında Motor nesnesi de yaratılır ve araba nesnesi motor nesnesine sahip olur (has a ilişkisi). Örneğin:

    class Board:
        def __init__(self):
            self.squares = [[Square() for _ in range(8)] for _ in range(8)]
            
    class Square:
        pass

    board = Board()

    Burada Board sınıfı Square sınıfını içermektedir. Ancak 1 Board nesnesi 64 tane Square nesnesini içerir. 
#------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------
    Birleşme ilişkisinde (aggregation) bir sınıf türünden nesne başka bir sınıf türünden nesneyi kullanmaktadır. Ancak kullanılan nesne
    tek bir nesne tarafından kullanılmak zorunda değildir. Kullanan nesneyle kullanılan nesnenin ömürleri de aynı olmak zorunda değildir. 
    Bu nesnelerin sınıfları arasında "birleşme" ilişkisi vardır. Aslında genel olarak "içerme" ilişkisine benzeyen ancak 
    içerme ilişkisi olmayan iişkiler "birleşme ilişkisidir. Örneğin "hstane" ile "doktor" sınıfları arasında, "bilgisayar" ile "fare" sınıfları 
    arasında "oda" ile "duvar" sınıfları arasında içerme ilişkisi yoktur, birleşme ilişkisi vardır. 

    UML sınıf diyagramlarında birleşme ilişkisi "kullanan sınıf tarafından içi boş bir baklavacık (diamond)" ile temsil edilmektedir. 
    Yine birleşme ilişkisi 1'e 1 olabileceği gibi 1'e N olabilmektedir. Birleşme ilişkisine İngilizce "holds a" ilişkisi de denilmektedir. 
#------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------
    Python'da birleşme ilişkisi kullanan sınıfta kullanılan nesneyi geçici olarak tutma yoluyla sağlanabilir. Yani birleşme ilişkisinde 
    kullanılacak nesnenin kulalna nesneye dahil edilmesi ve çıkartılması gibi işlemler söz konusu olmaktadır. Örneğin:

    class Hospital:
        def __init__(self, name):
            self.name = name
            self.doctors = []
        
        def add_doctor(self, doctor):
            self.doctors.append(doctor)
            
        def remove_doctor(self, doctor):
            self.doctors.remove(doctor)
            
    class Doctor:
        def __init__(self, name, specialty):
            self.name = name
            self.specialty = specialty
        
    h1 = Hospital('A')
    h2 = Hospital('B')
    #...
    d1 = Doctor('Ali', 'Kulak Burun')
    #...
    h1.add_doctor(d1)
    #...
    h2.add_doctor(d1)

    Burada bir Hospital nesnesi birden fazla Doctor nesnesini kullanabildiği gibi bir Doctor nesnesi de birden fazla hastane tarafından 
    kullanılabilmektedir. Hospital nesnesinin ve Doctor nesnelerinin ömürlerinin farklı olabildiğine dikkat ediniz. 
#------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------
                                                    43. Ders 26/09/2022 Pazartesi
#------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------
    Sınıflar arasındaki diğer bir ilişki biçimi de "türetme" ilişkisidir. Türetme ilişkisine İngilizce  "inheritance" yani 
    "kalıtım" da denilmektedir. Türetme mevcut bir sınıfa dokunmadan onu genişletme anlamına gelir. Burada asıl sınıfa "taban sınıf (base class)",
    genişletilmiş olan sınıfa da "türemiş sınıf (derived class)" denilmektedir. Türetmede türemiş sınıf tamamen taban sınıf gibi de işlem görür 
    ancak fazlalıkları da vardır. UML sınıf diyagramlarında türetme ilişkisi türemiş sınıftan taban sınıfa doğru çekilen içi boş 
    bir okla gösterilmektedir. Türem,ş sınıftan yeniden türetme yapılabilir. Böylece bir dizi türetme söz konusu olabilir. 

    Türetme işleminin en önemlşi faydası tekrarı engellemektir. Prosedürel teknikte tekrarın engellenmesi için tekrar eden kodun 
    fonksiyon biçiminde ifade edilmesi gerekir. Ancak nesne yönelimli teknikte tekrar eden metotlar ortak taban sınıflarda bulundurularak tekrar engellenir. 
    Örneğin B sınıfında foo, bar ve tar metotları bulunyor olsun. C sınıfında da foo, bar ve zar metotlarının bulunduğunu kabul edelim.
    Burada foo ve bar ortak metotlardır ve tekrar etmektedirler. İşte biz foo ve bar metotlarını A gibi bir taban snıfta toplayıp
    B'yi ve C'yi A'dan türetebiliriz. Böylece B'de yalnızca tar, C'de de yalnızca zar bulunmuş olur. 

    Bir türetme şemasında yukarıya çıktıkça genelleşme, aşağıya indikçe özelleşme olur. Yani yukarıdaki sınıflar diğer sınıflarda olan 
    ortak özellikleri barındırır. NYPT'de türetme ilişkisine İngilizce "is a" ilişkisi de denilmektedir. Örneğin "işçi bir çalışandır". O zaman
    İşçi sınıfı Çalışan sınıfından türetilebilir. 

    Bir sınıfın birden fazla fazla sınıfa taban sınıflık yapması tamamen normal bir durumdur. Ancak bir sınıfın birden fazla taban sınıfa 
    sahip olması durumu özel bir durumdur. Buna NYPT'de "çoklu türetme (multiple inheritance)" denilmektedir. Doğada çoklu türetme az olmasına karşın
    karşılaşılmaktadır.

#------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------
    Sınıflararası son ilişki biçimine "çağrışım ilişkisi (association)" denilmektedir. Çağrışım ilişkisinde bri sınıf nesnesi
    başka bir nesneyi kullanır. Ancak bu kullanma yüzeyseldir. Bünyesine katarak bir kullanma değildir. Örneğin Taksi sınıfı Müşteriyi kullanır.
    Ancak Taksi ile Şoför arasındaki ilişki birleşme ilişkisiyken Taksi ile Müşteri arasındaki ilişki çağrışım ilişkisidir. 
    Çağrışım ilişkisi UML sınıf diyagramlarında kullanan sınıftan kullanılan sınıfa çekilen ince bir ok ile temsil edilir. 
#------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------
    Python'da türetme sentaksının genel biçimi şöyledir:

    class <türemiş sınıf ismi>(<taban sınıf listesi>):
        pass

    Örneğin:

    class A:
        pass

    class B(A):
        pass

#------------------------------------------------------------------------------------------------------------------------

class A:
    def foo(self):
        print('A.foo')
    
    def bar(self):
        print('A.bar')
        
class B(A):
    def tar(self):
        print('B.tar')
        
b = B()

b.foo()
b.bar()
b.tar()

#------------------------------------------------------------------------------------------------------------------------
    Türetme ilişkisinde türemiş sınıf taban sınıfı kullanmaktadır. Taban sınıf türemiş sınıfı kullanmamaktadır. 
#------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------
    Anımsanacağı gibi nesnelerin öznitelikleri tipik olarak __init__ metotlarında yaratılmaktadır. Türemişl sınıf türünden 
    bir nesne yaratıldığında türemiş sınıfın __init__ metodu çağrılır. Bu durumda bu türemiş sınıf türünden nesneyle taban sınıf 
    metodu çağrıldığında taban sınıf metodu taban sınıfın __init__ metodunda yaratılacak olan öznitelikleri kullanıyorsa sorun oluşacaktır. 
    Çünkü bu öznitelikler henüz yaratılmamış olacaktır. Örneğin:

    class A:
        def __init__(self):
            self.a = 10
            
        def dispA(self):
            print(self.a)
            
    class B(A):
        def __init__(self):
            self.b = 20

    a = A()
    a.dispA()       # sorun yok

    b = B()
    b.dispA()       # sorun var! Nesnenin a özniteliği yaratılmamış!

    Buradaki sorun türemiş sınıfın __init__ metodunun taban sınıfın __init__ metodunu çağırmamasındna kaynaklanmaktadır. C++, Java ve C# 
    gibi dillerde türemiş sınıfların "constructor" denilen metotları taban sınıfın "constructor" metotlarını zaten otomatik çağırmaktadır. 
    Ancak Python'da böyle bir otomatik çağırma yoktur. Yani Python'da türemiş sınıfın __init__ metodunun taban sınıfın __init__metodunu açıkça 
    çağırması gerekir. Pekiyi bu nasıl yapılacaktır. Çağrı aşağıdaki gibi yapılamaz:

    class A:
        def __init__(self):
            self.a = 10
            
        def dispA(self):
            print(self.a)
            
    class B(A):
        def __init__(self):
            self.__init__()         # dikkat metot kendi kendisini çağırıyor!
            self.b = 20

    b = B()
    b.dispA()      

    Burada B sınıfının __init__ metodu yine kendisini çağırmaktadır. Çağırmanın açıkça taban sınıf ismi belirtilerek yapılması gerekir:

    class A:
        def __init__(self):
            self.a = 10
            
        def dispA(self):
            print(self.a)
            
    class B(A):
        def __init__(self):
            A.__init__(self)        # açıkça A'nın __init__ metodunun çağrıldığı anlaşılıyor
            self.b = 20

    b = B()
    b.dispA()       # geçerli, sorun yok

    Pekiyi türemiş sınıfın __init__ metodu taban sınıfın __init__ metdounu nerede çağırmalıdır? İşte en normal olan ve uygun durum türemiş sınıfın __init__ 
    metodunun taban sınıfın __init__ metodunu hemen türemiş sınıfın __init__ metdounun başında çağırmasıdır. Çünkü önce nesnenin taban sınıf kısmının 
    ilkdeğer alması normal olan durumdur. Ne de olsa türemiş sınıf taban sınıfı kullanabilmektedir. 

#------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------
    Bir sınıfın "taban sınıfları (base classes)" denildiğinde onun yukarıya doğru tüm taban sınıfları anlaşılır. Ancak sınıfın 
    "doğrudan taban sınıfları (direct base classes)" sınıfın hemen bir yukarısındakiş taban sınıflar anlaşılır. Sınıfın 
    "dloaylı taban sınıfları (indirect base classes)" sınıfın doğurdan taban sınıflarının taban sınıflarıdır. Örneğin aşağıdaki
    gibi bir türetme şeması olsun:

   A
   B
   C
   D

   Burada D'nin taban sınıfları C, B ve A'dır. D'nin doğrudan taban sınıfı C'dir. D'nin dolaylı taban sınıfları A ve B'dir.
#------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------
    Türemiş sınıfın taban sınıfn __init__ metodunu çağırması gerektiğini belirtmiştik. İşte türemiş sınıflar tüm btaban sınıfların __init__
    metotlarını çağırmamalıdır. Yalnızca doğrudan taban sınıfların __init__ metotlarını çağırmalıdırlar. Zaten her sınıf kendi doğrudan 
    taban sınıflarının __init__ metotlarını çağırınca tüm taban sınıfların __init metotları çağrılmış olur. Örneğin:

    class A:
        def __init__(self):
            pass

    class B(A):
        def __init__(self):
            A.__init__(self)
            pass

    class C(B):
        def __init__(self):
            B.__init__(self)
            pass

    c = C()

    Burada C sınıfı türünden bir nesne yaratıldığında aslında A, B, C sırasına göre sınıfların __init__ metotları çağrılacaktır.
#------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------
    Taban sınıfla türemiş sınıf aynı isimli metotlara sahip olabilir. Bu durumda bu metotlar hangi sınıf türünden nesneyle çağrılmışsa
    o sınıfın aynı isimli metodu çağrılmış olur. Örneğin:

    class A:
        def foo(self):
            print('A.foo')
            
    class B(A):
        def foo(self):
            print('B.foo')
            
    b = B()
    b.foo()     # b nesnesi B sınıfı türündne olduğu için B.foo çağrılır

    a = A()
    a.foo()     # A.foo çağrılır, zaten taban sınıf türemiş sınıfa erişemez!

    Yabii türemiş sınıfın bir metodunda taban sınııfn aynı isimli metodu çağrılacaksa burada açıkça taban sınıf ismi belirtilmelidir. 
    Örneğin:

    class A:
        def foo(self):
            print('A.foo')
            
    class B(A):
        def foo(self):
            A.foo(self)     # açıkça belirtilmeli
            print('B.foo')
            
    b = B()
    b.foo()     # b nesnesi B sınıfı türündne olduğu için B.foo çağrılır

#------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------
    Yukarıda da belirtildiği gibi Python'da çoklu türetme vardır. Ancak Java ve C# gibi bazı dillerde çok türetme yapılamamaktadır. 
    C++'ta ve Object Pascal'da da çoklu türetme bulunmaktadır. Çoklu türetmede türemiş sınıf tüm taban sınıflarının metotlarını 
    kullanabilir. 
#------------------------------------------------------------------------------------------------------------------------

class A:
    def foo(self):
        print('A.foo')
        
class B:
    def bar(self):
        print('B.bar')
        
class C(A, B):
    def tar(self):
        print('C.tar')
        
c = C()

c.foo()
c.bar()
c.tar()

#------------------------------------------------------------------------------------------------------------------------
    Anımsanacağı gibi türemiş sınıfn __init__ metodunun kendi doğrudan taban sınıflarının __init__ metotlarını çağırması gerekiyordu. Çoklu türetmede
    türemiş sınıf bütün taban sınıflarının __init__ metotlarını çağırmalıdır. Örneğin:

    class A:
        def __init__(self):
            self.a = 10
            
        def dispA(self):
            print(self.a)
            
    class B:
        def __init__(self):
            self.b = 10
            
        def dispB(self):
            print(self.b)
            
    class C(A, B):
        def __init__(self):
            A.__init__(self)
            B.__init__(self)
            self.c = 30
            
        def dispC(self):
            print(self.c)
            
    c = C()

    c.dispA()
    c.dispB()
    c.dispC()
    
#------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------
    Çoklu türetmede baklava (diamond) biçiminde türetme şemasında her sınıfın kendi doğrudan taban sınıflarının __init__metotlarını çağırması önemli bir soruna yol açmaktadır. Aşağıda baklava biçiminde bir türetme şeması görüyorsunuz:

        A
    B       C
        D

    Burada her sınıfın __init__ metodu kendi doğrudan taban sınıfının __init__ metodunu çağırdığında A sınıfının __init__ metodu 
    iki kez çağrılmışç olur. Bir sınıfın __init__ metodunun iki kez çağrılması bazen sorunlarlara yol açmayabilir ancak bazen sorunlara 
    yol açabilir. Örneğin C++'ta burada A sınıfının constructor'ının iki kez çağrılmasının engellenmesi için "virtual base class" denilen 
    bir kavram uydurulmuştur.

    Aşağıdaki örnekte baklava şeklinde türetmeden A taban sınıfının __init__ metodu iki kere çağrılmıştır.
#------------------------------------------------------------------------------------------------------------------------

class A:
    def __init__(self):
        print('A.__init__')
            
class B(A):
    def __init__(self):
        A.__init__(self)
        print('B.__init__')
        
class C(A):
    def __init__(self):
        A.__init__(self)
        print('C.__init__')
        
class D(B, C):
    def __init__(self):
        B.__init__(self)
        C.__init__(self)
        print('D.__init__')
        
d = D()

#------------------------------------------------------------------------------------------------------------------------
                                            44. Ders 28/09/2022 - Çarşamba
#------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------
    Karmaşık türetme durumlarında taban sınıflarda aynı isimli elemanlar varsa isim araması kabaca aşağıdan yukarıya doğru yapılmaktadır.
    Ancak çoklu türetme söz konusu olduğunda bu durum o kadar açık olmayabilir. Örneğin:

    A     B
       C
       D

    Böyle bir türetme şemasında aşağıdakiş gibi bir foo metodu çağrılmış olsun:

    d = D()
    d.foo()

    Burada önce D sınıfına bakılacaktır. Çünkü meton çağrılmasında kullanılan nesne D sınıfı türündendir. Pekiyi D'de foo yoksa 
    ne lacaktır? Bu durumda C'ye bakılacaktır? Pekiyi ya C'de yoksa ne olacaktır? Örneğin:


     A     
     B     C
        D
        E

    Burada e.foo() çağrısı yapıldığını düşünelim. E'de ve D'de foo olmasaydı foo hangi sırada ve nerede aranacaktı? 

    İşte türetme durumunda sırasıyla bir ismin hangi sınıflarda aranacağını belirten sıraya "MRO (Member Resolution Order)" 
    denilmektedir. MRO sırası ilgili sınıfın __mro__ isimli sınıf değişkeni ile elde edilebilir. __mro__ elemanı bize type nesnelerinden 
    olulan bir demet verir. Arama işlemi sınıflarda bu demetle belirtilen sırada yapılır. 
#------------------------------------------------------------------------------------------------------------------------

class A:
    pass

class B(A):
    pass

class C:
    pass

class D(B, C):
    pass

class E(D):
    pass

print(E.__mro__)

#------------------------------------------------------------------------------------------------------------------------
    MRO sırası inspect modülündeki getmro fonksiyonuyla da elde edilebilir. Bu fonksiyona biz bir sınıf ismini (yani tytpe nesnesini veririz). Örneğin:

    import inspect

    t = inspect.getmro(E)
    print(t)

    Tabii getmro fonksiyonu şöyle yazılmıştır:

    def getmro(cls):
        return cls.__mro__

    Genel olarak MRO sırası şu biçimdedir: Eğer çoklu türetme yoksa aşağıdan yukarıya doğrudur. Çoklu türemte varsa soldan sağa taban sınıflarda
    bir kol bitirildikten sonra diğerine geçilecek biçimde bir sıra izlenir. Örneğin:

    A
    B      D
    C      E
        F
        G

    Burada G'nin MRO sırası şöyle olacaktır: G, F, C, B, A, E, D.

#------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------
    MRO sırası isim aramasında etkili olmaktadır. Bir sınıf türünden değişkenle ya da sınıf ismi kullanılarak nokta operatörü ile
    bir eleman belirtilirse bu elemanın sırasıyla türetme durumunda hangi sınıflarda aranacağına MRO sırası denilmektedir. Tabii isim 
    bulunursa arama devam etmez. Örneğin:

    A
    B      C
        D
        E

    e = E()
    s.foo()

    Burada foo'nun yalnızca A ve C sınıflarında bulunduğunu varsayalım. Çağrılan foo hangi foo'dur? İşte bu durum E'nin MRO 
    sırası ile ilgilidir. E'nin MRO sırası şöyledir: E, D, B, A, C. Bu şu anlama gelmektedir: "İSmi önce E'de ara, bulamazsan D'de ara, 
    bulamazsan B'de ara, bulamazsan A!da ara, bulamazsan C'de ara.
#------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------
    Tabii MRO sırasında asla bir sınıftan iki tane bulunmamaktadır? Pekiyi baklava şekline ilişkin türetmede MRO sırası nasıl olacaktır?
    Örneğin:

        A
    B       C
        D

    Burada D'nin MRO sırası şöyledir: D, B, C, A.

#------------------------------------------------------------------------------------------------------------------------

class A:
    pass

class B(A):
    pass

class C(A):
    pass

class D(B, C):
    pass

print(D.__mro__)

#------------------------------------------------------------------------------------------------------------------------
    Python'da "her şey bir çeşit nesne" olduğuna göre tüm sınıflar aslında doğrudan ya da dolaylı olarak object denilen bir sınıftan 
    türetilmiş durumdadır. Biz bir sınıfta taban sınıf belirtmezsek Python yorumlayıcısı onun object sınıftan türetildiğini varsayar. 
    Örneğin:

    class Sample:
        pass

    Burada Sample object sınıfından türetilmiştir. Tabii biz buna açıkça da belirtebilirdik:

    class Sample(object):
        pass

    Örneğin:

    class A:
        pass

    class B(A):
        pass

    Burada B sınıfı A'dan A sınıfı da object sınıfından türetilmiştir. İşte böyle yukarıya çıktığımızda her zaman tepede object sınıfıyla 
    karşılaşırız. Yani "her sınıf doğrudan ya da dolaylı olarak object sınıfından türetilmiş durumdadır. 

    Pekiyi object sınıfının içerisinde ne vardır? İşte object sınıfının içerisinde her nesne için geçerli olabilecek metotlar 
    bulunmaktadır. 
#------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------
    super isimli fonksiyon built-in bir fonksiyondur. super fonksiyonu aslında baklava şeklindeki türetmelerde __init__ 
    metotlarının aynı sınıf için ikinci kez çağrılmasını önlemek amacıyla düşünülmüştür. 

    super fonksiyonu tipik olarak iki argümanla çağrılır. Fonksiyonun birinci parametresi bir sınıf ismini (yani bir sınıfın type referansını alır), 
    ikinci parametresi o sınıf türünden bir değişkeni alır. super fonksiyonu bir "proxy" nesne geri döndürmektedir. super fonksiyonun 
    geri dönş değeri ile bir metot çağrılırsa sanki ikinci argümanla belirtilmiş değişkenle o metot çağrılmış etkisi oluşur. Örneğin:

    d = D()
    super(D, d).foo()

    Burada aslında oluşan etki d.foo() gibi bir etkidir. Ancak bu etki oluşturulurken isim araması d değişkenin ilşkin olduğu sınıfın MRO sırasnda 
    D sınıfından sonraki sınıftan başlatılmaktadır. Örneğin d değişkeninin ilişkin olduğiu sınıfın MRO sırası şöyle olsun: D, B, C, A, object. Burada super(D, d).foo() çağrısında arama B sınıfından başlatılacaktır. 

    Aşağıdaki örnekte super(B, b).foo() çağrısı aslında b.foo() çağrısı gibidir. Ancak arama b değişkeninin ilişkin olduğu sınıfın MRO sırasında B'den sonraki sınıftan yani A sınıfından başlatılır. Böylece A sınıfının foo metodu çağrılmış olur. 
#------------------------------------------------------------------------------------------------------------------------

class A:
    def foo(self):
        print('A.foo')
        
class B(A):
    def foo(self):
        print('B.foo')
        
b = B()

b.foo()                 # B.foo

super(B, b).foo()       # A.foo

#------------------------------------------------------------------------------------------------------------------------
    super fonksiyonu ne işe yaramaktadır? Kabaca elimizde bir sınıf türünden bir değişken varsa biz de bu değişkenle kendi sınıfımızın değil 
    taban sınıfın metodunu çağırmak istiyorsak super fonksiyonu kullanırız. Örneğin:

    class A:
        def foo(self):
            print('A.foo')
            
    class B(A):
        def foo(self):
            print('B.foo')

    b = B()

    Şimdi biz b.foo() biçiminde bir çağrı uyaparsak B sınıfının foo metodu çağrılır. Pekiyi biz B sınıfını bypass ederek A 
    sınıfının foo metodunu nasıl çağırmalıyız. Yöntemlerden biri şöyle olabilir:

    A.foo(b)

    Burada açıkça A sınıfının foo metodu b ile çağrılmıştır. Aynı şeyi super fonksiyonu ile de yapabilirdik:

    super(B, b).foo()

    super fonksiyonun birinci parametresi isim aramasının başlatılacağı sınıf üzerinde etkili olmaktadır. Şöyle ki: İsim araması 
    b değişkeninin ilişkin olduğu sınıfın MRO sırasında B sınıfından sonraki sınıflan yapılır. super fonksiyonun ikinci 
    parametresi çağrılacak metotta kullanılacak nesneyi ve aynı zamanda söz konusu MRO sırasının ilişkin olduğu sınıf belirtmektedir. 
    Şimdi C sınıfı B'den, B sınıfı da A'dan türetilmiş olsun:

    class A:
        def foo(self):
            print('A.foo')
            
    class B(A):
        def foo(self):
            print('B.foo')

    class C(B):
        def foo(self):
            print('C.foo')

    c = C()

    Burada c değişkeni ile A'nın foo'su şöyle çağrılabilir:
    
    super(B, c).foo()

    Burada c değişkeni C sınıfı türündendir. C'nin MRO sırası C, B, A biçimindedir. Bu durumda super(B, c).foo() çağrısında C'nin MRO sırasında B'den sonraki sınıfı 
    A'dır.

#------------------------------------------------------------------------------------------------------------------------

class A:
    def foo(self):
        print('A.foo')
        
class B(A):
    def foo(self):
        print('B.foo')

class C(B):
    def foo(self):
        print('C.foo')
        
c = C()
c.foo()                 # C.foo
super(C, c).foo()       # B.foo
super(B, c).foo()       # A.foo

#------------------------------------------------------------------------------------------------------------------------
    Pekiyi mademki aslında taban sınıf ismini belirterek taban sınıfını çağırabiliyoruz bu durumda super fonksiyonuna ne gerek vardır? Örneğin:

    class A:
        def foo(self):
            print('A.foo')
            
    class B(A):
        def foo(self):
            print('B.foo')

    class C(B):
        def foo(self):
            print('C.foo')
            
    c = C()

    B.foo(c)        # B.foo
    A.foo(c)        # A.foo

    İşte bu biçimde taban sınıf ismi ile çağrı yapıldığında MRO sırası dikkate alınmamaktadır. super fonksiyonu MRO sırasını dikkate 
    aldığı için önemli bir işleve sahiptir. 
#------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------
    Aslında super fonksiyonun en önemli faydası baklava şeklinde türetme durumunda taban sınıfın __init__ metodunun birden fazla kez çağrılmasını engellemek
    içindir. Anımsanacağı gibi super(X, r).foo() gibi bir çağırmada foo metodunun aranması r değişkeninin ilişkin olduğu sınıfın MRO sırasında 
    X sınıfından sonraki sınıftan başlatılmaktadır. O halde örneğin:

    class X(Y):
        def __init__(self):
            super(X, self).__init__()

    Burada self'in ilişkin olduğu sınıfın MRO sırasında X'ten sonraki sınıfan başlanarak __init__ metodu aranacaktır. 

    O halde baklava biçimindeki türetme şemasında "eğer her sınıfın __init__ metodunda birinci parametresi kendi sınıf ismi, ikinci parametresi 
    self olacak biçimde __init__ metodu çağrılırsa bu durumda baklava biçiminde türetme olsa bile tam istenilen durum elde edilmiş olur. Örneğin:

    class A:
        def __init__(self):
            print('A.__init__')


    class B(A):
        def __init__(self):
            super(B, self).__init__()   # D'nin MRO sırasında göre B'den sonraki sınıf C'dir
            print('B.__init__')

    class C(A):
        def __init__(self):
            super(C, self).__init__() # D'nin MRO sırasına göre C'den sonraki sınıf A'dır
            print('C.__init__')

    class D(B, C):
        def __init__(self):
            super(D, self).__init__()  # D'nin MRO sırasında D'den sonraki sınıf B'dir.
            print('D.__init__')

    d = D()

    Burada D'nin MRO sırtası D, B, C, A biçimindedir. O halde D() biçiminde nesne yaratıldığında D'nin __init__ metodundaki self 
    D sınıfı türündendir:

     class D(B, C):
        def __init__(self):
            super(D, self).__init__()  # D'nin MRO sırasında D'den sonraki sınıf B'dir, o halde B sınıfın __init__ metodu çağrılır
            print('D.__init__')

    Burada super(d, self).__init__ ile self D sınıfı türünden olduğu için ve D'nin MRO sırasında D'den sonra gelen sınıf B olduğu için B'nin__init__ 
    metodu çağrılacaktır B'nin __init__ metodu şöyledir:

     class B(A):
        def __init__(self):
            super(B, self).__init__()   # self hala D sınıfı türünden D'nin MRO sırasında göre B'den sonraki sınıf C'dir
            print('B.__init__')    


    Burada self yine D sınıfı türündendir. D'nin MRO sırasına göre B'den sonraki sınıf C olduğuna göre aslında super(Bi self).__init__
    çağrısı ile C sınıfının __init__ metodu çağırılır. C sınıfının __init__ metodu şöyledir:

    class C(A):
        def __init__(self):
            super(C, self).__init__() # self hala D türünden, D'nin MRO sırasına göre C'den sonraki sınıf A'dır
            print('C.__init__')

    Burada da self hala D türündendir. D'nin MRO sırasına göre C'den sonraki sınıf A olduğu için aslında A'nın __init__ metodu çağrılır. 

#------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------
    Yukarıdaki anlatımlşardan şu sonucu çıkartabiliriz: Biz her zaman taban sınıfın __init__ metodunu taban sınıf ismiyle değil 
    super fonksiyonuyla çağırmalıyız. Bu durumda baklava biçiminde bir türetme olsa bile her zaman taban sınıfların __init__
    metotları bir kez çağrılmış olur. Örneğin:

    class A:
        def __init__(self):
            pass

    class B(A):
        def __init__(self):
            super(B, self).__init__()

    Demek ki türetme durumlarında taban sınıfın __init__ metodunun super fonksiyonuyla çağrılması iyi bir tekniktir. 
    Çağırma şöyle yapılmalıdır:

    super(kendi_sınıfımızın_ismi, self).__init__(...)

#------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------
    Pekiyi türetme şemasının en yukarısında her zaman object sınıfı olduğuna göre biz object sınıfının da __init__ metodunu 
    çağırmalı mıyız? Örneğin:

    class Sample:
        def __init__(self):
            super(Sample, self).__init__()
            # ...

    object sınıfın __init__ metodunun içini boş sayabilirsiniz. Bu durumda programcının object sınıfının __init__ metodunu çağırması
    gerekmez. 

#------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------
    Biz yukarıda genel olarak türemiş sınıfın __init__ metodunun taban sınıfn __init__ metodunu super fonksiyonuyla çağırması 
    gerektiğini belirtmiştik. Sonra da taban object sınıfı için __init__ metodunun çağrılmasına gerek olmadığını da ifade etmiştik. 
    Pekiyi bu durumda aşağıdaki gibi bir çoklu türetmede ne olacaktır:

    A      B
        C

    Burada C'nin MRO sırası C, A, B biçimindedir. Burada eğer A'da A'nın object sınıfından türetilmiş olduğu fikriyle A'nın 
    __init__ metodunda super çağrısı yapılmazsa B'nin __init__ metodu çağrılmayacaktır. O zaman A sınıfını oluşturan kişi 
    object sınıfın __init__ metodunu super fonksiyonu ile çağırmalı mıdır? Örneğin:

    class A:
        def __init__(self):
            print('A.__init__')

    class B:
        def __init__(self):
            print('B.__init__')
            
    class C(B, A):
        def __init__(self):
            super(C, self).__init__()
            print('C.__init__')
            
    c = C()

    Burada C'nin MRO sırası C, A, B olduğu için C ve A'nin __init__ metotları çağrılacaktır ancak B'ninki çağrılmayacaktır. 
    Genellikle object sınıfından türetme yapıldığında (default durum) programcılar super çağrısıyla __init__ metotlarını çağırmazlar. Bu durumda da
    çoklu türetmede sorunlar çıkabilir. Pekiyi çözüm nedir?

    - Aslında bir sınıfı yazan kişi o sınıfın çoklu türetmede kullanılıp kullanılmayacağını belirleyip bunu dokümantasyonda belirtmelidir. 
    Eğer programcının sınıfı çoklu türetmeyi destekleyecekse sınıf object sınıfından türetilmiş olsa bile super çağrısıyla MRO sırasına 
    göre sıradaki sınıfın __init__ metoduu çağırmalıdır. Eğer sınıfı çoklu türetmeyi desteklemiyorsa bu durumda böyle bir çağrı yapmasına gerek yoktur. Örneğin:

    class A:
        def __init__(self):
            super(A, self).__init__()
            print('A.__init__')

    class B:
        def __init__(self):
            super(B, self).__init__()
            print('B.__init__')
            
    class C(A, B):
        def __init__(self):
            super(C, self).__init__()
            print('C.__init__')
            
    c = C()

    - Çoklu türetme yapacak kişi taban sınıflarının çoklu türetmeyi destekleyip desteklemediğine dikkat etmelidir. Eğer taban sınıfları çoklu türetmeyi desteklemiyorsa taban 
    sınıfın __init__ metodunu uper çağrısıyla değil isimsel olarak yapabilir. Tabii bu durumda baklava biçiminde türetme yapılmışsa yine sorun oluşabilecektir. 
    Örneğin:

    class A:
        def __init__(self):
            print('A.__init__')

    class B:
        def __init__(self):
            print('B.__init__')
            
    class C(A, B):
        def __init__(self):
            A.__init__(self)
            B.__init__(self)
            print('C.__init__')
            
    c = C()

    Eğer sınıfın dokümantasyonunda özellikle çoklu türetme desteği için bir şey söylenmemişse sınıfın çoklu türetmeyi desteklemediği 
    sonucu çıkartılmalıdır. 
#------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------
                                                        45. Ders 03/10/2022 - Pazartesi
#------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------
    Çoklu türetmede diğer bir sorun da çoklu türetilmiş sınıfın __init__ metotlarının MRO sırasına göre diğer sınıfların __init__
    metotlarına iletilmesidir. Burada genel uygulama çoklu türetmeyi destekleyen sınıfların __init__ metotlarının *args ve **kwargs
    parametrelerini bulundurmaları ve bu parametreleri *'lı bir biçimde super fonksiyonunda kullanmalarıdır. Böylece aktarım başaırıyla yapılabilmektedir. 
#------------------------------------------------------------------------------------------------------------------------

class A:
    def __init__(self, a, *args, **kwargs):
        super(A, self).__init__(*args, **kwargs)
        self.a = a
        print('A.__init__')

class B:
    def __init__(self, b, *args, **kwargs):
        super(B, self).__init__(*args, **kwargs)
        self.b = b
        print('B.__init__')
        
class C(A, B):
    def __init__(self, a, b, c):
        super(C, self).__init__(a, b)
        self.c = c
        
c = C(10, 20, 30)

print(c.a, c.b, c.c)

#------------------------------------------------------------------------------------------------------------------------
    super fonksiyonu parametresiz de kullanılabilir. Bu durumda fonksiyonun birinci parametresi içinde bulunulan sınıfının ismi 
    olarak, ikinci parametresi self olarak geçilmiş kabul edilir. Tabii bu kullanım yalnıcz metotlar içerisinde yapılabilir. ÖÇrneğin A 
    sınıfının __init__ metodunda şöyle bir çağırma yapılmış olsun:

    super().__init__()

    Bu çağrı şununla eşdeğerdir:

    super(A, self).__init__()
#------------------------------------------------------------------------------------------------------------------------

class A:
    def __init__(self):
        print('A.__init__')
        
class B(A):
    def __init__(self):
        super().__init__()      # super(B, self).__init__()
        print('B.__init__')
        
class C(B):
    def __init__(self):
        super().__init__()      # super(C, self).__init__()
        print('C.__init__')

c = C()

#------------------------------------------------------------------------------------------------------------------------
    NYPT'nin önemli bir prensibi "kapsülleme (encapsulation)" denilen prensiptir. Kapsülleme bir kavramın bir sınıfla temsil edilmesi 
    ve sınıfın dışarıya ilgilendirmeyen, iç işleyişe ilişkin olan öğelerinin dış dünyadan gizlenmesi anlamına gelmektedir. 
    Bu gizleme hem algısal bir açıklık sağlamakta hem de yanlış kullanımları engellemektedir. Aslında kapsülleme dış dünyada da sıklıkla
    karşılaştığımız bir olgudur. Örneğin bir otomobilin pek çok aksamı kaput içerisinde gizlenmiştir. Yalnızca kullanıcıyı ilgilendiren kısımları 
    görünür hale getirilmiştir. Bir televizyon için de aynı durum söz konusudur. Biz televizyonu kullanmak için onun karmaşık yapısını bilmemiz 
    gerekmemektedir. 
    
    C++, Java ve C# gibi dillerde kapsülleme için sınıfların "public", "private", "protected" gibi bölümleri vardır. Sınıfı yazan kişi birtakım
    elemanları private bölüme yerleştirire o öğelere dışarıdan erişilemez. Sınıfın veri elemanlarının dış dünyadan gizlenmesine ise 
    "veri elemanlarının gizlenmesi (data hiding)" prensibi denilmektedir. Sınıfın veri elemanları iç işleyişe ilişkindir. Bunun genellikle 
    programcılar bu dillerde olnları sınıfın private bölümüne yerleştireek dış dünyadan gizlerler. 

    Ancak Python'da bu anlamda bir gizleme mekanizması yoktur. Yani C++, Java ve C# gibi dillerdeki "public", "protected", private" kavramları 
    Python'da bulunmamaktadır. 
#------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------
    Python'da her ne kadar C++, 'java ve C# gibi dillerdeki sınıflarda bulunan "public", "private", "protcted" bölümler olmasa da
    bir sınıf elemanının ya da nesnenin özniteliğinin dış dünyadan gizlenmesi isimsel biçimde sağlanmaya çalışılmıştır. Öyle ki
    eğer bir sınıfın bir elemanının ya da nesnenin özniteliğinin ismi '_' ile başlatılırsa bu durum private etkisi yaratmaktadır. Ancak bu 
    etki yalnızca bir bilgi sağlamaktadır. Yorumlayıcı tarafından erişimde bir denetleme yapılmamaktadır. Başka bir deyişle biz Python'da
    sınıfın bir elemanının ya da bir nesnenin özniteliğinin '_' ile başladığını gördüğümüzde "bu elemanlara ya da özniteliklere 
    dışarıdan erişilmesinin istenmediği" anlamını çıkartmalıyız. Ancak yine de biz istersek bu elemanlara ya da özniteliklere erişebiliriz. 
    Burada bir zorlayıcılığın olmadığna yalnızca yazım biçiyle bir bilgi verildiğine dikkat ediniz. Örneğin:

    class Sample:
        def do_someting_important(self):
            # ....
            self._foo()
            # ....
            self._bar()
            # ....
            self._tar()
            #....
            
        def _foo(self):
            pass
        
        def _bar(self):
            pass
        
        def _tar(self):
            pass
        
    s = Sample()

    s.do_someting_important()

    Burada sınıfın _foo, _bar ve _tar metotlarının dışarıdan çağrılması istenmemektedir. Bu metotlar yalnızca sınıf içerisindeki diğer
    metotlardan çağrılmaktadır. Tabii biz istersek gerçekten istenmemesine karşın bu çağrıyı yapabiliriz:

    s._foo()

    Aynı durum nesnenin öznitelikleri için de geçerlidir. Örneğin:

    import math

    class Circle:
        def __init__(self, radius):
            self.radius = radius
            self._area = radius * radius * math.pi
        
        # ...

    c = Circle(10)

    print(c.radius)

    Burada sınıfın radius örnek özniteliğine dışarıdan erişebiliriz ancak _area örnek özniteliğine dışarıdan erişmemiz istenmemektedir. 
#------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------
    Sınıfın elemanlarının ve örnek özniteliklerinin dış dünyadan gizlenmesi için diğer bir yöntem de isimleirn başına '__' (iki alt tire)
    getirmektir. Bir isim iki alt tire ile başlanarak isimlendirilmesi "dışarıdan kullanımın daha katı bir biçimde istenmediği" anlamına 
    gelmektedir. İki alt tire ile verilen isimlere gerçekten dışarıdan erişilemez. Ancak _sınıf_ismi__ öneki erişilebilir. Yani başka bir deyişle
    Sample sınıfının  __xxx elemanına biz s.__xxx gibi bir ifadeyle erişemeyiz. Ancak s._Sample__xxx ismiyle erişebiliriz. Bunun amacı kişilerin 
    ilgili elemana yanlışlıkla erişmelerinin engellenmesidir. Mutlak anlamda erişmelerinin engellenmesi değildir. 
        
    Örneğin:

    class Sample:
        def do_someting_important(self):
            # ....
            self.__foo()
            # ....
            self.__bar()
            # ....
            self.__tar()
            #....
            
        def __foo(self):
            pass
        
        def __bar(self):
            pass
        
        def __tar(self):
            pass
        
    s = Sample()

    s.do_someting_important()
    s.__foo()               # error!


    Nesnenin özniteliğini iki alt tire ile başlatarak isimlendirirsek yine bu özniteliklere dışarıdan erişemeyiz. 
    Bunlara dışarıdan erişim yine _sınıfismi__ önekiyle yapılmaktadır. Örneğin:

    import math 

    class Circle:
        def __init__(self, radius):
            self.radius = radius
            self.__area = math.pi * radius * radius
            
        def disp(self):
            print(self.radius, self.__area)
        #...
        
    c = Circle(1)

    print(c._Circle__area)      # geçerli
    print(c.__area)             #error!

    Başka bir deyişle biz sınıf içerisinde bir özniteliği ya da bir metodu iki alt tire ile isimlendirirsek aslında
    yorumlayıcı bu özniteliği ya da metodu _sınıfismi__ öneki ile isimlendirmektedir. Biz sınıf içerisinde iki alt tireli 
    isimlere iki alt tire ile erişebilmeteyiz. Ancak dışarıdan iki alt tire ile erişemeyiz. Dışarıdan ancak _sınıfismi__
    öneki ile erişebiliriz. 

    Ancak iki altireli bir örnek özniteliği sınıfın içerisinde değil de dışarıda oluşturulmuşsa bu durumda erişim iki alt tireli 
    isimle yapılabilmektedir. Örneğin:

    class Sample:
        def __init__(self):
            self.__a = 10

    s = Sample()
    s.__b = 20  
    print(s.__b)        # dışarıdan erişilebilir
    print(s.__a)        # dışarıdan erişilemez!

    İsimlerin önüne tek alt tire getirilmesine "Python Language Specification" dokümanında bir atıfta bulunulmamıştır. Ancak 
    isimlerin başına iki alt tire getirilmesi konusu yukarıdaki açıklandığı gibi "Python Language Specification" dokümanında (6.2.1)
    belirtilmektedir. 

    Sınıfların __xxx__ biçiminde isimlendirilmiş elemanlarında "dunder" elemanlar dendiğini belirtmiştik. Bu dunder elemanlar semantik olarak 
    başı iki alt tire ile başlayan isimler gibi değerlendirilmemektedir. Yani iki alt tire ile başlayan isimlerin sonunda da iki alt tire varsa
    bu isimlere dılarıdan aynı biçimde erişilebilmektedir. 
#------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------
    Pekiyi biz dışarıdan kullanılmasını istemediğimiz isimlerin başına tek alt tire mi yoksa iki alt tire mi getirmeliyiz? 
    Bu durum tamamen bizim isteğimize bağlıdır. Eğer biz "dışarıdan erişme" fikrini vurgulamak istiyorsak ik alt tire kullanabiliriz. 
    Ancak programcıların çoğu tek alt tire kullanmaktadır. 
#------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------
    Pek çok teorisyene göre bir dilin "nesne yönelimli" olması için dilin şu üç özelliği destekliyor olması gerekmektedir:

    - Sınıf kavramı
    - Türetme kavramı
    - Çokbiçimlilik (polymophism)

    Eğer bir dilde sınıflar olduğu halde çokbiçimlilik yoksa böyle dillere "nesne tabanlı (object based)" diller denilmektedir. 
    Başka bir deyişle dilin nesne yönelimli olabilmesi için "çokbiçimli mekanizmaya" sahip olması gerekmektedir. C++, Java, C# gibi dillerde
    bu çokbiçimli mekanizma bulunmaktadır. 

#------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------
    NYPT'de çokbiçimlilik biyolojiden aktarılmış bir terimdir. Biyolojide çokbiçimlilik "canlıların çeşitli doku ve organlarının 
    temel işlevleri aynı kalmak üzere farklılıklar göstermesi" anlamına gelmektedir. Yani örneğin kulak pek çok canlıda vardır. 
    Temel işlevi duymaktır. Ancak her canlı kendine göre bir kulak yapısına sahiptir. 

    NYPT'de bir eylem temel işlevi aynı olmak üzere sınıflar arasında farklılıklar gösteriyorsa bu eyleme "çokbiçimli" eylem denilmektedir. 
    Örneğin A, B, C, D, E sınıflarının disp isimli metotları olsun. Bu metotlar kendi sınıflarının birtakım elemanlarını kendilerine özgü biçimde
    ekrana yazdırıyor olsun. Burada disp metodu "çokbiçimli" bir metottur. Çeşitli sınıflarda vardır. Temel işlevi sınıf hakkında bilgileri 
    ekrana yazdırmaktır. Ancak her sınıfın disp metodu kendine özgüdür ve temel işlevi aynı olmasına karşın birbirlerinden farklıdır. Örneğin
    Worker, Manager, Executive, SalesPerson sınıfları ösz konusu olsun. Bu sınıfların hepsinde kişilerin maaşlarını hesaplayan calculate_salary
    isimli bir metot olsun. Buradaki eylem çokbiçimlidir. Bu sınıfların hepsinde vardır ama her sınıfın maaş hesabı kendine özgü bir biçimde yapılmaktadır. 
    Çokbiçimli metotlar farklı sınıflarda aynı isimle bulunurlar. Bunların yaptıkları işler anahatlarıyla aynıdır ancak o sınıfa özgü 
    farklılıklar içermektedir.  
#------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------
    C++, Java, C# gibi dillerde çokbiçimli mekanizma "türetme yoluyla" sağlanmaktadır. Tipik olarak bir taban sınıf oluşturulur. 
    O taban sınıftan sınıflar türetilir. Taban sınıftaki bir fonksiyon (metot) türemiş sınıfta aynı isimle yeniden yazılır. Buna 
    taban sınıftaki fonksiyonun (metodun) türemiş sınıfta "override" edilmesi denilmektedir. Ancak Python dinamik tür sistemine 
    sahip olduğu için Python zaten doğuştan çokbiçimlidir. Python'da zaten isim araması programın çalışma zamanında yapıldığı için 
    çokbiçimli mekaznizma türetmeye bağlı değildir. Bu nedenle Python'da çokbiçimli mekanizmayı oluşturmak için özel bir sentaks da yoktur. 

    Aşağıdaki örnekte "duy" metodu çokbiçimli bir metottur. Farklı sınıflarda aynı isimle bulunmaktadır. Ancak o sınıflara özgü bir 
    gerçekleştirimi vardır. Aşağıdaki örnekteki foo fonksiyonu bir canlıyı alır. O canlının hangi canlı olduğunu bilmeden 
    onun duyma eyleminden hareketle ona özgü eylemleri gerçekleştirmektedir. 
#------------------------------------------------------------------------------------------------------------------------

class Kedi:
    def duy(self):
        print('kedi duyuyor')
        
class Köpek:
    def duy(self):
        print('köpek duyuyor')
        
class At:
    def duy(self):
        print('at duyuyor')

class Aslan:
    def duy(self):
        print('aslan duyuyor')
        
class İnsan:
    def duy(self):
        print('insan duyuyor')
        
def foo(canlı):
    print('--------')
    canlı.duy()
    #....
    canlı.duy()
    #...
    canlı.duy()
    
kedi = Kedi()
köpek = Köpek()
at = At()
aslan = Aslan()
insan = İnsan()

foo(kedi)
foo(köpek)
foo(at)
foo(aslan)
foo(insan)

#------------------------------------------------------------------------------------------------------------------------
                                                    46. Ders 05/10/2022 - Çarşamba
#------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------
    Çokbiçimlilikten en önemli amaç "türden bağımsız kod parçalarının" oluşturulmasıdır. Çokbiçimlilik biribirine benzeyen ancak farklı olan nesnelerin 
    sanki aynı nesneymiş gibi işleme sokulmasına olanak sağlamaktadır. 
    
    Örneğin bir Tetris oyunu yazacak olalım. Bu oyunda çelşitli şekiller düşmektedir. Bu şekiller duruma göre sola, sağa hareket ettirilmekte
    ve döndürülebilmektedir. Şeklin sola, sağa hareket ettrilmesi, düşmesi ve döndürülmesi "çokbiçimli (polymoprhic)" eylemlerdir. Yani bu eylemler
    bu şekil sınıflarının hepsinde vardır. Ancak her şekil kendine göre bu eylemleri yerine getirmektedir. 

    Aşağıdaki örnekte böyle bir Tetris oyunu mantıksal olarak simüle edilmeye çalışılmıştır. Burada biz Microsoft sepsifik msvcrt 
    modülünü kullandık. Bu modül standart Python kütüphanesinde olmasına karşın yalnızca Windows sistemlerinde kullanılabilmektedir. 
    Ayrıca maalesef bu modül Spyder konsolunda çalışmamaktadır. Bu nedenle bu örneği Windows konsoluna geçerek çalıştırınız. 
#------------------------------------------------------------------------------------------------------------------------

import random 
import time
import msvcrt

class Shape:
    def __init__(self):
        pass
    
class BarShape(Shape):
    def __init__(self):
        super().__init__()
        
    def move_down(self):
        print('BarShape moves down')
        
    def move_left(self):
        print('<<BarShape moves left>>')
        
    def move_right(self):
        print('<<BarShape moves right>>')
        
    def rotate(self):
        print('<<BarShape rotates>>')
        
class SquareShape(Shape):
    def __init__(self):
        super().__init__()
        
    def move_down(self):
        print('SquareShape moves down')
        
    def move_left(self):
        print('<<SquareShape moves left>>')
        
    def move_right(self):
        print('<<SquareShape moves right>>')
        
    def rotate(self):
        print('<<SquareShape rotates>>')
    
class ZShape(Shape):
    def __init__(self):
        super().__init__()
        
    def move_down(self):
        print('ZShape moves down')
        
    def move_left(self):
        print('<<ZShape moves left>>')
        
    def move_right(self):
        print('<<ZShape moves right>>')
        
    def rotate(self):
        print('<<ZShape rotates>>')
             
class LShape(Shape):
    def __init__(self):
        super().__init__()
        
    def move_down(self):
        print('LShape moves down')
        
    def move_left(self):
        print('<<LShape moves left>>')
        
    def move_right(self):
        print('<<LShape moves right>>')
        
    def rotate(self):
        print('<<LShape rotates>>')

class TShape(Shape):
    def __init__(self):
        super().__init__()
        
    def move_down(self):
        print('TShape moves down')
        
    def move_left(self):
        print('<<TShape moves left>>')
        
    def move_right(self):
        print('<<TShape moves right>>')
        
    def rotate(self):
        print('<<TShape rotates>>')

    
class Tetris:
    def __init__(self):
        pass
    
    def get_random_shape(self):
        shapes = [BarShape, TShape, ZShape, LShape, SquareShape]
        shape_type = random.choice(shapes)
        return shape_type()
    
    def run(self):
        while True:
            shape = self.get_random_shape()
            for _ in range(20):
                shape.move_down()
                if msvcrt.kbhit():
                    ch = msvcrt.getch()
                    if ch == b'a':
                        shape.move_left()
                    elif ch == b's':
                        shape.move_right()
                    elif ch == b'd':
                        shape.rotate()
                    elif ch == b'q':
                        return
                time.sleep(0.5)
                
tetris = Tetris()
tetris.run()

#------------------------------------------------------------------------------------------------------------------------
    Bir sınıf türünden nesneyi str türüne dönüştürebiliriz. Böyle bir dönüştürme ilgili sınıfın __str__ isimli bir metodunun 
    bulunuyor olması gerekir. s bir sınıf türünden değişken olmak üzere str(s) işlemi tamamen s.__str__() ile aynı anlamdadır. 
    Programcı sınıfın __str__ metodunu bir str nesnesiyle geri döndürmelidir. 

    Aslında print fonksiyonu yalnızca string'leri bastırmaktadır. Eğer print fonksiyonuna girdiğimiz argüman string değilse print 
    fonksiyonu onu string türüne dönüştürüp yazıyı ekrana basmaktadır. s string türünden olmayan bir türden olsun. Bu durumda:

    print(s)

    ile 

    print(s.__str__())

    tamamen aynı anlamdadır. 

#------------------------------------------------------------------------------------------------------------------------

class Sample:
    def __str__(self):
        return 'this is a test'
    
s = Sample()

print(s)            # this is a test

k = str(s)          # k = s.__str__()
print(k)            # this is a test

#------------------------------------------------------------------------------------------------------------------------
    Tipik olarak programcı sınıfı için __str__ metodunu yazarak o sınıfın tuttuğu bilgiyi bu metotta bir yazı olarak döndürür. 
    Böylece bu türden bir sınıf nesnesi print ile yazdırılmak istendiğinde ekranda o nesneyi betimleyen bir yazı görünecektir. 
#------------------------------------------------------------------------------------------------------------------------

class Date:
    def __init__(self, day, month, year):
        self.day = day
        self.month = month
        self.year = year
        
    def __str__(self):
        return f'{self.day}/{self.month}/{self.year}'
    
d = Date(4, 10, 2022)
print(d)

k = Date(11, 10, 2008)
print(k)

#------------------------------------------------------------------------------------------------------------------------
    Aslında biz list gibi, tuple gibi sınıf nesnelerini print yazdırdığımızda önce o nesneler string türüne dönüştürülüp elde 
    edilen yazılar yazdırılmaktadır. Bunun için o sınıflarda __str__ metotları bulunmaktadır. Bir listenin print ile nasıl 
    yazdırılabildiği hakkında fikir edinmeniz için aşağıdaki örneği veriyoruz.
#------------------------------------------------------------------------------------------------------------------------

class MyList:
    def __init__(self, *args):
        self.args = args
        
    def __str__(self):
        s = '['
        for x in self.args:
            if s != '[':
                s += ', '
            s += str(x)
        s += ']'
        
        return s
    
ml = MyList(1, 2, 3, 4, 5)
print(ml)

#------------------------------------------------------------------------------------------------------------------------
    Örneğin bir karmaşık sayıları temsil eden bir sınıfın __str__ metodu nesnenin tuttuğu karmaşık sayıyı yazı olarak verebilir. 
#------------------------------------------------------------------------------------------------------------------------

class Complex:
    def __init__(self, real, imag):
        self.real = real
        self.imag = imag
        
    def __str__(self):
        return f'{self.real}+{self.imag}i'
    
z = Complex(3, 2)
print(z)            # 3+2i

#------------------------------------------------------------------------------------------------------------------------
    Anımsanacağı gibi bir sınıf türünden bir değişken ile bir metot çağrıldığında metot sırasıyla değişkenin ilişkin olduğu sınıfın 
    MRO sırasına göre sınıflarda aranıyordu. Normal türetme durumlarında MRO sırasının aşağıdan yukarıya doğru olduğunu anımsayınız.
    Daha önce bir sınıfı hiçbir sınıftan türetmemişsek onun otomatik olarak object sınıfından türetildiğini belirtmiştik. İşte 
    object sınıfının da bir __str__ metodu vardır. object sınıfının bu __str__ metodu nesnenin ismini id'sini hex sistemde yazı olarak vermektedir. 
    Yani özetle biz kendi sınıfımız için __str__ metodunu yazmazsak object sınıfının __str__ metodu çağrılacak, object sınıfının __str__ 
    metodu da değişkenin ilişkin olduğu sınıfın ismini ve onun id'sini verecektir. 
#------------------------------------------------------------------------------------------------------------------------

class A:
    pass

a = A()
print(a)        # <__main__.A object at 0x000001F36F45E580>

#------------------------------------------------------------------------------------------------------------------------
    Programcı bir sınıf yazmışsa onun için bir __str__ metodunu yazması iyi bir tekniktir. Tabii __str__ metotlarının nasıl bir yazı
    geri döndüreceğinin bir standardı yoktur. Programcı bu metotlarda genel olarak sınıfın örnek özniteliklerini yazısal olarak
    kendisinin istediği biçimde verir. Python'ın standart kütüphanesindeki sınıflarda da hep bu __str__ metotları yazılmış durumdadır. 
#------------------------------------------------------------------------------------------------------------------------

import datetime

d = datetime.date(2022, 10, 4)
print(d)        # 2022-10-04

s = str(d)
print(s)        # 2022-10-04

#------------------------------------------------------------------------------------------------------------------------
    __str__ metodunun __repr__ isminde bir benzeri de vardır. __repr__ metodu da tıpkı __str__ netodunda olduğu gibi bir 
    string ile geri dönmelidir. Pekiyi iki metot arasında ne farklılık vardır? İşte __str__ metodu "daha çok kullanıcıya yönelik", 
    __repr__ metodu "daha çok programcıya yönelik" bir yazı verme iddiasındadır. Tabii bu iki metodun veridği yazılar aynı da olabilir. 
    Örneğin Python2ın komut satırında, Spyder'ın komut satırında (IPython) bir değişkeni yazıp ENTER tuşuna bastığımızda bu komut satırı programları
    değişken ile __repr__ metodunu çağırıp buradan elde edilen yazıyı bastırmaktadır. Örneğin:

    >>> class Sample:
    ...     def __str__(self):
    ...         return '__str__'
    ...
    ...     def __repr__(self):
    ...         return '__repr__'
    ...
    >>> s = Sample()
    >>> s
    __repr__
    >>> print(s)
    __str__

    Özetle:

    1) Bir sınıf türünden değişken str türüne dönüştürüldüğünde (ya da print fonksiyonu ile yazdırıldığında) __str__ metodu
    çağrılarak onun geri dörndürdüğü yazı verilmektedir. 

    2) Bir değişkenin ismi komut satırında yazılıp ENTER tuşuna basıldığında __repr__ metodunun geri döndürdüğü yazı 
    görüntülenmektedir. 

    Aslında programcının bu iki metodu ayrı ayrı yazması da bazen gerekmemektedir. Çünkü:

    1) Eğer sınıfın __repr__ metodu varsa fakat __str__ metodu yoksa str türüne dönüştürmede __repr__ metodu kullanılmaktadır. Aynı zamanda 
    komu satırında değişken ismi yazılıp ENTER tuşuna basıldığında da __repr__ nmetodu kullanılmaktadır. 

    2) Sınıfta hem __str__ hem de __repr__ metodu varsa bu durumda str türüne dönüştürmede __str__ metodu, komut satırından değişken ismini 
    yazıp ENTER tuşuna basıldığında __repr__ çağrılmaktadır. 

    3) Sınıfta yalnızca __str__ metodu varsa str türüne dönüştürmede __str__ metodu çağrılır. Komut satırında değişken ismi yazıldığında onject sınıfının 
    __repr__ metodu çağrılır. 

    Yukarıda da belirtildiği gibi object sınıfın da __repr__ metodu vardır. Bu metot da yine değişkenin ilişkin olduğu sınıfın ismini 
    ve nesnenin id'sini vermektedir. 

    >>> class Sample:
    ...     def __str__(self):
    ...         return '__str__'
    ...
    >>> s = Sample()
    >>> print(s)
    __str__
    >>> s
    <__main__.Sample object at 0x0000026954AC5850>
    
    O halde bu metotların yazımı konusunda ne tavsiye edilebilir? Eğer programcı tek bir metot yazacaksa __repr__ metodunu yazması daha uygun olur. 
    Eğer bu iki yazıyı birbirinden ayırmak istiyorsa her iki metodu da yazmalıdır. Python'ın standart kütüphanesindeki sınıflarında genellikle 
    bu metotlar ayrı ayrı yazılmıştır. Örneğin:

    >>> import datetime
    >>> d = datetime.date(2022, 10, 4)
    >>> print(d)
    2022-10-04
    >>> d
    datetime.date(2022, 10, 4)

    Aslında standart kütüphanede repr isimli bir buil-in fonksiyon da vardır. Bu fonksiyon aslında parametresiyle aldığı nesne ile __repr__ 
    metodu çağırıp onunla geri dönmektedir. Yani gerçekleştirimi kabaca şöyledir:

    def repr(o):
        return o.__repr__()

    Bazen programcı komut satırında değil de kendi programı içerisinde de __str__ yerine __repr__ metodunu kullanmak isteyebilir. Örneğin:

    import datetime

    d = datetime.date(2022, 10, 4)
    print(d)
    print(repr(d))      # print(d.__repr__())

    Örneğin bazen programcı birtakım yazılardaki özel karakterleri görebilmek için yazıyı __rep__ metodu ile yazdırmak isteyebilir:

    import datetime

    f = open('test.txt')
    s = f.read()
    print(repr(s))
    f.close()

#------------------------------------------------------------------------------------------------------------------------
                                                    47. Ders 10/10/2022 - Pazartesi
#------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------
    Python'da bir nesne yaratıldığında sistem o nesnesnin kaç değişken değişken tarafından referans edildiğini (yani gösterildiğini)
    tutmaktadır. Buna nesnenin "referans sayacı (reference count)" denilmektedir. Nesnenin referans sayacı programın çalışması 
    sırasında azalıp artabilmektedir. Nesnenin referans sayacı 0 olduğunda artık o nesneyi hiçbir değişken göstermiyor durumda olur. 

    Aşağıdaki örnekte list nesnesinin çeşitli durumlardaki referans sayacının kaç olduğu gösterilmiştir. 
#------------------------------------------------------------------------------------------------------------------------

def foo(x):             
    # RC: 5
    y = x
    # RC: 6

a = [100, 200, 300]     
# RC: 1
b = a                   
# RC: 2
foo(b)
# RC: 2
b = None
# RC: 1
a = None
# RC: 0

#------------------------------------------------------------------------------------------------------------------------
    Bir nesnenin referans sayacı sys modülündeki getrefcount isimli fonksiyonla elde edilebilir. Bu fonksiyon nesnenin referans 
    sayacını her zaman bir fazla olarak vermektedir. Çünkü bu fonksiyon referans sayacı bulunacak nesnenin adresini parametre 
    yoluyla aldığı için fonksiyonun içerisinde nesnenin referans sayacı bir artmış olmaktadır. Ayrıca örneğin bir değişken 
    bir fonksiyona geçirildiğinde Python yorumlayıcısı fonksiyonun parametre değişkenini de ayrıca tuttuğu için nesnenin referans
    sayacı bir değil iki de artabilir. Tabii burada aslında sayıların pek önemi yoktur. Buradaki en önemli nokta nesnesinin referans sayacının 
    sıfıra düşmesidir. bı

    Tabii Python'da aslında int, float, str, bool gibi temel türler de birer sınıf biçimindedir. Dolayısıyla örneğin int bir nesnenin de referans 
    sayacı vardır, floatr bir nesnenin de referans sayacı vardır. 
#------------------------------------------------------------------------------------------------------------------------

import sys

def foo(x):             
    print(sys.getrefcount(x))
    y = x
    print(sys.getrefcount(x))

a = [100, 200, 300]     
print(sys.getrefcount(a))
b = a                   
print(sys.getrefcount(a))
foo(b)
print(sys.getrefcount(a))
b = None
print(sys.getrefcount(a))
a = None
print(sys.getrefcount(a))

#------------------------------------------------------------------------------------------------------------------------
    getrefcount fonksiyonu ile nesnelerin referans sayaçlarını elde ettiğinizde bu sayılar umduğunuz gibi çıkmayabilir. 
    Çünkü Python yorumlayıcıları kendi içlerinde çeşitli nedenlerden dolayı nesnenin başka değişkenler tarafından da gösterilmesini
    sağlayabilmektedir. Ayrıca CPython gibi yorumlayıcılar belli sabitleri işin başında bir kez yaratıp o sabitler kullanıldığında 
    zaten yaratılmış olan nesnelerin adreslerini kullanabilmektedir. Bu nedenle pek çok sabitin yüksek bir referans sayacı olabilmektedir. Örneğin:

    >>> a = 0
    >>> sys.getrefcount(a)
    313
#------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------
    Python'da bir nesne yaratıldktan sonra o nesnenin referans sayacı sıfıra düştüğünde nesne artık çöp duruma gelmektedir ve
    "çöp toplayıcı (garbage collector)" denilen mekanizma sayesinde bellekten yok edilmektedir. Yani Python'da programcı nesneleri yaratır
    ancak onların yok edilmesiyle uğraşmaz. Onların yok edilmesi yorumlayıcı sistem tarafından otomatik yapılmaktadır. 

    Çöp toplama mekanizması Python'a özgü değildir. Java, C# gibi dillerde ve onların kullanıldığı ortamlarda da çöp toplama 
    mekanizması vardır. Çöp toplama mekanizması için değişik algoritmalar kullanılmaktadır. Çöp toplama sisteminin gerçekleştiriminde 
    kullanılan bu algoritmaların birbirlerine göre avantajları ve dezavantajları söz konusu olabilmektedir. Örneğin CPython yorumlayıcısı
    "referans sayacı yoluyla çöp toplama algoritmasını" kullanmaktadır. Burada bir nesnenin referans sayacı sıfıra düşer düşmez
    çöp toplayıcı onu silmektedir. Ancak örneğin .NET ve Java ortamlarında "mark and sweep" algoritması tercih edilmektedir. O ortamlarda 
    nesnenin silinmesi hemen değil belli bir zaman sonra yapılır. Örneğin Iron Python ve Jython yorumlayıcıları bu ortamlarda çalıştığı 
    için bu ortamların çöp toplama mekanizmasını kullanmaktadır. Python standartlarında çöp toplama algoritması hakkında ayrıntılar verilmemiş 
    dolayısıyla bu konu yorumlayıcıları yazanların isteğine bırakılmıştır. 
#------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------
    Python'ın çöp toplayıcı mekanizması nesneyi yok etmeden hemen önce o nesne için eğer varsa ilgili sınıfın __del__ isimli metodunu çağırmaktadır.
    Böylece programcı nesne yok edilmeden önce nesne ile ilgili birtakım son işlemleri yapabilir. Tabii programcılar genel olarak Python 
    dünyasının içerisinde kaldıklarından dolayı bu metodu yazmaya pek gereksinim duymamaktadır. Ancak eğer programcı Python dünyasının dışında 
    birtakım tahsisatları sınıfın __init__ metdounda yapmışsa bu tahsisatların otomatik geri bırakılmasını __del__ metodunda sağlayabilir. 
    İşletim sistemi düzeyinde tahsis edilen kaynaklara .NET ve Java dünyasında "unmanaged" kaynaklar denilmektedir. Aslında Python2ın standart 
    kütüphanesi zaten bu tür unmanaged kaynakları kullanmaktadır ve onların boşaltımını ilgili sınıfların __del__ metotlarında yapmaktadır.
    Yukarıda da belirttiğimiz gibi programcılar genel olarak bu __del__ metotlarını yazmayı gerektirecek uygulamalar içerisinde seyrek olarak 
    bulunurlar. 

    Aşağıdaki örnekte __del__ metodu tam olarak s = None işleminden sonra hemen çağrılacaktır. CPython yorumlayıcısında kullanılan 
    algoritma nesnenin referans sayacı sıfıra düşer düşmez nesneyi yok eder ve nesneyi yok etmeden önce sınıfın __del__ metodunu çağırır.
#------------------------------------------------------------------------------------------------------------------------

class Sample:
    def __init__(self):
        print('işletim sistemi düzeyinde kaynak tahsis ediliyor')
        
    def __del__(self):
        print('işletim sistemi düzeyinde tahsis edilen kaynak boşaltılıyor')
            
print('program başladı')
s = Sample()
print('program devam ediyor')
s = None
print('program sonlanıyor')

#------------------------------------------------------------------------------------------------------------------------
    Aşağıdaki örnekte bir fonksiyon içerisinde bir nesne yaratılmıştır. Fonksiyon biterken yerel değişkenler yok edildiği için 
    fonksiyon içerisinde yaratılmış olan nesnenin referans sayacı sıfıra düşmüş ve çöp toplayıcı nesneyi hemen silmiştir. 
#------------------------------------------------------------------------------------------------------------------------

class Sample:
    def __init__(self):
        print('işletim sistemi düzeyinde kaynak tahsis ediliyor')
        
    def __del__(self):
        print('işletim sistemi düzeyinde tahsis edilen kaynak boşaltılıyor')
            

def foo():
    print('foo başlıyor')
    s = Sample()
    print('foo bitiyor')
    
print('program başlıyor')
foo()
print('program bitiyor')

#------------------------------------------------------------------------------------------------------------------------
    Pekiyi CPython'daki __del__ metodunun çağrılması ytamamen deterministik midir? Aslında büyük ölçüde CPython'da bu __del__ 
    metodunun çağrılması deterministik gibi gözükmektedir. Ancak yine de tam olarak böyle bir durum söz konusu değildir. Örneğin:

    def foo():
        print('foo begins')
        s = Sample()
        print('foo ends')

    Burada s ne zaman hayatını kaybetmektedir? CPython yorumlayıcısı s'in bir daha kullanılmadığını fark edip hemen 
    son print'ten önce nesneyi silebilmektedir. Halbuki örneğin C++'ta kesinlikle bu durumda "destructor" fonksiyonun nerede 
    çağrılacağı kesin olarak bellidir. 
#------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------
    Biz bir sınıftan türetme yapıyorsak ve sınıfımız için __del__ metodunu yazmışsak bu durumda türemiş sınıf türünden nesnemiz
    çöp toplayıcı tarafından yok edilirken bizim türemişl sınıfın __del__ metodu çağrılacaktır. Ancak eğer taban sınıfın da __del__ metodu varsa
    bizim türemiş sınıfın __del__ metodu içerisinde taban sınıfın __del__ metodunu çağırmamız gerekir. Bu çağırma işlemi tipik olarak 
    türemiş sınıfın __del__ metodunun sonunda yapılmalıdır. Tabii eğer taban sınıfın bir __del__ metodu yoksa biz türemiş sınıfın __del__ 
    metodu içerisinde taban sınııfın __del__ metodunu çağırmamalıyız. Çünkü Python'da object sınıfınn bir __del__ metodu yoktur. 
   
#------------------------------------------------------------------------------------------------------------------------

class A:
    def __init__(self): 
        print('A.__init__')
        
    def __del__(self):
        print('A.__del__')
             
class B(A):
    def __init__(self): 
        super().__init__()
        print('B.__init__')
        
    def __del__(self):
        print('B.__del__')
        super().__del__()
        
b = B()
b = None

#------------------------------------------------------------------------------------------------------------------------
    Pekiyi biz taban sınıfın __del__ metodunun olduğunu nasıl anlayabiliriz? Aslında en sağlam yol dökümantasyona bakmak olabilir. Eğer 
    dokğmantasyon yoksa biz de taban sınıfın __del__ metoduna sahip olup olmadığını bilemeyecek durumdaysak o zaman  hasattr fonksiyonuyla bu kontrolü yapabiliriz. 
    (has fonksiyonu ileri ele alınacaktır.) Aşağıdaki örnekte türemiş sınıfın __del__ metodu önce hasattr fonksiyonu ile taban sınıfın __del__ metodu var mı 
    diye bakmıştır. Sonra eğer varsa taban sınıfın __del__   metodunu çapırmıştır.
#------------------------------------------------------------------------------------------------------------------------

class A:
    def __init__(self): 
        print('A.__init__')
        
    def __del__(self):
        print('A.__del__')
  
class B(A):
    def __init__(self): 
        super().__init__()
        print('B.__init__')
        
    def __del__(self):
        print('B.__del__')
        o = super()
        if hasattr(o, '__del__'):
            o.__del__()
             
b = B()
b = None

#------------------------------------------------------------------------------------------------------------------------
                                                48. Ders 12/10/2022 - Çarşamba
#------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------
    "Operatör metotları" konusu nesne yönelimli dillerin çoğunda bulunmaktadır. Örneğin bu özellik C++'ta, C#'ta, Swift'te 
    vardır. Ancak Java'da bulunmamaktadır. Python'da da "operatör metotları" bulunmaktadır. Operatör metotları aslında dile ekstra 
    bir özellik katmamaktadır. Yalnızca okunabilirlik bakımından bir avantaj sağlamaktadır. Yani başka bir deyişle nesne yönelimli bir dilde
    operatör metotları olmasa da bu işlemler normal metotlarla sağlanabilir. Ancak operatör metotları güzel bir görünüm sunmaktadır. 

    Aşağıdaki örnekte bir Complex sayı sınıfı oluşturulmuştur. İki Complex sayıyı toplayabilmek için sınıfa add isimli bir metot eklenmiştir. 
#------------------------------------------------------------------------------------------------------------------------

class Complex:
    def __init__(self, real = 0, imag = 0):
        self.real = real
        self.imag = imag
        
    def add(self, z):
        result = Complex()
        
        result.real = self.real + z.real
        result.imag = self.imag + z.imag
        
        return result
        
    def __repr__(self):
       return f'{self.real}+{self.imag}i'
            
x = Complex(3, 2)       # 3 + 2i
print(x)

y = Complex(4, 2)       # 4 + 2i
print(y)

z = x.add(y)
print(z)

#------------------------------------------------------------------------------------------------------------------------
    Operatör metotları özel dunder isimli bazı metotlardır. Örneğin toplama işlemini yapan operatör metodu __add__, çıkartma işlemini 
    yapan opereatör metodu __sub__, çarpma işleminş yapan operatör metodu __mull__ ismindedir. Programcı bu metotları yazarak 
    Python opereatörlerinde kendi sınıfları için bu metotların çağrılmasını sağlayabilir. 

    Python yorumlayıcısı sınıf türünden bir değişkenin bir operatörler kullanıldığını gördüğünde bu ifadeyi eşğder metot çağrısına dönüştürmektedir. 
    Örneğin a bir sınıf türünde olmak üzere a + b ifadesi tamamen a.__add__(b) ile eşdeğerdir. Örneğin a > b ifadesi a.__gt__(b) ile eşdeğerdir. 
    Böylece aslında biz bir sınıf nesnesini operatörlerle işleme soktuğumuzda arka planda sınıfın dunder'lı operatör metotları çağrılmaktadır. 
    Tabii biz de a + b yerine aslında a.__add__(b) yazabilirdik. İki ifade arasında bir farklılık yoktur. 
#------------------------------------------------------------------------------------------------------------------------

class Complex:
    def __init__(self, real = 0, imag = 0):
        self.real = real
        self.imag = imag
        
    def __add__(self, z):
        result = Complex()
        
        result.real = self.real + z.real
        result.imag = self.imag + z.imag
        
        return result
        
    def __repr__(self):
       return f'{self.real}+{self.imag}i'
            
x = Complex(3, 2)       # 3 + 2i
print(x)

y = Complex(4, 2)       # 4 + 2i
print(y)

z = x.__add__(y)
print(z)

z = x + y   # x.__add__(y)

#------------------------------------------------------------------------------------------------------------------------
    a, b ve c bir sınıf türünden değişkenler olsun. a + b + c işleminin eşdeğeri a.__add__(b).__add__(c) biçimindedir. 
#------------------------------------------------------------------------------------------------------------------------

class Complex:
    def __init__(self, real = 0, imag = 0):
        self.real = real
        self.imag = imag
        
    def __add__(self, z):
        result = Complex()
        
        result.real = self.real + z.real
        result.imag = self.imag + z.imag
        
        return result
        
    def __repr__(self):
       return f'{self.real}+{self.imag}i'
            
x = Complex(3, 2)       # 3 + 2i
y = Complex(4, 2)       # 4 + 2i
z = Complex(1, 4)       # 1 + 4i

result = x.__add__(y).__add__(z)
print(result)

result = x + y + z;
print(result)

#------------------------------------------------------------------------------------------------------------------------
    Operatör metotları operatör önceliklerini değiştirmez. Örneğin a, b, c birer sınıf türünden olmak üzere a + b * c işleminin
    eşdeğeri a.__add__(b.__mull__(c)) biçimindedir. Operatör metotları bu biçimde kombine edilebilir. 
#------------------------------------------------------------------------------------------------------------------------

class Complex:
    def __init__(self, real = 0, imag = 0):
        self.real = real
        self.imag = imag
        
    def __add__(self, z):
        result = Complex()
        
        result.real = self.real + z.real
        result.imag = self.imag + z.imag
        
        return result
    
    def __mul__(self, z):
        result = Complex()
        
        result.real = self.real * z.real - self.imag * z.imag
        result.imag = self.real * z.imag + self.imag * z.real
        
        return result  
        
    def __repr__(self):
       return f'{self.real}+{self.imag}i'
            
x = Complex(3, 2)       # 3 + 2i
y = Complex(1, 2)       # 4 + 2i
z = Complex(1, 4)       # 1 + 4i

result = x + y * z;
print(result)

#------------------------------------------------------------------------------------------------------------------------
    Tabii iki operand'lı operatörlerin diğer operand'ları temel türlere ilişkin olabilir. Yani iki operand da aynı sınıfa ilişkin 
    olmak zorunda değildir. Örneğin z değişkeni Complex sınıfı türünden olsun. Biz iki Complex sayıyı toplama isteyebileceğimiz gibi
    bir Complex sayı ile bir int, float değeri de toplamak isteyebiliriz. Bu durumda örneğin bu int ya da float değer Complex nesnesinin
    gerçek kısmıyla toplanır.
#------------------------------------------------------------------------------------------------------------------------

class Complex:
    def __init__(self, real = 0, imag = 0):
        self.real = real
        self.imag = imag
        
    def __add__(self, z):
        result = Complex()
        
        if isinstance(z, (int, float)):
            result.real = self.real + z
            result.imag = self.imag
        else:
            result.real = self.real + z.real
            result.imag = self.imag + z.imag
        
        return result
        
    def __repr__(self):
       return f'{self.real}+{self.imag}i'
            
x = Complex(3, 2)       # 3 + 2i
y = Complex(1, 2)       # 4 + 2i

result = x + 2 + y
print(result)

#------------------------------------------------------------------------------------------------------------------------
    Anımsanacağı gibi Python'da iki tane bölme operatörü vardır. / operatörü her zaman float değer vermektedir. // operatörü (floordiv)
    ise bölüm sonucunda noktadan sonraki kısmı atmaktadır. / operatyörü __truediv__ ismiyle // operatörü __floordiv__ ismiyle yazılmaktadır. 
#------------------------------------------------------------------------------------------------------------------------

class Number:
    def __init__(self, number = 0):
        self.number = number
        
    def __add__(self, val):
        result = Number()
        if isinstance(val, (int, float, bool)):
            result.number = self.number + val 
        else:
            result.number = self.number + val.number
            
        return result
    
    def __truediv__(self, val):
        result = Number()
        if isinstance(val, (int, float, bool)):
            result.number = self.number / val
        else:
            result.number = self.number / val.number
            
        return result
    
    def __floordiv__(self, val):
        result = Number()
        if isinstance(val, (int, float, bool)):
            result.number = self.number // val
        else:
            result.number = self.number // val.number
            
        return result
    
    def __repr__(self):
        return str(self.number)
                
a = Number(10)
b = Number(4)

result = a / b
print(result)

result = a // b
print(result)

#------------------------------------------------------------------------------------------------------------------------
    Python'a 3.5 versiyonuyla birlikte @ operatörü de eklenmiştir. Bu operatöre "matris çarpımı" operatörü de denilmektedir.
    Ancak bu @ operatörü standart Python sınıfları tarafından kulalnılmamaktadır. Fakat NumPy gibi Pandas gibi kütüphaneler 
    bu operatörü kullanmaktadır. Bu operatör aslında sınıfının __matmul__ isimli bir metodunu çağırır. Operatörün Python'a 
    eklenme sebebi matris çarpımı işlemi olsa da aslında operatör başka amaçlarla da kullanılabilmektedir. 

    Aşağıda matris çarpımının sınıfın __matmul__ metodu tarafından yaptırılmasına bir örnek verilmiştir. 
#------------------------------------------------------------------------------------------------------------------------

class Matrix:
    def __init__(self, matrix):
        self.matrix = matrix
        self.rowsize = len(matrix)
        self.colsize = len(matrix[0])
                
    def __matmul__(self, a):
        result = [[0] * a.colsize for i in range(self.rowsize)]
        for i in range(self.rowsize):
            for j in range(self.colsize):
                total = 0   
                for k in range(self.colsize):
                    total += self.matrix[i][k] * a.matrix[k][j]
                result[i][j] = total
                
        return result
        
m = Matrix([[1, 2, 1]])
k = Matrix([[3, 2, 1], [1, 1, 1], [1, 2, 3]])

result = m @ k
print(result)

#------------------------------------------------------------------------------------------------------------------------
    Karşılaştırma operatörleri için operatör metot isimleri de şöyledir:

    >       __gt__
    <       __lt__
    >=      __ge__
    <=      __file__
    ==      __eq__
    !=      __ne__

    Tabii programcı tipik olarak bu operatör metotlarını bool bir değerle geri döndürür. 

#------------------------------------------------------------------------------------------------------------------------

class Number:
    def __init__(self, number = 0):
        self.number = number
    
    def __gt__(self, val):
        return self.number > val.number
    
    def __lt__(self, val):
        return self.number < val.number
    
    def __ge__(self, val):
        return self.number >= val.number
    
    def __le__(self, val):
        return self.number <= val.number
    
    def __eq__(self, val):
        return self.number == val.number
    
    def __ne__(self, val):
        return self.number != val.number
    
    def __repr__(self):
        return str(self.number)
                
a = Number(4)
b = Number(4)

if a > b:
    print('a > b')
elif a < b:
    print('a < b')
elif a == b:
    print('a == b')
  
#------------------------------------------------------------------------------------------------------------------------
    Bazı operatörlerin değişme özelliği vardır. Yani örneğin a + 3 gibi bir ifadeyi biz 3 + a gibi de yazabiliriz. Ancak operatör metotlarında
    soldaki operandın bizim sınıfımız türünden olması gerekmektedir. Örneğin a Number sınıfı türünden olsun. a + 3 gibi bir toplama
    işleminş yapan bir operatör metodu yazabiliriz. Pekiyi 3 + a işlemini yapacak bir operatör netodunu nasıl yazabiliriz? 3 + a 
    işleminşn eşdeğeri 3.__add__(a) biçimindedir. int sınıfı ise bizim yazdığımız bir sınıf değildir. İşte iki operand'lı operatör metodunun ismi 
    __xxx__ olmak üzere bir bunların __rxxx__ biçiminde başı "r" ile başlayan (reverse sözcüğünden geliyor) versiyonları vardır. Python yorumlayıcısı 
    @ bir operatör belirtmek üzere a @ b işlemini yapacak operatör metodunu önce sol taraftaki operandın sınıfında __xxx__ biçiminde arar. 
    Bulursa bu ifadeyi a.__xxx__(b) olarak değerlendirir. Eğer bu sınıfta bu operatör metodu yoksa bu kez sağ taraftaki operandın sınıfında 
    __rxxx__ metodunu arar. Eğer bu metodu bulursa ifadeyi b.__rxxx__(a) biçiminde değerlendirir. 

    Programcının ___xxx__ hem de __rxxx__ metotlarını ayrı ayrı yazmasına gerek yoktur. Bunlar işi yapacağında göre ve metotlar aslında sınıf değişkenleri 
    olduğuna göre bu işlem basit bir atama ile de sağlanabilir. Örneğin:

    class Number:
        def __init__(self, number = 0):
            self.number = number
        
        def __add__(self, n):
            result = Number()
        
            result.number = self.number + n
            
            return result

        __radd__ = __add__
            
        def __repr__(self):
            return str(self.number)
    
    Tabii bazen bunların ayrı ayrı yazılması da gerekebilmektedir. 
#------------------------------------------------------------------------------------------------------------------------

class Number:
    def __init__(self, number = 0):
        self.number = number
    
    def __add__(self, n):
       result = Number()
       
       result.number = self.number + n
       
       return result
   
    __radd__ = __add__

    def __repr__(self):
        return str(self.number)
    
a = Number(4)

result = a + 3      # a.__add__(3) 
print(result)   

result = 3 + a      # a.__radd__(3)
print(result)

#------------------------------------------------------------------------------------------------------------------------
    @ bir operatör sembolü olmak üzere her zaman a = a @ b ile a @= b aynı anlamda olmayabilir. Örneğin a + b ile a+= b 
    int, float gibi temel türlerde eşdeğerdir. Ancak örneğin listelerde bu iki ifade eşdeğer değildir. Listelerde bilindiği gibi 
    a += b aslnda a üzerinde eklemeye yol açmaktadır. Yani programcı @= operatörleri için farklı operatör metotları yazarak 
    semantik farklılık oluşturabilmektedir. İşte @= operatörleri için __ixxx__ biçiminde başı "i" ile başlayan operatörler bulundurulmuştur. 
    Yorumlayıcı a @= b ifadesini gördüğünde eğer sınıfta bu işi yapacak bir __ixxx__ metodu yoksa bu ifadeyi a = a @ b olarak ele alır. 
    Ancak eğer fınıfta bu işi yapacak bir __ixxx__ metodu varsa ifadeyi a = a.__ixxx__(b) olarak ele alır. Yani özetle biz bu işlemli 
    atama operatörleri için operatör metodu yazmak zorunda değiliz. Bu durumda normal operatör metodu devreye girecektir. 

    Pekiyi biz __ixxx__ operatör metotlarını nasıl yazmalıyız? Öncelikle bu metotların yine bir bu işlemin sonucu olan bir nesneyle geri dönmesi gerekir. 
    Çünkü a += b gibi bir işlem eğer sınıfta bunu yapabilecek bir __iadd__ metodu varsa a = a.__iadd__(b) biçiminde ele alınmaktadır. 
    Yani görüldüğü g,b, bu "i" li metotların geri dönüş değerleri yine sol taraftaki operanda atanmaktadır. Böylece programcı isterse 
    hiç yeni nesne yaratmadan işlemi soldaki operand üzerinde yapıp onunla geri dönebilir. Örneğin:

    class Number:
        def __init__(self, number = 0):
            self.number = number
        
        def __add__(self,  val):
            result = Number()
        
            result.number = self.number + val.number
        
            return result
    
        def __iadd__(self,  val):
            self.number += val.number
            
            return self
            
        def __repr__(self):
            return str(self.number)

    Burada __iadd__ metodu aslında toplamı self üzerinde oluşturup yeniden self nesnesine geri dönmüştür. Örneğin:

    a = Number(4)
    b = Number(3)

    print(id(a))        # 4565685328

    a += b              # a = a._iadd__(b)
    
    print(id(a))         # 4565685328

    Yani özetle a += b gibi bir işlemde eğer sınıfta __iadd__ operatör metodu yoksa bu işlem a = a.__add__(b) ile varsa 
    a = a.__iadd__(b) ile eşdeğerdir. Bu durumda a += b işleminde zaten a sınıfı "değiştirilebilir (mutable)" olmadıktan sonra
    ya da a = a + b ile aynı semantik uygulanmadıktan sonda __iadd__ metodunun yazılmasına da gerek yoktur. Örneğin list sınıfında __iadd__ 
    metodu vardır. Ancak tuple sınıfında yoktur. 
#------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------
                                                    49. Ders 17/10/2022 - Pazartesi
#------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------
    a bir sınıf türünden değişken olmak üzere a(...) biçiminde biz bu değişkeni sanki fonksiyonmuş gibi fonksiyon çağırma operatörü ile 
    kullanabiliriz. Ancak bunun için ilgili sınıfın __call__ isiml bir operatör metodunun bulunuyor olması gerekir. Yani:

    a(...)

    çağrısı aslında tamamen aşağıdakiyle eşdeğerdir:

    a.__call__(...)

    Bu nedenle Python'da fonksiyon çağırma operatörü ile çağrılabilen nesnelere "callable" nesneler denilmektedir. Bir fonksiyon "callable" bir nesnedir. 
    __call__ metodu buunan bir sınıf nesnesi de "callable" bir nesnedir.
#------------------------------------------------------------------------------------------------------------------------

class Sample:
    def __call__(self):
        print('this is a test')
        
s = Sample()

s()

#------------------------------------------------------------------------------------------------------------------------
    Tabii __call__ metotları ekstra parametrelere ve geri dönüş değerlerine sahip olabilir.                                          
#------------------------------------------------------------------------------------------------------------------------

class Sample:
    def __init__(self, text):
        self.text = text
        
    def __call__(self, n):
        return self.text * n
        
s = Sample('test')

result = s(5)       # s.__call__(5)
print(result)       # testtesttesttesttest

#------------------------------------------------------------------------------------------------------------------------
    Fonkisyon yerine sanki fonksiyonmuş gibi sınıf nesnelerinin kullanılması bazı durumlarda faydalar sağlamaktadır. Sınıf nesneleri 
    örnek özniteliklerinde bilgi tutabildiği için çağrılar arasında daha tutulan bilgiler sonraki çağrılarda kullanılabilmektedir. 
    Fonksiyon yerine sınıf nesnelerinin kullanılması "callback" mekanizmasında yoğun olarak kullanılabilmektedir. Bir foksiyon bir işi yaparken 
    arka planda bizim ona verdiğimiz bir fonksiyonu çağırıyor olabilir. Bu mekanizmaya "callback" mekanizaması, burada çağrılan fonksiyona da "callback"
    fonksiyon denilmektedir. İşte bu tür callback fonksiyonların "callable" nesnelerle oluşturulmasının bazı avantajları vardır. 
#------------------------------------------------------------------------------------------------------------------------

class Sample:
    def __init__(self, text):
        self.text = text
        
    def __call__(self, n):
        return self.text * n
        
s = Sample('test')

result = s(5)       # s.__call__(5)
print(result)       # testtesttesttesttest

#------------------------------------------------------------------------------------------------------------------------
    Biz daha önce listelerini demetlerin, sözlüklerin len fonksiyonuna sokulabildiğini gördük. Aslında len fonksiyonu ilgili 
    sınıfın __len__ metodunu çağırmaktadır. Yani:

    len(a)    

    ile 
    
    a.__len__()

    aynı anlamdadır. Yani len fonksiyonu aslında şöyle yazılmıştır:

    def len(a):
        return a.__len__()

    O zaman biz de kendi sınıfımız türünden nesnelerin len fonksiyonuna sokulmasını istersek dsınıfımızda __len__ metodunu 
    yazmalıyız. __len__ metodunun yalnızca self parametresi vardır. Bu self parametresi len fonksiyonun argümanını oluşturmaktadır. 

#------------------------------------------------------------------------------------------------------------------------

class Sample:
    def __init__(self, *args):
        self.args = args
        
    def __len__(self):
        return len(self.args)
        
s = Sample(1, 2, 3, 4, 5, 10, 20)
result = len(s)
print(result)           # 7

print(s.__len__())      # 7

#------------------------------------------------------------------------------------------------------------------------
    Kendi sınıfımız türünden bir nesneyi biz int, float, bool, str, complex türlerine dönüştürmek istediğimizde bu dönüştürme 
    işlemi için sınıfımızın sırasıyla __int__, __float__, __bool__, __str__ ve __complex__ metotları çağrılmaktadır. Bu metotların
    yalnızca self parametreleri bulunmaktadır. Aslında biz daha önce __str__ metodunu görmüştük. Bu metot str türüne dönüştürülürken 
    çağrılıyordu. İşte diğer metotlar da diğer türlere dönüştürülürken çağrılmaktadır.
#------------------------------------------------------------------------------------------------------------------------

class Rational:
    def __init__(self, num, denom):
        self.num = num
        self.denom = denom
        
    def __float__(self):
        return self.num / self.denom;
    
r = Rational(1, 4)
result = float(r)
print(result)

#------------------------------------------------------------------------------------------------------------------------
    Bir sınıf türünden değişken köşeli parantez operatörüyle kullanıldığında sınıfın __getitem__ metodu çağrılmaktadır. 
    Böylece sanki sınıf türündne nesne bir liste gibi köşeli parantez operatörleriyle kullanılabilmektedir. Sınıf türünden 
    değişken atama operatörünün solunda da kullanılabilir. Bu durumda da __setitem__ metodu çağrılmaktadır. __getitem__ metodu self
    parametresinin indeks belirten bir parametre daha sahiptir. __setitem__ ise hem indeks belirten hem de atanacakl değeri belirten 
    iki ek parametreye sahiptir. Bu iki metodun parametik tapıladı şöyledir:

    def __getitem__(self, index):
        pass

    def __setitem__(self, index, value):
        pass

    Kullanım sırasında köşeli parantez içerisindeki ifade metotların index parametresine aktarılmaktadır. __setitem__ metodunun 
    üçüncü parametresi ise atanan değeri belirtmektedir. a bir sınıf nesnesi olmak üzere:

    b = a[index]

    Bu işlemin eşdeğeri şöyledir:

    b = a.__getitem__(index)

    Benzer biçimde:

    a[index] = value

    işlemiin de eşdeğeri şöyledir:

    a.__setitem__(index, value)

#------------------------------------------------------------------------------------------------------------------------

class Sample:
    def __init__(self, *args):
        self.args = list(args)
        
    def __getitem__(self, index):
        return self.args[index]
    
    def __setitem__(self, index, value):
        self.args[index] = value
        
    def __str__(self):
        return str(self.args)
    
    def __len__(self):
        return len(self.args)
    
s = Sample(10, 20, 30, 40, 50)

result = s[0]           # result = s.__getitem__(0)
print(result)           # 10

result = s[1] + 5       # result = s.__getitem__(1)  + 5
print(result)           # 25

s[2] = 100 + 200        # s.__setitem__(2, 300)
print(s)                # [10, 20, 300, 40, 50]

result = len(s)
print(result)           # 5

#------------------------------------------------------------------------------------------------------------------------
    Köşeli parantez operatöründe dilimleme yapabilmek için slice isminde bir sınıftn faydalanılmaktadır. slice sınıfı built-in 
    bir sınıftır. Bir slice nesnesi tek argümanla, iki argümanla ya da üç argümanla yaratılabilir. slice sınıfının start, stop ve 
    step isimli üç örnek özniteliği vardır. Eğer slice nesnesi tek argümanla yaratılmışsa start ve step None değerinde ancak stop 
    girilen argüman değerinde olur. slice nesnesi iki argümanla yaratılmışsa start birinci argümanın, stop ikinci argümanın değerinde olur ancak
    step None değrinde olur. slice nesnesi üç argümanla yaratılmışsa argümanlar sırasıyla start, stop ve step değerlerinde olur. 
    Örneğin:

    >>> s = slice(10)
    >>> print(s.start, s.stop, s.step)
    None 10 None
    >>> s = slice(10, 20)
    >>> print(s.start, s.stop, s.step)
    10 20 None
    >>> s = slice(10, 20, 2)
    >>> print(s.start, s.stop, s.step)
    10 20 2

    İşte biz köşeli parantez içerisinde dilimle yaparsak Python yorumlayıcısı bu dilimleme için __getitem__ ve __setitem__ 
    metotlarına slice nesnesi geçirmektedir. Yani örneğin:

    result = a[2:4]

    bu işlemin eşdeğeri şöyledir:

    result = a.__getitem__(slice(2, 4, 1))

    Örneğin:

    s[2:10:2] = 100

    Bu işlemin eşdeğeri de şöyledir:

    s.__setitem__(slice(2, 10, 2), 100)

    Örneğin biz listelerde, demetlerde dilimleme yaparken dilimleme yerine doğrudan slice nesnelerini kullanabiliriz. Zaten yorumlayıcı 
    dilimlemeyi gördüğünde onu slice nesnelerine dönüştürmektedir. Örneğin:

    >>> a = [10, 20, 30, 40, 50, 60]
    >>> a[2:4]
    [30, 40]
    >>> a[slice(2, 4, 1)]
    [30, 40] 

    O halde biz __getitem__ ve __setitem__ metotlarını yazarken index parametresinin bir slice nesnesi olup olmadığını isinstance 
    fonksiyonu ile kontrol edip uygun işlemleri yapabiliriz. 

    Aşağıdaki örnekte aslında __getitem__ metodunun index parametresi bir slice nesnesi olsa da zaten args örnek özniteliği bir liste olduğu için 
    o listede doğrudan kullanılabilirdi. Ancak biz bu örnekte genel olarak nbu metotlar içerisinde slice nesnelerinin fark edilip işleme 
    sokulması hakkında ip ucu veriyoruz.
#------------------------------------------------------------------------------------------------------------------------

class Sample:
    def __init__(self, *args):
        self.args = list(args)
        self.a = 0
        
    def __getitem__(self, index):
        if isinstance(index, int):
            return self.args[index]
        
        if isinstance(index, slice):
            return self.args[index.start:index.stop:index.step]
        
    """
    def __getitem__(self, index):
        return self.args[index]
    """
        
    def __setitem__(self, index, value):
        self.args[index] = value
        
    def __str__(self):
        return str(self.args)
    
    def __len__(self):
        return len(self.args)

s = Sample(10, 20, 30, 40, 50, 60, 70, 80)

result = s[2:4]     # result = s.__getitem__(slice(2, 4, 1))
print(result)
    
#------------------------------------------------------------------------------------------------------------------------
    Aşağıdaki örnekte Date sınıfına köşeli parantez desteği verilmiştir. Yani bu örnekte Date nesnesinin gün, ay, yıl bileşenlerine 
    sanki onlar bir diziymiş gibi erişebilmektedir. 
#------------------------------------------------------------------------------------------------------------------------

class Date:
    def __init__(self, day, month, year):
        self.day = day
        self.month = month
        self.year = year
        
    def __repr__(self):
        return f'{self.day}/{self.month}/{self.year}'
    
    def __getitem__(self, index):
        if index < 0 or index > 2:
            raise IndexError('out range')
        if index == 0:
            return self.day
        if index == 1:
            return self.month
        if index == 2:
            return self.year
        
    def __setitem__(self, index, value):
        if index < 0 or index > 2:
            raise IndexError('out range')
        if index == 0:
            self.day = value
        elif index == 1:
            self.month = value
        elif index == 2:
            self.year = value
    
d = Date(17, 10, 2022)
print(d[0])
print(d[1])
print(d[2])

d[1] = 1

print(d)

    
#------------------------------------------------------------------------------------------------------------------------
    Python'a 3'lü versiyonlarla birlikte "... (ellipsis)" biçiminde bir sabit de eklenmiştir. Önceleri bu sabit yalnızca 
    köşeli parantez içerisinde kullanılıyordu. Sonradan genelleştirildi. "..." sabiti aslında Ellipsis isimli anahtar sözcük 
    olan bir nesneyle temsil edilmektedir. Başka bir deyişle:

    a = ...

    ile

    a = Ellipsis 

    aynı anlamdadır. Tıpkı None sabitinde olduğu gibi Ellipsis sabiti için de toplamda tek bir nesne vardır. Yani program içerisindeki 
    bütün "..." sabitleri ve Ellipsis değişkenleri aslında aynı nesneyi göstermektedir. Bunun için iki Ellipsis nesnesi == ve != 
    operatörleriyle karşılaştırılabilir ya da benzer biçimde is ve is not operatötleriyle de karşılaştırmalar yapılabilir. Örneğin:

    >>> a = ...
    >>> a
    Ellipsis
    >>> type(a)
    <class 'ellipsis'>
    >>> id(a)
    140734384027912
    >>> b = Ellipsis
    >>> type(b)
    <class 'ellipsis'>
    >>> id(b)
    140734384027912
    >>> a == b
    True
    >>> a is b
    True

    CPython yorumlayıcısında Ellipsis değişkeni "ellipsis" isimli bir sınıf türündendir. Ancak Python standartları Ellipsis değişkeninin 
    ya da "..." sabitinin hangi sınıf türünden olması gerektiği konusunda bir açıklamada bulunmamıştır. 
#------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------
    Bir sınıfın bir metodunun self parametresiyle belirtilen nesnenin özniteliklerini kullanmadığını düşünelim. Örneğin
    tarih işlemlerini yapan Date isimli sınıfta parametresiyle aldığı bir yılın artık olup olmadığına geri dönen bir isleap metodu 
    düşünelim. Bu metot aslında bu self parametresini hiç kullanmamaktadır:

    class Date:
        def __init__(self, day, month, year):
            self.day = day
            self.month = month
            self.year = year
            
        def __repr__(self):
            return f'{self.day}/{self.month}/{self.year}'
        
        def isleap(self, year):
                return year % 4 == 0 and year % 100 != 0 or year % 400 == 0

    d = Date(10, 12, 2009)

    if d.isleap(2000):
        print('artık')
    else:
        print('artık değil')

    Buradaki isleap metodu self parametresini kullanmadığı halde mecburen Date sınıfı türünden bir nesneyle çağrılmak zorunda kalmıştır. 
    O zaman aklımıza bu metodun metot olarak değil de sınıfın dışında bir fonksiyon olarak yazılması gerektiği gelebilir:

    class Date:
        def __init__(self, day, month, year):
            self.day = day
            self.month = month
            self.year = year
            
        def __repr__(self):
            return f'{self.day}/{self.month}/{self.year}'
            
    def isleap(year):
        return year % 4 == 0 and year % 100 != 0 or year % 400 == 0"

    if isleap(2000):
        print('artık')
    else:
        print('artık değil')

    Ancak NYPT'de belli bir konu üzerinde işlem yapan fonksiyonların o konuya ilişkin sınıflarda ulundurulması iyi bir tekniktir. 
    O halde bizim şöyle bir şeye ihitiyacımız vardır. Bir fonksiyon hem bir metot olsun hem de self parametresine sahip olmasın.
    Yani global bir fonksiyon gibi metot olsun. Tabii bu durum self parametresini kaldırarak sağlanamaz. Çünkü self parametresinin ismi self 
    olmak zorunda değildir. Metotların birinci parametreleri simi ne olursa olsun self parametresidir. Dolayısıyla aşağıdaki gibi bir yazım 
    hatalıdır:

    class Date:
        def __init__(self, day, month, year):
            self.day = day
            self.month = month
            self.year = year
            
        def __repr__(self):
            return f'{self.day}/{self.month}/{self.year}'
            
        def isleap(year):
            return year % 4 == 0 and year % 100 != 0 or year % 400 == 0"

    if isleap(2000):
        print('artık')
    else:
        print('artık değil')

    isleap metodundaki year parametresi aslında self anlamındadır. 

    İşte bir fonksiyon hem bir sınıfın içerisinde olsun hem de self parametresine sahip olmasın isteniyorsa bu fonksiyonun 
    static metot yapılması gerekir. static metotlar self parametresine sahip değildir ancak sınıfın içerisinde bulunurlar.

    static metotlar @staticmethod biçiminde bir dekoratörle tanımlanırlar. Dekoratörler konusu izleyen bölümlerde ele alınmaktadır. 
    Bu durumda yukarıdaki date sınıfının isleap metodu aşağıdaki gibi static metot yapılabilir:

    class Date:
        def __init__(self, day, month, year):
            self.day = day
            self.month = month
            self.year = year
            
        def __repr__(self):
            return f'{self.day}/{self.month}/{self.year}'
        
        @staticmethod
        def isleap(year):
            return year % 4 == 0 and year % 100 != 0 or year % 400 == 0

    Artık burada isleap metodunun year parametresi birinci parametre olmasına karşın self anlamında dğeildir .
#------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------
                                                50. Ders 19/10/2022 - Çarşamba
#------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------
    Örneğin yukarıdaki Date sınıfına o anki tarihi veren today isimli bir metot eklemek isteyelim. Bu metot bir nesneyle çağrılmayacaktır.
    Yalnızca geri dönüş değeri olarak bir Date nesnesi verecektir. Bu metot tipik olarak sınıfın static bir metodu biçiminde yazılabilir. 
#------------------------------------------------------------------------------------------------------------------------

class Date:
    def __init__(self, day, month, year):
        self.day = day
        self.month = month
        self.year = year
        
    def __repr__(self):
        return f'{self.day}/{self.month}/{self.year}'
    
    @staticmethod
    def isleap(year):
        return year % 4 == 0 and year % 100 != 0 or year % 400 == 0
    
    @staticmethod
    def today():
        import datetime
        
        dt = datetime.date.today()
        d = Date(dt.day, dt.month, dt.year)
        
        return d;

d = Date.today()
print(d)

#------------------------------------------------------------------------------------------------------------------------
    Sınıfların statik metotlara benzer ismine "sınıf metotları (class methods)" denilen metotları da olabilmektedir. Sınıf metotlrı ile
    statik metotlar tamamen benzer amaçlarla kullanılırlar. Ancak sınıf metotlarının ekstra bir parametresi olur. Bunların birinci parametreleri 
    metodun çağrılmasında kullanılan (yani içinde bulunduğu sınıfa ilişkin) sınıfın type nesnesini almaktadır. Sınıf metotları @classmethod isimli
    dekoratörle dekore edilirler. Örneğin:

    class Sample:
        @staticmethod 
        def foo():
            pass

        @classmethod
        def bar(cls):
            pass

        def tar(self):
            pass

    Burada foo bir static metottur. bar ise bir sınıf metodudur. tar metodu normal bir metottur. bar metodunun cls parametresi self anlamında değildir. 
    Bu parametreye sınıfın type nesnesi geçirilir. 
#------------------------------------------------------------------------------------------------------------------------

class Sample:
    @classmethod
    def foo(cls):
        print(cls)                  # <class '__main__.Sample'>
        print(cls is Sample)        # True
        
Sample.foo()

s = Sample()
s.foo()

#------------------------------------------------------------------------------------------------------------------------
    Taban sınıfta bir sınıf metodu bulunyor olabilir. Bu sınıf metodu türemiş sınıf ismiyle çağrılırsa metodun cls parametresine 
    türemiş sınıfın type nesne referansı aktarılır. Böylece biz bu metodun hangi sınıf ismi ile çağrıldığını anlayabiliriz. 
    static metotlarda bunu anlayamayız. 
#------------------------------------------------------------------------------------------------------------------------

class Sample:
    @classmethod
    def foo(cls):
        print(cls)                  
        print(cls is Sample)        
    
    @staticmethod
    def bar():
        print('bar')
        
class Mample(Sample):
    pass
        
Sample.foo()
Mample.foo()
Mample.bar()

#------------------------------------------------------------------------------------------------------------------------
    Python'da özel bir durum vardır. Eğer sınıf içerisindeki bir metot hiç parametre almazsa Pyton'ın 3'lü versiyonlardında o metot
    sanki static bir metot gibi ele alınmaktadır. Bu durum Python'ın 2'li versiyonlarında geçersizdi. Örneğin:

    class Sample:   
        def foo():              # foo sanki statik metot gibi
            print('foo')
                
    Sample.foo()                # geçerli

    s = Sample
    s.foo()                     # geçerli

    Ancak yine statik metot parametresiz olsa bile onu açıkça @staticmethod dekoratörü ile dekore etmemiz iyi bir tekniktir. 
#------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------
    NYPT'de "dekoratör (decorator)" denilen bir "tasarım kalıbı (design pattern)" vardır. Python'da bu tasarım kalıbı sentaks 
    bakımından desteklenerek bir dil öğesi haline getirilmiştir. Bu sayede bazı tasarımlar daha özlü bir biçimde yapılabilmektedir. 

    Python'da dekoratörler fonksiyon ve metotlara ve sınıflara uygulanabilmektedir. Bir dekoratör bir fonksiyona ya da metoda uygulanmışsa 
    bunlara "fonksiyon dekoratörleri", bir sınıfa uygulanmışsa bunlara da "sınıf dekoratörleri" denilmektedir. Bir fonksiyonu ya da sınıfı
    dekora edebilmek için fonksiyon ya da sınıfın üstüne @isim biçiminde bir sentaksın eklenmesi gerekir. Örneğin:

    @foo
    def bar():
        pass

    Burada bar fonksiyonu dekore edilmiştir. Örneğin:

    @foo
    class Sample:
        pass

    Burada da Sample sınıfı dekore edilmiştir.

    Bir dekorasyon yaparken @ sembolünün sağındaki ismin "çağrılabilen (callable)" bir nesne belirtmesi gerekir. Yani bu isim tipik olarak 
    bir fonksiyon ismi olabilir ya da __call__ metodu bulunan bir sınıf nesnesi olabilir. 
#------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------
    Aşağıdaki gibi dekore edilmş bir fonksiyon olsun:

    @foo
    def bar():
        pass

    Bunun tamamen eşdeğeri şöyledir.

    def bar():
        pass
    bar = foo(bar)

    Yani @ atomunun yanındaki bir fonksiyondur (genel olarak calllable bir nesne). Dekore edilmiş fonksiyon bu fonksiyona parametre 
    yapılıp yeniden bu fonksiyon ismine atanmıştır. Bu durumda artık dekore edilmiş fonksiyonu çağıran birisi aslında dekoratör fonksiyonun geri 
    döndürdüğü fonksiyonu çağırmış olacaktır. Örneğin:

    def foo(f):
        print('foo')
        return 

    @foo
    def bar():
        print('bar')

    Burada aslında foo fonksiyonu çağrılmış geri dönüş değeri yine bar değişkenine atanmıştır. bar değişkeni yine bar fonksiyonunu belirtmektedir. 
    Ancak ekranda "foo" yazısı gözükecektir. Aşağıdaki örnekte dekoratör fonkisyonu başka bir fonksiyonla geri dönmüştür. O halde artık 
    bar ismi tar ismi ile fonksiyonu ile aynı fonksiyonu belirtmektedir. Ekranda foo ve tar yazıları görülecektir.

    def tar():
        print('tar')

    def foo(f):
        print('foo')
        return tar

    @foo
    def bar():
        print('bar')

    bar()
#------------------------------------------------------------------------------------------------------------------------

def tar():
    print('tar')

def foo(f):
    print('foo')
    return tar

@foo
def bar():
    print('bar')

bar()

#------------------------------------------------------------------------------------------------------------------------
    Dekoratörlerin en önemli kullanım nedeni "araya girme" işlemini gerçekleştirmektir. Yani biz bir fonksiyon çağırırken aslında başka bir 
    fonksiyonu çağırırız o fonksiyon da birşeyler çağırdığımızı sandığımız fonksiyonu çağırır. Böylece biz fonksiyonu her çağırdığımızda
    aslında bir araya girme işlemi yapılmış olur. Tabii bunun sağlanması için tipik olarak dekortör fonksiyonunun iç bir fonksiyonla
    geri dönmesi gerekir. Örneğin:

    def foo(f):
        def bar():
            print('araya giren kod')
            f()
        
        return bar

    @foo
    def tar():
        print('tar')
        
    tar()
    tar()
    tar()

    Burada aslında tar çağrıldığında foo'nun geri döndürdüğü bar çağrılmaktadır. Fakat bar da bir şeyler yapıp yine orijinal fonksiyon olan 
    tar'ı çağırmaktadır. Bu durumda aslında tar'ı çağıran kişi yine tar'ı çağırmış olacaktır. Ancak her çağırmada bir kod da çalışmış olacaktır. 

#------------------------------------------------------------------------------------------------------------------------

def foo(f):
    def bar():
        print('araya giren kod')
        f()
    
    return bar

@foo
def tar():
    print('tar')
    
tar()
tar()
tar()

#------------------------------------------------------------------------------------------------------------------------
    Tabii yukarıdaki araya girme işlemini daha genel bir biçimde yapabiliriz. Yani örneğin tar fonksiyonun bir geri dönüş değeri ve 
    parametreleri de söz konusu olabilir. Bunu yapabilmek için geri döndürülen fonksiyonun *'lı ve **'lı parametrelere sahip olması 
    ve bunu yine *'lı ve **'lı argümanlarla iletebilmesi gerekmektedir. 
#------------------------------------------------------------------------------------------------------------------------

def foo(f):
    def bar(*args, **kwargs):
        print('araya giren kod')
        return f(*args, **kwargs)
    
    return bar

@foo
def tar(a, b, c):
    print(f'tar: {a}, {b}, {c}')
    
tar(10, 20, c=30)

#------------------------------------------------------------------------------------------------------------------------
    Pekiyi dekoratörler araya girmeyi sağlıyorsa araya girmenin na anlamı olabilir? İşte araya giren kod arka planda bizim 
    için bazı faydalı işlemleri yapıyor olabilir. Örneğin araya giren kod bir log oluşturabilir. Aşağıdaki örnekte foo isimli dekoratör
    aslında arka planda ilgili fonksiyonun kaç kere çağrıldıüı bilgisini tutmaktadır. 
#------------------------------------------------------------------------------------------------------------------------

count = 0

def foo(f):
    def bar(*args, **kwargs):
        global count
        
        count += 1
        
        return f(*args, **kwargs)
    
    return bar

@foo
def tar():
    print('tar')
    
tar()
tar()
tar()

print(count)

#------------------------------------------------------------------------------------------------------------------------
    Tabii dekorasyonun illa da @ atomuyla yapılması gerekmez. Biz dekorasyonla eşdeğer olan çağrıyı kendimiz de yapabiliriz. 
    Örneğin:

    math.sqrt = foo(math.sqrt)

    Burada biz sqrt fonksiyonunu dekore etmiş olduk. Görüldüğü gibi dekorasyon için @ sentaksı yalnızca bir kolaylık sağlamaktadır. 
#------------------------------------------------------------------------------------------------------------------------

count = 0
def foo(f):
    def bar(*args, **kwargs):
        global count
        
        count += 1
        
        return f(*args, **kwargs)
    
    return bar

import math

math.sqrt = foo(math.sqrt)

result = math.sqrt(10)
result = math.sqrt(20)
result = math.sqrt(30)

print(count)   

#------------------------------------------------------------------------------------------------------------------------
    Daha önce görmüş olduğumuz @staticmethod ve @classmethod da aslına birer built-in callable nesnelerdir. 
#------------------------------------------------------------------------------------------------------------------------

class Sample:
    @staticmethod
    def foo():
        print('foo')
        
    def bar():
        print('bar')    
    bar = staticmethod(bar)
    
Sample.foo()
Sample.bar()

#------------------------------------------------------------------------------------------------------------------------
    Aslında araya girme işlemi bir sınıf yoluyla da yapılabilir. Genellikle bu yöntem daha fazla tercih edilmektedir. Örneğin:

    @Sample
    def foo():
        pass

    Bu kodun eşdeğeri aşağıdaki gibidir:

    def foo():
        pass
    foo = Sample(foo)    

    Burada eğer Sample bir sınıf ise aslında artık foo Sample sınıfı türünden bir nesne haline gelecektir. O halde biz bu foo'yu
    çağırdığımızda aslında Sample sınıfının __call__ metodu çağrılacaktır. 

    class Sample:
        def __init__(self, f):
            self.f = f
            
        def __call__(self, *args, **kwargs):
            print('araya giren kod')
            return self.f(*args, **kwargs)
            
    @Sample
    def foo():
        print('foo')
        
    foo()
    
#------------------------------------------------------------------------------------------------------------------------

class Sample:
    def __init__(self, f):
        self.f = f
        
    def __call__(self, *args, **kwargs):
        print('araya giren kod')
        return self.f(*args, **kwargs)
        
@Sample
def foo():
    print('foo')
    
foo()

#------------------------------------------------------------------------------------------------------------------------
                                                51. Ders 24/10/2022 - Pazartesi
#------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------
    Görüldüğü gibi dekoratörler aslında arka planda birtakım işlemlerin pratik bir biçimde yapılması için araç oluşturmaktadır. 
    Örneğin bir dekoratör fonksiyonun çalışma zamanını ölçerek geri dönüş değeri biçiminde bize verebilir. Bu durumda dekore edilmiş
    fonksiyonun geri dönüş değerine ilaveten fonksiyonun çalışma zamanı da bize veriliyor olabilir. 
#------------------------------------------------------------------------------------------------------------------------

import time

class Profiler:
    def __init__(self, f):
        self.f = f
        
    def __call__(self, *args, **kwargs):
       start = time.time()
       retval = self.f(*args, **kwargs)
       stop = time.time()
       
       return stop - start, retval 
       
@Profiler
def add_total(n):
    time.sleep(1000)
    total = 0
    for i in range(n):
        total += i
        
    return total
    
runtime, total= add_total(1000000000)

print(runtime, total)

#------------------------------------------------------------------------------------------------------------------------
    Aslında daha önce görmüş olduğumuz statc ve class metotların yazılmasında kullanılan @staticmethod ve @classmethod
    sentaksı bir dekoratördür. 
#------------------------------------------------------------------------------------------------------------------------

class Sample:
    @staticmethod
    def foo():
        print('static method')
        
class Mample:
    def foo():
        print('static method')
    foo = staticmethod(foo)
    
Sample.foo()
Mample.foo()

#------------------------------------------------------------------------------------------------------------------------
    Dekoratörler fonksiyonların yanı sıra sınıf tanımlamalarında da kullanılabilmektedir. Bunlara sınıf dekoratörleri denilmektedir. 
    Sınıf dekoratörlerin genel biçimi şöyledir:

    @decorator
    class class_name:
        pass

    Sınıf dekoratörlerinde de dekoratör yine bir fonksiyon ya da sınıf olabilir. Mekanizmanın çalışma biçimi aynıdır. Yani:

    @decorator
    class class_name:
        pass

    işleminin eşdeğeri şöyledir:

    class class_name:
        pass
    class_name = decorator(classd_name)

    Aşağıdaki örnekte yorumlayıcı sınıf tanımlamasını gördüğünde aslında foo fonksiyonunu çağırmaktadır. Bu örnekte 
    foo fonksiyonu da aynı type nesnesi ile geri dönmüştür. Ancak bir araya girme işlemi yapılmıştır.

#------------------------------------------------------------------------------------------------------------------------

def foo(c):
    print('foo')
    return c

@foo
class Sample:
    pass

#------------------------------------------------------------------------------------------------------------------------
    Sınıf dekoratörleri sayesinde örneğin biz bir sınıf türünden nesne yaratıldığında araya girip bir şeyler yapabiliriz. 
    Genellikle burada araya giren kodlar nesne üzerinde bazı öznitelikleri de arka planda yaratmaktadır. 

    Aşağıdaki örnekte Samplke sınıfı türünden bir nesne yaratıldığında bar fonksiyonu çağrılmaktadır. Aslında bar fonksiyonu
    Sample nesnesini yaratmaktadır:

    def foo(c):
        def bar():
            print('bar')
            return c()
        return bar

    @foo
    class Sample:
        def disp(self):
            print('disp')

    # Sample = foo(Sample)

    s = Sample()
    s.disp()


    k = Sample()
    k.disp()

    Bu örnekte Sample değişkeninin aslında type nesnesini göstermediğine bar fonksiyonunu gösterdiğine dikkat ediniz. Ancak bar fonksiyonu da 
    zaten Sample nesnesini yaratıapa aonunla geri döndüğü için programcının gerçek olanı biliyor olması gerekmez. Burada programcı Sample 
    nesnesini Sample(...) ifadesiyle yaratmaktadır. Programcının istediği olmaktadır. Ancak arka planda başka şeyler de yapılmaktadır.
#------------------------------------------------------------------------------------------------------------------------

def foo(c):
    def bar(*args, **kwargs):
        print('bar')
        return c(*args, **kwargs)
    return bar

@foo
class Sample:
    def disp(self):
        print('disp')

# Sample = foo(Sample)

s = Sample()
s.disp()


k = Sample()
k.disp()

#------------------------------------------------------------------------------------------------------------------------
    Tabii yukarıdaki örnekte iç fonksiyon kullanmak yerine dekoratör olarak bir sınıf da kullanabilirdik. Genel olarak dekoratör 
    olarak sınıf kullanmak tercih edilmektedir. 
#------------------------------------------------------------------------------------------------------------------------

class foo:
    def __init__(self, cls):
        self.cls = cls
        
    def __call__(self, *args, **kwargs):
        print('araya giren kod')
        return self.cls(*args, **kwargs)

@foo
class Sample:
    def disp(self):
        print('disp')

# Sample = foo(Sample)

s = Sample()
s.disp()

k = Sample()
k.disp()

#------------------------------------------------------------------------------------------------------------------------
    Bu tür sınıf dekoratörleri bazı framework'ler tarafından bazı karmaşık işlemleri yapmak için kullanılabilmektedir. 
    Örneğin bir sınıf içerisine gizlice bir metot eklemek, sınıf türünden nesnelerin içerisine öznitelikler eklemek 
    sık karşılaşılan durumlardandır.

    Aşağıda örnekte bir sınıfa dekoratör yoluyla aslında o sınıfta olmayan bir metot eklenmiştir. Aynı zamanda o sınıf türünden 
    nesne her yaratıldığında ona arka planda bir örnek özniteliği de eklenmiştir. Tabii bu örnekte neden sınıfa bu eklemelerin yapıldığını 
    merak edebilirsiniz. Bu tür uygulamalar genellikle ileri düzey frtamework'lerde karşımıza çıkmaktadır.
#------------------------------------------------------------------------------------------------------------------------

def test(self):
    print('test')

class foo:
    def __init__(self, cls):
        self.cls = cls
        cls.test = test
        
    def __call__(self, *args, **kwargs):
        obj = self.cls(*args, **kwargs)
        obj.x = 'this is a test'
        return obj
@foo
class Sample:
    def disp(self):
        print('disp')

# Sample = foo(Sample)

s = Sample()
s.test()
print(s.x)

#------------------------------------------------------------------------------------------------------------------------
    Yukarıdaki örnekler bu tür temalarla ilk kez karşılaşanlara kavramsal olarak karmaşık ve biraz da soyut gelmektedir. 
    Bu konuyla ilgili olan diğer ileri bir konu da "meta class" konusudur. Biz bu "meta class" konusunu Python Uygulamaları kursunda
    göreceğiz. Böylece kişilerin anlaması bazı konuları gördükten ve uygulamaları yaptıktan sonra daha kolay olacaktır.
#------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------
    Dekoratörler parametre de alabilmektedir. Örneğin log isimli bir dekoratör olsun. Bu dekoratör bir fonksiyon çağrıldığında 
    çağrılma zamanını, fonksiyonun çalışma zamanını bir log dosyasına yazıyor olsun. ama onun yazacağı dosyayı biz belirleyecek olalım. 
    İşte bu tür durumlarda dekoratörlerin parametre alması gerekebilmektedir. Örneğin:

    @log('test.log')
    def foo():
        pass

    Parametreli dekoratörler aslında callable bir nesnenin çağrısı sonucunda elde edilen callable nesneyi dekoratör olarak kullanmaktadır. 
    Başka bir deyişle örneğin:

    @decorator(a, b, c)
    def foo():
        pass

    Tanımlamasının eşdeğeri şöyledir:

    foo = decorator(a, b, c)(foo)

    Burada aslında parametreli dekoratör çağrılmış bunun geri dönüş değeri yeniden çağrılmıştır. Yani parametreli dekoratörün çağrılması sonucunda
    yine bir callable nesne elde edeilmelidir. 

    Aşağıdaki örnekte bar fonksiyonu tar fonksiyonuna tar fonksiyonu da zar fonksiyonuna geri dönmektedir. Böylece aslında foo fonksiyonu
    çağrıldığında zar fonksiyonu çağrılmaktadır. zar fonksiyonu da dekoratör parametrelerini kullanabilmektedir. 
#------------------------------------------------------------------------------------------------------------------------

def bar(a, b, c):
    print('bar')
    def tar(f):
        print('tar')
        def zar(*args, **kwargs):
            print(f'her çağrışta araya giren kod dekoratör parametrelerini kullanabiliyor: {a}, {b}, {c}')
        return zar
    return tar
    
@bar(10, 20, 30)
def foo():
    print('foo')
    
foo()
foo()

"""
Eşdeğeri

def foo():
    print('foo')
foo = bar(10, 20, 30)(foo)

foo()   # aslında zar çağrılıyor
foo()   # aslında zar çağrılıyor

"""
Ekran çıktısı şöyle oalacaktır:

bar
tar
her çağrışta araya giren kod dekoratör parametrelerini kullanabiliyor: 10, 20, 30
her çağrışta araya giren kod dekoratör parametrelerini kullanabiliyor: 10, 20, 30
"""

#------------------------------------------------------------------------------------------------------------------------
    Aşağıdaki örnekte her ne kadar henüz dosya işlemlerini görmediysek de fonksiyon çağrıldıkça bir dosyaya log bilgilerini yazan
    örnek bir parametreli dekoratör verilmiştir.
#------------------------------------------------------------------------------------------------------------------------

import datetime
import time

def log(file):
    def loglog(f):
        def logloglog(*args, **kwargs):
            now = datetime.datetime.now()
            file.write(f'{f.__name__} => {now.hour}:{now.minute}:{now.second} ')
            start = time.time()
            retval = f(*args, **kwargs)
            stop = time.time()
            file.write(f'({stop - start})\n')
            file.flush()
            return retval
        
        return logloglog
    
    return loglog

f = open('test.txt', 'w')

@log(f)
def get_total(n):
    total = 0
    for i in range(n):
        total += i
    return total
        
result = get_total(100000000)
print(result)  

result = get_total(1000000)
print(result)     

f.close() 

#------------------------------------------------------------------------------------------------------------------------
    Parametreli dekoratörler de bir sınıf biçiminde yazılabilirler. Aşağıda bu işlemin nasıl yapılabileceğine ilişkin bir 
    fikir verilmiştir.
#------------------------------------------------------------------------------------------------------------------------

class decorator:
    def __init__(self, a, b, c):
        self.a = a
        self.b = b
        self.c = c
        
    def __call__(self, f):
        self.f = f
        return self.proc
        
    def proc(self, *args, **kwargs):
        print(f'fonksiyon her çağrıldığında dekoratör parametrelerini kullanabiliyor: {self.a}, {self.b}, {self.c}')
        return self.f(*args, **kwargs)
        
@decorator(10, 20, 30)
def foo():
   print('foo')
  
# foo = decorator(10, 20, 30)(foo)

foo()
foo()

#------------------------------------------------------------------------------------------------------------------------
    Dekoratör olarak sınıf kullanarak yukarıdaki log örneğini de aşağıdaki gibi yapabiliriz. 
#------------------------------------------------------------------------------------------------------------------------

import datetime
import time

class log:
    def __init__(self, file):
        self.file = file
        
    def __call__(self, f):
        self.f = f
        
        return self.do_log
    
    def do_log(self, *args, **kwargs):
        now = datetime.datetime.now()
        self.file.write(f'{self.f.__name__} => {now.hour}:{now.minute}:{now.second} ')
        start = time.time()
        retval = self.f(*args, **kwargs)
        stop = time.time()
        self.file.write(f'({stop - start})\n')
        self.file.flush()
        return retval

f = open('test.txt', 'w')

@log(f)
def get_total(n):
    total = 0
    for i in range(n):
        total += i
    return total
        
result = get_total(100000000)
print(result)  

result = get_total(1000000)
print(result)     

f.close() 

#------------------------------------------------------------------------------------------------------------------------
    Sonuç olarak biz bir fonksiyonundekore edildiğini gördüğümüzde şunu düşünmeliyiz: "Bu fonyksiyonu çağırdığımda aslında 
    ben muhtemelen başka bir fonksiyonu çağırmış olacağım. Ama o fonksiyon da benim fonksiyonumu çağıracak. Fakat bu arada
    benim faydama bazı şeyler de arka planda yapılmış olacak". Benzer biçimde bir sınıf dekoratörünü gördüğümüzde de 
    şunu düşünmeliyiz: "Bu sınıfa benim eklediklerimden başka şeyler de eklenşyor olabilir. Ben bu sınıf türünden nesne yarttığımda 
    arka planda başka şeyler de yapılıyor olabilir. Yarattığım nesneye bazı öznitelikler de ekleniyor olabilir."
#------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------
                                                52. Ders 26/10/2022 - Çarşamba
#------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------
   İngilizce "exception" sözcüğü "istisna" anlamına gelmektedir. Ancak bu sözcük yazılımda "programın çalışma zamanı sırasında oluşan 
   problemlemli durumları" anlatmak için kullanılmaktadır. Exception mekanizması genel olarak nesne yönelimli programlama dillerinde bulunmaktadır.
   Prosedürel dillerin çoğunda bu mekanizma yoktur. Exception programın çalışma zamanına ilişkin bir kavramdır. Etimolojik kökeni 
   donanımsal sorunlara dayanmaktadır.

   Bir exception oluştuğunda exception'ın ele alınması (exception handling) gerekir. Eğer exception ele alınmazsa program çöker. 
   Python'da exception'ların birers ınıf ismi vardır. Bu isimler XXXError biçimindedir (örneğin TypeError, IndexError, ValueError gibi).
   Örneğin:

   >>> int('ali')
    Traceback (most recent call last):
    File "<stdin>", line 1, in <module>
    ValueError: invalid literal for int() with base 10: 'ali'
    >>> 10 + 'ali'
    Traceback (most recent call last):
    File "<stdin>", line 1, in <module>
    TypeError: unsupported operand type(s) for +: 'int' and 'str'
    >>> a = [1, 2, 3]
    >>> a[10]
    Traceback (most recent call last):
    File "<stdin>", line 1, in <module>
    IndexError: list index out of range

    Bir exception oluştuğunda programın çökmemesi için exception'ın ele alınması (handle edilmesi) gerekir. Çünkü hatalıu bir 
    durum oluştuğunda başka şeyler denenebilir. Ya da hata düzeltilip programın devam etmesi istenebilir. 

    Python'da exception'ların ele alınması için "try", "except", "finally" ve "raise" anahtar sözcükleri kullanılmaktadır. try deyiminin genel biçimi
    şöyledir:

    try: <suit>

    try deyimi tek başına bulundurulamaz. try deyimini except blokları ya da finally bloğu izlemek zorundadır. except ve finally 
    bloklarının genel biçimi şöyledir:

    except [<exception sınıf bildirimleri>] [as <değişkenismi>]: <suit>
    finally <suit>

    try bloğunu bir ya da birden fazla except bloğu izleyebilir. Ya da try bloğunu hiç except bloğu olmadan finally bloğu da izleyebilir. 
    eğer try bloğunu except bloğu izliyorsa finally bloğu isteğe bağlı olarak except bloklarının sonuna yerleştirilebilir. 
    except anahtar sözcüğünün yanında bie exception sınıf ismi bulunur. Eğer birden fazla exc eption sınıf ismi bulunduurlacaksa 
    parantezler içerisinde demet sentaksıyla bu sınıfların belirtilmesi gerekir. Exception sınıf isimlerinden sonra isteğe bağlı olarak
    as anahtar sözcüğü ve değişken ismi getirilebilir. Örneğin geçerli except blokları şöyle olabilir:

    except TypeError:
        pass

    except (TypeError, IndexError):
        pass

    except IndexError as e:
        pass

    except (TypeError, IndexError) as e:
        pass

    except anahtar sözcüğünden sonra hiçbir şey de bulunmayabilir. Örneğin:

    except:
        pass

    try bloğunu bir ya da birden fazla except bloğu izleyebilir ya da finally bloğu izleyebilir. finally bloğu her zaman en sonda
    bulunmak zorundadır. Örneğin:

    try:
        pass
    except IndexError:
        pass
    except ValueError:
        pass
    finally:
        pass

    Aşağıdaki sentaks da geçerlidir:

    try:
        pass
    finally:
        pass

    Tabii finally bloğu da bulunmak zorunda değildir:

    try:
        pass
    except IndexError:
        pass

    Ancak yalnızca try bloğu bulunamaz. 

#------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------
    Exception mekanizması şöyle çalışlmaktadır: Programın akışık try bloğuna girdikten sonra bir exception kontrolü 
    uygulanır. Akış try bloğuna girdikten sonra herhangi bir yerde exception oluşursa akış bir goto işlemi gibi oluşan exception'ın türüne 
    uygun olan except bloğuna aktarılır. İlgili except bloğu çalıştırılır, diğer except blokları atlanır. Akış except bloklarının sonundan 
    devam eder. Eğer programın akışı try bloğuna girdikten sonra hiç exceptionb oluşmazsa akış try bloğunun sonuna geldiğinde except 
    blokları atlanır ve akış except bloklarının sonundan devam eder. Yani except blokları "exception oluşursa çalıştırılmaktadır". Exception
    oluşmazsa onların bir işlevi kalmaz. Bir exception oluştuğunda akış o exception ile aynı türden except bloğuna aktarılmaktadır. 
    except bloklarının yalnızca bir tanesi çalıştırılmaktadır. (Yani bunlar adeta match/case gibi işlem görmektedir). 
    Exception nerede oluşursa oluşsun akış except bloğuna aktarıldıktan sonra bir daha geri dönmez. except bloklarının sonundan devam eder. 
    finally bloğu ve parametresiz except bloğu daha ileride ele alınacaktır. Bir exception oluştuğunda bu exception'ın türüne uygun bir except
    bloğunun bulunyor olması gerekir. Aksi takdirde yine program çökecektir. 
#------------------------------------------------------------------------------------------------------------------------

def tar():
    print('tar başladı')
    int('xxxxx')        # ValueError oluşacak
    print('tar bitti')

def bar():
    print('bar başladı')
    tar()
    print('bar bitti')

def foo():
    print('foo başladı')
    bar()
    print('foo bitti')

try:
    foo()
except ValueError:
    print('ValueError yakalandı')
print('program devam ediyor')

#------------------------------------------------------------------------------------------------------------------------
    Python'da en çok karşılaşılan altı Exception sınıfı vardır: ValueError, TypeError, IndexError, KeyError, NameError ve AttributeError. Bir fonksiyonun ya da 
    metodun parametresi uygun girilmemişse genel olarak ValueError oluşur. Ancak bir fonksiyona argüman olarak yanlış bir tür verilmişse 
    ya da bir işlemde türler uygunsuz ise TypeError oluşmaktadır. Örneğin int('xxx') işlemi ValueError oluşturur. Çünkü burada int fonksiyonu
    str türünden bir argüman alabilir. Ama aldığı argümanın içeriği hatalıdır. Fakat örneğin z bir complex nesnesi olmak üzere int(z) 
    gibi bir işlem TypeError oluşturur. Çünkü int fonksiyonu argüman olarak complex türünden bri nesne alamaz. Yani tür uygun ancak 
    içerik uygun değilse ValueError, tür uygun değilse TypeError oluşmaktadır. Bir liste, demet gibi indekslenebilir nesnelerde 
    indeksin uygun bir değer belirtmemesi durumunda (örneğin 10 elemanlı bir listede 20'inci elemana erişmek istediğimiz bir durumda)
    IndexError oluşmaktadır. Sözlük tarzı bir veri yapısında köşeli parantezler içerisinde anahtar verildiğinde böyle bir anahtar
    bulunamadıysa KeyError oluşmaktadır. Bir değişken kullanıldığında henüz o değişken yaratılmamışsa NameError oluşmaktadır.
    Bir sınıf türünden değişken nokta operatörüyle kullanıldığında o değişken yaratılmış olabilir ama nokta operatörünün sağındaki 
    öznitelik yaratılmamış olabilir. Bu durumda ise AttributeError exception'ı oluşmaktadır. Yani a.b gibi bir ifadede a yoksa NameError ancak
    a var fakat b yoksa AttributeError oluşur. Tüm sınıflar built-in sınıflardır. Yani hiçbir şeyi import etmeden bu sınıfları kullanabiliriz. 
#------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------
    Aşağıdaki örnekte klavyeden bir sayı okunmak istenmiştir. Kullanıcı sayı olarak yanlış bir giriş yapmışsa sayı yeniden 
    istenmiştir.
#------------------------------------------------------------------------------------------------------------------------

while True:
    try:
        val = int(input('Bir sayı giriniz:'))
        print(val * val)
        break
    except ValueError:
        print('Girdiğiniz sayı geçersiz!')

#------------------------------------------------------------------------------------------------------------------------
    Exception'ı oluşturan asıl deyim raise deyimidir. Exception'lar kendiliğinde oluşmaz. Exceptyion'ı oluşturmk için raise 
    anahtar sözcüğünü kullanmak gerekir. raise deyiminin genel biçimi şöyledir:

    raise <exception sınıf nesnesi>

    raise anahtar sözcüğünün yanında exception nesnesi bulunur. Bir problem ortaya çıktığında programcı bir exception nesnesi 
    oluşturur. Probleme ilişkin bazı bilgileri eğer gerekiyorsa o nesnenin örnek özniteliklerine yazar ve o nesneyle raise işlemi yapar. 
    C++ gibi bazı programlama dillerinde bu tür işlemlerde herhangi bir türden nesneler kullanılabilmektedir. Ancak Java gibi, C# gibi,
    Python gibi dillerde exception nesneleri özel sınıflardan türetilmiş olan sınıflar türünden olmak zorundadır. 

    Aşağıdaki örnekte foo fonksiyonu negatif parametreleri kabul etmemektedir. Eğer fonksiyon negatif bir değerle çağrılırsa exception
    oluşturmaktadır.
#------------------------------------------------------------------------------------------------------------------------

def foo(a):
    print('foo başladı')
    if a < 0:
        raise ValueError()
    print('foo bitti')
    
try:
    foo(1)
    print('her şey yolunda')
except ValueError:
    print('hata oluştu')
print('program bitiyor')

#------------------------------------------------------------------------------------------------------------------------
    Programcı kendi exception sınıflarını yazabilir ve onları kullanabilir. Bir sınıf ile raise işleminin yapılabilmesi için ve o sınıfın 
    except anahtar sözcüğünün yanında kullanılabilmesi için BaseException isimli built-in bir sınıftan türetilmiş olması gerekir. 
    Tabii bizim kendi exception sınıflarımızı hemen BaseException sınıfından türetmemiz gerekmez. Önemli olan o sınıftan yukarıya çıkıldığında 
    BaseException sınıfının bulunuyor olmasıdır. Örneğin biz ValueError sınıfından da sınıf türetip onu kullanabiliriz. 
    BaseException sınıfından türetilmiş olan en önemli sınıf Exception sınıfıdır. Yukarıda sözünü ettiğimiz TypeError, ValueError, NameError,
    AttributeError sınıfları Exception sınıfından türetilmiştir. IndexError ve KeyError sınıfları LookupError sınıfından, LookupError 
    sınıfı da Exception sınıfından türetilmiş durumdadır.

    Aşağıdaki örnekte ValueError sınıfından NegativeError sınıfı türetilip bu sınıf türünden bir nesneyle raise işlemi yapılmıştır.
#------------------------------------------------------------------------------------------------------------------------

class NegativeError(ValueError):
    pass

def foo(a):
    print('foo başladı')
    if a < 0:
        raise NegativeError()
    print('foo bitti')
try:
    foo(-1)
    print('her şey yolunda')
except NegativeError:
    print('hata oluştu')
print('program bitiyor')

#------------------------------------------------------------------------------------------------------------------------
    raise deyiminde yalnızca exception sınıfının ismi de yazılabilir. Bu durumda yorumlayıcı bu sınıf türünden nesneyi yaratıp o nesne ile 
    raise işlemş yapmaktadır. Yani:

    raise ValueError

    ile

    raise ValueError()

    tamamen aynı anlamdadır.
#------------------------------------------------------------------------------------------------------------------------
    
#------------------------------------------------------------------------------------------------------------------------
   Exception sınıflarının __init__ metotları *args parametresine sahiptir ve bu args parameresi nesnenin args isimli özniteliğinde
   saklanmaktadır. Yani biz bir exception nesnesini istediğimiz kadar argüman girerek yaratabiliriz. Sonra bu argümanları 
   sınıfın args örnek özniteliğinden bir demet biçiminde elde edebiliriz. Exception sınıflarının __repr__ ve __str__ metotları 
   yazılmış durumdadır. __str__ metodu eğer nesne yaratılırken tek bir argüman girilmişse o argümanı bir yazı olarak verir. 
   Ancak birden fazla argüman girilmişse o argümanları demet sentaksıyla bir yazı olarak vermektedir. Örneğin:

   >>> ve = ValueError('test')
    >>> str(ve)
    'test'
    >>> ve = ValueError('test', 123)
    >>> str(ve)
    "('test', 123)"
    >>> ve
    ValueError('test', 123)

    Aslında bu args özniteliği BaseException sınıfında oluşturulmuştur. Örneğimn ValueError sınıfının __init__ metodu aslında 
    doğrudan super çağrısı ile aldığı args parametresini üst sınıfa yollamaktadır. args örnek özniteliği aslında BaseException sınıfının __init__ 
    metodunda oluşturulmaktadır. Yani başka bir deyişle ValueError gibi bir sınıfın __init__ metodu muhtemelen şöyle oluşturulmuştur:

    class ValueError(Exception):
        def __init__(self, *args):
            super(*args)
        
    Bu durumda programcı da kendi exception sınıfları için aynı şeyi yapabilir:

    class NegativeError(Exception):
        def __init__(self, *args):
            super().__init__(*args)
#------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------
                                 
#------------------------------------------------------------------------------------------------------------------------
                                                            53. Ders 31/10/2022 - Pazartesi
#------------------------------------------------------------------------------------------------------------------------
   
#------------------------------------------------------------------------------------------------------------------------
    Bir exception raise deyimi ile fırlatıldığında oluşan exception yakalandığında exception nesnesi except bloğunun as 
    ile belirtilen değişkenine atanmaktadır. Böylece programcı oluşan exception nesnesini as ile elde edip içerisindeki bilgilere
    args özniteliği ile erişebilmektedir. Örneğin:

    try:
        foo()
    except ValueError as e:
        print(e)

    Anımsanacağı gibi temel exception sınıflarıın __str__ ve __repr__ metotları yazılmış durumdadır. Aşağıdaki örnekte 
    foo fonksiyonu içerisinde bir exception fırlatılmıştır. Bu exception bir mesaj ve error numarası içermektedir. Exception'ı 
    yakalayan kişi args parametresinden bu bilgilere erişip bunları kullanabilir. 
#------------------------------------------------------------------------------------------------------------------------

def foo(a):
    if a < 0:
        raise ValueError('value must not be negative', 123)
    print('ok')        
    
try:
    foo(-4)
except ValueError as e:
    print(f'Exception occured with message "{e.args[0]}", error code: {e.args[1]}')
    
#------------------------------------------------------------------------------------------------------------------------
    Programcı kendi exception sınıflarını oluşturup yine aynı biçimde kendi exception nesneleriyle exception fırlatabilir. 
#------------------------------------------------------------------------------------------------------------------------

class NegativeError(Exception):
    def __init__(self, *args):
        super().__init__(*args)

def foo(a):
    if a < 0:
        raise NegativeError('value must not be negative', 123)
    print('ok')        
    
try:
    foo(-4)
except NegativeError as e:
    print(f'Exception occured with message "{e.args[0]}", error code: {e.args[1]}')
    
#------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------
    Programcı genellikle zaten var olan exception sınıflarını kullanır. Ancak bazen var olan exception sınıfları yetersiz kalabilmektedir. 
    Bu tür durumlarda programcılar kendi exception sınıflarını yazarlar. Standart kütüphanede de built-in exception sınıflarının dışında 
    o modüle özgü çeşitli exception sınıfları kullanılmıştır. 
#------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------
    Anımsanacağı gibi birden fazla türdeki exception demet sentaksıyla tek bir except bloğu tarafından yakalanabiliyordu. 
    Bu durumda yine as cümleceği kullanılabilir. Ancak tabii yakalanan exception'ın türünü programcı ancak isinstance fonksiyonuyla 
    anlayabilir. Örneğin:

    try:
        foo(1000)
    except (ValueError, TypeError) as e:
        print(e)

    Burada ValueError oluşursa e değişkeni ValueError nesnesini, TypeError oluşursa e değişkeni TypeError nesnesini tutar. 
    Oluşan mesaj düzgün bir biçimde yazdırılacaktır. 
#------------------------------------------------------------------------------------------------------------------------

def foo(a):
    if not isinstance(a, int):
        raise TypeError('argument must be int')
    
    if a > 100 or a < 0:
        raise ValueError('A must be 0-100 range')
        
    print('Ok')

try:
    foo(1000)
except (ValueError, TypeError) as e:
    print(e)
    
#------------------------------------------------------------------------------------------------------------------------
    Türemiş sınıf türünden oluşan bir exception taban sınıf türünden bir except bloğu tarafından yakalanabilir. Örneğin bu sayede
    biz tüm exception'ları BaseException ya da Exception sınıflarıyla yakalaybiliriz. 
#------------------------------------------------------------------------------------------------------------------------

def foo(a):
    if not isinstance(a, int):
        raise TypeError('argument must be int')
    
    if a > 100 or a < 0:
        raise ValueError('A must be 0-100 range')
        
    print('Ok')
try:
    foo(1000)
except Exception as e:
    print(e)

#------------------------------------------------------------------------------------------------------------------------
    Aşağıdaki örnekte klavye kuması sırasında oluşan hatalar doğrudan Exception sınıfı ile yakalanmıştır. 
#------------------------------------------------------------------------------------------------------------------------

try:
    val = int(input('Bir sayı giriniz:'))
    print(val * val)
except Exception as e:
    print(e)

#------------------------------------------------------------------------------------------------------------------------
   Bazen programcı bazı özel exception'ları ilgili exception sınıfı türünden except blokları ile yakalayıp işlemek isteyebilir. 
   Ancak geri kalan exception'ların hepsini Exception parametreli bir except bloğu ile işlemek isteyebilir. Yani başka bir deyişle
   hemen taban sınıfa ilişkin hem de türemiş sınıfa ilişkin except bloklarını bulundurabilir. İşte bu tür durumlarda except bloklarına yukarıdan
   aşağıya doğru baklıdığı için türemiş sınıfa ilişkin except bloğunun taban sınıfa ilişkin except bloğunun yukarısında bulundurulması uygun olur.
   Aksi takdirde taban sınıfa ilişkin except bloğu türemiş sınıfa ilişkin exception'ları da yakalar ve durum anlamsızlaşır. 
   Örneğin:

   try:
        foo('ankara')
    except ValueError as e:
        pass
    except Exception as e:
        pass

    Burada ValueError oluşursa bunu ValueError parametreli except bloğu yakalayacaktır. Ancak diğer tüm exception'ları Exception 
    parametreli except bloğu yakalayacaktır. Burada sıra ters olsaydı anlamsız olurdu:

    try:
        foo('ankara')
     except Exception as e:
        pass
    except ValueError as e:
        pass
   
    Burada tüm exception'lar zaten Exception parametreli except bloğu tarafından yakalanacağı için ValueError parametreli except 
    bloğu boşuna yerleştirilmiştir. Bu tür durumlarda türemiş sınıfa ilişkin except blokları taban sınıfa ilişkin except bloklarının 
    yukarısında bulundurulmalıdır. 
#------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------
    Programın akışı birden fazla kez trye bloğuna girebilir. Bu durumda bir exception oluşursa try bloklarının except kısımları içten 
    dışa doğru (yani son girilen try bloğundan ilk girilene doğru) gözden geçirilir. Eğer exception iç try bloğunun except blokları tarafından 
    yakalanırsa orada ele alınmış alur. Artık dış try bloklarına bu exception yansıtılmaz. Eğer exception dış hiçbir try bloğunun 
    except blokları tarafından yakalanamazsa program çöker. 
#------------------------------------------------------------------------------------------------------------------------

def foo(a):
    print("foo başladı")
    try:
        bar(a)
    except ValueError:
        print("ValueError foo'da yakalandı")
    print("foo bitiyor")
        
def bar(a):
    print('bar başladı')
    
    if not isinstance(a, int):
        raise TypeError('argument must be int')
    
    if a > 100 or a < 0:
        raise ValueError('A must be 0-100 range')
    
    print('bar bitiyor')

try:
    foo(1000)
    print('Ok')
except ValueError:
    print("ValueError dışarıda yakalandı")
except TypeError:
    print("TypeError dışarıda yakalandı")
    
print('---------------------------------------')
    
try:
    foo('ali')
    print('Ok')
except ValueError:
    print("ValueError dışarıda yakalandı")
except TypeError:
    print("TypeError dışarıda yakalandı")

#------------------------------------------------------------------------------------------------------------------------
    Özel bir except bloğu da parametresiz except bloğudur. Parametresiz except blokları tüm exception'ları yakalar. Ancak parametresiz 
    except blokları bulundurulacaksa tüm except bloklarının sonunda bulundurulmalıdır. Örneğin:

    try:
        foo()
    except ValueError:
        pass
    except TypeError:
        pass
    except:
        pass

    Burada ValueError ve TypeError ayrı except bloklarıyla yakalanmıştır. Ancak diğer tüm exception'lar parametresiz except bloğu ile 
    yakalanır. Parametresiz except bloğunda bir as cümleceği bulunamaz. 
#------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------
    try bloğunun bir de finally bloğu olabilmektedir. Bu blok parametresiz olmak zorundadır. finally bloğu except blokları ile birlikte 
    ya da except blokları olmadan kullanılabilir. Her durumda finally bloğu en sonda olmak zorundadır. Örneğin:

    try:
        foo()
    except ValueError:
        pass
    except TypeError:
        pass
    except:
        pass
    finally:
        pass

    finally bloğu exception oluşsa da oluşmasa da çalıştırılır. Yani exception oluşursa önce exception'ı yakalayan except
    bloğu çalıştırılır sonra finally bloğu çalıştırılır. Eğer exception oluşmazsa finally bloğu çalıştırılır. 

    Bu durumu aşağıdaki programla test ediniz. 
#------------------------------------------------------------------------------------------------------------------------

def foo(a):
    print('foo başladı')
    
    if not isinstance(a, int):
        raise TypeError('argument must be int')
    
    if a > 100 or a < 0:
        raise ValueError('A must be 0-100 range')
    
    print('foo bitiyor')

try:
    foo(10)
except ValueError:
    print("ValueError oluştu...")
except:
    print("Diğer bir exception oluştu...")
finally:
    print('finally...')
    
print('------------------')

try:
    foo('ankara')
except ValueError:
    print("ValueError oluştu...")
except:
    print("Diğer bir exception oluştu...")
finally:
    print('finally...')

#------------------------------------------------------------------------------------------------------------------------
    Pekiyi mademki finally bloğu exception oluşsa da oluşmasa da çalıştırılmaktadır. O halde finally bloğu yerine oradakileri
    except bloklarının sonuna taşırsak değişen ne olacaktır? Örneğin:

    try:
        foo()
    except:
        print('exception oluştu')
    finally:
        print('finally bloğunda bir işlem yapılıyor')

    Bununla aşağıdaki kod arasında işlevsel ne farklılık vardır?

    try:
        foo()
    except:
        print('exception oluştu')
    print('finally bloğunda bir işlem yapılıyor')

    İşte finally her zaman çalıştırılmaktadır. Örneğin bir dönü içerisinde try bloğu olabilir. Bu döngüden dolayısıyla try bloğundan 
    break ya continue deyimleriyle çıkılmış olabilir. Bu durumda yine finally bloğu çalıştırılır. Örneğin:

    while True:
        try:
            val = int(input('Bir değer giriniz:'))
            if val == 0:
                break
            print(val * val)
        except:
            print('giriş geçersiz!')
        finally:
            print('finally işlemi yapılıyor')

    print('program devam ediyor')

    Burada try bloğundan break ile çıkılmış olsa da finally bloğu çalıştırılacaktır. Halbuki kod aşağıdaki gibi olsaydı finally kodu 
    çalıştırılmayacaktı:

    while True:
        try:
            val = int(input('Bir değer giriniz:'))
            if val == 0:
                break
            print(val * val)
        except:
            print('giriş geçersiz!')
        print('finally işlemi yapılıyor')

    print('program devam ediyor')

    Tabii return işleminde de aynı durum söz konusudur. Örneğin:

    def foo():
        try:
            val = int(input('Bir değer giriniz:'))
            if val == 0:
                return
            print(val * val)
        except:
            print('giriş geçersiz!')
        finally:
            print('finally işlemi yapılıyor')

    foo()

    Görüldüğü gibi try bloğundan nasıl çıkılmış olursa olsun her zaman finally bloğu çalıştırılmaktadır.

    Ayrıca iç içe try bloklarının olduğu durumda exceptin oluştuğunda exception dış try bloğu tarafından yakalansa bile
    iç try bloklaının finally blokları yine çalıştırılmaktadır. Örneğin:

    def foo(a):
        print("foo başladı")
        try:
            bar(a)
        except ValueError:
            print("ValueError foo'da yakalandı")
        finally:
            print("foo'daki finally bloğu çalıştırılıyor")
            
        print("foo bitiyor")
            
    def bar(a):
        print('bar başladı')
        
        if not isinstance(a, int):
            raise TypeError('argument must be int')
        
        if a > 100 or a < 0:
            raise ValueError('A must be 0-100 range')
        
        print('bar bitiyor')

    try:
        foo('test')
        print('Ok')
    except TypeError:
        print("TypeError dışarıda yakalandı")

    Burada her ne kadar TypeError dıştaki except bloğu tarafından yakalansa da iç try bloğunun finally bloğu yine çalıştırılacaktır.

    Buradan çıkan sonuç şudur: finally bloğu her zaman çalıştırılır. Yani çalıştırılması garanti edilmiştir. İşte finally 
    bloğu birtakım tahsisatların garantili bir biçimde boşaltılmasını sağlamak için kullanılmaktadır. Yani programın akışı başka bir yere 
    gidip ilgili bağlamdan koparsa yine de boşaltım gerçekleşir. Örneğin:

    def foo():
        f = None
        try:
            f = open('test.txt')
            s = f.read()
            #...
            s = f.read()
            #...
        finally:
            if f:
                f.close()
        
    Burada programcının read metodundaki IO hatalarını dışarıda ortak bir yerde ele aldığını düşünelim. read metotlarının birinde IO hatası 
    olduğunda akış başka bir faaliyet alanına gidecek dolayısıyla dosyanın kapatılma imkanı kalmayacaktır. (Gerçi dosya bu tür sınıfların 
    __del__ metotlarında da kapatılmaktadır ancak çöp toplayıcı mekanizmanın da nasıl gerçekleştirileceği belli değildir.) İşte bu tür 
    durumlarda kaynakların finally bloğunda boşaltılması en uygun durumdur. Özellikle çöp toplama mekanizmasının etkili olmadığı Python dünyasının 
    dışındaki tahsisatların garantili boşaltılması için finally bloğuna gereksinim duyulmaktadır. Programcı herhangi bir noktada 
    exception oluştuğunda o zaman akadar yapılan birtakım işlemleri geri almak istiyorsa bunu finally bloğunda yapmalıdır. 
#------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------
    raise deyiminde raise anahtar sözcüğünün yanına ifade getirilmeyebilir. Buna "reraise" denilmektedir. Bu biçimdeki reaise
    deyimi ancak except bloklarında kullanılabilir. Reraise işlemi aslında "exception'ın yakalanmamış hale getirmektedir. Başka bir deyişle
    aynı exception aynı parametreyle yeniden fırlatılır. Reraise işlemleri tipik olarak iç içe try bloklarında exception'ın içteki try bloğunun 
    except blokları tarafından yakalanması durumunda aynı yakalamanın dışarıda da yapılması amacıyla kullanılmaktadır. 

    Aşağıdaki örnekte TypeError iç try bloğunun except bloğu tarafından yakalanmış işlenmiştir. Ancak aynı zamanda bu işlemenin dış try 
    bloğunun except bloğu tarafından da yapılması istenmiştir. 
#------------------------------------------------------------------------------------------------------------------------

def foo(a):
    print("foo başladı")
    try:
        bar(a)
    except ValueError:
        print("ValueError foo'da yakalandı")
    except TypeError:
        print("TypeError foo'da yakalandı")
        raise  # reraise işlemi exception aynı nesneyle yeniden fırlatılıyor
    finally:
        print("foo'daki finally bloğu çalıştırılıyor")
    print("foo bitiyor")
def bar(a):
    print('bar başladı')

    if not isinstance(a, int):
        raise TypeError('argument must be int')

    if a > 100 or a < 0:
        raise ValueError('A must be 0-100 range')

    print('bar bitiyor')

try:
    foo('test')
    print('Ok')
except TypeError:
    print("TypeError dışarıda yakalandı")

#------------------------------------------------------------------------------------------------------------------------
    Python'ın standart sys modülünde exc_info isimli bir fonksiyon vardır. Bu fonksiyon bir except bloğu içerisinde çağrılabilmektedir. 
    Bu fonksiyon bize üçlü demet vermektedir. Demetin ilk elemanı oluşan exception'ın türünü, ikinci elemanı exception nesnesini ve üçüncü 
    elemanı da trace bilgisini verir. Programcı isterse as cümleciği ile elde edebileceği bu bu bilgileri bu fonksiyonla da elde edebilir. 
    Örneğin parametresiz except bloklarında as cümleciği kullanılamayacağından dolayı exception nesnesi ve türü bu yolla elde edilebilmektedir. 
    Bu fonksiyonu çağırmanın bir exception oluşmamışsa anlamı yoktur. Bu durumda fonksiyon üç eşemanı da None olan bir demete geri dönmektedir. 
    Yani bu fonksiyon except bloklarında gerekirse çağrılmalıdır.  

    Aşağıdaki örnekte parametresiz except bloğunda exception bilgileri sys.exc_info fonksiyonu ile elde edilmiştir. 
#------------------------------------------------------------------------------------------------------------------------

import sys

def foo(a):
    print('foobaşladı')
    
    if not isinstance(a, int):
        raise TypeError('argument must be int')
    
    if a > 100 or a < 0:
        raise ValueError('A must be 0-100 range')
    
    print('foo bitiyor')

try:
    foo('test')
except:
    exc_type, exc_obj, exc_trace = sys.exc_info()
    print(exc_type, exc_obj.args[0], exc_trace)


#------------------------------------------------------------------------------------------------------------------------
    sys.exc_info fonksiyonundan elde edilen trace bilgisi bir bağlı liste biçimindedir ve bu bilgi exception'ın program kodunun sırasıyla nerelerinde
    oluşarak ortaya çıktığını bize gösterir. trace nesnelerinin tb_next öznitelikleri bir sonraki tarce nesnesini belirtir. tb_linno özniteliği 
    ise exception oluşumuna ilişkin fonksiyon çağrılarını belirtir. Bu bilgiler genellikle debugger gibi, REPL gibi ortamlar tarafından kullanılmaktadır.  

    Aşağıdaki exception satır numaralarının ekrana yazdırılmasına yönelik bir örnek görüyorsunuz. 
#------------------------------------------------------------------------------------------------------------------------

import sys

def foo():
    bar()

def bar():
    tar()
    
def tar():
    raise ValueError()

try:
    foo()
except:
    _, _, trace = sys.exc_info()  
    while trace:
        print(trace.tb_lineno)
        trace = trace.tb_next
        
#------------------------------------------------------------------------------------------------------------------------
                                                        54. Ders 02/11/2022 - Çarşamba
#------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------
    İçerisinde bilgilerin bulunduğu ikincil belleklerdeki bölgelere "dosya (file)" denilmektedir. Dosya aslında işletim sistemleri tarafından
    oluşturulan yüksek seviyeli bir organizasyona ilişkin bir terimdir. İşletim sistemlerinin dosya işlemlerini yapan bölümlerine 
    "dosya sistemi (file system)" denilmektedir. Dosyaların parçaları aslında disklerdeki bloklarda bulunur. İşletim sistemi bir biçimde 
    hangi dosyaların parçalarının diskte hangi bloklarda olduğunu tutmaktadır. Bu tutuş biçimine göre dosya sistemleri çeşitli isimlerle 
    anılmaktadır. Örneğin NTFS, Ext-2, HFS gibi. İşletim sistemleri uygulama programcılarına dosyaları sanki ardışıl byte topluluklarından 
    oluşan varlıklarmış gibi göstermektedir. Dosya işlemleri hangi dille yapılıyor olursa olsun eninde sonunda işletim sistemlerinin sistem 
    fonksiyonları yoluyla gerçekleştirilmektedir. Çünkü dosya işlemlerinin asli sorumlusu işletim sistemleridir. 

    İşletim sistemlerinin çoğu diskleri sanki dizinlerden (directory) ve dosyalardan oluşan bir varlık biçiminde göstermektedir. 
    Bir dosya bir diskteki dizinlerin içerisinde bulunur. Diskteki en dışarıdaki dizine "kök dizin (root directory)" denilmektedir. 
    Microsoft dosya sistemlerinde farklı diskler "sürücü (drive)" ismiyle farklı birimler gibi ele alınmaktadır. Her sürücünün ayrı bir kök 
    dizini vardır. Ancak UNIX/Linux sistemlerinde ve macOS sistemlerinde sürücü kavramı yoktur. Toplamda bu sistemlerde tek bir kök vardır. 

    Bir dosyanın dizinler içerisindeki yerini belirten yazısal ifadelere "yol ifadesi (path)" denilmektedir. Yol ifadelerinde 
    dizin geçişlerinde Microsoft sistemlerinde "\", UNIX/Linux ve macOS sistemlerinde "/" kullanılmaktadır. Microsoft sistemleri 
    programlama söz konusu olduğunda "/" yü de kabul etmektedir. 

    Yoli ifadeleri "mutlak (absolute)" ve "göreli (reelative)" olmak üzere ikiye ayrılmaktadır. Eğer bir yol ifadesinin ilk karakteri 
    UNIX/Linux sistemlerinde "/", Windows sistemlerinde "\" ise böyle yol ifadelerine mutlak yol ifadeleri değilse göreli tol ifadeleri 
    denilmektedir. Örneğin:

    "/home/kaan/study/test.txt"     ---> Mutlak yol ifadesi
    "a/b/c.txt"                     ---> Göreli yol ifadesi
    "test.txt"                      --> Göreli yol ifadesi
    "\a.txt"                        --> Mutlak yol ifadesi (Windows)

    Mutlak yol ifadeleri her zaman kök dizinden itibaren yer belirtmektedir. Göreli yol ifadeleri ise prosesin "çalışma dizininden (current working directory)"
    itibaren yer belirtir. Çalışmakta olan programlara "prosess (process)" denilmektedir. İşletim sistemleri her proses için bir 
    çalışma dizini tutmaktadır. İşte göreli yol ifadeleri bu çalışma dizininden itibaren bir yer belirtir. Örneğin programımızın 
    çalışma dizini "C:\temp" olsun. Biz de "a\b\test.txt" biçiminde göreli bir yol ifadesi vermiş olalım. Bu dosya işletim sistemi tarafından 
    "c:\temp\a\b\test.txt" biçiminde ele alınacaktır. Eğer yol ifadesi "\b\c.txt" biçiminde olsaydı prosesin çalışma dizininin bir
    önemi kalmayacaktı. Çünkü mutlak yol ifadeleri her zaman kök dizinden itibaren bir yer belirtmektedir. Örneğin "test.txt" biçimindeki bir 
    yol ifadesi göreli bir yol ifadesidir. Prosesin çalışma dizininde aranır.

    Windows sistemlerinde yol ifadesine sürücü ismi de dahi ledilebilir. Örneğin "c:\temp\test.txt" gibi. Bu tür yol ifadelerine Microsoft
    "tam yol ifadeleri (full path)" demektedir. Microsoft sistemlerinde mutlak bir yol ifadesinde sürücü belirtilmezse bu durumda 
    bu yol ifadesinin prosesin çalışma dizinine ilişkin sürücüdeki bir yol ifadesi olduğu sonucu çıkartılır. Örneğin prosesimizin çalışma dizini
    "F:\test\study" oslun. Biz "\a\b\c.txt" biçiminde bir yol ifadesi verirsek buradaki kök F sürücüsünün köküdür. 

    Windows sistemlerinde sürücü içeren göreli yol ifadeleri de söz konusu olabilmektedir. Örneğin "C:a\b\test.txt" gibi. 
    Bu özel bir durumdur. Bu durumda işletim sistemi proseste bazı çevre değişkenlerine bakıp göreli yol ifadesi için orijini belirlemeye
    çalışır. Ancak proseste bu çevre değişkenleri yoksa (ki genellike yoktur) bu durumda bu yol ifadesi tam yol ifadesi biçiminde yani
    "C:\a\b\test.txt" biçiminde ele alınır. 
#------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------
    Prosesin çalışma dizini "os" modülündeki getcwd fonksiyonu ile bir string biçiminde elde edilebilir.
#------------------------------------------------------------------------------------------------------------------------

import os

cwd = os.getcwd()
print(cwd)

#------------------------------------------------------------------------------------------------------------------------
    Prosesin çalışma dizini yine "os" modülü içerisindeki chdir fonksiyonu ile değiştilebilmektedir. Eğer bu fonksiyonda geçersiz bir dizin
    girilirse FileNotFoundError isimli exception oluşmaktadır. 
#------------------------------------------------------------------------------------------------------------------------

import os

cwd = os.getcwd()
print(cwd)

os.chdir(r'c:\windows')

cwd = os.getcwd()
print(cwd)

#------------------------------------------------------------------------------------------------------------------------
   Pekiyi prosesin çalışma dizinini os.chdir fonksiyonu ile hiç değiştirmemişsek program çalışmaya başladığında default çalışma dizini 
   neresi olmaktadır? İşte aslında işletim sistemlerinde prosesin çalışma dizini üst prosesten alınmaktadır. Ancak üst proses bunu değiştirebilmektedir. 
   Python'da eğer komut satırında programı çalıştırıyorsak o anda komut satırında hangi dzindeysek prosesin default çalışma dizini o dizin olur. 
   Spyder IDE'sinde default çalışma dizini Python kaynak dosyasının bulunduğu dizindir. PyCharm'da ise proje dizini default çalışma dizinidir. 
#------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------
   Bir dosya ile işlem yapmadan önce dosyanın açılması gerekir. İşlemler bitince de dosya kapatılmalıdır. Eğer dosya kapatılmazsa 
   program bittiğinde zaten otomatik olarak kapatılır. Dosyanın açılması sırasında işletim sistemi bazı ön işlemler yapmaktadır. 
   
   Python'da dosya built-in open fonksiyonu ile açılır. open fonksşyonunun birinci parametresi açılacak dosyanın yol ifadesini belirtir. 
   İkinci parametre ise açış modunu belirtmektedir. Açış modu "dosya üzerinde yapılmak istenen eylemi" belirtmektedir. Açış modunda 
   kullanılabilecek mod belirten yazılar şunlardır:

   'r': Bu modda ancak var olan dosyalar açılabilir. Açılan dosyadan yalnızca okuma yapılabilir. Dosya yoksa exception olur. 
   Açış modu hiç girilmezse default durum 'r' kabul edilmektedir.

   'w': Bu modda dosya yoksa yaratılır ve açılır, dosya varsa sıfırlanarak açılır (yani dosyanın içerisindekiler silinir). Bu modda 
   dosyaya ancak yazma yapılabilir. 

   'r+': Bu modda yine var olan dosya açılabilir. Ancak dosyaya hem okuma hem de yazma yapılabilir. Dosya yoksa exception oluşur.

   'w+': Bu modda yine dosya yoksa yaratılır ve açılır, dosya varsa sıfırlanarak açılır. Ancak hem okuma hem yazma yapılabilir. 

   'a': Bu modda eğer dosya yoksa yaratılır ve açılır, dosya varsa olan dosya açılır (sıfırlanmaz). Ancak bu modda dosyaya her yazılan 
   hep sona eklenir. Dosyanın başka bir yerine bir şey yazmak mümkün değildir. Dosyadan okuma yapılamaz. 

   'a+': Bu modda da eğer dosya yoksa yaratılır ve açılır, dosya varsa olan dosya açılır (sıfırlanmaz). Ancak bu modda dosyaya her yazılan 
   hep sona eklenir. Dosyanın başka bir yerine bir şey yazmak mümkün değildir. Ancak dosyadan okuma da yapılabilir. 

   Genel olarak dosyaların gereksinimi karşılayacak en dar modda açılması tavsiye edilmektedir. Örneğin:

   - Var olan bir dosyanın bir yerindeki yazının bir kısmını değiştirmek isteyelim. Bu durumda dosyayı 'r+' modunda açmalıyız. 
   - Sıfırdan bir dosyanın içerisine bir şeyler yazmak isteyelim. Bunun dosyayı 'w' modunda açmalıyız. Ancak dosya varsa dosya varsa dosyanın içeriği 
   silinecektir. Dikkat etmemiz gerekir. 
   
   Dosya başarılı bir biçimde açılmışsa open fonksiyonu bir "dosya nesnesine (file object)" geri döner. Artık programcı işlemleri 
   bu geri döndürülen sınıf nesnesinin metotlarıyla yapar. 

#------------------------------------------------------------------------------------------------------------------------

f = open('text.txt', 'r')

#------------------------------------------------------------------------------------------------------------------------
    İşletim sistemi bir dosyadaki her bir byte'a ilk byte 0 olmak üzere ardışıl bir pozisyon numarası vermektedir. Buna 
    "ilgili byte'ın offset'i" denilmektedir. Dosya işlemleri adeta kalemin ucu görevini yapan "dosya göstericisi (file pointer)" 
    denilen bir offset'ten itibaren yapılmaktadır. Dosya açıldığında dosya göstericisi 0'ıncı offset'tedir. Okuma ve yazma miktarı kadar dosya 
    göstericisi otomatik ilerletilir. Yazma ve okuma işlemleri her zaman dosya göstericisinin gösterdiği yerden itibaren yapılır. Örneğin:

    0 1 2 3 4 5 6 7
    x x x x x x x

    Burada dosya göstericisi 0'ın offset'te olsun. Biz dosyaya iki byte yazdığımızda artık 0 ve 1 numaralı offset'lerdeki byte'lar güncellenir
    ve dosya göstericisi 2'inci offset'i gösterir duruma gelir. 

    Dosya göstericisinin dosyanın sonundaki byte'tan sonraki byte'ı göstermesi durumuna EOF durumu denir. Yukarıdaki örnekte dosya
    göstericisi 7'inci offset'teyse EOF durumundadır. EOF durumundan okuma yapılamaz. Ancak EOF durumunda yazma yapılabilir. Bu durum "ekleme" anlamına gelmektedir. 
    Dosyaya ekleme yapmak için tek yol dosyanın sonuna yazmaya çalışmaktır. 
#------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------
    Dosyalar "text" ve "binary" olmak üzere ikiye ayrılmaktadır. (Aslında işletim sistemi böyle bir ayrım yapmamaktadır. Ancak bazı programlama dilleri 
    işlemleri kolaylaştırmak için bu ayrımı yaparlar.) İçerisinde yalnızca yazıların bulunduğu dosyalara "text" dosyalar, içerisinde yazıların
    dışında başka bilgilerin bulunduğu dosyalara "binary" dosyalar denilmektedir. Örneğin bir Python kaynak dosyası, bir notepad dosyası text dosyalardır. 
    Ancak örneğin bir jpeg dosyası, bir exe dosyası binary dosyalardır. Dosyalar Python'da text ya da binary modda açılabilmektedir. 
    Default mod text moddur. Binary modda açış yapmak için açış modunun sonuna 'b' harfi getirilir. Örneğin:

    f = open('text.txt', 'r')       # text modda açılıyor

    Fakat örneğin:

    f = open('test.jpg', 'rb')      # binary modda açılıyor

    Bir dosyayı text modda açtığımızda ondan yazı okuruz, ona yazı yazarız. Ancak binary modda açtığmızda ondan byte'lar okuyup byte'lar yazarız.
    
#------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------
    Açılan bir dosya programcının işi bittiğinde kapatılmalıdır. Kapatma işlemi open fonksiyonunun geri döndürdüğü dosya nesnesine 
    ilişkin sınıfın close metoduyla yapılmaktadır. Bir dosyayı kapatmazsak dosya en kötü olasılıkla program bittiğinde kapatılır. Ancak ne olursa olsun
    programcının dosyayı artık kullanmayacağı noktada kapatması iyi bir tekniktir. Örneğin:

    f = open('test.txt')
    ...
    f.close()

    Zaten kapatılmış olan bir dosyanın yeniden kapatılması kıonusunda Python dokümanları net bir şey söylememiştir. CPython
    yorumlayıcısı bu durumda herhangi bir exception fırlatmamaktadır. Bir dosyanın açık olup olmadığı nesnenin closed özniteliği ile 
    de sorgulanabilir. 

#------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------
    Dosya nesnesine ilişkin sınıfın read metodu dosya göstericisinin gösterdiği yerden n byte ya da n karakter okumak için 
    kullanılır. ASCII yazılarda ve ASCII karakterlerinin kullanıldığı UTF-8 yazılarda yazının her bir karakteri 1 byte'tır. 
    Eğer dosya text modda açılmışsa read metodu n karakter okur ve bize onu bir str nesnesi olarak verir. Eğer dosya binary modda 
    açılmışsa read metodu n byte okur ve bize onu bytes nesnesi olarak verir. read metodu ile dosya göstericisinin gösterdi yerden 
    dosya sonuna kadar olan karakter ya da byte sayısından daha fazla okuma yapmak istenirse bu durum normal karşılanmaktadır. 
    Bu durumda okunabilen kadar karakter ya da byte okunur. Dosya göstericisi EOF konumuna gelir. Eğer dosya göstericisi EOF 
    durumundaysa read metodu hiçbir karakter ya da byte kuyamaz. Bu durumda dosya text modda açılmışsa boş string, binary modda 
    açılmışsa boş bytes nesnesi elde edilir. Eğer okuma sırasında bir IO hatası oluşursa exception fırlatılmaktadır. 
#------------------------------------------------------------------------------------------------------------------------

f = open('test.txt', 'r')
s = f.read(2)
print(s)

s = f.read(2)
print(s)

s = f.read(1000)
print(s)

f.close()

#------------------------------------------------------------------------------------------------------------------------
   read metoduna hiç parametre geçilmezse "EOF'a kadar dosyanın tamamı" okunmaya çalışılır. 
#------------------------------------------------------------------------------------------------------------------------

f = open('test.txt', 'r')
s = f.read()
print(s)
f.close()

#------------------------------------------------------------------------------------------------------------------------
    Bir dosyanın içerisindekileri tek hamlede değil bir döngü içerisinde okumak isteyelim. Yani her defasında örneğin 1024 byte okuya okuya
    dosyanın tamamını okumak isteyelim. Bunu şöyle yapabiliriz
#------------------------------------------------------------------------------------------------------------------------

SIZE = 1024

f = open(r'F:\Dropbox\Kurslar\Python\Doc\Python-Examples.txt', 'r')

while True:
    s = f.read()
    if s == '':
        break
    print(s, end='')

f.close()
    
#------------------------------------------------------------------------------------------------------------------------
   Tabii yukarıdaki kod walrus operatörüyle aşağıdaki gibi daha sade yazılabilir. 
#------------------------------------------------------------------------------------------------------------------------

SIZE = 1024

f = open(r'F:\Dropbox\Kurslar\Python\Doc\Python-Examples.txt', 'r')

while (s := f.read(SIZE)) != '':
    print(s, end='')

f.close()

#------------------------------------------------------------------------------------------------------------------------
                                            55. Ders 07/11/2022 - Pazartesi
#------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------
    Bir binary dosyadan read metodu ile okuma yapmak için binary dosyayı açarken açış moduna 'b' eklememiz gerekir. Bundan sonra artık
    biz read işlemi yaptığımızda read metodu bize str nesnesi değil bytes nesnesi verecektir. Tabii biz istersek text dosyaları da binary modda 
    açabiliriz. Bu durumda read metodu bize yine bytes nesnesi verir. Ancak binary bir dosyanın text modda açılması çoğu kez anlamsızdır. 
    Örneğin bir PDF dosyası binary bir dosyadır. Bizim onu binary modda açıp okumamız uygun olur. Bu durumda read metodu bize bytes nesnesi verecektir.

    Dosya türü          Açış Modu           read Metodunun Geri Dönüş Değeri
    text                text                str
    text                binary              bytes
    binary              binary              bytes
    binary              text                str ama anlamsız

#------------------------------------------------------------------------------------------------------------------------

f = open('../doc/python.pdf', 'rb')
b = f.read(10)
print(b)
f.close()

#------------------------------------------------------------------------------------------------------------------------
    Bir dosyaya yazma yapmak için write metodu kullanılmaktadır. write metodunun tek bir parametresi vardır. Dosya text modda açılmışsa
    write metodu bir string argüman alır, binary modda açılmışsa bir bytes nesnesini argüman olarak alır. Tabii dosyaya yazma yapılabilmesi için 
    açış modunun uygun olması gerekir. 
#------------------------------------------------------------------------------------------------------------------------

f = open('test.txt', 'w')

f.write('this is a test')
f.write('\nyes this is a test')

f.close()

#------------------------------------------------------------------------------------------------------------------------
    Aşağıdaki örnekte binary modda açılan bir dosyaya write metodu ile bytes nesnesinin içerisindeki byte'lar yazdırılmıştır.
#------------------------------------------------------------------------------------------------------------------------

f = open('test.dat', 'wb')

f.write(b'\x01\x02\x03\x04\x05')

f.close()

#------------------------------------------------------------------------------------------------------------------------
    Dosya işlemlerinde hatalar oluştuğunda open fonksiyonu, read ve write metotları exception fırlatmaktadır. Fırlatılan exception'lar
    OSError ya da eşdeğer olarak IOError sınıfları türünden ya da bu sınıflardan türetilmiş sınıflar türündendir. Programcı 
    kodunda bir sorun oluşursa hatayı rapor etmek için dosya işlemlerini try-except-finally bloklarını kullanarak yapabilir. 
    Dosyanın kapatılması tipik olarak finally bloğunda yapılır. Çünkü finally bloğu arada bir exception oluşup akış başka bir yere 
    gitse bile çalıştırılmaktadır. Tabii bu işlemi daha pratik yapmak için with deyimi de kullanılabilir. with deyimi izleyen 
    bölümlerde ele alınacaktır. Örneğin:

    f = None
    try:
        f = open('test.txt', 'r')
        s = f.read(10)
        print(s)
    except IOError as e:
        print(f'file error: {e}')
    except Exception as e:
        print(e)
    finally:
        if f:
            f.close()
        
    Burada dosyaya ilişkin exception'lar IOError parametreli except bloğu ile el alınmış geri kalan diğerleri ise Exception parametreli 
    except bloğu tarafından ele alınmıştır. Dosya finally bloğunda kapatılmıştır. Ancak open fonksiyonunda exception oluştuğunda henüz 
    f değişkeni değer almadığı için finally bloğunda bu yönde bir kontrol uygulanmıştırç 

#------------------------------------------------------------------------------------------------------------------------
    Dosyalar ister text olsun ister binary olsun ardışıl byte topluluklarından oluşmaktadır. Dolayısıyla bir dosyanın arasına bir şey insert 
    etmek ya da dosyanın arasından bir şeyler silmek kolay işlemler değildir. Bu tür işlemler tipik olarak başka bir dosya yaratılarak 
    dolaylı bir biçimde yapılmaktadır. 
#------------------------------------------------------------------------------------------------------------------------
   
#------------------------------------------------------------------------------------------------------------------------
    Dosya nesneleri (file objects) dolaşılabilir nesnelerdir. Bir dosya nesnesi dolaşıldığında dosyadaki satırlar elde edilir. 
    Tabii elde edilen satırların sonında '\n' karakterleri de vardır. (Yani satırları print fonksiyonuyla yazdırırken imleci iki kere 
    aşağı satıra geçirmemek için end parametresi '' biçiminde geçilmelidir.) Dosyanın satırları bittiğinde dolaşma da biter.

    Her ne kadar binary dosyalar da bu biçimde dolaşılabilse de binary dosyaların bu biçimde satır satır dolaşılması anlamsızdırç. 
#------------------------------------------------------------------------------------------------------------------------

f = open('test.txt')

for line in f:
    print(line, end='')
    
f.close()

f = open('test.txt')

a = list(f)

print(a)

#------------------------------------------------------------------------------------------------------------------------
    Dosya nesnesine ilişkin sınıfın readline isimli metodu da vardır. Bu metot dosya göstericisinin gösterdiği yerden satır sonuna 
    kadar ('\n' karakteri de dahil olmak üzere) karakterleri okur ve o yazaıyla geri döner. Eğer dosya sonuna eglinirse metot boş 
    string'le geri dönmektedir. Bu durumda biz bir text dosyayı readline metotlarını çağırarak satır satır aşağıdaki gibi de 
    okuyabiliriz:

    f = open('test.txt', 'r')

    while True:
        s = f.readline()
        if s == '':
            break
        print(s, end='')
        
    Tabii bu işlem yine Walrus operatörü ile daha pratik yapılabilir:

    f = open('test.txt', 'r')

    while (s := f.readline()) != '':
        print(s, end='')
        
#------------------------------------------------------------------------------------------------------------------------
   
#------------------------------------------------------------------------------------------------------------------------
    Bazen dosyanın içerisinde bir yerlerden okuma yapmak ya da içerisinde bir yerlere yazma yapmak gerekebilmektedir. 
    Bunun için seek metodu kullanılmaktadır. seek metodunun iki parametresi vardır. Birinci parametre offset belirtir. İkinci parametre ise 
    konumlandırmanın nereden itibaren yapılacağını belirten orijin belirtir. İkinci parametre 0, 1 ya da 2 değerini alır. Başka bir değer alamaz.
    0 konumlandırmanın baştan itibaren yapılacağını, 1 konumlandırmanın o anda dosya göstericisinin gösterdiği yerden itibaren yapılacağını,
    2 ise konumlandırmanın EOF pozisyonundan itibaren yapılacağını belirtir. İkinci parametre 0 ise birinci parametre >= 0 olmak zorundadır. 
    İkinci parametre 1 ise birinci parametre pozitif, negatif ya da 0 olabilir. Pozitif ileriye, negatif geriye konumlandırma anlamına gelir. 
    İkinci parametre 2 ise birinci parametre <= 0 olmak zorundadır. Bu durumda konumlandırma EOF'tan itibaren geriye yapılır. Metodun 
    ikinci parametresi 0 default değerini almıştır. Aşağıda bazı örnekler ve anlamları verilmiştir:ç

    - f.seek(100, 0) ya da f.seek(100) burada konumlandırma dosyanın başından itibaren 100'üncü offset'e yapılır.

    - f.seek(-1, 1) burada konumlandırma dosya göstericisi neredeyse onun bir gerisine yapılır.

    - f.seek(0, 2) burada konumlandırma EOF pozisyonuna yapılır

    - f.seek(1, 2) burada konumlandırma son byte'a yaılır.

#------------------------------------------------------------------------------------------------------------------------

f = open('test.txt', 'r')

f.seek(20, 0)
s = f.read(10)
print(s)
f.close()

#------------------------------------------------------------------------------------------------------------------------
    Dosya nesnesine ilişkin sınıfın tell isimli metodu dosya göstericisinin baştan itibaren konumunu gei döndrümektedir.
#------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------
    Bir dosyaya bir şeyler eklemek için ya dosya "a" ya da "a+" modunda açılmalı ya da dosya göstericisi EOF durumuna çekilerek 
    yazma yapılmalıdır. Aşağıdaki örnekte bir text dosyanın sonuna "ankara\n" yazısı eklenmiştir.
#------------------------------------------------------------------------------------------------------------------------

f = open('test.txt', 'r+')

f.seek(0, 2)
f.write('ankara\n')
f.close()

#------------------------------------------------------------------------------------------------------------------------
    Biz dosyaları text dosyalar ve binary dosyalar olmak üzere ikiye ayırmıştık. Ancak text dosyalar da içerisindeki karakterlerin 
    kodlanma biçimine göre farklılıklar gösterebilmektedir. İşte text dosyalarda bilinmesi gereken bazı karmaşık konular bulunmaktadır.
    Bu konudaki önemli terimler şunlardır:

    - Character Repertoire: Bir karakter tablosundaki karakterlerin kümesine denilmektedir.
    - Glyph: Karakter tablosundaki karakterlerin görüntüsüne yani eşkline denilmektedir.
    - Code Point: Karakter tablosu içerisindeki karakterlere tek tek 0'başlanarak numara verilmiştir. Bu numralara code point denilmektedir.
    - Character Encoding: Karakter tablosundaki bir code point'in ikilik sisteme yani byte formatına dönüştürülme biçimidir. 

    İlk karakter tablosu ASCII tablosudur. ASCII tablosu 128 karakterden oluşuyordu ve [0-127] code point'e sahipti. Code point'ler
    doğrudan binary sayılara dönüştürülerek encoding yapılıyordu. Sonra latin dilleri bu 128 karakter yetmeyince ASCII tablosunu 
    128 daha artırıp 256 karaktere çıkarttılar. Yani 128 code point daha eklediler. Böylece ilk 128 code point standart ASCII olan
    ancak diğer 128 code point farklı farklı karakterlerden oluşan tablolar ortaya çıktı. Ancak her ulus bu düzenlemeyi kendisine göre 
    yaptığı için karmaşa oluştu. Bugün ASCII tablosunun bu farklı düzenlemelerine "code page" denilmektedir. Code page denilince
    ASCII tablosunun birinci yarısı aynı olan ancak ikinci yarısı farklı düzenlemelere sahip olan ASCII tarzı karakter tabloları anlaşılmaktadır.
    Fakat bu durum meseleyi hepten karmaşık hale getirmiştir. Örneğin Türkçe için bile üç farklı code page vardır: OEM 754, Microsoft 1254, 
    ISO 8859-9. Nihayetinde dünyanın bütün karakterlerini tutan ancak 65536 code point'e sahip olan UNICODE isimli yeni bir karakter 
    tablosu geliştirildi. Tabii code point'ler 256'dan fazla olduğu için bunların bir byte ile kodlanması (encoding) mümkün olamamaktadır. 
    UNICODE tablonun ilk 128 code point'e karşı gelen karakterleri standart ASCII tablosu ile aynı karakterlerdir. Sonraki 128 code point'e 
    karşı gelen karakterler ise Latin-1 code page'inin (ISO 8859-1) karakterleridir. UNICODE tablonun değişik encoding'leri vardır. 
    En yaygın kullanılan encoding'i UTF-8'dir. UTF-8 encoding'inde UNICODE'un ilk 128 code point'i 1 byte ile kodlanır. Sonraki code point'leri 
    2 byte, 3 byte, 4 byte ve 5 byte ile kodlanmaktadır. Bunun bir algoritması vardır. UTF-8 kodlaması adeta UNICODE tablonun sıkıştırılmış bir kodlaması 
    gibidir. Ayrıca standart ASCII metinler tamamen UTF-8 encoding'i ile aynı olmaktadır. 

    Bu anlatımlardan çıkan en önemli sonuç programcı bir text dosyayla çalışıyorsa onun encoding'ini bilme zorunluluğudur. Örneğin biz 
    UTF-8 olarak kodlanmış bir yazıyı ISO 8859-9 olarak okumak istersek tuhaf karakterler elde edebiliriz. Pekiyi bir yazının encoding'ini
    nereden bilebiliriz? Text dosların başında UNICODE tablo için bir BOM marker bulundurulabilmektedir. Böyelce prograölar bu 
    BOM marker'a bakarak encoding tespitini yapmaya çalışabilmektedir. Ancak BOM marker yalnızca UNICODE encoding'leri için söz konusudr 
    ve text dosyaların bşında bulunmak zorunda değildir. Text editörler genellikle BOM marker'a bakarlar eğer bu BOM marker'ı göremezlerse 
    default bir encoding ile yazıyı yorumlarlar. Tabii en iyi durum zaten kullanıcının bunu biliyor olması ve ona göre dosyayla ilgili 
    işlem yapmasıdır. 

    Python'da bir dosya text modda open fonksiyonuyla açılırken open fonksiyonun encoding parametresi ile encoding belirtilebilmektedir. Örneğin:

    f = open('test.txt', 'r', encoding='utf-8')

    Dosyaların default encoding'i sistemden sisteme değişebilmektedir. Bu durum işletim sistemindeki locale ayarlarına bağlıdır. 
    Default encoding standart local modülündeki getpreferredencoding fonksiyonuyla ya da 3.11 ile eklenen getencoding fonksiyonu ile elde edilebilmektedir. 

#------------------------------------------------------------------------------------------------------------------------
                                                56. Ders 14/11/2022 - Pazartesi
#------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------
    Bir exception oluştuğunda exception başka bir yere eele alınıyor olabilir. Ancak bu tür durumlarda exception'ın oluştuğu noktadan önce 
    bir kaynak tahsis edilmişse akış başka bir yere gitmeden önce kaynağın geri bırakılması gerekmektedir. Bunun için try-finally kalıbı 
    kullanılabilmektedir. Örneğin:

    f = None
    try:
        f = open(...)
        ...
        ...
        ...
    finally:
        if f:
            f.close()

    İşte genel olarak with deyimi bu tür durumlarda kolay bir yazım sağlamak için kullanılmaktadır. Deyimin genel biçimi şöyledir:

    with <ifade> [ as <değişken_ismi>]:
        <suite>

    Burada ifade as anahtar sözcüğünün yanındaki değişkene atanır. Sonra suit çalıştırılmaktadır. Ancak withc deyiminde as kısmı olmak zorunda da değildir. Örneğin:

    with <ifade>:
        <suite>

    with benzeri deyimler diğer programlama dillerinde de bulunmaktadır. Bir ifadenin with deyimi ile kullanılabilmesi için o ifadenin türünün 
    "bağlam yönetim protokolüne (context management protocol)" uygun olması gerekir. 

    Bir sınıfın bağlam yönetim protokolüüne uygun olması için sınıfta __enter__ ve __exit__ isimli iki metodun bulunuyor olması gerekir. 
    __enter__ metodunun yalnızca self parametresi vardır. Ancak __exit__ metodunun self dışında üç parametresi daha bulunur. 
    Bu parametreler istenildiği gibi isimlendirilebilir. Ancak programcılar genellikle bunları xc_type, exc_value, traceback biçiminde isimlendirirler. 
    Örneğin:

    class Sample:
        def __enter__(self):
            pass
        def __exit__(self, xc_type, exc_value, traceback):
            pass

    with Sample() as s:
        pass

    with deyimi kabaca şöyle çalışmaktadır: Önce with anahtar sözcüğünün yanındaki ifade yapılır. Sonra bu nesne ile __enter__ metodu çağrılır, __enter__ metodunun geri dönüş değeri as değişkenine atanır. Akış with deyiminden hangi yolla çıkarsa çıksın (exception dahil olmak üzere) with deyiminin yanındaki nesne ile __exit__ metodu çağrılır. 

    Örneğin:

    class Sample:
        def __init__(self):
            print('__init__')
        def __enter__(self):
            print('__enter__')
        def __exit__(self, xc_type, exc_value, traceback):
            print('__exit__')

    with Sample() as s:
        print('suite')    
    print('ends')

    Burada ekrana şu yazılar çıkacaktır:

    __init__
    __enter__
    suite
    __exit__
    ends

    with deyimi bir sınıf nesnesi yaratılırken yapılan bazı tahsisatların otomatik bırakımını mümkün hale getirmek için düşünülmüştür. 
    Tabii bu tür kaynaklar genellikle Python dünyasının dışında tahsis edilen "unmanaged" denilen kaynaklardır. Fakat herhangi bir kaynak 
    bu tür durumlarda otomatik bırakılabilir. Örneğin:

    with open('test.txt') as f:
        s = f.read()
        print(s)

    Burada open fonksiyonun geri döndürdüğü dosya nesnesine ilişkin sınıf bağlam yönetim protokolünü desteklemektedir. Bu nedenle 
    with deyiminden çıkılırken yorumlayıcı tarafından adeta f.__exit__(...) biçiminde sınıfın __exit__ metodu çağrılacaktır. İşte bu metotta
    sınıfı yazanlar dosyayı zaten kapatmışilardır. O halde biz open fonksiyonunu bu biçimde kullanırsak with deyiminden çıılırken 
    dosya kapatılacaktır. Bizim ayrıca dosyayı close ile kapatmamıza gerek yoktur. 

    with deyimi try-finally gibi düşünülmelidir. with deyimi ile exception ele alınmamaktadır. Yalnızca otomatik boşaltım mekanizması oluşturulmaktadır. 
    Exception ele alınmak isteniyorsa ayrıca try deyimi uygulamalıdır. Örneğin:

    class Sample:
        def __init__(self):
            print('__init__')
        def __enter__(self):
            print('__enter__')
        def __exit__(self, xc_type, exc_value, traceback):
            print('__exit__')
        def foo(self):
            raise ValueError

    try:
        with Sample() as s:
            s.foo()
            print('suite')
    except:
        print('exception caught')
    
    print('ends')

    Programcı bağlam yönetim protokülüne uygun bir sınıf yazarken gerekli boşaltım işlemlerini __exit__ metodu içerisinde yapmalıdır.
     
    Aslında with deyiminin çalışması biraz ayrıntılara sahiptir. Python Language Reference dokğmanına göre:

    with EXPRESSION as TARGET:
        SUITE

    deyiminin eşdeğeri şöyledir:

    manager = (EXPRESSION)
    enter = type(manager).__enter__
    exit = type(manager).__exit__
    value = enter(manager)
    hit_except = False

    try:
        TARGET = value
        SUITE
    except:
        hit_except = True
        if not exit(manager, *sys.exc_info()):
            raise
    finally:
        if not hit_except:
            exit(manager, None, None, None)

    Yukarıdaki kod daha basit bir biçimde şöyle de ifade edilebilirdi:

    manager = (EXPRESSION)
    value = manager.__enter__()

    hit_except = False

    try:
        TARGET = value
        SUITE
    except:
        hit_except = True
        if not manager.__exit__(*sys.exc_info()):
            raise
    finally:
        if not hit_except:
            manager.__exit__(None, None, None)


    Bu eşdeğerlilikten deyimin çalışması hakkında şunlar söylenebilir:

    1) Öncelikle with anahtar sözcüğünün yanındaki ifade işletilir. 
   
    2) with anahtar sözcüğünün yanındaki ifadenin değeri ile sınıfın __enter__ metodu çağrılır. Bu __enter__ metodunun 
    geri dönüş değeri as anahtar sözcüğünün yanındaki değişkene atanmaktadır. Yani:

    with EXPRESSION as TARGET:
        SUITE

    Burada aslında TARGET = EXPRESSION.__enter__() ataması yapılmaktadır. 

    O halde bizim en azından __enter__ metodu içerisinde self ile geri dönmemiz gerekir. Örneğin:

    class Sample:
        def __enter__(self):
            return self
        ...
    
    3) with deyimindeki suite'ten bir exeption ile çıkıldığında exception'ın bilgileri ile __exit__ metodu çağrılmaktadır. 
    Ancak with deyiminden exception ile çıkılmadıysa bu durumda __exit__ metodunun parametreleri None, None, None olmaktadır.

    4) Eğer with deyiminden exception ile çıkılmışsa bu durumda __exit__ metodunun geri dönüş değerine bakılmaktadır. Eğer __exit__ metodu
    True ile geri dönmüşse sanki exception oluşmamış gibi akış with deyiminden sonra devam etmektedir. Yani adeta oluşan exception  yakalnmış gibi 
    işlem yapılmaktadır. Ancak __exit__ metodundan False ile geri dönülmüşse exception yakalanmamış gibi  davranış oluşmaktadır. Bu durumda
    __exit__ metodunun geri dönüş değeri önemli olmaktadır. 

    with deyimi bazı potansiyel olanakları programcı kullanabilsin diye bu biçimde biraz karışık tasarlanmıştır. Ancak programcılar genellikle 
    bu protokülü desteklerken oldukça yalın bir kod kullanırlar. Programcılar genellikle __enter__ metodundan self ile geri dönerler. 
    __exit__ metodunda kaynak boşaltımını yaparlar ve __exit__ metodunda return kullanmazlar. Bu durumda __exit__ metodu None ile geri döner ve exception oluşursa
    exception dışarıya verilir.  

    Pekiyi __enter__ metoduna neden gereksinim duyulmuştur? İşte bazen programcı __enter__ metodunda aslında bir nesne vermek isteyeblir. 
    Ancak bu böylesi durumlara seyrek biçimde gereksinim duyulmaktadır. 

    with anahtar sözcüğünün yanındaki ifadede exception oluşursa artık __exit__ metodunun çağrılmayacağına dikkat ediniz. Bu ifade 
    semantik olarak with deyimi ile bağlantılı değildir. Örneğin:

    with open('test.txt) as f:
        pass

    Burada open fonksiyonunda bir exception oluşursa bu exception dıştaki bir try blok tarafından yakalanabilir. Çünkü henüz 
    with deyiminin içerisine girilmemiştir.

    Aşağıdaki örnekte bir dosyayı sarmalayan bir sınıf örneği verilmiş ve __exit__ metodunda dosyanın kapatılması sağlanmıştır. 

#------------------------------------------------------------------------------------------------------------------------

class FileWrapper:
    def __init__(self, *args, **kwargs):
        self.f = open(*args, **kwargs)
        
    def __enter__(self):
       return self
    
    def __exit__(self, xc_type, exc_value, traceback):
        self.f.close()
        
    def read(self, *args, **kwargs):
        return self.f.read(*args, **kwargs)
        
    def write(self, *args, **kwargs):
        return self.f.write(*args, **kwargs)
        
    def seek(self, *args, **kwargs):
        return self.f.seek(*args, **kwargs)

with FileWrapper('test.txt', 'r', encoding='cp1254') as fw:
    s = fw.read()
    print(s)
    
#------------------------------------------------------------------------------------------------------------------------
    Aslında with deyiminde birden fazla ifade de kullanılabilmektedir. Yani örneğin:

    with ifade1 as değişken1, ifade2 as değşken2, ifade3 as değişken3:
        <suit>

    gibi bir with deyimi geçerlidir. Bu biçimdeki with deyimleri "iç içe" gibi ele alınmaktadır. Yani yukarıdaki with deyiminin eşdeğeri 
    şöyledir:

    with ifade1 as değişken1:
        with ifade2 as değişken2:
            with ifade3 değişken3:
                <suite>

    Burada örneğin ifade3'te bir exception oluşursa önce ifade2 için sonra ifade1 için __exit__ metotları çağrılacaktır. 

#------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------
    Biz şimdiye kadar dolaşılabilir (iterable) nesneler üzerinde çalıştık. Onları for döngüsüyle doğrudan list gibi tuple gibi 
    sınıflarla dolaylı olarak dolaştık. Pekiyi kendimiz nasıl dolaşılabilir bir sınıf yazabiliriz? Bu bölümde bu konu ele alınacaktır. 

    Bir sınıfın dolaşılabilir olması için sınıfın içerisinde __iter__ isimli yalnızca self parametresine sahip olan bir metodun bulunuyor olması gerekir. 
    Örneğin:

    class Sample:
        def __iter__(self):
            pass

    Burada Sample dolaşılabilir (iterable) bir sınıftır. __iter__ metodunun bir "dolaşım (iterator)" nesnesiyle geri döndürülmesi gerekmektedir. 
    Bu durumda dolaşılabilir bir sınıf bize bir dolaşım nesnesi vermelidir. Asıl dolaşım işlemi bu dolaşım nesnesiyle yapılmaktadır. Bu durumda iki sınıf söz konusu olmaktadır:

    1) Dolaşılabilir (iterable) sınıf 
    2) Dolaşım (iterator) sınıfı

    Bir sınıfın dolaşılabilir olması için __iter__ metoduna sahip olması gerekir. Ancak sınıfın dolaşım sınıfı olması için __next__ metoduna sahip olması gerekmektedir. 
    Dolaşılabilir sınıf ile dolaşım sınıfları farklı olabilmektedir. Ancak çoğu kez bunlar aynı sınıf da olabilirler. Bu durumda sınıfın __iter__ ve __next__ 
    metotları bulunur. __iter__ metodu self ile geri döndürülür. Aşağıdaki örnekte dolaşılabilir sınıf ile dolaşım sınıfı farklı sınıflar olarak oluşturulmuştur. 
    Dolaşılabilir sınıfın __iter__ metodunda dolaşım sınıfı türünden bir nesne ile geri dönülmüştür:

    class SampleIterator:
        def __next__(self):
            pass

    class SampleIterable:
        def __iter__(self):
            si = SampleIterator()
            return si

    Burada dolaşılabilir sınıfının __iter__ metodunun dolaşım sınıfı türünden bir nesneye geri döndüğüne dikkat ediniz. __iter__ 
    ve __next__ metotları yalnızca self parametresine sahiptir. Aşağıda ise dolaşılabilir sınıf ile dolaşım sınıfı aynı sınıf yapılmıtır:

    class SampleIterable:
        def __iter__(self):
            return self

        def __next__(self):
            pass

    Aşağıdaki gibi bir for döngüsü olsun:

    for x in iterable:
        <suite>

    Bu döngünün tam eşdeğeri aslında şöyledir:

    iterator = iterable.__iter__()
    try:
        while True:
            x = iterator.__next__()
            <suite>
    except StopIteration:
        pass

    Buradaki eşdeğer kodun sözel açıklaması şöyle yapılabilir. Yorumlayısı dolaşılabilir nesne ile __iter__ metodunu çağırır ve ondan
    dolaşımı nesnesini elde eder. Sonra sürekli olarak dolaşım nesnesi ile __next__ metodu çağrılmaktadır. Her __next__ bir değer verir ve o değer
    döngü değişkenine yerleştirilerek suit çalıştırılır. Bu döngüden çıkış StopIteration exception'ı ile yapılmaktadır. Başka bir deyişle programcı 
    dolaşım sınıfının __next__ metodu ile vereceklerini verir. Artık verecek bir şeyi kalmayınca StopIteration exception'ını fırlatır. 
#------------------------------------------------------------------------------------------------------------------------

class Sample:
    def __init__(self, stop):
        self.stop = stop
        
    def __iter__(self):
        self.i = 0
        return self
    
    def __next__(self):
        if self.i == self.stop:
            raise StopIteration()
        self.i += 1
        return self.i - 1   
    
s = Sample(5)

for x in s:
    print(x)
    
#------------------------------------------------------------------------------------------------------------------------
                                                57. Ders 16/11/2022 - Çarşamba
#------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------
    Aşağıdaki örnekte bir sınıf __init__ metodu ile aldığı parametreleri bir demet biçiminde nesnenin örnek özniteliğinde saklamaktadır. 
    Daha sonra her __next__ metodunda sırasuyla bunlardan brini vermektedir. 
#------------------------------------------------------------------------------------------------------------------------

class Args:
    def __init__(self, *args):
        self.args = args
        
    def __iter__(self):
        self.index = -1
        return self
    
    def __next__(self):
        self.index += 1
        if self.index == len(self.args):
            raise StopIteration()
        return self.args[self.index]
    
args = Args('ali', 'veli', 123, True)

for x in args:
    print(x)

#------------------------------------------------------------------------------------------------------------------------
    İki değer arasında rastgele değer veren dolaşılabilir bir sınıf örneğini aşağıdaki gibi yazabiliriz. 
#------------------------------------------------------------------------------------------------------------------------

import random

class RandomIterable:
    def __init__(self, beg, end, n):
        self.beg = beg
        self.end = end
        self.n = n
        
    def __iter__(self):
        self.i = -1
        return self
    
    def __next__(self):
        self.i += 1
        if self.i == self.n:
            raise StopIteration()
        return random.randint(self.beg, self.end)
        

a = list(RandomIterable(0, 100, 10))
print(a)
    
#------------------------------------------------------------------------------------------------------------------------
    Dolaşılabilir (iterable) sınıf ile dolaşım (iterator) sınıfı aynı sınıf olmak zorunda değildir. Ancak Python Language Reference dokümanına göre 
    dolaşım sınıfı aynı zamanda dolaşılabilir bir sınıf gibi de davranmak zorundadır. Yani dolaşım sınıfının __iter__ metodu da bulunmalı ve bu __iter__ 
    metodu self ile geri dönmelidir. 

    Dolaşılabilir sınıf ile dolaşım sınıflarının farklı yazıldığı bir örnek verelim. Aşağıdaki örnekte 0'dan belli sayıya kadar 
    sayıların karekökünü veren dolaşılabilir bir sınıf verilmiştir.
#------------------------------------------------------------------------------------------------------------------------

import math

class SqrtIterable:
    def __init__(self, n):
        self.n = n
        
    def __iter__(self):
        return SqrtIterator(self)
    
class SqrtIterator:
    def __init__(self, iterable):
        self.index = -1
        self.iterable = iterable

    def __iter__(self):
        return self
        
    def __next__(self):
        self.index += 1
        if self.index == self.iterable.n:
            raise StopIteration()
        
        return math.sqrt(self.index)
    
for x in SqrtIterable(10):
    print(x)
    
#------------------------------------------------------------------------------------------------------------------------
    Aşağıdaki örnekte orijinal built-in range sınıfının myrange isminde bir benzeri yazılmıştır. 
#------------------------------------------------------------------------------------------------------------------------

import math

class myrange:
    def __init__(self, start, stop = None, step = 1):
        if stop == None:
            self.start = 0
            self.stop = start
        else:
            self.start = start
            self.stop = stop
            
        self.step = step
        
    def __iter__(self):
        self.i = self.start - self.step
        return self
    
    def __next__(self):
        self.i += self.step
        if self.i >= self.stop:
            raise StopIteration()
        return self.i
    
    def __len__(self):
        return math.ceil((self.stop - self.start) / self.step)
    
    def __getitem__(self, index):
        if isinstance(index, slice):
            return myrange(index.start, min(index.stop, self.stop), index.step)
            
        if not isinstance(index, (int, bool)):
            raise TypeError('range indices must be integers or slices, not float')
        if index < 0:
            count = len(self)
            if index < -count:
                raise IndexError('myrange object index out of range')
            index = count + index
        retval = self.start + self.step * index
        if  retval >= self.stop:
            raise IndexError('myrange object index out of range')
        return retval
    
    def __repr__(self):
        s = f'myrange({self.start}, {self.stop}'
        if self.step > 1:
            s += f', {self.step}'
        s += ')'
        
        return s
            
mr = myrange(10)

a = list(mr)
print(a)

mr = myrange(10, 20)
a = list(mr)
print(a)
        
mr = myrange(10, 20, 3)
a = list(mr)
print(a)
    
result = mr[-4]
print(result)
        
#------------------------------------------------------------------------------------------------------------------------
    Tabii dolaşılabilir bir nesne dolaşılırken tek bir değer vermek zorunda değildir. Örneğin bir demet nesnesi de verebilir. 
#------------------------------------------------------------------------------------------------------------------------

import math

class SqrtIterable:
    def __init__(self, n):
        self.n = n
        
    def __iter__(self):
        self.i = -1
        return self
    
    def __next__(self):
        self.i += 1
        if self.i == self.n:
            raise StopIteration()
        return self.i, math.sqrt(self.i)

s = SqrtIterable(10)

for number, root in s:
    print(number, '=>', root)
    
d = dict(SqrtIterable(100))
print(d)

#------------------------------------------------------------------------------------------------------------------------
    Built-in enumerate fonksiyonunu biz de basit bir biçimde aşağıdaki gibi yazabiliriz.
#------------------------------------------------------------------------------------------------------------------------

class myenumerate:
    def __init__(self, iterable, start = 0):
        self.iterator = iterable.__iter__()
        self.start = start - 1
        
    def __iter__(self):
        return self
    
    def __next__(self):
        self.start += 1
        
        return self.start, self.iterator.__next__()
    
a = [10, 20, 30, 40]

for t in myenumerate(a):
    print(t)

#------------------------------------------------------------------------------------------------------------------------
    Yukarıdaki örnekte olduğu gibi bazen manuel bir biçimde __next__ metodunun çağrılması gerekebilir. Örneğin elimzde 
    dolaşılabilir bir nesne olsun. Biz bu nesneyi for döngüsü ile dolaşmak isteyelim. Ancak ilk elemanı pas geçmek isteyelim.
    Ya da elimizde yine bir dolaşılabilir nesne olsun. Biz bu nesnenin elemanlarını bir list nesnesine yerleştirelim. Ancak ilk elemanı 
    pas geçmek isteyelim. Dolaşım nesnelerinin de dolaşılabilir nesneler gibi davrandığını anımsayınız.
#------------------------------------------------------------------------------------------------------------------------

a = [10, 20, 30, 40, 50, 60]

iterator = a.__iter__()
iterator.__next__()     # ilk elemanı pas geçmek için

for x in iterator:
    print(x)
        
#------------------------------------------------------------------------------------------------------------------------
    Örneğin dolaşılabilir nbir nesnenin en büyük elemanını bulan bir fonksiyon yazmak isteyelim. Bilindiği bu fonksiyon aslında built-in 
    biçimde max ismiyle bulunmaktadır. Biz en büyük elemanı bulurken ilk elemanın en büyük olduğunu kabul edip sonraki elemanlarla 
    karşılaştırırız. Bu tür durumlarda manule __next__ işlemi gerekebilmektedir. Aşağıdaki örnekte böyle bir mymax fonksiyonu yazılmıştır. 
    (Orijinal max fonksiyonu eğer dolaşılabilir nesnede eleman yoksa ValueError ile raise işlemi yapmaktadr.)
#------------------------------------------------------------------------------------------------------------------------

import random

class RandomIterable:
    def __init__(self, beg, end, n):
        self.beg = beg
        self.end = end
        self.n = n
        
    def __iter__(self):
        self.i = -1
        return self
    
    def __next__(self):
        self.i += 1
        if self.i == self.n:
            raise StopIteration()
        return random.randint(self.beg, self.end)
        
def mymax(iterable):
    iterator = iterable.__iter__()
    try:
        maxval = iterator.__next__()
    except StopIteration:
        raise ValueError('iterable has zero element')
    
    for x in iterator:
        if x > maxval:
            maxval = x
            
    return maxval

result = mymax(RandomIterable(0, 100, 2))
print(result)
        
#------------------------------------------------------------------------------------------------------------------------
    Python standart kütüphanesinde iter ve next isimli iki built-in fonksiyon vardır. Bu fonksiyonlar aslında parametresiyle verilen
    nesne üzerinde __iter__ ve __next__ metotlarını çağırmaktadır. Başka bir deyişle iterable.__iter__() çağırısı ile iter(iterable) 
    aynı işlevdedir. Benzer biçimde iterator.__next__() çağrısı ile next(iterator) çağrısı da anı anlamdadır. Yani bu fonksiyonlar aşağıdaki gibi 
    yazılmıştır (bazı ayrıntılar söz konusudur):

    def iter(i):
        return .__iter__()

    def next(i):
        return i.__next__()
#------------------------------------------------------------------------------------------------------------------------

a = [10, 20, 30, 40, 50]

iterator = iter(a)                  # a.__iter__()

try:
    while True:
        val = next(iterator)        # iterator.__next__()
        print(val)      
except StopIteration:
    pass

#------------------------------------------------------------------------------------------------------------------------
    Dolaşılabilir nesnelerdeki dolaşım işlemi ileriye doğru yapılmaktadır? Pekiyi geriye doğru dolaşım yapılamaz mı? 
    İşte Python'da bunun için built-in global reversed fonksiyonu bulundurulmuştur. Biz bu fonksiyonu daha önce yüzeysel 
    biçimde görmüştük. reversed foksiyonu bizden dolaşılabilir bir nesneyi alır, bize tersten dolaşıma izin veren yeni bir dolaşılabilir
    nesne verir. Yani kullanımı şmöyledir:

    new_iterable = reversed(iterable)

    Biz bu nesneyi dolaşırsak elemanları tersten elde ederiz. Örneğin:

    a = [10, 20, 30, 40, 50]

    iterable = reversed(a)

    for x in iterable:
        print(x)

    Ancak her dolaşılabilir nesne reversed fonksiyonuna sokulamamaktadır. Sınıf yazanların buna izin vermesi gerekir. Aslında reversed 
    fonksiyonun tek yaptığı şey sınıfın __reversed__ isimli özel metodunu çağırmaktır. Yani fonksiyon şöyle yazılmıştır:

    def reversed(iterable):
        return iterable.__reversed__()

    Bu durumda bizim bir sınıf nesnesini reversed fonksiyonuyla kullanabilmemiz için sınıfın __reversed__ isimli bir metodunun 
    bulunuyor olması gerekir. 

    Aşağıdaki örnekte daha önce yazmış olduğumuz SqrtIterable sınıfını tersten dolaşılabilir hale getiriyoruz. 
#------------------------------------------------------------------------------------------------------------------------

import math

class SqrtIterable:
    def __init__(self, n):
        self.n = n
        
    def __iter__(self):
        self.i = -1
        return self
    
    def __next__(self):
        self.i += 1
        if self.i == self.n:
            raise StopIteration()
        return math.sqrt(self.i)
    
    def __reversed__(self):
        return SqrtReverseIterator(self)
        
class SqrtReverseIterator:
    def __init__(self, siter):
        self.siter = siter
        self.i = siter.n
        
    def __iter__(self):
        return self
        
    def __next__(self):
        self.i -= 1
        if self.i < 0:
            raise StopIteration()
            
        return math.sqrt(self.i)

for x in SqrtIterable(4):
    print(x)
    
for x in reversed(SqrtIterable(4)):
    print(x)

#------------------------------------------------------------------------------------------------------------------------
    Geriye doğru dolaşımı sağlamak için __reversed__ metodunda yukarıdaki örnekte olduğu gibi farklı bir iterator sınıfı oluşturmak
    işlemleri kolaylaştırmaktadır. Aynı sınıfın hem ileriye doğru hem de geriye doğru dolaşım yapabilmesi mümkün olsa da 
    karmaşık bir tasarımı gerektirir. Aşağıdaki örnek biraz kusurlu olsa da tek bir sınıfın hem ileriye hem de geriye doğru dolaşımsağlamasının zorluğunu göstermektedir. 
#------------------------------------------------------------------------------------------------------------------------

import math

class SqrtIterable:
    def __init__(self, n):
        self.n = n
        self.direction = 1
        
    def __iter__(self):
        if self.direction == 1:
            self.i = -1
        else:
            self.i = self.n
        
        return self
    
    def __next__(self):
        self.i += self.direction
        if self.direction == 1:
            if self.i == self.n:
                raise StopIteration()
        else:
            if self.i < 0:
                raise StopIteration()
                
        return math.sqrt(self.i)
    
    def __reversed__(self):
        self.direction = -1
        return self
    
for x in SqrtIterable(4):
    print(x)
    
for x in reversed(SqrtIterable(4)):
    print(x)

#------------------------------------------------------------------------------------------------------------------------
    Dolaşılabilir (iterable) nesne kavramı ile dolaşım (iterator) nesnesi kavramı birbirine benzemektedir. Bir nesnenin dolaşılabilir olması için ona ilişkin sınıfta __iter__ metodunun olması gerekir. Halbuki bir nesne dolaşım nesnesi ise ona ilişkin sınıfta __next__ metodu olur. Ancak dolaşım nesneleri de dolaşılabilir nesneler gibi kullamılabilmektedir. Daha önceden de belirttiğimiz gibi dolaşım nesnelerinin de __iter__ metodu olmak zorundadır. İki kavram arasındaki öenmli fark şudur: Elimizde bir dolaşılabilir nesne varsa biz onu her defasında yeniden yani baştan itibaren dolaşabiliriz. Ancak elimizde dolaşım nesnesi varsa biz onu bir kez dolaştığımızda bitirmiş oluruz. Artık bir daha dolaşamayız. Örneğin list nesnesi dolaşılabilir bir nesnedir. Biz her defasında o nesnenin elemanlarını baştan dolaşabiliriz:

    a = [1, 2, 3, 4, 5]

    for x in a:
        print(x, end=' ')
        
    print()

    for x in a:
        print(x, end=' ')

    Ancak list nesnesinden elde ettiğimiz dolaşım nesnesini bir kez dolaşabiliriz. İkinci dolaştığımızda zaten sona gelindiği için dolaşım yapılamayacaktır. 
    Örneğin:

    a = [1, 2, 3, 4, 5]

    iterator = iter(a)      # a.__iter__()

    for x in iterator:
        print(x, end=' ')
        
    print()

    for x in iterator:
        print(x, end=' ')

    İşte bir üretici fonksiyonu çağırdığımızda fonksiyon bize bir dolaşım nesnesi vermektedir. O nesneyi biz bir kez dolaşabiliriz. Örneğin:

    def foo():
        for i in range(10):
            yield i
            
    g = foo()

    for x in g:
        print(x, end=' ')
    print()

    for x in g:
        print(x, end=' ')
    print()
#------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------
    Anımsanacağı gibi map isimli built-in fonksiyon bizden bir fonksiyon ve dolaşılabilir nesneyi parametre olarak alıp bize bir dolaşım
    nesnesi veriyordu. Biz bu nesneyi dolaştığımızda dolaşılabilir nesnedeki elemanların bu fonksiyona argüman olarak geçilmesi sonucunda 
    elde edilen değerleri elde ediyorduk. Örneğin:

    def foo(x):
        return x ** 2

    a = [1, 2, 3, 4, 5]

    result = map(foo, a)

    for x in result:
        print(x, end= ' ')
        
    map fonksiyonu dolaşılabilir bir sınıf biçiminde aşağıdaki gibi yazılabilir.
#------------------------------------------------------------------------------------------------------------------------

class mymap:
    def __init__(self, f, iterable):
        self.f = f
        self.iterator = iter(iterable)

    def __iter__(self):
        return self
    
    def __next__(self):
        val = next(self.iterator)
        return self.f(val)

def foo(x):
    return x ** 2

a = [1, 2, 3, 4, 5]

result = mymap(foo, a)

for x in result:
    print(x, end= ' ')

#------------------------------------------------------------------------------------------------------------------------
                                            58. Ders 21/11/2022 - Pazartesi
#------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------
    Üretici fonksiyonlara (generators) özellikle yorumlayıcılarla çalışılan dillerde karşılaşılmaktadır. Ancak derleyici temelli bazı dillerede de
    özellikle son yıllarda üretici fonksiyonlar eklenmiştir. Python'da bir fonksiyonda en az bir kez yield isimli deyim kullanılırsa artık 
    o fonksiyona üretici fonksiyon denilmektedir. Örneğin:

    def foo():
        print('one')
        yield 1
        print('two')
        yield 2
        print('three')
        yield 3
    
    yield deyiminin genel biçimi şöyledir:

    yield [ifade]
    
    Bir üretici fonksiyonun türü normal bir fonksiyondur. Ancak üretici fonksiyon çağrıldığında bir "üretici nesne (generator object)" 
    elde edilmektedir. Bu üretici nesneye Python Language Reference dokümanlarında "generator iterator" da denilmektedir. Örneğin:

    g = foo()

    Burada g bir üretici nesnedir. 
#------------------------------------------------------------------------------------------------------------------------

def foo():
    print('one')
    yield 1
    print('two')
    yield 2
    print('three')
    yield 3

print(type(foo))        # <class 'function'>

g = foo()

print(type(g))          # <class 'generator'>

#------------------------------------------------------------------------------------------------------------------------
    Üretici nesneler birer dolaşım (iterator) nesnesidir dolayısıyla da dolaşılabilir nesnelerdir. Yani biz bir üretici nesnei 
    for döngüsüyle dolaşabiliriz. İstersek next metodunu sürekli çağırarak da (__iter__ metodunu çağırmadan) de dolaşabiliriz. Bir üretici 
    nesne dolaşılmak istendiğinde (next yapıldığında) üretici fonksiyon çalıştırılır ve yield deyiminin olduğu yerde durur ve yield deyiminin 
    yanındaki ifadenin değerini verir. Bir daha dolaşılmak istendiğinde (yan inext yapıldığında) fonksiyon yield deyiminde kaldığı yerden devam 
    eder ve sonraki yield deyiminde durur. Sonraki yield deyiminin değerini verir. Yani yield deyimi fonksiyonu bitirmemektedir. 
    O anki iterasyonu bitirmektedir Programın akışı yield deyimini gördüğünde durdurulur. Ancak bu durdurma geçici bir durdurmadır. 
    Her next işleminde fonksiyon durdurulduğu yerden çalışmaya devam eder. Nihayet fonksiyon bittiğinde (return ile de bitebilir) StopIteration oluşmaktadır. 
    Bu da dolaşımın bittiği anlamına gelir. Örneğin:

    def foo():
        print('one')
        yield 1
        print('two')
        yield 2
        print('three')
        yield 3

    g = foo()

    result = next(g)
    print(result)

    result = next(g)
    print(result)

    result = next(g)
    print(result)

    result = next(g)     # StopIteration 

    Burada g bir üretici nesnedir. Biz next(g) yaptığımızda akış ilk yield deyimine kadar çalışır onun yanındaki ifadenin değeri 
    next fonksiyonundan elde edilen değerdir. Sonraki next fonksiyonun kaldığı yerden devam etmesini sağlar. Fonksiyon bitince dolaşım da bitecektir. 
    Yukarıki kod çalıştırıldığında ekrana şunlar basılacaktır:

    one
    1
    two
    2
    three
    3
    (StopIteration exception)

#------------------------------------------------------------------------------------------------------------------------

def foo():
    print('one')
    yield 1
    print('two')
    yield 2
    print('three')
    yield 3

g = foo()

result = next(g)
print(result)

result = next(g)
print(result)

result = next(g)
print(result)

result = next(g)     # StopIteration 

#------------------------------------------------------------------------------------------------------------------------
    Üretici nesneler dolaşılabilir olduğuna göre biz onları for döngüsüyle de dolaşabiliriz. Örneğin:

    def foo():
        print('one')
        yield 1
        print('two')
        yield 2
        print('three')
        yield 3

    for x in foo():
        print(x)

    Burada her iterasyonda akış sonraki yield'te duracak ve o yield ifadesinin değeri x'e atanacaktır. Fonksiyon bittiğinde 
    StopIterarion oluşacağından for döngüsü sonlanmış olacaktır. 
#------------------------------------------------------------------------------------------------------------------------

def foo():
    print('one')
    yield 1
    print('two')
    yield 2
    print('three')
    yield 3

for x in foo():
    print(x)

#------------------------------------------------------------------------------------------------------------------------
    Üretici fonksiyonlar sayesinde biz dolaşılabilir nesneleri çok daha kolay oluşturabiliriz. Örneğin:

    def foo():
        for i in range(10):
            yield i * i

    for x in foo():
        print(x)
        
    Burada her yield işlemi bize bir sayının karesin verecektir. Bu durumda ekrana 0'dan 10'a kadar sayıların kareleri yazdırılacaktır.
#------------------------------------------------------------------------------------------------------------------------

def foo():
   for i in range(10):
       yield i * i

for x in foo():
    print(x)
    
#------------------------------------------------------------------------------------------------------------------------
    Biz range fonksiyonunu dolaşılabilir bir sınıf olarak yazmıştık. Standart kütüphanedeki range fonksiyonu aslında dolaşılabilir bir sınıftır. 
    Ancak istersek range fonksiyonunu bir üretici fonksiyon biçiminde de yazabiliriz. Üretici fonksiyonlar dolaşılabilir nesne oluşturmanın 
    alternatif ve kolay yollarından biridir. 
#------------------------------------------------------------------------------------------------------------------------

def myrange(start, stop = None, step = 1):
    if stop == None:
        stop = start
        start = 0
    
    i = start
    while i < stop:
        yield i
        i += step
        
for i in myrange(10, 20, 2):
    print(i)
   
#------------------------------------------------------------------------------------------------------------------------
    Aşağıdaki örnekte her asal sayı bulunduğunda akış yield ile durdurulup bulunan asal sayı verilmektedir. Böylece biz 
    asal sayıları veren dolaşılabilir bir nesne elde etmiş oluruz. 
#------------------------------------------------------------------------------------------------------------------------

import math

def get_primes(n):
    if n < 2:
        raise ValueError('argument ')
    def isprime(x):
        if x % 2 == 0:
            return x == 2
        for i in range(3, int(math.sqrt(x)) + 1, 2):
            if x % i == 0:
                return False
        return True
    
    if n >= 2:
        yield 2
    
    i = 3
    while i <= n:
        if isprime(i):
            yield i
        i += 2   
        
for prime in get_primes(7):
    print(prime)
      
#------------------------------------------------------------------------------------------------------------------------
    Pekiyi dolaşılabilir nesnelere neden gereksinim duyarız? Yani örneğin biz yukarıdaki get_primes fonksiyonunu zaten asal sayıları bir liste 
    biçiminde veren bir fonksiyon gibi yazamaz mıydık? İşte bir böyle bir fonksiyonun önce asal sayıları bulup bunu bir listeye doldurması gerekirdi. 
    Halbuki dolaşılabilir nesneler yalnızca bir talep ettiğimizde yeni değeri bize vermektedir. 

    Örneğin diskimizdeki tüm dosyalar üzerinde bir işlemler yapmak isteyelim. Yani kökten başlayarak her dizine tek tek geçip tüm 
    dosyaları elde etmek isteyelim. Bu çok yorucu ve uzun zaman alana bir işlemdir. Diskimizde binlerce dosya bulunuyor olabilir. 
    Bunlarının hepsinin elde edilmesi ve bize bir liste olarak verilmesi oldukça zordur. Oysa biz istediğimzde bize kalınan yerden
    devamedilerek dosyalar verilse bu işlem çok daha anlamlı olur. İşte dolaşılabilir nesneler bir adım adım yapmak için tercih edilmektedir. 
    Eğer dizin ağacını dolaşan bir fonksiyonu dolaşılabilir bir nesne yoluyla gerçekleştirmezsek hem bizim tüm dosyaları bir listede saklamamız gerekir 
    hem de bu işlem çok uzun zaman alabilir. Gerçekten de os modülü içerisindeki walk fonksiyonu bir üretici fonksiyon olarak yazılmıştır. 
    Yani walk fonksiyonu dizin ağacını dolaşırken her yeni girişi bulduğunda yield onu bize vermekte ve sonra kaldığı yerden devam etmektedir. 
#------------------------------------------------------------------------------------------------------------------------

import os

for root, dirs, files in os.walk('f:\\'):
    print(root)

#------------------------------------------------------------------------------------------------------------------------
   Pekiyi dolaşılabilir bir nesne elde etmek için dolaşılabilir sınıflar mı yoksa üretici fonksiyonlar mı tercih edilmelidir? 
   İşte bu tercih içinde bulunulan duruma göre değişebilmektedir:

   - Dolaşılabilir sınıflar her __next__ metodunda bize yeni değeri verirler. Oysa üretici fonksiyonlar her yield işleminde bize değer verirler. 
   Üretici fonksiyonun durudulması ve o noktadan çalışma devam ettirilmesi daha uzun zaman almaktadır. Yani dolaşılabilir sınıflar 
   daha hızlı olma eğilimindedir. 

   - Üretici fonksiyonları yazmak kolaydır. Çünkü herhangi bir fonksiyon hemen üretici fonksiyon haline getirilebilir. Oysa 
   dolaşılabilir sınıfları yazmak daha zordur. Dolaşılabilir sınıflarda akış durudurulmadığı için her __next__ metodunda durumsal bilginin saklanarak 
   o noktadan devam ettirilmesi gerekmektedir. Bu da daha fazla çaba anlamına gelir. Üretici fonksiyonlar çok daha pratik yazılabilmektedir. 
#------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------
    Anımsanacağı gibi dolaşılabilir nesne kavramı ile dolaşım nesnesi kavramı birbirinden farklıydı. Bir dolaşım nesnesi dolaşıldığında
    artık sona geliniyordu ve bir daha dolaşılamıyordu. İşte bir üretici fonksiyonu çağırdığımızda fonksiyon bize bir dolaşım nesnesi vermektedir. O nesneyi biz bir kez dolaşabiliriz. Örneğin:

    def foo():
        for i in range(10):
            yield i
            
    g = foo()

    for x in g:
        print(x, end=' ')
    print()

    for x in g:
        print(x, end=' ')
    print()

    Örneğin enumerate fonksiyonu bize dolaşılabilir bir nesne vermez, bir dolaşım nesnesi verir. Yani enumerate fonksiyonun verdiği nesneyi
    biz dolaşırsak bir kez dolaşım yapabiliriz:

    a = [1, 2, 3, 4, 5]

    e = enumerate(a)
    for index, x in e:
        print(f'{index}  => {x}')
        
    print()

    for index, x in e:
        print(f'{index}  => {x}')
        
    Şimdi de built-in enumarate fonskiyonu dolaşım sınıfı olarak ve üretici fonksiyon olarak yazalım:

    class myenumerate:
        def __init__(self, iterable, start=0):
            self.iterator = iter(iterable)
            self.i = start - 1
            
        def __iter__(self):
            return self
        
        def __next__(self):
            self.i += 1
            return self.i, next(self.iterator)
        
    a = [10, 20, 30, 40, 50]

    e = myenumerate(a)
    for index, x in e:
        print(f'{index} => {x}')
    print('---------------')

    for index, x in e:
        print(f'{index} => {x}')
    print('---------------')

    def myenumerate(iterable, start=0):
        i = start
        for x in iterable:
            yield i, x
            i += 1
            
    e = myenumerate(a)
    for index, x in e:
        print(f'{index} => {x}')
    print('---------------')

    for index, x in e:
        print(f'{index} => {x}')
    print('---------------')
 
#------------------------------------------------------------------------------------------------------------------------
    Daha önce built-in map fonksiyonunu dolaşılabilir bir sınıf biçiminde yazmıştık. Şimdi de bu fonksiyonu bir üretici 
    fonksiyon biçiminde yazalım. (Standart kütüphanede map üretici fonksiyon biçiminde değil dolaşılabilir sınıf biçiminde yaızlmıştır.)
#------------------------------------------------------------------------------------------------------------------------

def mymap(f, iterable):
    for val in iterable:
        yield f(val)
    
def foo(x):
    return x ** 2

a = [1, 2, 3, 4, 5]

result = mymap(foo, a)

for x in result:
    print(x, end= ' ')
    
#------------------------------------------------------------------------------------------------------------------------
    Üretici nesneler birer dolaşım nesnesi belirtiyordu. Dolayısıyla o nesnelerle __next__ metodunu çağırsak ya da eşdeğer olarak next 
    fonksiyonuna o nesneleri versek akış ilk yield deyimine kadar çalışıyor ve yield değerini bize veriyordu. Ancak bu işlemin tersi de mümkündür. Yani yield deyimi de bir değer üretebilmektedir. Default durumda next işlemleri sırasında yield deyimi None değer üretir. Örneğin:

    def foo():
        result = yield 1
        print(result)
        
        result = yield 2
        print(result)
        
        result = yield 3
        print(result)
        
    g = foo()

    result = g.__next__()
    print(result)

    result = g.__next__()
    print(result)

    result = g.__next__()
    print(result)

    Buradan şöyle bir çıktı elde edilecektir:

    1
    None
    2
    None
    3

    İşte biz üretici nesne ile send metodunu çağırırsak aslında hem akışı durduğu yerden devam ettirmiş oluruz hem de yield işleminden 
    istediğimiz bir değerin elde edilmesini sağlarız. Ancak send metodu ancak yield'de durmuş akış için kullanılır. Dolayısıyla üretici nesne üzerinde 
    dolaşım send ile başlatılmaz. Ancak devam ettirilebilir. Örneğin:

    def foo():
        result = yield 1
        print(result)
        
        result = yield 2
        print(result)
        
        result = yield 3
        print(result)
        
    g = foo()

    result = next(g)
    print(result)

    result = g.send(10)
    print(result)

    result = g.send(20)
    print(result)

    Her send işlemi yield'de duran akışı devam ettirir. Ancak next işlemşnden farkı yield'den bir değer üretilmesini sağlamasıdır. 
    Yani biz yield'de duran akışı devam ettirirken aynı zamanda yield'den bir değer de elde edilmesini istiyorsak bu durumda 
    send uygulamalıyız. 

    Üretici fonksiyonu next ile kaldığı yerden devam ettirirsek yield None üretmektedir. Başka bir deyişle:

    next(g)

    işlemi adeta aşağıdaki ile eşdeğerdir:

    g.send(None)

    Anımsanacağı gibi next isimli built-in fonksiyon aslında __next__ metodunu çağırmaktadır. Yani şöyle yazılmıştır:

    def next(iterator):
        return iterator__next__()

    Ancak built-in bir send fonksiyonu yoktur. Yani send üretici nesneyle kullanılmalıdır. 

    Bazen üretici fonksiyon durmuşken onu çalışıtırırken özel değerler fonksiyonu geçirilmek istenebilmektedir. İşte bu tür durumlarda 
    send metodu kullanılır. Ancak bu tür ihtiyaçlar oldukça seyrektir. 
#------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------
    Anımsanacağı gibi liste içlemleri, küme içlemleri ve sözlük içlemleri vardı ancak demet içlemleri yoktu. Bunun ana nedeni 
    demetlerin değiştirilebilir nesneler olmamasıdır. Ancak demet içlemi sentaksı Python'da bulunmaktadır fakat başka bir anlama gelmektedir. 
    Demet içlemi sentaksına Python'da "üretici ifadeler (generator expresssions)" denilmektedir. Örneğin:

    a = [1, 2, 3, 4, 5]

    b = [x * x for x in a]      # list comprehensin
    print(b)

    c = (x * x for x in a)      # üretici ifade (generator expression)

    Bir üretici ifade aslında üretici bir fonksiyonun basit bir yazım biçimidir. Üretici ifade bize aslında bir üretici nesne vermektedir. Yani:

    g = (ifade for değişken in dolaşılabilir_nesne)

    İşleminin eşdeğeri şöyedir:

    def some_generator_name(dolaşılabilir_nesne):
        for x in dolaşılabilir_nesne:
            yield ifade

    g = some_generator_name()
    
#------------------------------------------------------------------------------------------------------------------------

a = [1, 2, 3, 4, 5]

g = (x * x for x in a)      # üretici ifade (generator expression)

for x in g:
    print(x, end=' ')
print()

#------------------------------------------------------------------------------------------------------------------------
                                59. Ders 23/11/2022 - Çarşamba
#------------------------------------------------------------------------------------------------------------------------
   
#------------------------------------------------------------------------------------------------------------------------
    Pekiyi üretici ifade de aslında üretici fonksiyon belirttiğine göe arada ne fark vardır? Yani örneğin:

    g = (i * i for i in trange(100))

    gibi bir üretici ifade ile aşağdıaki arasında ne farklılık vardır?

    def foo():
        for i in range(100):
            yield i * i

    g = foo()

    İşte üretici ifadeler "ifade (expression)" tanımına uymaktadır. Dolayısıyla başka ifadelerin içerisinde kullanılabilirler. Örneğin:

    import statistics

    result = statistics.mean((i * i for i in range(10)))

    print(result)        

    Biz burada üetici ifadeyi doğrudan fonksiyon çağırma işleminde argüman olarak kullandık. Halbuki aynı işlemi üretici 
    fonksiyonlarla yapmak isteseydik daha zor olacaktı:

    def foo():
        for i in range(10):
            yield i * i
        
    result = statistics.mean(foo())
    print(result)

#------------------------------------------------------------------------------------------------------------------------
    Üretici ifadeler eğer bir fonksiyon ya da metot çağrılırken argüman olarak kullanılıyorsa ve çağrım işleminde başka da bir argüman bulundurulmuyorsa üretici ifadelerdeki dıştaki parantezler hiç kullanılmayabilir. Örneğin:

    import statistics

    result = statistics.mean((i * i for i in range(10)))

    print(result) 

    Yukarıdaki çağrımda dıştaki parantezler hiç kullanılmayabilirdi. Örneğin:

    result = statistics.mean(i * i for i in range(10))
    Ancak eğer çağrımda başka bir argüman da kullanılıyorsa bu durumda dıştaki parantezler ihmal edilemez. Örneğin:

    for index, val in enumerate(i * i for i in range(10), 100):     # geçersiz!
        print(f'{index} => {val}')

    Burada enumerate fonksiyonu iki argümanla çağrıldığı için üretici ifadedeki dış parantezler ihmal edilemez. Tabii enumerate fonksiyonu tek argümanla çağrılsaydı dıştaki parantezler ihmal edilebilirdi:

    for index, val in enumerate(i * i for i in range(10)):     # geçerli!
        print(f'{index} => {val}')

#------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------
    Aşağıdaki örnekte print fonksiyonuna dolaşılabilir bir üretici ifade *'lı bir biçimde verilmiştir. Bu durumda bu üretici 
    ifade dolaşılıp elde edilen değerler ekrana yazdırılacaktır. 
#------------------------------------------------------------------------------------------------------------------------

print(*(i for i in range(100) if i % 7 == 0)) 

#------------------------------------------------------------------------------------------------------------------------
    Bir fonksiyonun bir ifade içerisinde tanımlanarak o ifade içerisinde kullanılmasına programlama dillerinde "lambda ifadeleri (lambda expressions)" denilmektedir. Aslında lambda ifadeleri eskiden fonksiyonel dillerde karşımıza çıkan yapılardı. Ancak son yıllarda 
    pek çok dile fonksiyonel özellikler katmak için lambda ifadeleri sokulmuştur. C++, C# ve Java gibi dillerde lambda ifadeleri 
    daha geniş bir sntaks yapısına dolayısıyla kullanım alanına sahiptir. Python'daki lambda ifadeleri bu dillerdekilere gör oldukça 
    kısıtlı ve minimalist bir yapıdadır. Lambda ifadelerinin genel biçimi şöyledir:

    lambda [parametre_listesi]: <ifade>

    Örneğin:

    f = lambda a: a * a
    result = f(10)
    print(result)

    lambda ifadeleri aslında bir fonksiyon oluşturmaktadır. lmabda anahtar sözcüğünün yanındaki değişken listesi fonksiyonun parametreleridir. 
    Burada (...) kullanılmaz. İki nokta üst üste atomunun yanında bir ifadenin olması gerekir. Bu ifade de aslında fonksiyonun 
    geri dönüş değerini belirtir. Burada return kullanılmaz. Zaten bu ifade return ifadesi anlamına gelmektedir. lambda ifadelerinden elde 
    edilen değer bir fonksiyon nesnesinin adresidir. Dolayısıyla biz onu bir değişkene atarsak o değişken fonksiyon nesnesini gösterecektir. 
    Bu da tamamen fonksiyon ile aynı etkinin yaratılması anlamına gelir. Örneğin:

    >>> f = lambda a: a * a
    >>> type(f)
    <class 'function'>
    >>> f(10)
    100
    >>> f(5)
    25

    Bu durumda:

    f = lambda a: a * a

    işleminin eşdeğeri şöyledir:

    def f(a):
        return a * a

    Tabii lambda ifadeleri bir deyim dğildir, ifadedir. Dolayısıyla başka ifadelerin içeisinde kullanılabilir. Örneğin:

    m = map(lambda a: a * a, [1, 2, 3, 4, 5])

    for x in m:
        print(x, end= ' ')

    Burada biz map fonksiyonuna bir fonksiyon oluşturup onu vermiş olduk. Bu işlemin eşdeğeri şöyledir:

    def f(a):
        return a * a
        
    m = map(f, [1, 2, 3, 4, 5])

    for x in m:
        print(x, end= ' ')

    Lambda ifadelerinin ':' atomundan sonraki kısmında içinde bulunulan fonksiyonun yerel değişkenleri ve global değişkenler kullanılabilir. 
    Yani bu anlamda lambda fonksiyonları adeta bir iç fonksiyon (nested function) gibidir. Örneğin:

    def foo(val):
        for x in map(lambda a: a * val, [1, 2, 3, 4, 5]):
            print(x, end=' ')
        print()
                    
    foo(5)
    foo(10)

    Bu durumda yukarıdaki kodun eşdeğeri şöyledir:

    def foo(val):
        def f(a):
            return a * val
        for x in map(f, [1, 2, 3, 4, 5]):
            print(x, end=' ')
        print()
                    
    foo(5)
    foo(10)

    lambda ifadelerinin parametresi olmak zorunda değildir. Ancak genellikle lambda ifadeleri parametreli olur. Örneğin:

    f = lambda: 100
    result = f()
    print(result)

    lambda ifadelerinin birden fazla parametresi de olabilir. Örneğin:

    f = lambda a, b: a + b
    result = f(10, 20)
    print(result)       # 30

    Lambda ifadelerinde ':' atomunun sağında bir deyim olamaz. (Yani if, for return gibi deyimler kullanılamaz.) Bir ifade olabilir. 
    Tabii koşul operatörü bir operatör olduğu için lambda ifadelerinde kullanılabilir. Örneğin:

    f = lambda a, b: a if a > b else b

    result = f(10, 20)
    print(result)       # 20

    Buradaki if deyim değildir bir operatör görevindedir. 

    Lambda ifadeleri fonskiyon belirttiğine göre hiç ara değişken kullanılmadna fonksiyon çağırma operatör ile çağrılabilir. Ancak 
    tabii dıştan bir parantez zorunludur. Örneğin:

    result = (lambda a, b: a if a > b else b)(10, 20)

    print(result)       # 20

    Mademki aslında metotlar birer sınıf değişkenidir. O halde bir lambda ifadesi ile de bir metot oluşturabiliriz. Örneğin:

    class Sample:
        def __init__(self, a):
            self.a = a

        get_a = lambda self: self.a 
        
    s = Sample(10)

    result = s.get_a()
    print(result)

#------------------------------------------------------------------------------------------------------------------------
    Standart kütüphanede filter isimli ilginç bir fonksiyon vardır. filter fonksiyonu bizden bir fonksiyon ve dolaşılabilir 
    nesne alır (tıpkı map gibi) ve bize dolaşım nesnesi verir. Biz filter fonksiyonunun veridiği dolaşım nesnesini dolaştığımızda aslında 
    filter fonksiyonuna verdiğimiz dolaşılabilir nesneyi dolaşmış oluruz. Ancak bu nesnedeki elemanlar önce filer fonksiyonun birinci parametresinde
    verdiğimiz fonksiyona sokulacak ve True ile geri dönenler bize verilecektir. Yani filer fonksiyonu bizim verdiğimiz dolaşılabilir nesnedeki 
    bazı değerleri atmak için (filtrelemek için) kullanılmaktadır. 

    f Örneğin.

    result = filter(lambda a: a % 2 == 0, [1, 2, 3, 4, 5, 6, 7, 8, 9, 10])

    for x in result:
        print(x, end= ' ')
    print()

    Burada biz yalnızca çift değerleri elde etmekteyiz. 

    filter fonksiyonu yoluyla bir grup değer içerisinde koşulu sağlayan değerleri filtreleyebiliriz. Örneğin:

    import math 

    def isprime(a):
        if a % 2 == 0:
            return a == 2
        
        for i in range(3, int(math.sqrt(a)) + 1, 2):
            if a % i == 0:
                return False
            
        return True

    for x in filter(isprime, [34, 71, 17, 41, 7, 101, 102]):
        print(x, end=' ')
    print()

    Burada biz liste içerisindeki asal olan değerleri elde etmekteyiz. 

    Fonksiyonel programlamada bu biçimde True/False değerlerine geri dönen fonksiyonlara "predicate" de denilmektedir. 
    Predicate fonksiyonlar eğer tek ifadeden oluşuyorsa lambda biçiminde yazılabilir. 

    Örneğin biz birler basamağı 1 olan değerleri şöyle elde edebiliriz:

    for x in filter(lambda a: a % 10 == 1, [34, 71, 17, 41, 7, 101, 102]):
        print(x, end=' ')
    print()

#------------------------------------------------------------------------------------------------------------------------
   
#------------------------------------------------------------------------------------------------------------------------
    filer fonksiyonu standart kütüphanede dolaşılabilir bir sınıf biçiminde yazılmıştır. Onu aşağdaıki gibi yazabiliriz.
#------------------------------------------------------------------------------------------------------------------------
 class myfilter:
     def __init__(self, f, iterable):
         self.f = f
         self.iterator = iter(iterable)
         
     def __iter__(self):
         return self
     
     def __next__(self):
         while True:
             val = next(self.iterator)
             if self.f(val):
                 return val
             
for x in myfilter(lambda a: a % 10 == 2, [34, 71, 17, 41, 7, 101, 102]):
     print(x, end=' ')
print()

#------------------------------------------------------------------------------------------------------------------------
    Şimdi de filter fonksiyonunu üretici fonksiyon olarak yazalım. Tabii üretici fonksiyon olarak yazmak çok kolay. Ancak yukarıda da 
    belirttiğimiz gibi üretici fonksiyonların durdurulup çalıştırılması zaman kaybına yol açmaktadır. 
#------------------------------------------------------------------------------------------------------------------------
   
def myfilter(f, iterable):
    for val in iterable:
        if f(val):
            yield val
            
for x in myfilter(lambda a: a % 10 == 1, [34, 71, 17, 41, 7, 101, 102]):
    print(x, end=' ')
print()

#------------------------------------------------------------------------------------------------------------------------
                                                60. Ders 28/11/2022 - Pazartesi
#------------------------------------------------------------------------------------------------------------------------
   
#------------------------------------------------------------------------------------------------------------------------
    Sınıfların diğer bir özel metodu ise __new__ isimli metottur. __new__ metodu nesneyi tahsis eden asıl metottur. Python'da 
    __new__ metodu nesneyi tahsis ederken __init__ metodu tahsis edilmiş olan nesne üzerinde ilk işlemleri yapar. Genellikle
    programcılar sınıfları için __new__ metodunu yazmazlar. Ancak __init__ metodunu yazarlar. __new__ metodua bazı ileri uygulamalarda 
    gereksinim duyulabilmektedir. Örneğin kurumuzun uygulama kısmında göreceğimiz "meta sınıflar (meta classes)" konusunda bu metodun 
    kullanımı üzerinde duracağız.

    Nesnelerin tahsis edilmesi object sınıfının __new__ metodu yoluyla yapılamaktadır. Dolayısıyla biz sınıfımız için __new__ metodunu çağırmazsak bu 
    sınıf türünden nesneler yarattığımızda object sınıfının __new__ metodu çağrılacaktır. object sınıfının __new__ metodu da 
    tahsisatı yapacaktır. Örneğin:

    class Sample:
        pass

    s = Sample()        # __new__ metodu çağrılıyor, ancak Sample sınıfının __new__ metodu olmadığı için object sınıfınınki çağrılıyor

    __new__ metodu static bir metottur ve metodun bir parametresi vardır. Bu parametre tahsis edilecek sınıf nesnesinin ilişkin olduğu 
    sınıf belirtmektedir. 

    Programcı tahsisatı eninde sonunda object sınıfının __new__ metodu ile yapar. Ancak programcı bazen nesne yaratılırken "araya girmek"
    isteyebilir. Örneğin:
    
    class Sample:
        @staticmethod
        def __new__(cls):
            print('nesne yaratılırken araya giriyoruz')
            
            return super().__new__(cls)
            
        def __init__(self):
            print('__init__ çağrılıyor')

    s = Sample()        # s = Sample.__new__(Sample)

    Burada aslında tahsisat sırasında Sample türünden nesnenin yaratılması için Sample sınıfının static __new__ metodunu çağrılmaktadır. 
    Sample sınıfının __new__ metodu bizim tarafımızdan yazılmıştır. Ancak biz nesneyi tahsis edemeyiz. Biz yalnızca bir araya girme işlemi yapabiliriz. 
    Nesnenin tahsis edilmesi object sınıfının __new__ metodu ile yapılmalıdır. Dolayısıyla nesnenin tahsis edilmesi için biz super çağrısıyla
    object sınıfın __new__ metodunu çağırdık. Pekiyi mademki aslında tahsisat object sınıfının __new__ metodu ile yapılacak neden biz __new__ metodunu yazdık?
    İşte bazen araya girme işlemlerinin yapılması gerekebilmektedir. Pekiyi ya nesne yaratırken argüman girsek ne olacaktır? İşte aslında __new__ metodu 
    birinci parametresi tahsis edilecek sınıfı alan ancak diğer parametreleri nesneyi yaratırken kullandığımız argümanları alan bir parametrik yapıda olmalıdır. 
    Örneğin:

    s = Sample(10, 20, 30)

    Aslında burada Sample.__new__(Sample, 10, 20, 30) gibi bir çağırma söz konusu olacaktır. O halde __new__ metodu her türlü argümanla çağrılabilir olması gerekir. 
    Onun da yolu *'lı **'lı parametre kullanmaktadır. Örneğin:

    class Sample:
        @staticmethod
        def __new__(cls, *args, **kwargs):        
            print('nesne yaratılırken araya giriyoruz')
            
            return super().__new__(cls)
            
        def __init__(self, a, b):
            self.a = a
            self.b = b
            print('__init__ çağrılıyor')

    s = Sample(10, 20)        # Sample.__new__(Sample, 10, 20)
    
    object sınıfının __new__ metodu tek parametrelidir. O da sınıfa ilişkin type nesnesini almaktadır. 

    Aslında buradaki meslenenin biraz daha karmaşık bir tarafı vardır. Öncelikle bu tarafı açıklamadan önce bir konuyu anımsatmak istiyoruz. 
    Anımsayacağınız gibi Python yorumlayıcısı bir sınıf tanımlamasını gördüğünde type sınıfı türünden bir nesne yaratıyor ve sınıf ismine o type nesnesinin 
    adresini atıyordu. Örneğin:

    class Sample:
        pass

    Burada aslında Sample sıradan değişkendir. Bu değşken type sınıf nesnesini görmektedir. Sample sınıfının bilgileri bu nesnenin içerisindedir. 
    Yani burada Sample type sınıfı türündendir. Mademki sınıf isimleri aslında type sınıfı türünden birer nesne beelirtmektedir. O halde aslında
    bir sınıf türünden nesne yaratılırken aslında type sınıfının __call__ metodu çağrılır. Örneğin:

    s = Sample(10, 20)        # Sample type türündne olduğuna göre type sınıfının __call__ metodu çağrılacaktır

    O zaman biz yukarıdaki gibi bir sınıf türünden nesne yaratmak istediğimizde aslında type sınııfnın __call__ metodu çağrılmaktadır. İşte nesnenin yaratılmasına önayak
    olan aslında type sınıfının __call__ metodudur. Örneğin nesne şöyle yaratılmış olsun:

    s = Sample(10, 20)

    Burada aslında type sınıfının __cal__ metodu çağrılacaktır. Sample da bu metoda self parametresi olarak aktarılacaktır. type sınıfının __call__ 
    metodununher argümanı kabul etmesi için aşağdaki gibi bir parametrik yapıya sahip olması gerekir:

    class type:
        def __call__(self, *args, **kwargs):
            pass

    type sınıfının __call__ metodu önce ilgili türün __new__ metodunu çağırır. Eğer metodun verdiği nesne belirtilen tür türündense bu sefer o nesne ile
    o sınıfın __init__ metodunu çağırmaktadır. Başka bir deyişle aslında type sınıfının __call__ metodu adeta aşağıdaki gibi yazılmıştır:

    class type:
        def __call__(self, *args, **kwargs):
            instance = self.__new__(self)
            if isinstance(instance, self):
                instance.__init__(*args, **kwargs)
            return instance

    Burada önemli noktaları tek tek belirtelim:

    1) Bir sınıf türünden nesne yaratılmak istendiğinde aslında type sınıfının __call__ metodu çağrılır.
    
    2) type sınıfının __call__ metodu aşağıdaki gibi yazılmıştır:

    class type:
        def __call__(self, *args, **kwargs):
            instance = self.__new__(self)
            if isinstance(instance, self):
                instance.__init__(*args, **kwargs)
            return instance

    __cal___ metodundaki self aslında yaratım yapıldığı sınıf belirtir. Yani örneğin:

    s = Sample(10, 20)

    gibi bir yaratımda aslında type snıfının __call__ metodunun self parametresi Sample'dır. 10 ve 20 değerleri ise __call__ metosunun args parametresine aktarılır. 
    Burada type sınıfının __call__ metodunun içerisinde önce aşağıdaki işlem yapılmıştır:

    instance = self.__new__(self)
    
    Pekiyi burada kimin __new__ metodu çağrlmaktadır? Tabii ki Sample'ın. Pekiyi Sample sınıfının __new__ metodu yoksa kiminki çağrılacaktır? Tabii ki object'in.
    O zaman bu satır Sample sınıfı türünden bir nesnenin yaratılmasına yol açacaktır. Sonra şu işlemler yapılmıştır:

    if isinstance(instance, self):
        instance.__init__(*args, **kwargs)

    Bunun anlamı şudur: Eğer yaratılan nesne Sample türünden değilse __init__ çağrılmamaktadır. (Zaten böylesi bir durumda Sample sınıfının __init__ metodunun çağrılması 
    anlamsızdır)

    Nihayet şu işlem yapılmıştır:

    return instance

    Burada tahsis edilen nesneyle geri dönülmüştür. Bu da s değişkenine atanmıştır. 

    Burada önemli nokta biz bir sınıf için __new__ metodunu yazdığımızda eğer bu metodu o sınıf türüden bir nesneyle geri döndürmezsek bu durumda 
    o sınıfın __init__ metou çağrılmayacaktır. Aşağıdaki örnekte Sample sınıfının __init__ metodu çağrılmayacaktır.

    class Mample:
        def __init__(self):
        print('Mample.__init__')

    class Sample:
        @staticmethod
        def __new__(cls, *args, **kwargs):
            print('Sample.__new__')
            instance = object.__new__(Mample)
            return instance
        
        def __init__(self):
            print('Sample.__init__')
        
    s = Sample(10, 20)

    3) Nesnenin yaratılması her zaman object sınıfının __new__ metodu ile yapılır. Yani eninde sonunda bir nesne yratılacaksa object sınıfının 
    __new__ metodu çağrılmış olmalıdır. type sınıfının __call__ metodu nesneyi kendisi yaratmaz. Yine object sınıfının __new__ metodu yoluyla nesne 
    yaratılmaktadır. 

    Özetle bir sınıf türünden bir nesne yaratılmaya çalışıldığında aslında type sınıfının __call__ metodu çağrılır. type sınıfının __call__ metodu 
    önce nesne yaratılmak istenen sınıfın __new__ metodunu çağrır sonra da __init__ metodunu çağırır. 
#------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------
    type sınıfı ile object sınıfı arasında mantıksal bir ilişki yoktur. type sınıfı bir "meta sınıf"tır. Yani bir sınıfın bilgilerini tutan sınıftır. 
    Meta sözcüğü üst kavram olarak kullanılmaktadır. Sınıf bilgi tutar, ancak sınıfın kendi bilgileri de bir sınıf tarafından tutulmaktadır. 
    İşte o type sınıfıdır. Bu durumda type meta bir sınıftır. object sınıfı ise her sınııfn taban sınıfı görevinde olan nesne yaratma işlemini yapan sınıftır. 
    Kaldı ki type sınıfı da object sınıfından türetilmiştir. 
#------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------
    Pekiyi biz neden bir sınıf için __new__ metodunu yazmak isteriz? İşte bunun nedeni biraz ileri düzey konularla ilgilidir. 
    Örneğin "singleton" kalıbı mecburen __new__ metodu kullanılarak oluşturulmaktadır. NYPT'de singleton kalıbı bir sınıf türünden tek bir nesnenin 
    yaratıldığı (yani kişiler nesne yarattığını sansalar da aslında hep aynı nesnenin elde edildiği) bir kalıptır. Aşağıda singleton 
    kalıbına örnek verilmiştir. 
#------------------------------------------------------------------------------------------------------------------------
   
class Sample:
    @staticmethod
    def __new__(self):
        if not Sample.singleton:
            Sample.singleton = super().__new__(Sample)
            print('initialize object')
            
        return Sample.singleton
    
    singleton = None
    
s = Sample()
k = Sample()
m = Sample()

print(id(s), id(k), id(m))

#------------------------------------------------------------------------------------------------------------------------
    Sınıfların eleman erişiminde kullanılan __getattr__ isimli bir metodu vardır. Bir sınıf türünden değişkenle o sınıfın olmayan 
    bir örnek özniteliğine ya da bir metoduna erişildiğinde sınıfın __getattr__ metodu çağrılmaktadır. __getattr__ metodunun self parametresi 
    dışında olmayan elemanın ismini alan bir name parametresi (ismi name olmak zorunda değildir) de vardır. __getattr__ metodu
    erişilen elemana geri dönmelidir. Örneğin:

    
    class Sample:
        def __getattr__(self, name):
            print(name)
            return 0
            
    s = Sample()
    x = s.val
    print(x)        # 0

    Burada s.val ifadesinde sınıfın olmayan bir örnek özniteliğine erişilmek istenmiştir. Bu udurmda sınıfın __getattr__ metodu çağrılacak
    ve name parametresine erişimde kullanılan gerçekte olmayan "val" ismi geçirilecektir. Bu erişimden elde edilen değer __getattrr__ metodundan 
    döndürülen değerdir. Eğer nesne ile olan bir elemana erişiyorsa bu durumda __getattr__ çağrılmamaktadır. Örneğin:

    class Sample:
        def __init__(self):
            self.val = 10
        def __getattr__(self, name):
            print(name)
            return 0

    s = Sample()
    x = s.val
    print(x)        # 10

    Burada s.val erişiminde val zaten vardır. Bu durumda __getattr__ çağrılmayacaktır.  

    Normal olarak eğer sınıfta __getattr__ metodu yoksa biz sınıfın olmayan bir elemanına erişmeye çalıştığımızda AttributeError 
    isimli exception oluşur.  
#------------------------------------------------------------------------------------------------------------------------
   
#------------------------------------------------------------------------------------------------------------------------
    Sınıfın __getattr__ metodu "property" kavramını oluşturmak amacıyla ve başka birtakım amaçlarla kullanılabilmektedir. 
    Property metotların adeta birer örnek özniteliği gibi kullanılmasını sağlayan bir mekanizmadır. C++ ve Java gibi 
    dillerde property yoktur. Fakat örneğin C#'ta vardır. Python'da property'ler __getattr__ metodu yoluyla ya da property 
    isimli dekoratör yoluyla oluşturulabilmektedir. Örneğin Circle isimli bir sınıf yazmak isteyelim. Sınıfın area isimli bir örnek 
    özniteliğinin olmasına gerek yoktur. Çünkü area aslında yarıçaptan hareketle hesaplanabilmektedir. İşte biz __getattr__ yoluyla sanki area isimli
    örnek özniteiği sınıfta varmış gibi bir durum oluşturabiliriz. 
#------------------------------------------------------------------------------------------------------------------------
   
import math

class Circle:
    def __init__(self, x, y, radius):
        self.x = x
        self.y = y
        self.radius = radius
        
    def __getattr__(self, name):
        if name == 'area':
            return math.pi * self.radius ** 2
        
        raise AttributeError(f'{name} not found')
    
c = Circle(10, 10, 2)
a = c.area
a = c.xxxx
print(a)

#------------------------------------------------------------------------------------------------------------------------
    Sınıfta olmayan elemanların kullanılması teması property dışında başka yerlerde de karşımıza çıkabilmektedir. 
    Örneğin biz __getattr__ sayesinde sınıf nesnesi yaratırken verdiğimiz isimli argümanları sanki onlar birer örnek özniteliğiymiş 
    gibi kullanabiliriz. 
#------------------------------------------------------------------------------------------------------------------------
   
class Sample:
    def __init__(self, **kwargs):
        self.kwargs = kwargs
        
    def __getattr__(self, name):
        result = self.kwargs.get(name)
        if result:
            return result
        
        raise AttributeError(f'{name} not found')
    
s = Sample(ali=10, veli=20, selami=30)

print(s.ali)
print(s.veli)
print(s.selami)

#------------------------------------------------------------------------------------------------------------------------
    Sınıfın __getattr__ metoduna benzer bir de __getattribute__ metodu vardır. __getattribute__ metodu bir sınıf türünden değişken ile
    sınıfın bir elemanına erişilirken eleman olsa da olmasa da çağrılmaktadır. __getattr__ metodunun eleman yoksa çağrıldığına dikkat ediniz. 
#------------------------------------------------------------------------------------------------------------------------

class Sample:
    def __init__(self):
        self.a = 10

    def __getattribute__(self, name):
        print(name)
        return 0

s = Sample()

result = s.x
result = s.y
result = s.a

#------------------------------------------------------------------------------------------------------------------------
                                            61. Ders 30/11/2022 - Çarşamba
#------------------------------------------------------------------------------------------------------------------------
   
#------------------------------------------------------------------------------------------------------------------------
    Sınıfın __getattribute__ metodunda sınıfın bir elemanına erişmeye çalışırsak yeniden __getattribute__ çağrılacağı için sonsuz 
    döngü oluşabilir. Örneğin:

    class Sample:
        def __init__(self):
            self.a = 10
            
        def __getattribute__(self, name):
            if name == 'a':
                return self.a           # dikkat! sonsuz döngü
                
            raise AttributeError()
        
    s = Sample()

    result = s.a

    Burada s.a erişiminde Sample sınıfının __getattribute__ metodu çağrılacaktır. Ancak __getattribute__ metodu içerisinde de 
    yine a örnek özniteliğine erişilmiştir. Bu durumda sonsuz döngü oluşacaktır. Biz __getattribute__ içerisinde sınııfn başka 
    bir örnek özniteliğine erişmek istediğimizde yine __getattribute__ metodu çağrılacaktır ve bu metotta yine sorun ortaya çıkacaktır. 
    Örneğin:

    class Sample:
        def __init__(self):
            self._a = 10
            
        def __getattribute__(self, name):
            if name == 'a':
                return self._a      # dikkat! yeniden __getattribute__ metodu çağrılacaktır
                
            raise AttributeError()
        
    s = Sample()

    result = s.a

    __getattribute__ metodu içerisinde özyineleme yapmadan nesnenin örnek özniteliğine erişmenin tek yolu object sınıfının __getattribute__
    metodunu kullanmaktır. Eğer object sınıfının __getattribute__ metodu kullanılırsa artık ilgili sınıfın __getattribute__ metodu çağrılmaz. Örneğin:

    class Sample:
        def __init__(self):
            self.a = 10
            
        def __getattribute__(self, name):
            if name == 'a':
                return object.__getattribute__(self, name)
                
            raise AttributeError()
        
    s = Sample()

    result = s.a
    print(result)

    Burada object.__getattribute(self, name) çağrısı ile name isimli örnek özniteliğinin değerine erişilmiştir. 

#------------------------------------------------------------------------------------------------------------------------
   
#------------------------------------------------------------------------------------------------------------------------
    Pekiyi sınıfın hem __getattr__ hem de __getattribute__ metotları varsa ne olur? İşte bu durumda __getattr__ hiç devreye girmez. 
    Olan elemana erişimde zaten __getattr__ devreye girmyecektir. Olmayan elemana erişimde de __getattr__ devreye girmez. Yani bu durumda
    __getattr__ metodunu yazmanın bir anlamı kalmaz. Örneğin:

    class Sample:
        def __init__(self):
            self.a = 10
            
        def __getattr__(self, name):            # dikkat bu metodu yazmanın bir anlamı kalmayacaktır
            print(f'__getattr__: {name}')
            
        def __getattribute__(self, name):
            print(f'__getattribute__: {name}')
        
    s = Sample()

    s.a
    s.b

#------------------------------------------------------------------------------------------------------------------------
   
#------------------------------------------------------------------------------------------------------------------------
    SInıfların __setattr__ metotları bir sınıf nesnesi ile sınıfın olan ya da olmayan elemanlarına değer atandığı durumda çağrılmaktadır.
    Buı anlamda __setattr__ adeta __getattribute__ metodunun set yapan biçimi gibidir. Ayrıca bir __setattribute__ metodu bulunmamaktadır. 
    Örneğin:

    class Sample:
        def __init__(self):
            self.a = 10             # dikkat! yine __setattr__ çağrılacak
            
        def __setattr__(self, name, value):
            print(name, value)
        
    s = Sample()

    s.a = 10        # dikkat! _setattr__ çağrılacak

    __setattr__ metodunun self parametresi dışında iki parametresi daha vardır. Bunlardan ilki atama yapılmak istenen elemanın ismini belirtir. 
    İkincisi ise o elemana atanacak değeri belirtmektedir. 

    Burada __init__ içerisinde self.a işlemi yapılırken de __setattr__ çağrılacaktır. Bu tür durumlarda da yine özyineleme yapmamak için 
    object sınıfının __setattr__ metodu kullanılabilir. 

    class Sample:
        def __init__(self):
            self.a = 10
            
        def __getattr__(self, name):
            print(f'__getattr__: {name}')
            
        def __getattribute__(self, name):
            if name == 'a':
                print(f'__getattribute__: {name}')
            
    s = Sample()

    s.a
    s.b
            
    Alında __setattr__ çağrılmadan sınıfın bir örnek özniteliğine eleman atamak için __dict__ örnek özniteliğini de 
    kullanabiliriz. __dict__ örnek özniteliği izleyen bölümde ele alınmaktadır.

    class Sample:
        def __init__(self):
            self.__dict__['a'] = 10         # __setattr__ çağrılmayacak
            
        def __setattr__(self, name, value):
            print(name, value)
        
    s = Sample()
    s.a = 10        # dikkat! _setattr__ çağrılacak

    Sınıfın __setattr__ metodu yine bir property etkisi yaratmak için kullanılabilmektedir. Örneğin:

    import math

    class Circle:
        def __init__(self, x, y, radius):
            object.__setattr__(self, 'x', x)
            object.__setattr__(self, 'y', y)
            object.__setattr__(self, 'radius', radius)
            
        def __getattr__(self, name):
            if name == 'area':
                return math.pi * self.radius ** 2
            
            raise AttributeError(f'{name} not found')
            
        def __setattr__(self, name, value):
            if name == 'area':
                object.__setattr__(self, 'radius', math.sqrt(value / math.pi))
                
        
    c = Circle(10, 10, 2)

    print(c.area)

    c.area = math.pi

    print(c.radius)

#------------------------------------------------------------------------------------------------------------------------
   
#------------------------------------------------------------------------------------------------------------------------
    Daha önce de bahsettiğimiz gibi property'ler veri elemanı gibi kullanılan metotlardır. Biz yukarıda Circle sınıfı örneğinde 
    Circle sınıfıın area isimli bir örnek özniteliğini kullanmıştır. Ancak gerçekte böyle bir örnek özniteliği sınıfta yoktu. Aslında 
    bir örnek özniteliğinin sınıfta olmasına gerek de yoktu. Çünkü eğer biz dairenin yarıçağını biliyorsak zaten alanını hesaplayabiliriz. 
    İşte yukarıdaki örnekte Circle sınıfında gereksiz bir area örnek özniteliğini tutmak yerine biz sanki bu örnek özniteliği varmış 
    gibi bir kod çalıştırmıştık. Bu kod da bize yarıçaptan hareketle daire alanını vermiştir. Property'lerin kullanılmasının birinci amacı
    bir veri elemanı tutmayıp sanki o veri elemanı varmış gibi bir durum oluşturmaktır. Ancak ikinci amacı (birinci amaçtan daha aşağı bir amaç 
    değildir) "veri elemanlarının gizlenmesi (data hiding)" prensibinin uygulanmasını sağlanaktır. Veri elemanlarının gizlenmesi NYPT'nin 
    önemli prensipkerinden biridir. Genellikle Python'da programcılar bu prensibi kullanmazlar. Ancak bazı programcılar property'ler yoluyla
    bu prensibi kullanabilmektedir. 
#------------------------------------------------------------------------------------------------------------------------
   
#------------------------------------------------------------------------------------------------------------------------
    Veri elemanlarının gizlenmesi (data hiding) veri elemanlarının dışarıdan kullanımını engelleyip onlara kodlar yoluyla erişimi
    mümkün hale getirmek anlamına gelmektedir. Python.2da dışarıdan erişilmesini istemedeiğimiz öniteliklerin başın '_' ve '__' ekliyorduk.
    Tabii bu eklama erişimi engellemiyordu. Yalnızca dışarıya bir "erişme" biçiminde mesaj veriyordu. Halbuıki C++, Java ve C# gibi 
    diğer dillerde dışarıdan erişimin tamamen engellenmesi için sınıflarda "private" bulundurulmuştur. 

    Veri elemanlarının dışarıdan erişilmesini engellemenin ve onlara kodlar yoluyla erişilmesine izin verilmesinin üç temel 
    neden vardır:

    1) Veri elemanlarına dışarıdan erişilirse onlar üzerinde yapılacak değişikliklerden onları kullanan kodlar etkilenir. Örneğin:

    class Date:
        def __init__(self, day, month, year):
            self.day = day
            self.month = month
            self.year = year
        # ...

    d = Date(10, 20, 2007)
    print(d.day, d.month, d.year)

    Burada sınıfın day, month ve year elemanları yerine programcı daha sonra tarih bilgisini bir yazıy ile tutacak biçimde tek bir eleman kullanırsa
    bu sınıfı kullanan kodlar geçersiz hale gelir. Halbuki bu elemanlara doğrudan erişimi engelleyip onlara kodlarla erişimi 
    mümkün hale getirirsek bu durumda biz sınıfın elemanları üzerinde değişiklik yapsak bile bu değişiklikten onları kullkanmış olan kodların 
    etkilenmesişni engelleyebiliriz. 

    2) Sınıfın bir örnek özniteliğine programcı geçersiz değerler atayabilir.  Bu da atamamen sınıfın hatalı çalışmasına yol açabilir. Örneğin:
    
    d.day = 100

    Burda bir gün hiçbir zaman 100 olmaz ancak bir denetim (validation) uygulanmamıştırç Halbuki bu atama bir kdola yapısaydı oarada 
    sınır kontrolü uygulanıp duruma göre exception fırlatılabilirdi.

    3) Sınıfn birbirleriyle ilişkili örnek öznitelikleri olabilir. Yani bunlardan birine değer atandığında diğerlerinin de değiştirilmesi gerekebilir. 
    İşte bu tür işlemlerin kodla yapılması bu karmaşık ilişkinin arka planda doğru bir biçimde oluşturulmasını sağlayabilmektedir. 
        
#------------------------------------------------------------------------------------------------------------------------
    Python'da property kullanımı aslında property isimli bir dekoratör sınıf yoluyla kolay bir biçimde yapılabilmektedir. 
    property sınıfı built-in bir sınıftır. Sınıfın __init__ metodunun parametrik yapısı şöyledir:

    class property(fget=None, fset=None, fdel=None, doc=None)

    Bu sınıfın kullanımı şöyledir:

    1) Programcı gizledeiği özniteliğin değerini alacak ve değerini set edecek iki metot bulundurur. (Aslında delete işlemi doc işlemi için 
    de iki metot daha bulundurabilmektedir.) get metodunun yalnızca self parametresi olur ve bu metot get edilecek değer ile geri döndürülür. 
    set metodunun ise self dışında bir parametresi daha vardır. Bu parametre örnek özniteliğine atanan değeri belirtmektedir. set metodunun bir 
    geri dönüş değeri yoktur.

    2) Sonra property sınıfı türünden bir sınıf değişkeni ekler. 

    artırmaktaık erişimde bu get ve set metotları devreye girecektir. Örneğin:

    import math

    class Circle:
        def __init__(self, x, y, radius):
            self.x = x
            self.y = y
            self.radius = radius
            
        def __repr__(self):
            return f'center = ({self.x},{self.y}), radius = {self.radius}'
        
        def _get_area(self):
            return math.pi * self.radius ** 2
        
        def _set_area(self, value):
            self.radius = math.sqrt(value / math.pi)
            
        area = property(_get_area, _set_area)
                
        
    c = Circle(10, 10, 2)
    print(c)

    print(c.area)
    c.area = 10
    print(c)

    Burada area isimli bir property oluşturulmak istenmiştir. Bu property için _get_area ve _set_area metotları sınıfa eklenmiştir. 
    Bu metotların başına getirilen '_' onların dışarıdan kullanılmamaları konusunda bir bildirim oluşturmaktadır. Sonra sınıfa 
    area isimli bir sınıf değişkeni eklenmiştir. Bu değişken property isimli bir sınıf türündedir. 

    Tabii property'lerin read/write olması gerekmez. Örneğin "read-only" property'ler söz konusu olabilmektedir. Read-only property demek
    yalnızca get yapılan ama set yapılamayan property demektir.

#------------------------------------------------------------------------------------------------------------------------

class Date:
    def __init__(self, day, month, year):
        self._day = day
        self._month = month
        self.year = year
        
    def __repr__(self):
        return f'{self.day}/{self.month}/{self.year}'
    
    def _get_day(self):
        return self._day
    
    def _set_day(self, day):
        if day < 0 or day > 31:
            raise ValueError(f'invalid day: {day}')
        self._day = day
        
    day = property(_get_day, _set_day)
    
    def _get_month(self):
        return self._month
    
    def _set_month(self, month):
        if month < 0 or month > 12:
            raise ValueError(f'invalid month: {month}')
        self._month = month
        
    month = property(_get_month, _set_month)
    
date = Date(10, 20, 2009)

print(date)

print(date.day)

date.day = 12

#------------------------------------------------------------------------------------------------------------------------
    property sınıfının __init__ metodunun üçüncü parametresi ilgili örnek özniteliği del deyimi ile silmeye çalıştığımızda çağrılacak 
    metodu belirtmektedir. Örneğin:

    class Sample:
        def __init__(self, a):
            self._a = a
            
        def _get_a(self):
            return self._a
        
        def _set_a(self, a):
            self._a = a
            
        def _del_a(self):
            print('delete a')
            
        a = property(_get_a, _set_a, _del_a)
        

    s = Sample(10)

    del s.a   # _del_a metodu çağrılacak
#------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------
    Aslında property'ler dekaratör sentaksıyla çok daha kolay bir biçimde oluşturulabilmektedir. Örneğin:

    class Sample:
        def __init__(self, a):
            self._a = a
            
        @property
        def a(self):
            return self._a
        
    # a = property(a)
    
    s = Sample(10)

    print(s.a)

    Burada dekoratör sentaksına dikkat ediniz:

     @property
     def a(self):
        return self._a

    Bu sentaks aslında aşağıoaki ile eşdeğerdir:

    a = property(a)

    O halde aslında a örnek özniteliği kullanıldığında a metodu çağrılacaktır. a metodunu çağırmanın başka bir yolu da yoktur.

    Pekiyi dekoratör yoluyla set metodu nasıl yazılmaktadır. İşte set için dekoratör fonksiyonu görevini property sınıfının setter 
    metodu yapmaktadır. Örneğin:

    class Sample:
        def __init__(self, a):
            self._a = a
            
        @property
        def a(self):
            return self._a
        
        # a = property(a)

        @a.setter
        def a(self, val):
            self._a = val
        
        # a = a.setter(a)
        
    s = Sample(10)

    print(s.a)

    s.a = 20
    print(s.a)

    Burada aşağıdaki dekoratöre dikkat ediniz:

    @a.setter
    def a(self, val):
        self._a = val

    Bu dekoratörün eşdeğer kodu şöyledir:

    a = a.setter(a)

    Bu eşdeğer koda göre yeni a metodu property sınıfının setter metoduna parametre yapılmıştır ve bunun geri dönüş değeri 
    yine a'ya atanmıştır. Bu durumda property sınıfnın setter metodu aslında bu yeni a metodunu property nesnesine set metodu olarak eklemektedir. 
    Yani buradaki setter dekoratörü aslında aşağıdaki gibi oluşturulmuştur:

    class myproperty:
        def __init__(self, fget = None, fset = None, fdel = None, doc = None):
            self.fget = fget
            self.fset = fset
            self.fdel = fdel
            self.doc = doc
            
        def setter(self, fset):
            self.fset = fset
            return self

    class Sample:
        def __init__(self, a):
            self._a = a
            
        @myproperty
        def a(self):
            return self._a
        
        # a = myproperty(a)

        @a.setter
        def a(self, val):
            self._a = val
        
        # a = a.setter(a)
        
    s = Sample(10)

    print(type(s.a))

    Burada bir yer kafa karıştırabilir. a eğer myproperty sınıfı türündense aşağıdaki metotta a ismi değişmeyecek midir?

    @a.setter
    def a(self, val):
        self._a = val
    
    Eğer a bir metot ismiyse ve yorumlayıcı bunun için bir fonksiyon nesnesi oluşturup adresine a'ya atayacaksa önce a bozulmayacak mıdır?
    İşte dekoratör sentaksında aslında dekoratöre konu olan değişken boşuna hiç oluşturulmamaktadır. Yani burada a ismi aslında bozulmamaktadır.
    Başka bir deyişle aslında yukarıdaki dekoratörün eşdeğeri şöyledir:

    def some_temporary_name(self, val):
        self._a = val

    a = a.setter(some_temporary_name)

    deleter dekoratrörü de benzer bir manrıkla oluşturulmuştur:

    class Sample:
        def __init__(self, a):
            self._a = a
            
        @property
        def a(self):
            return self._a
        
        # a = property(a)

        @a.setter
        def a(self, val):
            self._a = val
        
        # a = a.setter(a)
        
        @a.deleter
        def a(self):
            print('a deleter')
        
    s = Sample(10)

    print(s.a)

    s.a = 20
    print(s.a)

    del s.a
  
#------------------------------------------------------------------------------------------------------------------------
    Şimdi de dekoratör yoluyla Date sınıfı için property yazalım.
#------------------------------------------------------------------------------------------------------------------------
   
class Date:
    def __init__(self, day, month, year):
        self._day = day
        self._month = month
        self._year = year
        
    @property
    def day(self):
        return self._day
    
    @day.setter
    def day(self, val):
        self._day = val
        
    @property
    def month(self):
        return self._month
       
    @month.setter
    def month(self, val):
        self._month = val
           
    @property
    def year(self):
        return self._year
    
    @year.setter
    def year(self, val):
        self._year = val
        
    def __repr__(self):
        return f'{self._day}/{self._month}/{self._year}'
                 
date = Date(10, 12, 2009)

print(date)

date.day = 15
date.month = 8
date.year = 2009

print(date)

#------------------------------------------------------------------------------------------------------------------------
                                                62. Ders 05/12/2022 - Pazartesi
#------------------------------------------------------------------------------------------------------------------------
   
#------------------------------------------------------------------------------------------------------------------------
    Betimleyiciler (descriptors) ya da betimleyici sınıflar Python'a sonradan eklenmiştir. property sınıfı gibi birtakım sınıfların 
    yazılabilmesi için böyle bir kavrama ihtiyaç duyulmuştur. Bir sınıfın betimleyici sınıf olması için o sınıfta __get__ ya da 
    __set__ ya da __delete__ metotlarının bulunuyor olması gerekir. Genellikle betimleyici sınıflarda __get__ ve __set__ metotları 
    bulunabilmektedir. Bazı sınıflarda yalnızca __get__ metodu bulunyor olabilir.

    __get__ metodunun self dışında iki parametresi olmalıdır. Örneğin:

    def __get__(self, instance, owner):
        pass

    __set__ metodunun da self dışında iki parametresi bulunur. Örneğin:

    def __set__(self, instance, value):
        pass

    __delete__ metodunun ise self parametresi dışında tek bir parametresi olmalıdır. Örneğin:

    def __delete__(self, instance):
        pass

    Betimleyici bir sınıf başka bir sınıfın sınıf değişkeni durumunda olur. Betimleyici sınıfların bu kullanım dışında başka anlamlı 
    kullanımları yoktur. Örneğin:

    class Sample:
        a = MyDescriptor()

    Burada a Sample sınıfının bir özniteliğidir yani bir sınıf değişkenidir. Bilindiği gibi sınıf değişkenlerine normalde ismiyle erişilir. 
    Ancak onlara ilgili sınıf türünden değişkenlerlle de erişebiliriz.

    Bir betimleyici sınıf elemanına sahip olan bir sınıf türünden nesne yaratıldıktan sonra bu sınıf değişkeni ile betimleyici elemana 
    değer almak amacıyla erişimde betimleyici sınıfın __get__ metodu, değer yerleştirmek amacıyla erişimde betimleyici sınıfın __set__ metodu 
    ve del operatörü ile kullanımda da betimleyici sınıfın __delete__ metodu çağrılmaktadır. Örneğin:

    s = Sample()

    Burada şöyle kod yazmış olalım:

    result = s.a

    Burada s nesnesi yoluyla sınıfın a isimli betimleyici elemanına erişilmektedir. Bu erişim değer almak amacıyla yapılmaktadır. O zaman betimleyici sınıfın 
    __get__ metodu çağrılacakltır. __get__ metodunun self parametresi a sınıf değişkenini belirten MyDescriptor sınıfı türünden olur. 
    instance parametresine s nesnesi geçirilecektir ve owner parametresine de Sample sınıfının type nesne referansı geçirilecektir. 
    Genellikle bu üçüncü parametreye __get__ metodunda gereksinim duyulmamaktadır. Şimdi s.a ifadesine atama yapmak isteyelim

    s.a = 100

    Burada artık betimleyici sınıfın __set__ metodu çağrılacaktır. Metodun self parametresine yine a betimleyici nesnesi geçirilecektir. 
    s nesnesi yine instance parametresine geçirilecektir. value paramtresine ise atanan değer olan 100 değeri geçirilecektir. 

    Şimdi de bu s.a ifadesini del operatörü ile silmeye çalışalım:

    del s.a

    Burada da betimleyici sınıfın __delete__ metodu çağrılacaktır. (Bu metodu __del__ metoduyla karıştırmayınız. __del__ metodu çöp toplayıcı tarafından 
    çağrılmaktadır.) __delete__ metodunun self parametresine yine a betimleyici nesnesi geçirilir. s yine metodun instance parametresine geçirilmektedir. 

    Aşağıdaki örnekte çıkan sonuçlara dikkat ediniz. 

#------------------------------------------------------------------------------------------------------------------------
   
class MyDescriptor:
    def __get__(self, instance, owner):
        print('__get__ params:')
        print(type(self), type(instance), type(owner), sep=', ')
        print(self, instance, owner, sep=',')
            
    def __set__(self, instance, value):
        print('__set__ params:')
        print(type(self), type(instance), type(value), sep=', ')
        print(self, instance, value)
      
    def __delete__(self, instance):
        print('__delete__ params:')
        print(type(self), type(instance), sep=', ')
        print(self, instance, sep=', ')
        
    def __repr__(self):
        return 'MyDescriptor object'
    
class Sample:
    a = MyDescriptor()
    
    def __repr__(self):
        return 'Sample object'
    
s = Sample()

result = s.a

s.a = 100

del s.a   

#------------------------------------------------------------------------------------------------------------------------
    Pekiyi betimleyici sınıflar ve değişkenler neden kullanılmaktadır? İşte bazı işlemler ancak bu betimleyici konusu ile 
    yapılabilmektedir. Örneğin daha önceki konumuzda property isimli bir sınıf görmüştük ve o sınıfı dekoratör olarak da 
    kullanmıştık. İşte property gibi bir sınıf yazabilmek için mecburen bir betimleyici sınıfa gereksinimimiz olur. 

    Aşağıdaki property kullanımına bir daha dikkat ediniz:

    class Sample:
        def __init__(self, a):
            self._a = a
            
        def get_a(self):
            print('get_a called ')
            return self._a
        
        def set_a(self, val):
            print('set_a called ')
            self._a = val
        
        def del_a(self):
            print('del_a called')
                
        a = property(get_a, set_a, del_a)
        
    s = Sample(100)

    result = s.a
    print(result)

    s.a = 20

    del s.a
    
    Buradaki property sınıfı bir betimleyici sınıftır. Ve böyle bir betimleyici işlevi olmadan daha önceki bilgilerimizle biz property 
    gibi bir sınıf yazamayız.  
    
    Aşağıda orijinalk property sınıfının tamamen bir benzeri yazılmıştır. Yazıma dikkat ediniz. Betimleyici olmadan property sınıfını yazmaya 
    çalışınız ve yazamadığınızı görünüz.

#------------------------------------------------------------------------------------------------------------------------

class myproperty:
    def __init__(self, fget = None, fset = None, fdel = None):
        self.fget = fget
        self.fset = fset
        self.fdel = fdel
        
    def __get__(self, instance, owner):
        if self.fget:
            return self.fget(instance)
        raise AttributeError('unreadable attribute')
    
    def __set__(self, instance, value):
        if self.fset:
            self.fset(instance, value)
        else:
            raise AttributeError("can't set attribute")
            
    def __delete__(self, instance):
        if self.fdel:
            self.fdel(instance)
        else:
            raise AttributeError("cant' delete attribute")
        
class Sample:
    def __init__(self, a):
        self._a = a
        
    def get_a(self):
        print('get_a called ')
        return self._a
    
    def set_a(self, val):
        print('set_a called ')
        self._a = val
    
    def del_a(self):
        print('del_a called')
            
    a = myproperty(get_a, set_a, del_a)
    
s = Sample(100)

result = s.a
print(result)

s.a = 20

del s.a
    
#------------------------------------------------------------------------------------------------------------------------
    Paketler (packages) içerisinde birden fazla Python kaynak dosyası bulunan dizinlere denilmektedir. Genellikle kütüphaneler
    tek bir kaynak dosya olarak yazılmaz. Birden fazla dosya biçiminde organize edilirler. İşte bir paket içerisinde birden fazla 
    kaynak dosyadan oluşan bir kavramı belirtmektedir. Python'da paketler "dizin (directory)" biçiminde oluşturulmak zorundadır. 

    Python'da bir dizin'in bir paket olarak ele alınması için tek gereken şey o dizin'in içinde __init__.py isimli bir dosyanın 
    bulunyor olmasıdır. Paketler de tamamen modüller gibi import edilmektedir. 

    Örneğin bulunduğumuz dizin'in altında mypackage isimli bir dizin yaratıp onun içerisine __init__.py dosyaı yerleştirelim. 
    Dosyanın içi boş olabilir. Biz bir paketi nasıl bir dosyayı import ediyorsak dosya gibi import edebiliriz. Örneğin:

    import mypackage

    Bir paket import edildiğinde paketin içerisindeki __init__.py dosyası otomatik çalıştırılmaktadır. Örneğin mypackage isimli paketteki __init__.py
    dosyasının içeriği şöyle olsun:

    # __init__.py

    print('__init__.py')

    Biz aşağıdaki gibi paketi import ettiğimizde bu dosyanın içindekiler çalıştırılacaktır:

    import mypackage

    Tabii paketi iki kere import edersek paket yalnızca ilk import edildiğinde __init__.py dosyası çalıştırılır. 

    Şimdi mypackage dizini içerisine __init__.py dosyasının yanı sıra a.py ve b.py dosyalşarını da yerleştirelim. Dosyaların içeriği şöyle olsun:

    # a.py

    print('this is mypackage.a module')

    def foo():
        print('foo)

    # b.py

    print('this is mypackage.b module')
    
    def bar():
        print('bar')

    Paketler import edildiğinde tıpkı kaynak dosyalar gibi module nesneleri oluşturulmaktadır. Paket isimleri de bu module nesnelerini gösteren 
    değişken durumunda olurlar. Örneğin:

    import mypackage 

    print(type(mypackage))      # <class 'module'>

    Bir kapetin içerisindeki spesifik bir dosya da import edilebilir. Örneğin:

    import mypackage.a

    Bu biçimde bir paketin içerisindeki dosyayı import etmeden önce paketin import edilmesine gerek yoktur. Bu tür durumlarda 
    zaten paketin kendisi de import edililir. Yani yukarıdaki import işleminde sanki önce paketin kendisi import edilmiş sonra da 
    paketin içerisindeki dosya import edilmiş gibi bir etki oluşacaktır. Dolayısıyla yine __init__.py dosyasının içeriği ve a.py 
    dosyasının içeriği çalıştırılacaktır. Örneğin:

    import mypackage.a
    import mypackage.b

    Burada ilk import eişleminde paketin __init__.py dosyası çalıştırılır. Ancak ikinci import işleminde artık çalıştırılmaz. Tabii 
    Yani burada ekrana şunlar çıkacaktır:

    __init__.py
    this is mypackage.a module
    this is mypackage.b module

    Bir paket içerisindeki bir dosyanın içerisindeki değişkenleri (örneğin fonksiyonları) kullanabilmek için önce o paketin 
    içerisindeki dosyanın import edilmesi gerekir. Sonra paket_ismi.modül_ismi.değişken_ismi biçiminde paket içerisindeki 
    modül içerisinde bulunan değişken kullanılabilir. Örneğin:

    import mypackage.a
    import mypackage.b

    mypackage.a.foo()
    mypackage.b.bar()

    Yalnızca paketi import edip dosyayı import etmeden o dosyanın içerisindeki değişkenleri kullanamayız. Örneğin:

    import mypackage

    mypackage.a.foo()       # error!
    mypackage.b.bar()       # error!

    Tabii import deyimindeki as cümleciği ile modül ismini kısaltabiliriz. Örneğin:

    import mypackage.a as a
    import mypackage.b as b

    a.foo()
    b.bar()

    Paketin içerisindeki dosyanın içerisinde bulunan spesifik bir değişkeni form import deyimi ile import edebiliriz. Tabii bu durumda
    yine paketin __init__.py dosyası ve paket içerisindeki dosyanın içerisindeki kodlar çalıştırılacaktır. Örneğin:

    from mypackage.a import foo
    from mypackage.b import bar

    foo()
    bar()

    Ekrana şu yazılar çıkacaktır:

    __init__.py
    this is mypackage.a module
    this is mypackage.b module
    foo
    bar

    Bir paketin __init__.py dosyasında paketin içerisindeki dosyalar import edilebilir. Bu durumda biz o paketi import ettiğimizde 
    o dosyaları da import etmiş gibi oluruz. Örneğin mypackage dizninindeki __init__.py dosyası şöyle yazılmış olsun:

    print('__init__.py')

    import mypackage.a 
    import mypackage.b

    Şimdi biz paketi import edelim:

    import mypackage

    Artık paketin içerisindeki dosyaların içerisindeki değişkenleri paket ismi ve dosya ismi belirterek kullanabiliriz. Örneğin:

    import mypackage

    mypackage.a.foo()
    mypackage.b.bar()

    Ancak __init__.py içerisinde o paketteki dosyalar import edilirken yine paket ismi kullanılmak zorundadır. Yani import işlemi aşağıdaki 
    gibi yapılamaz:

    # __init__. py

    print('__init__.py')

    import a                # error!
    import b                # error!

    Örneğin numpy kütüphanesini import ettiğimizde onun __init__.py dosyasında paket içerisindeki birtakım dosyalar zaten import edilmektedir. 
    Biz de aşağıdaki gibi işlemler yapabilmekteyiz:

    import numpy

    a = numpy.random.randint(0, 10, 100)
    print(a)

    Burada numpy bir pakettir. random ise bir dosyadır. Bu random dosyasının import işlemi paketin __init__ dosyasında yapıldığı için biz 
    randint fonksiyonunu numpy.random.randint biçiminde kullanabildik.

    Bazen programcı paketin __init__ metodunda from import deyimi ile o paketteki dosyaların içerisideki değişkenleri paketin içerisine
    taşır. Böylece artık yalnızca paket ismi ile o değişkenlere eriebilir. Örneğin mypackage paketindeki __init__.py dosyasının içeriği 
    şöyle olsun:

    print('__init__.py')

    from mypackage.a import foo
    from mypackage.b import *

    Şimdi biz bu paketi import ettiğimizde buradaki from import deyimleri çalıştırılacak (tabii bu deyimler çalışırken a ve b dosyalarının içi de çalıştırılşacaktır)
    ve foo ile bar isimleri sanki bu paketin içerisindeymiş gibi bir etki olulacaktır. Şimdi pakaeti aşağıdaki gibi kullanalım:

    import mypackage

    mypackage.foo()
    mypackage.bar()

    Artık foo ve bar değişkenlerine mypackage ismiyle eriştik. Ekranda şu yazılar görünecektir:

    __init__.py
    this is mypackage.a module
    this is mypackage.b module
    foo
    bar

    Burada kullandığımız teknik aslıunda çok yaygın kullanılmaktadır. Yani biz bir paketi import ettiğimizde o paketin __init__.py
    dosyası içerisinde from import deyimleriyle aslında o paketin ieçrisindeki dosyaların içerisindeki isimler paket isim alanına taşınmaktadır.
    Örneğin aslında pandas içerisinde yüzlerce dosyanın olduğu bir pakettir. Ancak biz sanki bütün isimler pandas isim alanındaymış gibi
    isimleri kullanırız. Örneğin:

    import pandas

    s = pandas.Series([1, 2, 3, 4, 5])
    print(s)

    Aslında Series sınıfı pandas paketinin içerisindeki bir dosyanın içerisinde bulunmaktadır. Ancak from import deyimi ile pandas paket
    isim alanına taşınmıştır.

    Yukarıdaki örnekte mypackage paketinin __init__.py dosyasında import as uygulamanın kısaltma bakımından bir faydasının olmayacağına dikkat ediniz:

    # __init__.py

    print('__init__.py')

    import mypackage.a as a

    Burada a ismi yine paket ismiyle kullanılmak zorundadır. 

    Bizim pip programıyla server'lardan indirdiğimiz paketler de aslında yerel makineye bir paket dizini olarak kopyalanmaktadır.

    İç içe paketler de oluşturulabilmektedir. Bir paketin içerisindeki pakete "alt paket (subpackage)" da denilmektedir.

#------------------------------------------------------------------------------------------------------------------------
                                                63. Ders 07/12/2022 - Carsamba
#------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------
    Şimfdi yukarıda oluşturmuş olduğumuz mypackage iismli paketin içerisinde util isimli bir paket daha oluşturalım. util paketinin 
    içerisinde de __init__.py dosyası ve bir de c.py dosyası olsun. Bu dosyaların içeriği de şöyle olsun:

    # mypackage/util/__init__.py

    print('util.__init__.py')

    # mypackage/util/c.py
    
    print('this is mypackage.util.c module')

    def tar():
        print('tar')

    Buradaki dizin şöyledir:

    mypackage
        __init__.py
        a.py
        b.py
        util
            __init__.py
            c.py

    Şimdi bu alt paket içeisindeki c.py dosyasını import edecek olalım:

    import mypackage.util.c

    Burada sırasıyla şu dosyalar çalıştırılacaktır:

    - mypackage için bu dizindeki __init__.py dosyası
    - mypackage.util dizini için bu dizindeki __init__.py dosyası
    - mypackage.util dizinindeki c.py dosyası 

    Aynı durum from import deyimi için de geçerlidir:

    from mypackage.util.c import tar

    Tabii biz dış paketin __init__.py dosyasında iç paketlerdeki isimleri de from import deyimi ile dış paketin isim alanına taşıyabiliriz. 
    Örneğin:

    print('__init__.py')

    from mypackage.a import *
    from mypackage.b import *
    from mypackage.util.c import *

    Pekiyi iç paketin __init__.py dosyası içerisinde nasıl import işlemi yapabiliriz? Biz iç pakette de import işlemi yaparken en dıştan itibaren
    import edeceğimiz dosyayı niteliklendirmeliyiz. Yani örneğin mypackage dizini içerisindeki util dzininindeki __init__.py dosyasında 
    aşağıdaki gibi bir import işlemi yapamayız:

    import c

    aşağıdaki gibi de bir import işlemi yapamayız:

    import util.c

    Şöyle import işlemi yapabiliriz:

    import mypackage.util.c
#------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------
    Modüllerin (yani .py dosyalarının) __all__ isminde özel bir global değişkenleri vardır. Bu global değişken dolaşılabilir bir nesne 
    biçiminde olmalıdır. Bu dolaşılabilir neesne string elemanlarından oluşmalıdır. from import deyimi ile *'lı import yapıldığında yalnızca modülün 
    __all__ değişkeninde belirtilen değişkenler dışarıya import edilir. Örneğin "x.py" isminde bir Python dosyamız olsun ve bu dosyanın içeriği
    aşağıdaki gibi olsun:

    def foo():
        print('foo')
        
    def bar():
        print('bar')
        
    def tar():
        print('tar')
        
    a = 10
    b = 20
    c = 30

    Normal olarak biz bu modülü *'lı import ettiğimizde foo, bar, tar, a, b, c değişken isimlerinin hepsini kullanabiliriz. Örneğin:

    from x import *

    foo()
    bar()
    tar()

    print(a)
    print(b)
    print(c)

    Şimdi x modülüne __all__ global değişkenini aşağıdaki gibi ekleyelim:

    __all__ = ['foo', 'bar', 'a', 'b']

    def foo():
        print('foo')
        
    def bar():
        print('bar')
        
    def tar():
        print('tar')
        
    a = 10
    b = 20
    c = 30
    
    Şimdi biz bu modülü *'lı bir biçimde import edersek yalnızca foo, bar, a ve b'yi kullanabiliriz. 

#------------------------------------------------------------------------------------------------------------------------
    Python'da diğer dillere ve framework'lere kıyasla nispeten zayıf dokümantasyon vardır. Bu zayıf dokümantasyon diğer dillerden Python'a geçenler 
    tarafından bazen şaşkınlıkla karşılanmaktadır. Zayıf dokümantasyon adtea bu dilde doğal karşılanan bir durum haline gelmiştir. 
    Pek çok Python programcısı yazdığı fonksiyonların ve sınıfların ve modüllerin dokümantasyonlarını kodun içerisine gömmektedir. Bunu sağlamak için 
    Python'da "doküman yazıları (document strings)" denilen bir dil özelliği kullanılmaktadır. 

    Bir fonksiyon için doküman yazısı fonksyonun hemen suit'inin başında bir string olarak belirtilir. Bu string tek tırnaklı ya da üç tırnaklı 
    olabilir. Bilindiği gibi üç tırnaklı string'ler birden fazla satır üzerine yazılabilmektedir. Örneğin:

    def square(a):
        """square fonksiyonu parametresiyle aldığı değerin karesine geri döner"""
        return a * a

    Bir fonksiyonun doküman yazısı yorumlayıcı tarafından fonksiyon nesnesinin __doc__ isimli değişkeninin içerisine yerleştirilmektdir. 
    Dolayısıyla biz doküman yazısını __doc__ değişkeni yoluyla elde edebiliriz. 

#------------------------------------------------------------------------------------------------------------------------
   
def square(a):
    """square fonksiyonu parametresiyle aldığı değerin karesine geri döner"""
    return a * a

result = square.__doc__
print(result)
    
#------------------------------------------------------------------------------------------------------------------------
    Python'da bazen programcılar bir fonksiyon hakkında bir açıklama bulamayabilirler. Bu tür durumlarda fonksiyonun __doc__ elemanına 
    başvurulabilir. Örneğin:

    >>> import math
    >>> math.floor.__doc__
    'Return the floor of x as an Integral.\n\nThis is the largest integer <= x.'

    Python'da built-in help isimli fonksiyon bir değişkenin ismini alıp ona ilişkin bilgileri ekrana yazdırmaktadır. 
    Bu yazdırma sırasında dokğman yazıları da yazdırılmaktadır. Örneğin:

    >>> help(math.floor)
    Active code page: 65001
    Help on built-in function floor in module math:

    floor(x, /)
        Return the floor of x as an Integral.

        This is the largest integer <= x.
#------------------------------------------------------------------------------------------------------------------------
   
#------------------------------------------------------------------------------------------------------------------------
    Sınıflar için de sınıfların metotları iöçin de dokğman yazıları oluşturulabilir. Örneğin:

    class Sample:
        "Bu sınıf çok önemli işlemler yapan metotlara sahiptir."
        
        def foo(self):
            "foo metodu falanca işi yapar."
            
        def bar(self):
            "bar metodu filanca işi yapar."

    Yine bir sınıfın dokğman yazısı sınıfın __doc__ isimli sınıf değişkeni biçiminde oluşturulmaktadır. Biz bu dokğman yazılarına sınıf isimleriyle
    ya da ilgili sınıf türünden değişkenlerle erişebiliriz. 
#------------------------------------------------------------------------------------------------------------------------
   
class Sample:
    "Bu sınıf çok önemli işlemler yapan metotlara sahiptir."
    
    def foo(self):
        "foo metodu falanca işi yapar."
        
    def bar(self):
        "bar metodu filanca işi yapar."
        
print(Sample.__doc__)
print(Sample.foo.__doc__)
print(Sample.bar.__doc__)

s = Sample()

print(s.__doc__)
print(s.foo.__doc__)
print(s.bar.__doc__)

#------------------------------------------------------------------------------------------------------------------------
    Programcı isterse tüm modüle de doküman yazısı iliştirebilir. Modülün dokğman yazıları hemen modülün ilk string'i olmak zorundadır. Öneğin:

    # x.py

    """Bu modül falanca işleri yapar """

    def foo():
        print('foo')
        
    def bar():
        print('bar')

    Biz yine modülün doküman yazısını modülün __doc__ değişkeni ile elde edebiliriz. Örneğin:

    import x

    print(x.__doc__)
#------------------------------------------------------------------------------------------------------------------------
   
#------------------------------------------------------------------------------------------------------------------------
    Dokğüan yazıları için herkes tarafından kabul edilen bir standart yoktur. NumPy'ın dokğman yazı standardına ilişkin bağlantı aşağıda verilmiştir:

    https://numpydoc.readthedocs.io/en/latest/format.html

    Google genel stili de aşağıda bağlantıda açıklanmıştır:

    https://google.github.io/styleguide/pyguide.html

    Tabii programcı kend
    i proje grubu tarafından benimsenmiş olan stili kullanabilir. 
#------------------------------------------------------------------------------------------------------------------------
   
#------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------
   
#------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------
   
#------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------
   
#------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------
   
#------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------
   
#------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------
   
#------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------
   
#------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------
   
#------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------
   
#------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------
   
#------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------
   
#------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------
   
#------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------
   
#------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------
   
#------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------
   
#------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------
   
#------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------
   
#------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------
   
#------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------
   
#------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------
   
#------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------
   
#------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------
   
#------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------
   
#------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------
   
#------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------
   
#------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------
   
#------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------
   
#------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------
   
#------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------
   
#------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------
   
#------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------
   
#------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------
   
#------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------
   
#------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------
   
#------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------
   
#------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------
   
#------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------
   
#------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------
   
#------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------
   
#------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------
   
#------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------
   
#------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------
   
#------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------
   
#------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------
   
#------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------
   
#------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------
   
#------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------
   
#------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------
   
#------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------
   
#------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------
   
#------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------
   
#------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------
   
#------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------
   
#------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------
   
#------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------
   
#------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------
   
#------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------
   
#------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------
   
#------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------
   
#------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------
   
#------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------
   
#------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------
   
#------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------
   
#------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------
   
#------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------
   
#------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------
   
#------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------
   
#------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------
   
#------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------
   
#------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------
   
#------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------
   
#------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------
   
#------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------
   
#------------------------------------------------------------------------------------------------------------------------

#------------------------------------------------------------------------------------------------------------------------
   
#------------------------------------------------------------------------------------------------------------------------


14	2414
13	2134
12	1838
11	1520
10	1214
09	  929
08	  649
07	  443
06	  242
05	    83
04	    12
